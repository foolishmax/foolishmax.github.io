<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>13个超实用的JavaScript数组操作技巧</title>
    <url>/2020/07/18/13%E4%B8%AA%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84JavaScript%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="13个超实用的JavaScript数组操作技巧"><a href="#13个超实用的JavaScript数组操作技巧" class="headerlink" title="13个超实用的JavaScript数组操作技巧"></a>13个超实用的JavaScript数组操作技巧</h2><h3 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fruits = [&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;&quot;watermelon&quot;,&quot;apple&quot;,&quot;orrage&quot;]</span><br><span class="line">//第一种方法</span><br><span class="line">let uniqueFruits = Array.from(new Set(fruits))</span><br><span class="line">//第二种方法</span><br><span class="line">let uniqueFruits2 = [...new Set(fruits)]</span><br></pre></td></tr></table></figure>

<h3 id="2-替换数组中的特定值"><a href="#2-替换数组中的特定值" class="headerlink" title="2.替换数组中的特定值"></a>2.替换数组中的特定值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用.splice(start,value to remove,valueToAdd),返回删除对象，并修改原数组</span><br><span class="line">let fruits = [&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;,&quot;watermelon&quot;,&quot;apple&quot;,&quot;orrage&quot;]</span><br><span class="line">fruits.splice(0,2,&quot;potato&quot;,&quot;tomato&quot;)</span><br><span class="line">console.log(fruits)</span><br></pre></td></tr></table></figure>

<h3 id="3-不使用-map-映射数组"><a href="#3-不使用-map-映射数组" class="headerlink" title="3.不使用.map()映射数组"></a>3.不使用.map()映射数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let friends = [</span><br><span class="line">    &#123; name: &#x27;John&#x27;, age: 22 &#125;,</span><br><span class="line">    &#123; name: &#x27;Peter&#x27;, age: 23 &#125;,</span><br><span class="line">    &#123; name: &#x27;Mark&#x27;, age: 24 &#125;,</span><br><span class="line">    &#123; name: &#x27;Maria&#x27;, age: 22 &#125;,</span><br><span class="line">    &#123; name: &#x27;Monica&#x27;, age: 21 &#125;,</span><br><span class="line">    &#123; name: &#x27;Martha&#x27;, age: 19 &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let friendsNames = Array.from(friends, (&#123;name&#125;) =&gt; name)</span><br><span class="line"></span><br><span class="line">console.log(friendsNames)//returns [&quot;John&quot;, &quot;Peter&quot;, &quot;Mark&quot;, &quot;Maria&quot;, &quot;Monica&quot;, &quot;Martha&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="4-清空数组"><a href="#4-清空数组" class="headerlink" title="4.清空数组"></a>4.清空数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fruits = [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;grape&quot;, &quot;apple&quot;];</span><br><span class="line">//要清空数组，仅需要将数组的长度设置为0</span><br><span class="line">fruits.length = 0;</span><br><span class="line">console.log(fruits); // returns []</span><br></pre></td></tr></table></figure>

<h3 id="5-数组转对象"><a href="#5-数组转对象" class="headerlink" title="5.数组转对象"></a>5.数组转对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fruits = [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;];</span><br><span class="line"></span><br><span class="line">let fruitsObj = &#123;...fruits&#125;;</span><br><span class="line"></span><br><span class="line">console.log(fruitsObj) // returns &#123;0: &quot;banana&quot;, 1: &quot;apple&quot;, 2: &quot;orange&quot;, 3: &quot;watermelon&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-用数据填充数组"><a href="#6-用数据填充数组" class="headerlink" title="6.用数据填充数组"></a>6.用数据填充数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let newArray = new Array(10).fill(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">console.log(newArray)</span><br></pre></td></tr></table></figure>

<h3 id="7-合并数组"><a href="#7-合并数组" class="headerlink" title="7.合并数组"></a>7.合并数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];</span><br><span class="line">var meat = [&quot;poultry&quot;, &quot;beef&quot;, &quot;fish&quot;];</span><br><span class="line">var vegetables = [&quot;potato&quot;, &quot;tomato&quot;, &quot;cucumber&quot;];</span><br><span class="line">//使用扩展运算符...</span><br><span class="line">var food = […fruits, …meat, …vegetables];</span><br><span class="line">console.log(food); </span><br></pre></td></tr></table></figure>

<h3 id="8-求数组的交集"><a href="#8-求数组的交集" class="headerlink" title="8.求数组的交集"></a>8.求数组的交集</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr1 = [0,2,3,5,6,8,6]</span><br><span class="line">var arr2 = [1,2,3,4,5,6,4]</span><br><span class="line">var duplicatedValues = [...new Set(arr1)].filter(item=&gt;arr2.includes(item))</span><br><span class="line">console.log(duplicatedValues)</span><br></pre></td></tr></table></figure>

<h3 id="9-从数组中删除虚值"><a href="#9-从数组中删除虚值" class="headerlink" title="9.从数组中删除虚值"></a>9.从数组中删除虚值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//虚值有：false、0、null、NaN、undefined、&quot;&quot;.</span><br><span class="line">var mixedArr = [0,&quot;blue&quot;,&quot;&quot;,NaN,9,true,undefined,&quot;white&quot;,false]</span><br><span class="line">var trueArr = mixedArr.filter(Boolean)</span><br><span class="line">console.log(trueArr)</span><br></pre></td></tr></table></figure>

<h3 id="10-从数组中获取随机值"><a href="#10-从数组中获取随机值" class="headerlink" title="10.从数组中获取随机值"></a>10.从数组中获取随机值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var colors = [&quot;blue&quot;, &quot;white&quot;, &quot;green&quot;, &quot;navy&quot;, &quot;pink&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;];</span><br><span class="line"></span><br><span class="line">var randomColor = colors[(Math.floor(Math.random() * (color.length)))]</span><br></pre></td></tr></table></figure>

<h3 id="11-反转数组"><a href="#11-反转数组" class="headerlink" title="11.反转数组"></a>11.反转数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var colors = [“blue”, “white”, “green”, “navy”, “pink”, “purple”, “orange”, “yellow”, “black”, “brown”];</span><br><span class="line">var reversedColors = colors.reverse();</span><br><span class="line">console.log(reversedColors); </span><br></pre></td></tr></table></figure>

<h3 id="12-lastIndexOf-方法"><a href="#12-lastIndexOf-方法" class="headerlink" title="12.lastIndexOf()方法"></a>12.lastIndexOf()方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查找给定元素的最后依次出现的索引</span><br><span class="line">var nums = [1, 5, 2, 6, 3, 5, 2, 3, 6, 5, 2, 7];</span><br><span class="line">var lastIndex = nums.lastIndexOf(5);</span><br><span class="line">console.log(lastIndex); // returns 9</span><br></pre></td></tr></table></figure>

<h3 id="13-对数组中所有值求和"><a href="#13-对数组中所有值求和" class="headerlink" title="13.对数组中所有值求和"></a>13.对数组中所有值求和</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var nums = [1,5,4,3]</span><br><span class="line">var sum = nums.reduce((x,y)=&gt;x+y)</span><br><span class="line">console.log(sum)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome打开一个页面需要启动多少线程？分别有哪些线程？</title>
    <url>/2019/10/14/Chrome%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E9%9C%80%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="Chrome打开一个页面需要启动多少线程？分别有哪些线程？"><a href="#Chrome打开一个页面需要启动多少线程？分别有哪些线程？" class="headerlink" title="Chrome打开一个页面需要启动多少线程？分别有哪些线程？"></a>Chrome打开一个页面需要启动多少线程？分别有哪些线程？</h2><pre><code>最新Chrome浏览器包括：一个浏览器(Browser)主线程、一个GPU进程、一个网络(NetWork)
进程、多个渲染进程和多个插件进程
</code></pre>
<ul>
<li><p>线程：</p>
<ul>
<li>浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。</li>
<li>渲染进程：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，<br>排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个<br>Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li>GPU进程：Chrome刚开始的时候是没有GPU进程的，而GPU使用的使用初衷是为了实现<br>3D CSS效果，之后随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU称为<br>浏览器普遍的需求，最后，Chrome在其多进程架构上也引入了GPU进程。</li>
<li>网络进程：主要负责网页的网络资源加载，之前是作为一个模块运行在浏览器进程里面<br>的，最近才独立出来，称为一个单独的进程。</li>
<li>插件进程：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以<br>保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-清除浮动</title>
    <url>/2019/07/07/CSS-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="CSS-清除浮动"><a href="#CSS-清除浮动" class="headerlink" title="CSS-清除浮动"></a>CSS-清除浮动</h2><p><a href="https://segmentfault.com/a/1190000004865198">原文链接</a></p>
<h3 id="什么是CSS清除浮动"><a href="#什么是CSS清除浮动" class="headerlink" title="什么是CSS清除浮动?"></a>什么是CSS清除浮动?</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left</span><br><span class="line">或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到</span><br><span class="line">容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行</span><br><span class="line">的CSS处理，就叫CSS清除浮动。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ul>
<li>方法一：使用带clear属性的空元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在浮动元素后使用一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，并在CSS中赋予</span><br><span class="line">.clear&#123;clear:both;&#125;属性即可清理浮动。亦可使用&lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt;</span><br><span class="line">来进行清理。</span><br><span class="line">优点：简单，代码少，浏览器兼容好。</span><br><span class="line">缺点：需要添加大量的无语义的html元素，代码不够优雅，后期不容易维护。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：使用CSS的overflow属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法三：给浮动的元素的容器添加浮动（不太推荐）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，</span><br><span class="line">不推荐使用。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法四：使用邻接元素处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么都不做，给浮动元素后面的元素添加clear:both属性。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法五：使用CSS的：after伪元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现</span><br><span class="line">元素末尾添加一个看不见的块元素（Block element）清理浮动。</span><br><span class="line"></span><br><span class="line">.clearfix::after&#123;</span><br><span class="line">  content: &quot;020&quot;; </span><br><span class="line">  display: block; </span><br><span class="line">  height: 0; </span><br><span class="line">  clear: both; </span><br><span class="line">  visibility: hidden;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonJS、AMD、CMD是什么及区别？</title>
    <url>/2019/08/13/CommonJS%E3%80%81AMD%E3%80%81CMD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8F%8A%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="CommonJS、AMD、CMD是什么及区别？"><a href="#CommonJS、AMD、CMD是什么及区别？" class="headerlink" title="CommonJS、AMD、CMD是什么及区别？"></a>CommonJS、AMD、CMD是什么及区别？</h2><ul>
<li>CommonJS是服务器端js模块化的规范，NodeJS是这种规范的实现，加载模块使用require方法，</li>
</ul>
<p>导出使用exports</p>
<ul>
<li>AMD和CMD都是为了解决浏览器端模块化问题而产生的，AMD规范对应的库Require.js,</li>
</ul>
<p>CMD规范对应的库Sea.js</p>
<ul>
<li>AMD 和 CMD的区别:<ul>
<li>AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li>
<li>CMD 推崇就近依赖，只有在用到的某个模块的时候再去require</li>
<li>对于依赖的模块，AMD是提前执行，CMD是延迟执行，但RequireJS(AMD)从2.0开始，也改为延迟执行</li>
<li>AMD的API默认是一个当多个，CMD的API严格区分，推崇职责单一</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM基本操作</title>
    <url>/2019/08/11/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h2><ul>
<li><p>获取Dom节点</p>
<ul>
<li>document代表整个文档</li>
<li>document.getElementById()</li>
<li>document.getElementByTagName()</li>
<li>document.getElementByName() //只有部分标签name可生效，表单之类的</li>
<li>document.getElementByClassName()</li>
<li>querySelector() //静态的，不是实时的，保存的是当时的状态，是一个副本</li>
<li>querySelectorAll() //即使以后元素发生了改变，该值也不会改变</li>
</ul>
</li>
<li><p>遍历节点树</p>
<ul>
<li>parentNode -&gt; 父节点（最顶端parentNode为#document）</li>
<li>childNodes -&gt; 子节点们</li>
<li>firstChild -&gt; 第一个子节点</li>
<li>lastChild  -&gt; 最后一个子节点</li>
<li>nextSibling -&gt; 后一个兄弟节点</li>
<li>previousSibling -&gt;前一个兄弟节点</li>
</ul>
</li>
<li><p>遍历元素节点树</p>
<ul>
<li>parentElement -&gt; 返回当前元素的父元素节点（IE9以下不兼容）</li>
<li>children -&gt; 返回当前元素的元素子节点</li>
<li>node.childElementCount === node.children.length 返回当前元素的子元素节点个数（IE9以下不兼容）</li>
<li>firstElementChild -&gt; 返回第一个元素节点（IE9以下不兼容）</li>
<li>lastElementChild -&gt; 返回最后一个元素节点（IE9以下不兼容）</li>
<li>nextElementSibling -&gt; 返回后一个元素节点（IE9以下不兼容）</li>
<li>previousElementSibling -&gt; 返回前一个元素节点（IE9以下不兼容）</li>
</ul>
</li>
<li><p>节点的类型</p>
<ul>
<li>元素节点 —— 1</li>
<li>属性节点 —— 2</li>
<li>文本节点 —— 3</li>
<li>注释节点（Comment）—— 8</li>
<li>document —— 9</li>
<li>DocumentFragment —— 11</li>
<li>获取节点类型 nodeType</li>
</ul>
</li>
<li><p>节点的四个属性</p>
<ul>
<li>nodeName <ul>
<li>元素的标签名，以大写形式表示，只读</li>
</ul>
</li>
<li>nodeValue<ul>
<li>Text节点或Comment节点的文本内容，可读写</li>
</ul>
</li>
<li>nodeType<ul>
<li>该节点的类型，只读</li>
</ul>
</li>
<li>attributes<ul>
<li>Element节点的属性集合</li>
</ul>
</li>
</ul>
</li>
<li><p>节点的一个方法</p>
<ul>
<li>Node.hasChildNodes()<ul>
<li>所有节点都有hasChildNodes()方法，判断有无子节点，有一个或多个返回true</li>
</ul>
</li>
</ul>
</li>
<li><p>Dom基本操作——增</p>
<ul>
<li>document.createElement()</li>
<li>document.createTextNode()</li>
<li>document.createComment()</li>
<li>document.createDocumentFragment()</li>
</ul>
</li>
<li><p>Dom基本操作——插</p>
<ul>
<li>parentNode.appendChild()</li>
<li>parentNode.insertBefore(a, b)</li>
</ul>
</li>
<li><p>Dom基本操作——删</p>
<ul>
<li>parent.removeChild()</li>
<li>child.remove()</li>
</ul>
</li>
<li><p>Dom基本操作-替换</p>
<ul>
<li>parent.replaceChild(new, origin)</li>
</ul>
</li>
<li><p>Element节点的一些属性</p>
<ul>
<li>innerHTML</li>
<li>innerText(火狐不兼容)/textContent(老版本IE不兼容)</li>
</ul>
</li>
<li><p>Element节点的一些方法</p>
<ul>
<li>ele.setAttribute()</li>
<li>ele.getAttribute()</li>
</ul>
</li>
<li><p>查看元素的几何尺寸</p>
<ul>
<li>domEle.getBoundingClientRect() </li>
<li>兼容性很好</li>
<li>返回一个对象，里面有left、top、right、bottom、width、height。</li>
</ul>
<p>  left和top代表元素左上角的X和Y坐标，right和bottom代表元素右下角的X和Y坐标</p>
<ul>
<li>height和width属性老版本IE未实现</li>
<li>返回的结果不是“实时的”</li>
</ul>
</li>
<li><p>查看元素的宽高尺寸<br>  dom.offsetWidth</p>
<p>  dom.offsetHeight</p>
</li>
<li><p>查看元素的位置<br>  dom.offsetLeft</p>
<p>  dom.offsetTop</p>
<p>  对于无定位父级的元素，返回相对文档的坐标。</p>
<p>  对于有定位的父级元素，返回相对最近的有定位的父级的坐标，无论距离是怎么产生的</p>
</li>
<li><p>dom.offsetParent<br>  返回最近的有定位的父级，若无，返回body，body.offsetParent返回nul</p>
</li>
<li><p>让滚动条滚动</p>
<ul>
<li>window上的三个方法：scroll()==scrollTo()、scrollBy()</li>
<li>scroll()和scrollTo()将x、y坐标传入，让滚动条滚动到当前位置</li>
<li>scrollBy() 会在之前的数据基础上累加，可以利用scrollBy()实现快速阅读的功能</li>
</ul>
</li>
<li><p>查询计算样式</p>
<ul>
<li>window.getComputedStyle(ele, null)[style]</li>
<li>第二个参数null，放的是伪元素，可以获取伪元素的属性</li>
<li>计算样式只读</li>
<li>返回的计算样式都是绝对值，没有相对单位</li>
<li>IE8及以下不兼容（ele.currentStyle[style]）</li>
</ul>
</li>
</ul>
<ul>
<li><p>封装函数，返回元素的第n层祖先元素节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function retParent(elem, n) &#123;</span><br><span class="line">    while(elem &amp;&amp; n) &#123;</span><br><span class="line">        elem = elem.parentElement</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">    return elem</span><br><span class="line">&#125;</span><br><span class="line">var i = document.getElementByTagName(&#x27;i&#x27;)[0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型上封装函数myChildren获取子元素，解决一千浏览器的兼容性问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.prototype.myChildren = function () &#123;</span><br><span class="line">    var child = this.childNodes</span><br><span class="line">    var len = child.length</span><br><span class="line">    for (var i = 0;i &lt; len; i++) &#123;</span><br><span class="line">        if(child[i].nodeType == 1) &#123;</span><br><span class="line">            arr.push(child[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var div = document.getElementByTagName(&#x27;div&#x27;)[0]</span><br></pre></td></tr></table></figure></li>
<li><p>自己封装hasChildren()方法，不可用children属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.prototype.hasChildren = function () &#123;</span><br><span class="line">    var child = this.childNodes</span><br><span class="line">    var len = child.length</span><br><span class="line">    for (var i = 0;i &lt; len; i++) &#123;</span><br><span class="line">        if(child[i].nodeType == 1) &#123;</span><br><span class="line">           return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var div = document.getElementByTagName(&#x27;div&#x27;)[0]</span><br></pre></td></tr></table></figure></li>
<li><p>封装函数，返回元素e的第n个兄弟元素节点，n为正，返回后面的兄弟元素节点，n为负，返回前面的，n为0，返回自己</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function retSibling(e, n) &#123;</span><br><span class="line">    while(e &amp;&amp; n) &#123;</span><br><span class="line">        if(n &gt; 0) &#123;</span><br><span class="line">            if(e.nextElementSibling) &#123;</span><br><span class="line">                e.nextElementSibling</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for(e = e.nextSibling; e &amp;&amp; e.nodeType != 1; e = e.nextSibling)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if(e.previousElementSibling) &#123;</span><br><span class="line">                e = e.previousElementSibling</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for(e = e.previousSibling; e &amp;&amp; e.nodeType != 1; e = e.previousSibling)</span><br><span class="line">            &#125;</span><br><span class="line">            n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装insertAfter(),功能类似与insertBefore(new, origin),直接在Element.prototype上编程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.prototype.insertAfter = function(new, origin) &#123;</span><br><span class="line">    var beforeNode = origin.nextElementSibling</span><br><span class="line">    if (beforeNode == null) &#123;</span><br><span class="line">        this.appendChild(new)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.insertBefore(new, beforeNode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装滚动条的x轴、y轴的距离函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getScrollOffset() &#123;</span><br><span class="line">    if (window.pageXOffset) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: window.pageXOffset,</span><br><span class="line">            y: window.pageYOffset</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: document.body.scrollLeft + document.documentElement.scrollLeft,</span><br><span class="line">            y: document.body.scrollTop + document.documentElement.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装可视区窗口大小的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getViewportOffset() &#123;</span><br><span class="line">    if (window.innerWidth) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            w: window.innerWidth,</span><br><span class="line">            h: window.innerHeight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (document.compatMode === &#x27;BackCompat&#x27;) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                w: document.body.clientWidth,</span><br><span class="line">                h: document.body.clientHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                w: document.documentElement.clientWidth,</span><br><span class="line">                h: document.documentElement.clientHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装样式获取的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getStyle(elem, prop) &#123;</span><br><span class="line">    if(window.getComputedStyle) &#123;</span><br><span class="line">        return window.getComputedStyle(elem, null)[prop]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return elem.currentStyle[prop]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>数组常见的API</title>
    <url>/2019/07/18/ES6%E4%B9%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="数组常见的API"><a href="#数组常见的API" class="headerlink" title="数组常见的API"></a>数组常见的API</h2><span id="more"></span>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><pre><code>遍历所有数组元素,会自动省略为空的数组元素
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line"></span><br><span class="line">array1.forEach(function(element) &#123;</span><br><span class="line">  console.log(element);</span><br><span class="line">&#125;);</span><br><span class="line">// a b c</span><br></pre></td></tr></table></figure>

<h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><pre><code>判断所有元素是否都符合条件
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3]</span><br><span class="line">var result = arr.every(function(item, index)&#123;</span><br><span class="line">    if (item &lt; 4) &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure>

<h4 id="some"><a href="#some" class="headerlink" title="some"></a>some</h4><pre><code>判断是否有至少一个元素符合条件
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">var even = function(element) &#123;</span><br><span class="line">  // checks whether an element is even</span><br><span class="line">  return element % 2 === 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(array.some(even));</span><br><span class="line">// expected output: true</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><pre><code>排序
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 4, 3, 2, 5]</span><br><span class="line">var arr2 = arr.sort(function(a, b)&#123;</span><br><span class="line">    //从小到达</span><br><span class="line">    return a - b</span><br><span class="line">    //从大到小</span><br><span class="line">    //return b- a</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2)</span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><pre><code>过滤符合条件的元素
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//filter回调函数会返回一个boolean值</span><br><span class="line"></span><br><span class="line">//true：当返回true时，函数内部会自动将这次回调的item加入到新的数组中arr2</span><br><span class="line">//false：当返回false时，函数内部会过滤掉这次的item</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">var arr2 = arr.filter(function(item, index)&#123;</span><br><span class="line">    if (item &gt;= 2) &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2)</span><br></pre></td></tr></table></figure>


<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><pre><code>对元素重新组装，生成新数组(该数组中的每个元素都调用一个提供的函数后返回的
结果。)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array1 = [1, 4, 9, 16];</span><br><span class="line"></span><br><span class="line">// pass a function to map</span><br><span class="line">const map1 = array1.map(x =&gt; x * 2);</span><br><span class="line"></span><br><span class="line">console.log(map1);</span><br><span class="line">// expected output: Array [2, 8, 18, 32]</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><pre><code>reduce作用是对数组中所有内容进行汇总
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3].reduce(function(prev, curr)&#123;</span><br><span class="line">    return prev + curr</span><br><span class="line">&#125;, 0)  //6</span><br><span class="line"></span><br><span class="line">=================</span><br><span class="line">//计算小于100，并二倍之后的和</span><br><span class="line">const nums = [10, 20, 111, 222, 444, 40, 50]</span><br><span class="line"></span><br><span class="line">let total = nums.filter(function(n)&#123;</span><br><span class="line">    return n &lt; 100</span><br><span class="line">&#125;).map(function(n)&#123;</span><br><span class="line">    return n * 2</span><br><span class="line">&#125;).reduce(function(pre, curr)&#123;</span><br><span class="line">    return pre + curr</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">let total = nums.filter(n =&gt; n &lt; 100).map(n =&gt; n * 2)</span><br><span class="line">.reduce((pre, curr) =&gt; pre + curr)</span><br><span class="line"></span><br><span class="line">console.log(total) //240</span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><pre><code>间隔数组元素
let arr = [&#39;hello&#39;, &#39;world&#39;, &#39;foolish&#39;]
console.log(arr.join(&#39;|&#39;))
// hello|world|foolish
</code></pre>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><pre><code>let arr = [&#39;hello&#39;, &#39;world&#39;, &#39;foolish&#39;]
console.log(arr.toString())
// hello,world,foolish
</code></pre>
<h4 id="includes-ES7"><a href="#includes-ES7" class="headerlink" title="includes() //ES7"></a>includes() //ES7</h4><pre><code>includes() 函数用来判断一个数组是否包含一个指定的值，如果包含则返回true，否则返回false
类似indexOf()
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用indexOf()验证数组中是否存在某个元素，根据返回值是否为-1来判断</span><br><span class="line"></span><br><span class="line">let arr = [&#x27;react&#x27;, &#x27;angular&#x27;, &#x27;vue&#x27;]</span><br><span class="line"></span><br><span class="line">if (arr.indexOf(&#x27;react&#x27;) !== -1) &#123;</span><br><span class="line">    console.log(&#x27;react存在&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用ES7的includes()方法</span><br><span class="line">let arr = [&#x27;react&#x27;, &#x27;angular&#x27;, &#x27;vue&#x27;]</span><br><span class="line"></span><br><span class="line">if (arr.includes(&#x27;react&#x27;)) &#123;</span><br><span class="line">    console.log(&#x27;react存在&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h4><pre><code>在ES7中引入了指数操作符 ** ,** 具有和Math.pow(a, b)等效的计算结果
</code></pre>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><pre><code>JSON数组格式（多个length属性）转换为数组
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let json = &#123;</span><br><span class="line">    &#x27;0&#x27;: &#x27;hello&#x27;,</span><br><span class="line">    &#x27;1&#x27;: &#x27;world&#x27;,</span><br><span class="line">    &#x27;2&#x27;: &#x27;foolishmax&#x27;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;</span><br><span class="line">let arr = Array.from(json)</span><br><span class="line">console.log(arr)</span><br></pre></td></tr></table></figure>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><pre><code>负责把一堆文本或者变量转换成数组
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 数字</span><br><span class="line">let arr = Array.of(1, 2, 3, 4)</span><br><span class="line">console.log(arr)    //[1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 字符串</span><br><span class="line">let arr = Array.of(&#x27;hello&#x27;, &#x27;world&#x27;)</span><br><span class="line">console.log(arr)    //[&quot;hello&quot;, &quot;world&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="find-实例方法"><a href="#find-实例方法" class="headerlink" title="find()实例方法"></a>find()实例方法</h4><pre><code>所谓的实例方法并不是以Array对象开始的，而是必须有一个已经存在的数组，
实例数组调用的方法，就是实例方法.

find接受一个方法作为参数，方法内部返回一个条件
find会遍历所有元素，执行给定的函数
符合该条件的元素会作为find方法的返回值
如果遍历结束没有符合条件的元素，则返回undefined   
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//value: 表示当前查找的值</span><br><span class="line">//index: 表示当前查找的数组索引</span><br><span class="line">//arr: 表示当前数组</span><br><span class="line"></span><br><span class="line">let arr = [2,3,4,5,6,7,8]</span><br><span class="line">let result = arr.find(function(value, index, arr)&#123;</span><br><span class="line">    return value &gt; 5</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result) //6</span><br></pre></td></tr></table></figure>

<h4 id="fill-实例方法"><a href="#fill-实例方法" class="headerlink" title="fill()实例方法"></a>fill()实例方法</h4><pre><code>fill()作用是把数组进行填充，接受三个参数，一个参数填充的变量，第二个
是填充的位置，第三个是填充到的位置
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">arr.fill(&#x27;hello&#x27;, 1, 3)</span><br><span class="line">console.log(arr)    // [1, &quot;hello&quot;, &quot;hello&quot;, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<h4 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;foolishmax&#x27;]</span><br><span class="line">for(let item of arr)&#123;</span><br><span class="line">    console.log(item)</span><br><span class="line">&#125;</span><br><span class="line">// hello world foolishmax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let arr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;foolishmax&#x27;]</span><br><span class="line">for(let index of arr.keys()) &#123;</span><br><span class="line">    console.log(index)</span><br><span class="line">&#125;</span><br><span class="line">// 0 1 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let arr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;foolishmax&#x27;]</span><br><span class="line">for (let [index, val] of arr.entries())&#123;</span><br><span class="line">    console.log(index+&#x27;:&#x27;+val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0:hello</span><br><span class="line">//1:world</span><br><span class="line">//2:foolishmax</span><br></pre></td></tr></table></figure>

<h4 id="entries-实例方法"><a href="#entries-实例方法" class="headerlink" title="entries()实例方法"></a>entries()实例方法</h4><pre><code>entries() 实例方法生成的是Iterator形式的数组，好处就是可以让我们在需要的时候
用next()手动跳转到下一个值
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;foolishmax&#x27;]</span><br><span class="line">let list = arr.entries();</span><br><span class="line">console.log(list.next().value);</span><br><span class="line">console.log(list.next().value);</span><br><span class="line">console.log(list.next().value);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之字符串</title>
    <url>/2019/08/12/ES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="ES6之字符串"><a href="#ES6之字符串" class="headerlink" title="ES6之字符串"></a>ES6之字符串</h3><ul>
<li>ES5的字符串拼接<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name = &#x27;foolishmax&#x27;</span><br><span class="line">let blog = &#x27;你好，我是&#x27;+name+&#x27;,是你的新朋友。&#x27;</span><br><span class="line">console.log(blog)   // 你好，我是foolishmax,是你的新朋友。</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li>ES6采用${name}的形式,同时里面支持HTML标签<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name = &#x27;foolishmax&#x27;</span><br><span class="line">let blog = `&lt;h3&gt;你好，我是$&#123;name&#125;,是你的新朋友。&lt;/h3&gt;`</span><br><span class="line">document.write(blog)   // 你好，我是foolishmax,是你的新朋友。</span><br></pre></td></tr></table></figure></li>
<li>对运算也支持<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">let b = 2</span><br><span class="line">let result = `$&#123;a + b&#125;`</span><br><span class="line">console.log(result) // 3</span><br></pre></td></tr></table></figure></li>
<li>查找是否存在<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//includes</span><br><span class="line">let name = &#x27;foolishmax&#x27;</span><br><span class="line">let str = &#x27;hello world, foolishmax&#x27;</span><br><span class="line">console.log(str.includes(name)) //true</span><br></pre></td></tr></table></figure></li>
<li>判断开头是否存在<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.startsWith(name)</span><br></pre></td></tr></table></figure></li>
<li>判断结尾是否存在<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.endsWith(name)</span><br></pre></td></tr></table></figure></li>
<li>复制字符串<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;hello &#x27;.repeat(3))</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之箭头函数</title>
    <url>/2019/08/12/ES6%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="ES6之箭头函数"><a href="#ES6之箭头函数" class="headerlink" title="ES6之箭头函数"></a>ES6之箭头函数</h2><ul>
<li>默认值<br>  在ES6中给我们增加了默认值的操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(a, b = 1) &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr(1))</span><br><span class="line">//2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>主动抛出错误 throw new Error(‘This is error’)</p>
</li>
<li><p>函数中的严格模式  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(a,b=1)&#123;</span><br><span class="line">    &#x27;use strict&#x27;</span><br><span class="line">    if(a == 0)&#123;</span><br><span class="line">        throw new Error(&#x27;This is error&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">     return a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(add(1));</span><br></pre></td></tr></table></figure>
<p>  上面代码运行会出现报错，原因就是如果使用了默认值，再使用严格模式的话，就会<br>  有冲突，需要取消默认值的操作。</p>
</li>
<li><p>获得需要传递的参数个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">    &#x27;use strict&#x27;</span><br><span class="line">    if(a == 0)&#123;</span><br><span class="line">        throw new Error(&#x27;This is error&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">     return a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(add.length); //2</span><br></pre></td></tr></table></figure>
<p>  add.length 可以查看 必须 传递值的参数个数<br>  如果去掉严格模式，再第二个参数加上默认值的话，add.length的值就变成了1</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS创建对象的几种方式</title>
    <url>/2019/08/13/JS%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="JS有哪几种创建对象的方式？"><a href="#JS有哪几种创建对象的方式？" class="headerlink" title="JS有哪几种创建对象的方式？"></a>JS有哪几种创建对象的方式？</h2><ul>
<li><p>对象字面量</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Object构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = new Object()</span><br></pre></td></tr></table></figure></li>
<li><p>工厂模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    var o = new Object()</span><br><span class="line">    o.age = age</span><br><span class="line">    o.name = name</span><br><span class="line">    o.say = function() &#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">    return o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> // 缺点：每次通过Person创建对象的say方法都一样，却存储了多次，浪费资源</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person (name, age) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">    this.say = function() &#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&#x27;foolish&#x27;, 18)</span><br><span class="line"></span><br><span class="line">// 构造函数在最后都会隐式返回return this，所以如果缺少new的时候，会将属性和方法</span><br><span class="line">添加给全局window对象，必须new，可以通过call和apply指定this。</span><br></pre></td></tr></table></figure></li>
<li><p>原型模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype.name = &#x27;foolish&#x27;</span><br><span class="line">Person.prototype.say = function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person()</span><br><span class="line"></span><br><span class="line">//实现了方法与属性的共享，可以动态添加对象的属性和方法。但是没有办法创建实例</span><br><span class="line">自己的属性和方法，也没有办法传递参数</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数和原型组合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person (name, age) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&#x27;hello&#x27;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之数字操作</title>
    <url>/2019/08/12/ES6%E4%B9%8B%E6%95%B0%E5%AD%97%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="ES6之数字操作"><a href="#ES6之数字操作" class="headerlink" title="ES6之数字操作"></a>ES6之数字操作</h3><ul>
<li><p>二进制和八进制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 二进制Binary，以0（零）开头，第二个位置b</span><br><span class="line">let binary = 0B010101</span><br><span class="line">console.log(binary) //21</span><br><span class="line"></span><br><span class="line">//八进制Octal，以0（零）开头，第二个位置O</span><br><span class="line">let b = 0o226;</span><br><span class="line">console.log(b)  //150</span><br></pre></td></tr></table></figure></li>
<li><p>数字验证 Number.isFinite(*)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 可以使用Number.isFinite()进行数字验证，只要是数字，无论是浮点型</span><br><span class="line">还是整形都会返回true，其他的返回false</span><br><span class="line">let a = 10/3</span><br><span class="line">Number.isFinite(a)  //true</span><br><span class="line">Number.isFinite(&#x27;foolishmax&#x27;)   //false</span><br><span class="line">Number.isFinite(NaN)    //false</span><br></pre></td></tr></table></figure></li>
<li><p>NaN验证： Number.isNaN()</p>
</li>
<li><p>判断是否为整数：Number.isInteger()</p>
</li>
<li><p>转换为整数：Number.parseInt()</p>
</li>
<li><p>转换为浮点型：Number.parseFloat()</p>
</li>
<li><p>最大安全整数：Number.MAX_SAFE_INTEGER</p>
</li>
<li><p>最小安全整数：Number.MIN_SAFE_INTEGER</p>
</li>
<li><p>安全整数判断：Number.isSafeInteger()</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS垃圾回收机制</title>
    <url>/2019/10/19/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="谈谈JS垃圾回收机制？"><a href="#谈谈JS垃圾回收机制？" class="headerlink" title="谈谈JS垃圾回收机制？"></a>谈谈JS垃圾回收机制？</h2> <span id="more"></span>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><pre><code>Javascript中的内存管理是自动执行的，而且是不可见的。在我们创建基本类型、对象、函数
时，这些都需要内存，当不需要某样东西时，JavaScript引擎会利用垃圾回收机制清除它。

在局部作用域中，当函数执行完毕，局部变量也就没必要存在了，因此垃圾收集器很容易
做出判断回收。但是全局变量什么时候需要自动释放内存空间很难判断，因此在开发中，
需要尽量避免使用全局变量。
</code></pre>
<h4 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h4><p>JavaScript中内存管理的主要概念是可达性。</p>
<p>当一些值以某种方式可访问或可用，它们会被存储在内存中，叫做可达值。</p>
<ul>
<li>一些固有可达值，由于显而易见的原因无法删除。例如：<ul>
<li>本地函数的局部变量或参数</li>
<li>当前嵌套调用链上的其他函数的变量和参数</li>
<li>全局变量等</li>
</ul>
</li>
</ul>
<p>这些值 称为 根</p>
<ul>
<li>如果引用或引用链 可以从根访问任何其他值，则认为该值是可访问的。<ul>
<li>一个对象引用另一个对象的属性，则该对象是为可达性。</li>
</ul>
</li>
</ul>
<p>JavaScript引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除哪些不可访问的对象。</p>
<h4 id="内部算法"><a href="#内部算法" class="headerlink" title="内部算法"></a>内部算法</h4><p>v8的垃圾回收策略基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同<br>的算法。</p>
<p>新生代采用Scavenge算法(赋值算法)</p>
<ul>
<li><p>Scavenge为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分<br>为from和to两个空间。每次gc,会将from空间的存活对象复制到to空间。然后两个空间角色<br>对换(又称反转)。</p>
</li>
<li><p>该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。</p>
</li>
</ul>
<p>老生代采用Mark-Sweep(标记清除)和Mark-Compact(标记整理)</p>
<ul>
<li>标记-清除算法，定期执行一下“垃圾回收”步骤：<ul>
<li>垃圾回收器获取根并“标记”它们</li>
<li>然后访问并标记所有来自它们的引用</li>
<li>然后访问标记的对象 并 标记它们的引用</li>
<li>以此类推，知道有为访问的引用为止</li>
<li>除了标记的对象外，所有对象都被删除。</li>
</ul>
</li>
</ul>
<p>Mark-Compact算法(标记整理)</p>
<ul>
<li>标记清除存在一个问题，清除死亡对象后会造成内存空间不连续，这时候v8会使用<br>Mark-Compact算法(标记整理)，它会在标记完成之后将活着的对象往一端移动，移动完成<br>后直接清理掉边界外的内存。</li>
</ul>
<p>Reference Counting(引用计数算法)</p>
<ul>
<li>引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时<br>更新计数器，如果计数器值为0则直接回收内存。 很明显，引用计数最大的优势是暂停时间短</li>
</ul>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li><p>增量回收：如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费<br>一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分，然后<br>各个部分分别执行，这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。</p>
</li>
<li><p>空闲时间收集：垃圾回收器只在CPU空闲时运行，以减少对执行的可能影响。</p>
</li>
</ul>
<h4 id="v8的内存限制"><a href="#v8的内存限制" class="headerlink" title="v8的内存限制"></a>v8的内存限制</h4><ul>
<li>64位系统最大约为1.4G</li>
<li>32位系统最大约为0.7G</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML语义化</title>
    <url>/2019/09/30/HTML%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>什么是HTML语义化？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据内容的结构化，选择合适的标签，便于开发者阅读和写出更优雅的代码的同时利于SEO的优化。</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要语义化？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；</span><br><span class="line">-  用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；</span><br><span class="line">- 有利于SEO ：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息： 爬虫依赖于</span><br><span class="line">标签来确定上下文和各个关键字的权重；</span><br><span class="line">- 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</span><br><span class="line">- 便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的</span><br><span class="line">团队都遵循这个标准，可以减少差异化。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript什么时候必须加分号？</title>
    <url>/2019/08/07/JavaScript%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BF%85%E9%A1%BB%E5%8A%A0%E5%88%86%E5%8F%B7%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="JavaScript什么时候必须加分号？"><a href="#JavaScript什么时候必须加分号？" class="headerlink" title="JavaScript什么时候必须加分号？"></a>JavaScript什么时候必须加分号？</h2><ul>
<li><p>当一行代码以 ( 开头的时候，在前面补一个分号避免一些语法错误</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say() &#123;</span><br><span class="line">    console.log(&#x27;hello world&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">say()</span><br><span class="line"></span><br><span class="line">;(function () &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">)()</span><br></pre></td></tr></table></figure></li>
<li><p>当一行代码以 [ 开头的时候</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;[&#x27;hello&#x27;, &#x27;world&#x27;].forEach(function (item) &#123;</span><br><span class="line">    console.log(item)   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>当一行代码以 ` 开头的时候</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;`hello`.toString()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6实用技巧</title>
    <url>/2020/10/07/ES6%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="ES6实用技巧"><a href="#ES6实用技巧" class="headerlink" title="ES6实用技巧"></a>ES6实用技巧</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//js变量命名：小驼峰，前缀应当是名词，例如 maxCount、tableTitle</span><br><span class="line"></span><br><span class="line">//js常量：全大写，单词以_分割</span><br><span class="line"></span><br><span class="line">//js函数命名：小驼峰，前缀应当是动词，例如 setCount、getTitle</span><br><span class="line">//常见动词：can has is get set load</span><br><span class="line"></span><br><span class="line">//类 &amp; 构造函数：大驼峰，首字母大写</span><br><span class="line">// class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">//类的成员</span><br><span class="line">//公共属性和方法：跟变量和函数的命名一样</span><br><span class="line">//私有属性和方法，前缀为_(下划线)，同上</span><br><span class="line">//private _name: string;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="let-amp-const"><a href="#let-amp-const" class="headerlink" title="let &amp; const"></a>let &amp; const</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ES6新增了let和const两个命令，let用来定义变量，const用于定义常量，let和const都是块级作用域。</span><br><span class="line">const对于对象类型使用的是指针式引用，常量只是指向了对象的指针，对象本身的内容却依然可以被修改。</span><br><span class="line">在使用中，建议使用let和const完全代替var命令</span><br></pre></td></tr></table></figure>

<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const foo = `this is a $&#123;example&#125;`;</span><br></pre></td></tr></table></figure>

<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转换</span><br><span class="line">Number.parseInt —— 将字符串或数字转换为整数</span><br><span class="line">Number.parseFloat —— 将字符串或数字转换为浮点数</span><br><span class="line"></span><br><span class="line">上述两个方法与parseInt和parseFloat功能一致，在ES6中推荐使用Number.的方法调用，目的是为了减少全局性方法，使语言逐步模块化。</span><br></pre></td></tr></table></figure>

<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//合并数组</span><br><span class="line">let a = [1,2]</span><br><span class="line">let b = [3]</span><br><span class="line">let c = [...a, ...b]</span><br><span class="line"></span><br><span class="line">//Array.from() 将伪数组对象或可遍历对象转换为真数组</span><br><span class="line">//典型的伪数组有：函数的arguments对象，以及大多数DOM元素，还有字符串</span><br><span class="line"></span><br><span class="line">//快速转换为数组</span><br><span class="line">Array.of(3, 4, 5)</span><br><span class="line"></span><br><span class="line">//判断对象是否为数组</span><br><span class="line">if(Array.isArray(obj))&#123;...&#125;</span><br><span class="line"></span><br><span class="line">//检索数据中是否有5</span><br><span class="line">[1, 2, 3].includes(5) //false</span><br><span class="line"></span><br><span class="line">//找出第一个匹配表达式的结果，只要匹配到一项，函数就返回</span><br><span class="line">let a =[1, 3, 4, -89].find((value, index, arr) =&gt; &#123;</span><br><span class="line">    return value &lt; 0;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a); //-89</span><br><span class="line"></span><br><span class="line">//找出第一个匹配表达式的结果的下标</span><br><span class="line">let a = [1, 2, 3, -2].findIndex((value, index, arr) =&gt; &#123;</span><br><span class="line">    return value &lt; 0;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a); //3</span><br><span class="line"></span><br><span class="line">//内容过滤</span><br><span class="line">let a = [1, 2, 3, -4].filter((item) =&gt; &#123;</span><br><span class="line">    return item &gt; 0;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a); //[1, 2, 3]</span><br><span class="line"></span><br><span class="line">//内容实例</span><br><span class="line">.keys() —— 获得数组中所有元素的键名(索引下标)</span><br><span class="line">.values() —— 获得数组中所有元素的数据</span><br><span class="line">.entries() —— 获得数组中所有数据的键名和数据</span><br><span class="line">类似Object中的同名函数</span><br></pre></td></tr></table></figure>

<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对象内容合并</span><br><span class="line">let a = &#123;a:1,b:2&#125;, //&#123;a: 1, b: 4&#125;</span><br><span class="line">    b = &#123;b:3&#125;,</span><br><span class="line">    c = &#123;b:4,c:5&#125;</span><br><span class="line">let d = Object.assign(a, b, c) //&#123;a: 1, b: 4, c: 5&#125;</span><br><span class="line">// 合并的同时更新a对象的内容</span><br><span class="line">// a自身没有的属性不会被添加，只会更新</span><br><span class="line">// 只会影响a第一个，不会影响后面的b、c</span><br><span class="line">// 推荐使用下面这种</span><br><span class="line">let d = Object.assign(&#123;&#125;, a, b, c)</span><br><span class="line"></span><br><span class="line">//对象内容</span><br><span class="line">Object.keys() —— 获取所有键名，以数组形式返回</span><br><span class="line">Object.values() —— 获取所有值内容，以数组形式返回</span><br><span class="line">Object.entries() —— 获取所有键名和值内容，以数组形式返回，成员内容也是数组形式 例如：[[&#x27;a&#x27;, 1],[&#x27;b&#x27;, 2]]</span><br><span class="line"></span><br><span class="line">//判断对象是否为数组对象</span><br><span class="line">if(Object.isArray(obj))&#123;&#125;</span><br><span class="line"></span><br><span class="line">//判断对象是否为空对象</span><br><span class="line">if(obj &amp;&amp; Object.keys(obj).length)</span><br></pre></td></tr></table></figure>

<h3 id="Destructuring解构赋值"><a href="#Destructuring解构赋值" class="headerlink" title="Destructuring解构赋值"></a>Destructuring解构赋值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [a, b, c] = [1, 2, 3] //如果个数不匹配，没有对应上的为undefined</span><br><span class="line"></span><br><span class="line">let [a, b, c = &#x27;default&#x27;] = [12, 23] //指定默认值</span><br><span class="line"></span><br><span class="line">let [a, ...b] = [1, 2, 3] //b的值为[2, 3]</span><br><span class="line"></span><br><span class="line">let [a, b, c] = &#x27;yes&#x27; //a的值为y，b的值为e，c的值为s</span><br><span class="line"></span><br><span class="line">//如果名称是字符串的自带属性，则会获得属性的值</span><br><span class="line">let &#123; length &#125; = &#x27;yes&#x27; //length 为3</span><br><span class="line"></span><br><span class="line">//解构赋值使用实例，作为函数传参，使用默认值</span><br><span class="line">let obj = &#123;a: 1, b: 2&#125;</span><br><span class="line">function test(&#123;a = 10, b&#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">test(obj)</span><br><span class="line"></span><br><span class="line">// 对象结构解构赋值</span><br><span class="line">let obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let &#123; a, b &#125; = obj; //a = 1,b = 2,需要严格匹配名称，数组的模式是严格匹配下标。</span><br><span class="line"></span><br><span class="line">let obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let &#123; a = 0, b = 3 &#125; = obj; //赋值并给定默认值</span><br><span class="line"></span><br><span class="line">let obj = &#123; a: 1, b: 2&#125;;</span><br><span class="line">let &#123;a: A, b&#125; = obj; //获得内容后，将变量会从新命名</span><br><span class="line"></span><br><span class="line">let a = 0;</span><br><span class="line">(&#123;a, b&#125; = obj);//对已存在的a进行修改值，并生成新的变量b</span><br><span class="line"></span><br><span class="line">//解构的同时使用重命名和设置默认值的语法</span><br><span class="line">const person = &#123;name: &quot;zhangsan&quot;,sex: &quot;male&quot;&#125;;</span><br><span class="line">const &#123;name: middleName = &quot;zhangxiaosan&quot;&#125; = person;</span><br><span class="line">console.log(middleName); //&quot;zhangsan&quot;</span><br><span class="line">// 首先声明middleName这个变量，查询person的middle属性，如果存在则赋值给middleNmae，如果不存在使用默认值&quot;zhangxiaosan&quot;</span><br><span class="line"></span><br><span class="line">//多层解构赋值</span><br><span class="line">let obj = &#123;</span><br><span class="line">    arr: [&#x27;aaa&#x27;, &#123;a: 1&#125;]</span><br><span class="line">&#125;</span><br><span class="line">let &#123;arr: [b, &#123;a&#125;]&#125; = obj; //b为&#x27;aaa&#x27;,a为1，注意结构要对应。</span><br><span class="line"></span><br><span class="line">//数组转化为对象</span><br><span class="line">const points = [</span><br><span class="line">    [1,2],</span><br><span class="line">    [3,4]</span><br><span class="line">];</span><br><span class="line">let newPoints = points.map(item =&gt; &#123;</span><br><span class="line">    const [x,y] = item;</span><br><span class="line">    return &#123;x, y&#125;;</span><br><span class="line">&#125;)</span><br><span class="line">or</span><br><span class="line">let newPoints = points.map(([x, y]) =&gt; &#123;</span><br><span class="line">    return &#123;x, y&#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newPoints);</span><br><span class="line">//[</span><br><span class="line">//  &#123;x:1,y:2&#125;,</span><br><span class="line">//  &#123;x:3,y:4&#125;</span><br><span class="line">//]</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错</span><br><span class="line">//报错，会报SyntaxError</span><br><span class="line">let count = num =&gt; &#123;base: 50&#125;;</span><br><span class="line">//正确返回方式</span><br><span class="line">let count = num =&gt; (&#123;base: 50&#125;);</span><br><span class="line"></span><br><span class="line">//特点：更简洁的函数和封闭上下文的this指向。</span><br></pre></td></tr></table></figure>

<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//基本用法</span><br><span class="line">let name = Symbol(&quot;name&quot;);</span><br><span class="line">console.log(name); //Symbol(name)</span><br><span class="line">console.log(typeof name); //&quot;symbol&quot;</span><br><span class="line"></span><br><span class="line">// Symbol 函数不能用new命令，因为Symbol是原始数据类型，不是对象</span><br><span class="line">// Symbol表示独一无二的值，因此带有相同参数的两个Symbol值也不相等</span><br><span class="line">let name1 = Symbol();</span><br><span class="line">let name2 = Symbol();</span><br><span class="line">name1 === name2;// false</span><br><span class="line">let name1 = Symbol(&quot;name&quot;);</span><br><span class="line">let name2 = Symbol(&quot;name&quot;);</span><br><span class="line">name1 === name2; // false</span><br><span class="line"></span><br><span class="line">//Symbol不能进行隐式类型转换</span><br><span class="line">let name = Symbol(&#x27;foo&#x27;);</span><br><span class="line">console.log(&quot;nihao&quot; + name);</span><br><span class="line">//浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a string.</span><br><span class="line"></span><br><span class="line">//Symbol值可以显示转换为字符串</span><br><span class="line">let name = Symbol(&#x27;foo&#x27;);</span><br><span class="line">String(name); //&quot;Symbol(foo)&quot;</span><br><span class="line">name.toString(); //&quot;Symbol(foo)&quot;</span><br><span class="line"></span><br><span class="line">//Symbol值不能转换为数字</span><br><span class="line">let name = Symbol(&#x27;foo&#x27;);</span><br><span class="line">Number(name);</span><br><span class="line">//浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a number.</span><br><span class="line"></span><br><span class="line">//Symbol值可以转换为布尔值</span><br><span class="line">let name = Symbol(&#x27;foo&#x27;);</span><br><span class="line">Boolean(name); //true</span><br><span class="line">!name //false</span><br><span class="line"></span><br><span class="line">//Symbol变量不能作为webStorage的键使用</span><br><span class="line">let name = Symbol();</span><br><span class="line">localStorage.setItem(name,&quot;aaaa&quot;);</span><br><span class="line">//浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a string.</span><br><span class="line"></span><br><span class="line">//使用场景</span><br><span class="line">//作为对象属性名</span><br><span class="line">//不能用.只能用[]</span><br><span class="line">let name = Symbol();</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">obj[name] = &quot;zhangsan&quot;;</span><br><span class="line">console.log(obj); //&#123;Symbol():&quot;zhangsan&quot;&#125;</span><br><span class="line"></span><br><span class="line">//Symbol作为属性名时，该属性时公有属性不是私有属性，可以在类的外部访问，但是不会出现在for...in,for...of的循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。</span><br><span class="line">//可以通过Object.getOwnPropertySymbols()和Reflect.ownKeys()取到。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义常量，保证唯一性</span><br><span class="line">const COLOR_RED = Symbol(&quot;red&quot;);</span><br><span class="line">const MY_RED = Symbol(&quot;red&quot;);</span><br><span class="line"></span><br><span class="line">//Symbol.for() </span><br><span class="line">//作用：用于将描述相同的Symbol变量指向同一个Symbol值</span><br><span class="line">//Symbol()定义的值每次都是新建的，即使描述相同值也不同</span><br><span class="line">//Symbol.for() 会先检查给定的描述是否存在，不存在才会新建一个值，并将这个值登记在全局环境中供搜索。</span><br><span class="line">let a1 = Symbol.for(&#x27;a&#x27;);</span><br><span class="line">let a2 = Symbol.for(&#x27;a&#x27;);</span><br><span class="line">a1 === a2 //true</span><br><span class="line">typeof a1 //&quot;symbol&quot;</span><br><span class="line">typeof a2 //&quot;symbol&quot;</span><br><span class="line"></span><br><span class="line">//Symbol.keyFor()</span><br><span class="line">//检测Symbol值是否被登记过，返回一个已登记的Symbol类型值的key</span><br><span class="line">let a1 = Symbol.for(&#x27;a&#x27;);</span><br><span class="line">Symbol.keyFor(a1); //&quot;a&quot;</span><br><span class="line"></span><br><span class="line">let a2 = Symbol(&#x27;a&#x27;);</span><br><span class="line">Symbol.keyFor(a2); //undefined</span><br><span class="line"></span><br><span class="line">//Symbol的属性</span><br><span class="line">//Symbol.peorotype.description 用于返回Symbol数据的描述</span><br><span class="line">let a = Symbol(&quot;accc&quot;);</span><br><span class="line">a.description //&quot;accc&quot;</span><br></pre></td></tr></table></figure>

<h3 id="排除Object中不需要的键值"><a href="#排除Object中不需要的键值" class="headerlink" title="排除Object中不需要的键值"></a>排除Object中不需要的键值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;a:1,b:2,c:3&#125;;</span><br><span class="line"></span><br><span class="line">const &#123;a,...rest&#125; = obj; //获取除了a之外的所有属性</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用reduce对象数组的某一个属性求和</span><br><span class="line">const obj = [</span><br><span class="line">    &#123;name: &quot;lilei&quot;,score: 98&#125;,</span><br><span class="line">    &#123;name: &quot;hanmeimei&quot;,score: 90&#125;</span><br><span class="line">]</span><br><span class="line">const scoreTotal = objs.reduce((total, obj) =&gt; &#123;</span><br><span class="line">    return total + obj.score;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//使用reduce同时做到map和filter的作用</span><br><span class="line">const number = [10,20,30,40];</span><br><span class="line">const doubledOver50 = number.reduce((finalList, num) =&gt; &#123;</span><br><span class="line">    num = num * 2;</span><br><span class="line"></span><br><span class="line">    if(num &gt; 50) &#123;</span><br><span class="line">        finalList.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    return finalList;</span><br><span class="line">&#125;,[]);</span><br><span class="line">doubledOver50; //[60, 80]</span><br></pre></td></tr></table></figure>

<h3 id="import-动态加载"><a href="#import-动态加载" class="headerlink" title="import() 动态加载"></a>import() 动态加载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//把import作为一个函数可以实现动态加载模块</span><br><span class="line">if(true) &#123;</span><br><span class="line">    import(&#x27;./module.js).then(res =&gt; &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之express</title>
    <url>/2019/09/08/Node-js%E4%B9%8Bexpress/</url>
    <content><![CDATA[<h2 id="Node-js之express"><a href="#Node-js之express" class="headerlink" title="Node.js之express"></a>Node.js之express</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引包</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于原来的http.createServer</span></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//公开指定目录</span></span><br><span class="line">app.use(<span class="string">&#x27;/puclic/&#x27;</span>, express.static(<span class="string">&#x27;./public/&#x27;</span>))</span><br><span class="line"><span class="comment">//当省略第一个参数的时候，可以通过省略/public的方式访问</span></span><br><span class="line"><span class="comment">//app.use(express.static(&#x27;./public/&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当服务器收到get请求 / 的时候，执行回调函数</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;hello exporess&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/about&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于server.listen</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;app is running at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Express使用art-template"><a href="#Express使用art-template" class="headerlink" title="Express使用art-template"></a>Express使用art-template</h2><ul>
<li><a href="http://aui.github.io/art-template/express/">Express&amp;art-template官网</a></li>
<li>Install<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save art-templates</span><br><span class="line">npm install --save express-art-template    </span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>Example<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">// view engine setup</span><br><span class="line">app.engine(&#x27;art&#x27;, require(&#x27;express-art-template&#x27;));</span><br><span class="line">app.set(&#x27;view&#x27;, &#123;</span><br><span class="line">    debug: process.env.NODE_ENV !== &#x27;production&#x27;</span><br><span class="line">&#125;);</span><br><span class="line">app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));</span><br><span class="line">app.set(&#x27;view engine&#x27;, &#x27;art&#x27;);</span><br><span class="line"></span><br><span class="line">// routes</span><br><span class="line">app.get(&#x27;/&#x27;, function (req, res) &#123;</span><br><span class="line">    res.render(&#x27;index.art&#x27;, &#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">            name: &#x27;aui&#x27;,</span><br><span class="line">            tags: [&#x27;art&#x27;, &#x27;template&#x27;, &#x27;nodejs&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h2><ul>
<li><p>在Express中没有内置获取表单POST请求体的API，需要引入一个第三方包：body-parser</p>
</li>
<li><p>Install</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save body-parser</span><br></pre></td></tr></table></figure></li>
<li><p>config</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;)</span><br><span class="line">var bodyParser = require(&#x27;body-parser&#x27;)</span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">//配置 body-parser,req对象上就会多出来一个 body 属性</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended: false&#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br></pre></td></tr></table></figure></li>
<li><p>use</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.use(function(req, res)&#123;</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;)</span><br><span class="line">    res.write(&#x27;hello&#x27;)</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之mongoDB</title>
    <url>/2019/09/09/Node-js%E4%B9%8BmongoDB/</url>
    <content><![CDATA[<h2 id="开启MongoDB服务器"><a href="#开启MongoDB服务器" class="headerlink" title="开启MongoDB服务器"></a>开启MongoDB服务器</h2><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongod</span><br></pre></td></tr></table></figure>

<h2 id="连接MongoDB服务器"><a href="#连接MongoDB服务器" class="headerlink" title="连接MongoDB服务器"></a>连接MongoDB服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>

<h2 id="退出MongoDB服务器"><a href="#退出MongoDB服务器" class="headerlink" title="退出MongoDB服务器"></a>退出MongoDB服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li><p>show dbs</p>
<ul>
<li>查看显示所有数据库</li>
</ul>
</li>
<li><p>db</p>
<ul>
<li>产看当前操作的数据库</li>
</ul>
</li>
<li><p>use 数据库名称</p>
<ul>
<li>切换到指定的数据库（没有会新建）</li>
</ul>
</li>
<li><p>show collections</p>
<ul>
<li>显示集合</li>
</ul>
</li>
<li><p>db.cats.find()</p>
<ul>
<li>查看并显示内容</li>
</ul>
</li>
<li><p><a href="https://github.com/mongodb/node-mongodb-native">node中使用mongodb</a></p>
</li>
</ul>
<h2 id="使用第三方mongoose来操作MongoDB数据库"><a href="#使用第三方mongoose来操作MongoDB数据库" class="headerlink" title="使用第三方mongoose来操作MongoDB数据库"></a>使用第三方mongoose来操作MongoDB数据库</h2><ul>
<li><p><a href="https://mongoosejs.com/">mongoose</a></p>
</li>
<li><p>安装<br><code>npm install mongoose</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入包</span><br><span class="line">const mongoose = require(&#x27;mongoose&#x27;);</span><br><span class="line">//连接数据库（数据库不需要存在，在插入第一条语句，就会自动创建）</span><br><span class="line"></span><br><span class="line">mongoose.connect(&#x27;mongodb://localhost:27017/test&#x27;, &#123;useNewUrlParser: true&#125;);</span><br><span class="line"></span><br><span class="line">//设计数据库集合结构</span><br><span class="line">//创建一个Cat表</span><br><span class="line">const Cat = mongoose.model(&#x27;Cat&#x27;, &#123; name: String &#125;);</span><br><span class="line"></span><br><span class="line">//实例化一个Cat，实例对象为kitty</span><br><span class="line">const kitty = new Cat(&#123; name: &#x27;Zildjian&#x27; &#125;);</span><br><span class="line"></span><br><span class="line">//持久化保存kitty实例</span><br><span class="line">kitty.save().then(() =&gt; console.log(&#x27;meow&#x27;));</span><br></pre></td></tr></table></figure>

<ul>
<li>mongoose的基本使用</li>
</ul>
<ul>
<li>生成模型构造函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var mongoose = require(&#x27;mongoose&#x27;);</span><br><span class="line">var Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line">//设计集合结构（表结构）schema---&gt;提要，纲要</span><br><span class="line">//字段名称就是表结构中的属性名称</span><br><span class="line">//值类型</span><br><span class="line">//约束的目的：为了保证数的完整性</span><br><span class="line">var blogSchema = new Schema(&#123;</span><br><span class="line">  title:  String,</span><br><span class="line">  author: String,</span><br><span class="line">  body:   String,</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    required: true</span><br><span class="line">  &#125;,</span><br><span class="line">  password: &#123;</span><br><span class="line">    typte: String,</span><br><span class="line">    required: true      </span><br><span class="line">  &#125;</span><br><span class="line">  comments: [&#123; body: String, date: Date &#125;],</span><br><span class="line">  date: &#123; type: Date, default: Date.now &#125;,</span><br><span class="line">  hidden: Boolean,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    votes: Number,</span><br><span class="line">    favs:  Number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//将文档结构发布为模型</span><br><span class="line">// 参数一：大写单数表示数据库名称</span><br><span class="line">//         mongoose会自动将大写单数改为小写复数</span><br><span class="line">// 参数二： 架构 Schema</span><br><span class="line">// 返回值： 模型构造函数</span><br><span class="line">var User = mongoose.model(&#x27;User&#x27;, blogSchema)</span><br><span class="line">// module.exports = mongoose.model(&#x27;Student&#x27;, blogSchema)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>基于模型构造函数 生成添加一条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var admin = new User(&#123;</span><br><span class="line">    username: &#x27;admin&#x27;,</span><br><span class="line">    password: &#x27;1245435&#x27;,</span><br><span class="line">    ....</span><br><span class="line">&#125;)</span><br><span class="line">admin.save(function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#x27;保存失败&#x27;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#x27;保存成功&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>基于模型构造函数 查询数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询所有数据</span><br><span class="line">User.find(function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">         console.log(&#x27;查询失败&#x27;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//promise 查询所有</span><br><span class="line">User.find()</span><br><span class="line">    .then(function(data)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">//按条件查询</span><br><span class="line"> User.find(&#123;</span><br><span class="line">    username: &#x27;xx&#x27;</span><br><span class="line"> &#125;, function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#x27;查询失败&#x27;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//查找符合条件的第一个（可以写多个条件）,没有条件的话，为第一条数据</span><br><span class="line"> User.findOne(&#123;</span><br><span class="line">    username: &#x27;xx&#x27;</span><br><span class="line"> &#125;, function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#x27;查询失败&#x27;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>基于模型构造函数 按条件更新数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Model.update(conditions, doc, [options], [callback])</span><br><span class="line">//Model.findOneAndUpdate([conditions], [update], [options], [callback])</span><br><span class="line">User.findByIdAndUpdate(&#x27;5a7d8f2sd78ag6g&#x27;,&#123;</span><br><span class="line">    username: &#x27;zs&#x27;</span><br><span class="line">&#125;, function(err, ret)&#123;</span><br><span class="line">   if(err)&#123;</span><br><span class="line">       console.log(&#x27;更新失败&#x27;)</span><br><span class="line">    else &#123;</span><br><span class="line">       console.log(&#x27;更新成功&#x27;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>基于模型构造函数 删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User.remove(&#123;</span><br><span class="line">    username: &#x27;zs&#x27;</span><br><span class="line">&#125;, function(err, ret)&#123;</span><br><span class="line">   if(err)&#123;</span><br><span class="line">       console.log(&#x27;查询失败&#x27;)</span><br><span class="line">    else &#123;</span><br><span class="line">       console.log(ret)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="补充（node使用mysql）"><a href="#补充（node使用mysql）" class="headerlink" title="补充（node使用mysql）"></a>补充（node使用mysql）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引包</span><br><span class="line">var mysql      = require(&#x27;mysql&#x27;);</span><br><span class="line">//创建连接</span><br><span class="line">var connection = mysql.createConnection(&#123;</span><br><span class="line">  host     : &#x27;localhost&#x27;,</span><br><span class="line">  user     : &#x27;me&#x27;,</span><br><span class="line">  password : &#x27;secret&#x27;,</span><br><span class="line">  database : &#x27;my_db&#x27;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> //连接数据库</span><br><span class="line">connection.connect();</span><br><span class="line"> </span><br><span class="line"> //执行数据操作,可以直接使用 SQL 语句</span><br><span class="line"> //查找</span><br><span class="line">connection.query(&#x27;SELECT * FROM `users`&#x27;, function (error, results, fields) &#123;</span><br><span class="line">  if (error) throw error;</span><br><span class="line">  console.log(&#x27;The solution is: &#x27;, results[0].solution);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//添加</span><br><span class="line"> connection.query(&#x27;INSERT INTO users VALUES(NULL, &quot;admin&quot;:&quot;123&quot;)&#x27;, function (error, results, fields) &#123;</span><br><span class="line">   if (error) throw error;</span><br><span class="line">   console.log(&#x27;The solution is: &#x27;, results[0].solution);</span><br><span class="line"> &#125;);</span><br><span class="line"> //关闭数据库</span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery学习</title>
    <url>/2020/09/05/Jquery%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="jQuery学习"><a href="#jQuery学习" class="headerlink" title="jQuery学习"></a>jQuery学习</h2><h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><ul>
<li>jQuery入口函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;)</span><br><span class="line">或者（简写）</span><br><span class="line">$(function()&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li>javascript入口函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>jQuery的入口函数是在html的所有标签DOM都加载之后，就会执行包裹的代码，可以执行多次，并且不会覆盖上次。</li>
<li>javascript的window.onload事件是等到所有内容，包括外部图片之类的文件加载完成后，才会执行，只能执行一次，如果第二次会把第一次的执行覆盖。</li>
</ul>
<h3 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h3><ul>
<li><p>元素选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>id选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#test&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>class选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;.test&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>属性选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;[href]&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>:empty 选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;:empty&quot;)</span><br><span class="line">//选择空的元素，既不不含子元素也不包含文本的元素</span><br><span class="line">$(&quot;div:empty&quot;) //选择div中为空的div元素</span><br></pre></td></tr></table></figure></li>
<li><p>:parent选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;td:parent&quot;)</span><br><span class="line">//选取所有带有子元素或文本的&lt;td&gt;标签元素</span><br></pre></td></tr></table></figure></li>
<li><p>:contains 选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;div:contains(&#x27;hello&#x27;)&quot;)</span><br><span class="line">//找到div中包含文本hello的指定元素</span><br></pre></td></tr></table></figure></li>
<li><p>:has选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;div:has(p)&quot;)</span><br><span class="line">//找到包含p标签元素的div</span><br></pre></td></tr></table></figure></li>
<li><p>补充</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;:button&quot;) //获取所有type为button的&lt;input&gt;元素和&lt;button&gt;元素，去掉冒号，只能获取&lt;button&gt;元素。</span><br></pre></td></tr></table></figure>
<h3 id="常用jQuery事件方法"><a href="#常用jQuery事件方法" class="headerlink" title="常用jQuery事件方法"></a>常用jQuery事件方法</h3></li>
<li><p>click() 点击事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).click(function()&#123;</span><br><span class="line">    $(this).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>dblclick() 双击事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).dblclick(function()&#123;</span><br><span class="line">    $(this).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>mouseenter() 鼠标指针穿过元素时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseenter(function()&#123;</span><br><span class="line">    alert(&quot;您的鼠标移到了p标签元素上！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>mouseleave() 鼠标指针离开元素时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseleave(function()&#123;</span><br><span class="line">    alert(&quot;您的鼠标离开了该p标签元素！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>mouseup() 当在元素上松开鼠标时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseup(()=&gt;&#123;</span><br><span class="line">    alert(&quot;鼠标在p标签上松开！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>hover() 模拟光标悬停事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).hover(</span><br><span class="line">    function()&#123;</span><br><span class="line">        alert(&quot;你进入了p标签！&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function()&#123;</span><br><span class="line">        alert(&quot;你离开了p标签！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>focus()  当元素获得焦点时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;input&quot;).focus(function()&#123;</span><br><span class="line">    $(this).css(&quot;background-color&quot;,&quot;#ccc&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>blur() 当元素失去焦点时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;input&quot;).blur(function()&#123;</span><br><span class="line">    $(this).css(&quot;background-color&quot;,&quot;#fff&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>keypress,keydown,keyup</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取按键代码或ASCII码</span><br><span class="line">$(window).keydown(function(event)&#123;</span><br><span class="line">    //通过event.which可以拿到按键代码，如果是keypress事件中则拿到ASCII码。</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;)</span><br><span class="line">//获取事件对象</span><br><span class="line">$(window).keypress(function(event)&#123;    </span><br><span class="line">    //获取事件对象，里面包含各种有用的信息。</span><br><span class="line">    console.log(event);</span><br><span class="line">    //console.log(event.which);</span><br><span class="line">&#125;);</span><br><span class="line">//keypress事件获取键入的字符</span><br><span class="line">$(window).keypress(function(event)&#123;</span><br><span class="line">    //event.which是获取ASCII码，前面的函数是将ASCII码转换成字符，空格键和Enter键输出均为空白。</span><br><span class="line">    console.log(String.fromCharCode(event.which));</span><br><span class="line">    //从event对象中key属性获取字符，但是Enter键的key值为&quot;Enter&quot;，空白键还是空白&quot; &quot;。</span><br><span class="line">    console.log(event.key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>off() 事件移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).off() //移除所有button元素身上绑定的事件</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).off(&quot;click&quot;) //移除所有的click事件，移除指定类型</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).off(&quot;click&quot;, test) //移除click事件中的test回调方法，移除指定类型的事件</span><br></pre></td></tr></table></figure></li>
<li><p>阻止事件冒泡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;.son&quot;).click(function(event)&#123;</span><br><span class="line">    alert(&quot;son&quot;)</span><br><span class="line">    //return false;</span><br><span class="line">    event.stopPropagation(); //阻止事件冒泡</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;.father&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;father&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>阻止默认行为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//a标签跳转、submit提交按钮等</span><br><span class="line">$(&quot;a&quot;).click(function(event)&#123;</span><br><span class="line">    alert(&quot;弹出注册框！&quot;);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>trigger()、triggerHandler() 自动触发事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//触发绑定到被选元素的所有事件</span><br><span class="line">$(&quot;.father&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;father&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.father&quot;).trigger(&quot;click&quot;);   //方法一:会触发事件冒泡</span><br><span class="line">$(&quot;.father&quot;).triggerHandler(&quot;click&quot;); //方法二:只触发事件，不会触发事件冒泡</span><br><span class="line">-------------------------------</span><br><span class="line">$(&quot;input[type=&#x27;submit&#x27;]&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;submit&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;input[type=&#x27;submit&#x27;]&quot;).trigger(&quot;click&quot;); //方法一：触发事件的同时，还会触发默认行为。</span><br><span class="line">$(&quot;input[type=&#x27;submit&#x27;]&quot;).triggerHandler(&quot;click&quot;) //方法二：只触发事件，不触发默认行为。</span><br><span class="line">//注意：这里&lt;a&gt;标签有点特殊，这两个方法都不会触发默认行为，如果想使用trigger()触发&lt;a&gt;标签的事件和默认行为的话，可以在&lt;a&gt;标签中添加一个&lt;span&gt;,例如&lt;a href =&quot;#&quot;&gt;&lt;span&gt;百度&lt;/span&gt;&lt;/a&gt; 这种写法。</span><br></pre></td></tr></table></figure></li>
<li><p>自定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 想要自定义事件，必须满足两个条件</span><br><span class="line">* 1.事件必须是通过on绑定的</span><br><span class="line">* 2.事件必须通过trigger来触发</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).on(&quot;myClick&quot;,function()&#123;</span><br><span class="line">    alert(&quot;son&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).trigger(&quot;myClick&quot;);</span><br><span class="line">or</span><br><span class="line">$(&quot;.son&quot;).triggerHandler(&quot;myClick&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>事件命名空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 想要事件的命名空间有效，必须满足两个条件</span><br><span class="line">* 1.事件通过on来绑定(自定义事件)</span><br><span class="line">* 2.通过trigger()或者triggerHandler()来触发</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).on(&quot;eventName.zs&quot;,function()&#123;</span><br><span class="line">    alert(&quot;click zhangsan&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.son&quot;).on(&quot;eventName.ls&quot;,function()&#123;</span><br><span class="line">    alert(&quot;click lisi&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.son&quot;).trigger(&quot;click.zs&quot;);</span><br><span class="line">or</span><br><span class="line">$(&quot;.son&quot;).triggerHandler(&quot;click.zs&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="隐藏和显示"><a href="#隐藏和显示" class="headerlink" title="隐藏和显示"></a>隐藏和显示</h3><ul>
<li><p>hide() 隐藏html元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#hide&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>show() 显示html元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#show&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).show();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>语法 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(selector).hide(speed,callback);</span><br><span class="line"></span><br><span class="line">$(selector).show(speed,callback);</span><br><span class="line"></span><br><span class="line">//可选的speed参数表示规定显示/隐藏的速度(slow、fast、毫秒)</span><br><span class="line">//可选的callback参数是隐藏或显示完成后所执行的函数名称</span><br><span class="line"></span><br><span class="line">$(&quot;.hidebtn&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;div&quot;).hide(1000,&quot;linear&quot;,function()&#123;</span><br><span class="line">        alert(&quot;Hide() 方法已完成!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//第二个参数是一个字符串，表示过渡使用哪种缓动函数，jQuery自身提供(linear、swing)</span><br><span class="line">//补充：callback函数名后面加上括号，会立刻执行函数体，而不是等到显示/隐藏之后才执行,如add()作为callback参数会立即执行，而add作为参数则不会，callback函数可以是匿名函数，$(selector)选中的元素个数为n个，则callback函数会执行n次。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>toggle() 切换hide()和show()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).toggle();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><ul>
<li><p>fadeIn() 用于淡入以隐藏的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeIn(3000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法： $(selector).fadeIn(speed, callback)</span><br><span class="line">// 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">// 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure></li>
<li><p>fadeOut() 用于淡出可见元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeOut(&quot;slow&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//语法： $(selector).fadeOut(speed, callback)</span><br><span class="line">// 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">// 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure></li>
<li><p>fadeToggle() 用于在fadeIn()与fadeOut()方法之间进行切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeToggle();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//语法： $(selector).fadeToggle(speed, callback)</span><br><span class="line">// 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">// 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure></li>
<li><p>fadeTo() 允许渐变为给定的不透明度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.3);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).fadeTo(speed, opacity, callback)</span><br><span class="line">//必须的speed参数规定效果时长(slow、fast、毫秒)</span><br><span class="line">//必须的opacity规定不透明度(介于0-1之间)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="滑动方法"><a href="#滑动方法" class="headerlink" title="滑动方法"></a>滑动方法</h3><ul>
<li><p>slideDown() 用于元素向下滑动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideDown();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).slideDown(speed,callback)</span><br><span class="line">//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">//可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure></li>
<li><p>slideUp() 用于元素向上滑动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideUp();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).slideUp(speed,callback)</span><br><span class="line">//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">//可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure></li>
<li><p>slideToggle() 在slideDown()与slideUp()方法之间进行切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideToggle();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).slideToggle(speed,callback)</span><br><span class="line">//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">//可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul>
<li><p>animate()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//默认情况下，所有html元素都有一个静态位置，且无法移动。</span><br><span class="line">//先将p标签元素设置为position:relative/absolute/fixed</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;p&quot;).animate(&#123;</span><br><span class="line">      left:&#x27;250px&#x27;,</span><br><span class="line">      opacity:&#x27;0.5&#x27;,</span><br><span class="line">      height:&#x27;400px&#x27;,</span><br><span class="line">      width: &#x27;400px&#x27;,</span><br><span class="line">      paddingLeft:&#x27;10px&#x27;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//语法： $(selector).animate(&#123;params&#125;,speed,callback)</span><br><span class="line">// params参数可以操作几乎所有的css属性，但名字要采用camel标记法</span><br></pre></td></tr></table></figure></li>
<li><p>stop() 停止动画</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> $(&quot;#flip&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;#panel&quot;).slideDown(5000);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">$(&quot;#stop&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;#panel&quot;).stop();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">语法: $(selector).stop(stopAll,goToEnd)</span><br><span class="line">//可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停/止活动的动画，允许任何排入队列的动画向后执行。</span><br><span class="line">//可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。</span><br></pre></td></tr></table></figure></li>
<li><p>jQuery方法链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;)</span><br><span class="line">  .slideUp(2000)</span><br><span class="line">  .slideDown(2000);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jQuery获取内容和属性"><a href="#jQuery获取内容和属性" class="headerlink" title="jQuery获取内容和属性"></a>jQuery获取内容和属性</h3><ul>
<li><p>获取内容 text()、html()、val()</p>
<ul>
<li>text() 设置或返回所选元素的文本内容</li>
<li>html() 设置或返回所选元素的内容(包括html标记)</li>
<li>val() 设置或返回表单字段的值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).text());</span><br><span class="line">&#125;)</span><br><span class="line">//-----------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).html())</span><br><span class="line">&#125;)</span><br><span class="line">//------------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  alert($(&quot;input&quot;).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>获取属性 attr()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//项目QC刚用过</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    console.log($(&quot;p&quot;).attr(&quot;data-text&quot;));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>补充：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop()函数返回相应属性或空字符串。</span><br><span class="line">attr()函数返回相应属性或undefined</span><br><span class="line">1.对于HTML元素本身就带有的固有属性，在处理时使用prop方法</span><br><span class="line">2.对HTML元素我们自己定义的DOM属性，在处理时使用attr方法</span><br><span class="line">3.具有true和false两个属性的属性，如checked、selected或者disabled使用prop()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置内容和属性"><a href="#设置内容和属性" class="headerlink" title="设置内容和属性"></a>设置内容和属性</h3><ul>
<li><p>设置内容 text()、html()、val()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).text(&quot;hello&quot;));</span><br><span class="line">&#125;)</span><br><span class="line">//-----------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).html(&quot;hello&quot;))</span><br><span class="line">&#125;)</span><br><span class="line">//------------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  alert($(&quot;input&quot;).val(&quot;hello&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>text()、html() 以及 val() 的回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).text(function(i,orignText)&#123;</span><br><span class="line">        //i 为被选元素列表中当前元素的下标</span><br><span class="line">        //orignText 为原来的值</span><br><span class="line">        //return 为返回的新值</span><br><span class="line"></span><br><span class="line">        return &quot;hello&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>设置属性 attr()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).attr(&quot;data-text&quot;,&quot;hello world&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 允许同时设置多个属性</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).attr(&#123;</span><br><span class="line">        &quot;data-text&quot;,&quot;hello world&quot;,</span><br><span class="line">        &quot;title&quot;,&quot;jQuery学习！&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>attr() 也存在回调函数(同上)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;#runoob&quot;).attr(&quot;href&quot;, function(i,origValue)&#123;</span><br><span class="line">    return origValue + &quot;/jquery&quot;; </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><ul>
<li><p>removeAttr()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;span&quot;).removeAttr(&quot;class name&quot;);</span><br><span class="line">//表示同时删除span标签的class和name属性</span><br></pre></td></tr></table></figure></li>
<li><p>removeProp()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;span&quot;).removeProp(&quot;class&quot;);</span><br><span class="line">//表示删除所有span标签的class属性</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jQuery-添加元素"><a href="#jQuery-添加元素" class="headerlink" title="jQuery 添加元素"></a>jQuery 添加元素</h3><ul>
<li><p>append/prepend 是在选择元素内容嵌入(文本或标签)</p>
</li>
<li><p>after/before 实在元素外部追加(文本或标签)</p>
</li>
<li><p>参数可以是多个，可以是一个list</p>
</li>
</ul>
<h3 id="jQuery-删除元素"><a href="#jQuery-删除元素" class="headerlink" title="jQuery 删除元素"></a>jQuery 删除元素</h3><ul>
<li><p>remove() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).remove()</span><br><span class="line"></span><br><span class="line">//remove() 方法删除被选元素及其子元素</span><br></pre></td></tr></table></figure></li>
<li><p>empty() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).empty()</span><br><span class="line"></span><br><span class="line">//empty() 方法删除被选元素的子元素而不删除自身</span><br></pre></td></tr></table></figure></li>
<li><p>过滤被删除的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).remove(&quot;.italic&quot;)</span><br><span class="line"></span><br><span class="line">//表示删除所有&lt;p&gt;标签元素中class = &quot;italic&quot;的元素</span><br><span class="line">//过滤时，只能作用于同级元素之间</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jQuery-获取并设置CSS类"><a href="#jQuery-获取并设置CSS类" class="headerlink" title="jQuery 获取并设置CSS类"></a>jQuery 获取并设置CSS类</h3><ul>
<li><p>addClass() 向不用的元素添加class属性，在添加类时可以选取多个元素,也可以设置多个类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">	$(&quot;h1, h3, p&quot;).addClass(&quot;fontColor fontSize&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>removeClass() 在不同元素中删除指定的class属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">	$(&quot;h1, h3, p&quot;).removeClass(&quot;fontSize&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>toggleClass() 对被选元素进行添加/删除类的切换操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;.btn2&quot;).click(function()&#123;</span><br><span class="line">	$(&quot;h1, h3, p&quot;).toggleClass(&quot;fontColor2&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="css-方法"><a href="#css-方法" class="headerlink" title="css() 方法"></a>css() 方法</h3><ul>
<li>返回css属性<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).css(&quot;background-color&quot;);</span><br></pre></td></tr></table></figure></li>
<li>设置css属性,可以同时设置多个<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).css(&#123;&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><ul>
<li><p>width()、height()</p>
<ul>
<li>width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）</li>
<li>height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).width() //获取</span><br><span class="line">$(&quot;p&quot;).width(20) //设置</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>innerWidth()、innerHeight()</p>
<ul>
<li>innerWidth() 方法返回元素的宽度（包括内边距）。</li>
<li>innerHeight() 方法返回元素的高度（包括内边距）。</li>
</ul>
</li>
<li><p>outerWidth()、outerHeight()</p>
<ul>
<li>outerWidth() 方法返回元素的宽度（包括内边距和边框）。</li>
<li>outerHeight() 方法返回元素的高度（包括内边距和边框）。</li>
</ul>
</li>
<li><p>offset()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;.son&quot;).offset().left //元素距离窗口的偏移距离</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).offset(&#123;</span><br><span class="line">    left: 20,</span><br><span class="line">&#125;) //设置元素距离窗口的偏移距离</span><br></pre></td></tr></table></figure></li>
<li><p>position()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;.son&quot;).position().left //获取元素距离定位元素的偏移距离</span><br><span class="line"></span><br><span class="line">// 注意点：position() 方法只能获取不能设置</span><br></pre></td></tr></table></figure></li>
<li><p>scrollTop() </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;scroller&quot;).scrollTop() //获取元素相对滚动条顶部的偏移</span><br><span class="line"></span><br><span class="line">$(&quot;scroller&quot;).scrollTop(300) //设置元素相对滚动条顶部的偏移</span><br><span class="line"></span><br><span class="line">//获取网页滚动的偏移(考虑兼容)</span><br><span class="line">$(&quot;body&quot;).scrollTop() + $(&quot;html&quot;).scrollTop() //ie-&gt;body,chrome...-&gt;html</span><br><span class="line"></span><br><span class="line">//设置网页滚动的偏移(考虑兼容)</span><br><span class="line">$(&quot;html,body&quot;).scrollTop(300) </span><br></pre></td></tr></table></figure></li>
<li><p>补充：设置了box-sizing后，width()=width - padding - border</p>
</li>
</ul>
<h3 id="jQuery遍历"><a href="#jQuery遍历" class="headerlink" title="jQuery遍历"></a>jQuery遍历</h3><h4 id="祖先"><a href="#祖先" class="headerlink" title="祖先"></a>祖先</h4><ul>
<li><p>parent() 返回元素的直接父元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>parents() 返回被选元素的所有祖先元素，直到文档根元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents();</span><br><span class="line">&#125;)</span><br><span class="line">//过滤所有祖先，并且是&lt;ul&gt;元素</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents(&quot;ul&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>parentsUntil() 返回给定的两个元素之间的所有祖先元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//返回&lt;span&gt;与&lt;div&gt;元素之间的所有祖先元素</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parentsUntil(&quot;div&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="后代"><a href="#后代" class="headerlink" title="后代"></a>后代</h4><ul>
<li><p>children() 返回被选元素的所有直接子元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;div&quot;).children();</span><br><span class="line"></span><br><span class="line">//可以使用可选参数来过滤子元素的搜索</span><br><span class="line">$(&quot;div&quot;).children(&quot;p.aaa&quot;); //返回类名为aaa的&lt;p&gt;元素，且是div的直接子元素。</span><br></pre></td></tr></table></figure></li>
<li><p>find() 返回被选元素的后代元素，一路向下直到最后一个后代</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;div&quot;).find(&quot;span&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="同胞"><a href="#同胞" class="headerlink" title="同胞"></a>同胞</h4><ul>
<li><p>siblings() 返回被选元素的所有同胞元素，可以使用可选参数过滤搜索。</p>
</li>
<li><p>next() 返回被选元素的下一个同胞元素，只返回一个元素</p>
</li>
<li><p>nextAll() 返回被选元素的所有跟随的同胞元素</p>
</li>
<li><p>nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素</p>
</li>
<li><p>pre()、prevAll()、prevUntil() 同上，方向相反</p>
</li>
</ul>
<h4 id="过滤：缩小搜索元素的范围"><a href="#过滤：缩小搜索元素的范围" class="headerlink" title="过滤：缩小搜索元素的范围"></a>过滤：缩小搜索元素的范围</h4><ul>
<li><p>first() 返回被选元素的首个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).first();</span><br></pre></td></tr></table></figure></li>
<li><p>last() 返回被选元素的最后一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).last();</span><br></pre></td></tr></table></figure></li>
<li><p>eq() 返回被选元素中带有指定索引号的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).eq(1);</span><br><span class="line"></span><br><span class="line">//索引号从0开始，eq(1)选择的是第二个&lt;p&gt;元素</span><br></pre></td></tr></table></figure></li>
<li><p>filter() 允许规定一个标准，返回匹配的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).filter(&quot;.className&quot;);</span><br><span class="line"></span><br><span class="line">//返回带有类名className的所有&lt;p&gt;元素</span><br></pre></td></tr></table></figure></li>
<li><p>not() 返回所有不匹配的元素，与filter()相反</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).not(&quot;.className&quot;);</span><br><span class="line"></span><br><span class="line">//返回所有不带有类名className的&lt;p&gt;元素</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之http</title>
    <url>/2019/09/06/Node-js%E4%B9%8Bhttp/</url>
    <content><![CDATA[<h3 id="创建一个简单的http服务"><a href="#创建一个简单的http服务" class="headerlink" title="创建一个简单的http服务"></a>创建一个简单的http服务</h3><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加载http核心模块</span><br><span class="line">var http = require(&#x27;http&#x27;)</span><br><span class="line"></span><br><span class="line">var server = http.createServer()</span><br><span class="line"></span><br><span class="line">//服务器要做的处理事情</span><br><span class="line">server.on(&#x27;request&#x27;, function() &#123;</span><br><span class="line">    console.log(&#x27;收到客户端的请求了&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//绑定端口号，启动服务器</span><br><span class="line">server.listen(3000, function()&#123;</span><br><span class="line">    console.log(&#x27;server start.....&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;)</span><br><span class="line"></span><br><span class="line">var server = http.createServer()</span><br><span class="line"></span><br><span class="line">//request 请求处理函数，需要接受两个参数</span><br><span class="line">server.on(&#x27;request&#x27;, function(request, response) &#123;</span><br><span class="line">//  request 请求对象</span><br><span class="line">//  请求对象可以获取客户端的一些请求信息，如请求路径</span><br><span class="line">    console.log(&#x27;收到客户端的请求了,路径是：&#x27;+ request.url)</span><br><span class="line">    </span><br><span class="line">//  response 响应对象</span><br><span class="line">//  响应数据只能是二进制数据或者字符串</span><br><span class="line">//  响应对象可以用开给客户端发送响应消息</span><br><span class="line">//  response对象中：write给客户端发送响应数据，最后使用end结束</span><br><span class="line">    response.write(&#x27;hello&#x27;)</span><br><span class="line">    response.write(&#x27; nodejs &#x27;)</span><br><span class="line">    response.end(request.url)</span><br><span class="line">    </span><br><span class="line">//  或者直接end的同时发送响应数据：</span><br><span class="line">//  response.end(&#x27;hello nodejs&#x27;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(3000, function()&#123;</span><br><span class="line">    console.log(&#x27;server start.....&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Content-Type设置编码"><a href="#Content-Type设置编码" class="headerlink" title="Content-Type设置编码"></a>Content-Type设置编码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;)</span><br><span class="line">var server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(&#x27;request&#x27;,function (req,res) &#123;</span><br><span class="line">    //设置服务器响应内容的编码</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/plain;charset=utf-8&#x27;)</span><br><span class="line">    res.end(&#x27;hello 世界&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000, function () &#123;</span><br><span class="line">    console.log(&#x27;server is running...&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中判断数据类型</title>
    <url>/2019/07/16/JavaScript%E4%B8%AD%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="JavaScript中判断数据类型的几种方法"><a href="#JavaScript中判断数据类型的几种方法" class="headerlink" title="JavaScript中判断数据类型的几种方法"></a>JavaScript中判断数据类型的几种方法</h2><h4 id="一、typeof直接返回数据类型，但是无法判断数组、null、对象"><a href="#一、typeof直接返回数据类型，但是无法判断数组、null、对象" class="headerlink" title="一、typeof直接返回数据类型，但是无法判断数组、null、对象"></a>一、typeof直接返回数据类型，但是无法判断数组、null、对象</h4><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof 1</span><br><span class="line">&quot;number&quot;</span><br><span class="line"></span><br><span class="line">typeof NaN</span><br><span class="line">&quot;number&quot;</span><br><span class="line"></span><br><span class="line">typeof &quot;1&quot;</span><br><span class="line">&quot;string&quot;</span><br><span class="line"></span><br><span class="line">typeof true</span><br><span class="line">&quot;boolean&quot;</span><br><span class="line"></span><br><span class="line">typeof undefined</span><br><span class="line">&quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">typeof null</span><br><span class="line">&quot;object&quot;</span><br><span class="line"></span><br><span class="line">typeof []</span><br><span class="line">&quot;object&quot;</span><br><span class="line"></span><br><span class="line">typeof &#123;&#125;</span><br><span class="line">&quot;object&quot;</span><br></pre></td></tr></table></figure>
<pre><code>其中，null、[]、&#123;&#125;都返回“object”。null可是原始数据类型的啊，怎么就是&#39;object&#39;
了呢？？原来这个已经是历史问题了，在 JS 的最初版本中使用的是 32 位系统，为了性能
考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，
所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个
 Bug 却是一直流传下来。
</code></pre>
<h4 id="二、instanceof"><a href="#二、instanceof" class="headerlink" title="二、instanceof"></a>二、instanceof</h4><pre><code>检测的是 原型，只能用来判断两个对象是否属于实例关系，而不能判断
一个对象实例具体属于哪种类型
</code></pre>
<p><code>MDN: instanceof 运算符用于测试构造函数的prototype属性是否出现在对象的原型链中。</code></p>
<pre><code>f instanceof Foo 的判断逻辑为：
f 的 __proto__ 一层一层往上，是否能找到对应的Foo.prototype
之后再判断f instanceof Object

如何判断一个数组？
方法1：instanceof
arr instanceof Array

方法2：Array.isArray()
Array.isArray([])
</code></pre>
<h4 id="三、constructor"><a href="#三、constructor" class="headerlink" title="三、constructor"></a>三、constructor</h4><pre><code>当一个函数被定义时，JS引擎会为其添加prototype原型，然后再再prototype上添加一个
constructor属性，并让其指向该函数的引用，在实例对象的__proto__属性上面。

null 和 undefined 是无效的对象，因此是不会有constructor存在的，这两种类型需要其他方式
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function F()&#123;&#125;</span><br><span class="line">var f = new F</span><br><span class="line">f.constructor == F //true</span><br><span class="line"></span><br><span class="line">F.prototype = &#123;a:1&#125;</span><br><span class="line">var f = new F</span><br><span class="line">f.constructor == F //false</span><br></pre></td></tr></table></figure>
<pre><code>函数的constructor是不稳定的，主要体现在自定义对象上，当开发者重写prototype时，
原有的constructor引用会丢失，constructor会默认为Object

因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证
对象实例的类型不被篡改
</code></pre>
<h4 id="四、使用Object-prototype-toString-call-判断"><a href="#四、使用Object-prototype-toString-call-判断" class="headerlink" title="四、使用Object.prototype.toString.call()判断"></a>四、使用Object.prototype.toString.call()判断</h4><pre><code>call()方法可以改变this的指向，把Object.prototype.toString.call()方法指向
不同的数据上面，返回不同的结果。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(1)</span><br><span class="line">&quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(NaN);</span><br><span class="line">&quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&quot;1&quot;);</span><br><span class="line">&quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)</span><br><span class="line">&quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null)</span><br><span class="line">&quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined)</span><br><span class="line">&quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(function a() &#123;&#125;);</span><br><span class="line">&quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([]);</span><br><span class="line">&quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;);</span><br><span class="line">&quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>

<p><code>最后我们可以定义一个完美的判断数据类型的方法_typeof()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _typeof(obj)&#123;</span><br><span class="line">  var s = Object.prototype.toString.call(obj);</span><br><span class="line">  return s.match(/\[object (.*?)\]/)[1].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_typeof([12,3,343]);</span><br><span class="line">&quot;array&quot;</span><br><span class="line"></span><br><span class="line">_typeof(&#123;name: &#x27;zxc&#x27;, age: 18&#125;);</span><br><span class="line">&quot;object&quot;</span><br><span class="line"></span><br><span class="line">_typeof(1);</span><br><span class="line">&quot;number&quot;</span><br><span class="line"></span><br><span class="line">_typeof(&quot;1&quot;);</span><br><span class="line">&quot;string&quot;</span><br><span class="line"></span><br><span class="line"> _typeof(null);</span><br><span class="line">&quot;null&quot;</span><br><span class="line"></span><br><span class="line">_typeof(undefined);</span><br><span class="line">&quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">_typeof(NaN);</span><br><span class="line">&quot;number&quot;</span><br><span class="line"></span><br><span class="line">_typeof(Date);</span><br><span class="line">&quot;function&quot;</span><br><span class="line"></span><br><span class="line">_typeof(new Date());</span><br><span class="line">&quot;date&quot;</span><br><span class="line"></span><br><span class="line">_typeof(new RegExp());</span><br><span class="line">&quot;regexp&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2019/08/12/Promise/</url>
    <content><![CDATA[<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><span id="more"></span>
<pre><code>promise: 用来解决两个问题：
    1. 回调地狱，代码难以维护，不易阅读。
    2. promise可以支持多个并发的请求，获取并发请求中的数据。
    
Promise对象有三个状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)
Promise状态一旦改变，结果就定死了，就不会再变了。

all方法：
    所有异步操作都执行成功，才会执行成功的回调，有一个失败就会执行失败的回调。
    
race方法：
    谁先执行完就返回谁的状态和回调。
    
finally() 允许指定最终的逻辑 （ES9新特性）
一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。而在某些情况下
想要在无论成功还是失败运行相同的代码，例如：清除，删除对话，关闭数据库连接等。
这时，.finally()可以允许你指定最终的逻辑

function doSomething() &#123;
    doSomething1()
    .then(doSomething2)
    .then(doSomething3)
    .catch(err =&gt; &#123;
        console.log(arr)
    &#125;)
    .finally(() =&gt; &#123;
        // 最终执行逻辑
    &#125;)
&#125;

=========================
</code></pre>
<p>   //实例演示(node中读取文件)：<br>   var fs = require(‘fs’)<br>   var p1 = new Promise(function(resolve, reject){<br>    fs.readFile(‘./data/a.txt’, ‘utf8’, function(err, data){<br>        if(err){<br>            reject(err)<br>        } else {<br>            resolve(data)<br>        }<br>    })<br>   })</p>
<p>   var p2 = new Promise(function(resolve, reject){<br>       fs.readFile(‘./data/b.txt’, ‘utf8’, function(err, data){<br>           if(err){<br>               reject(err)<br>           } else {<br>               resolve(data)<br>           }<br>       })<br>      })</p>
<p>   // 返回promise对象时，可以进行链式调用<br>   p1<br>   .then(function(data){<br>    console.log(data)<br>    return p2<br>   }, function(err){<br>    console.log(‘读取文件失败’, err)<br>   })<br>   .then(function(data){<br>    console.log(data)<br>    //return p3<br>   },function(err){<br>    console.log(err)<br>   )</p>
<p>   =====================<br>   //用promise封装node中readFile API<br>   var fs = require(‘fs’)</p>
<p>   function ReadFile(filePath){<br>    return new Promise(function(resolve, reject){<br>        fs.readFile(filePath, ‘utf8’, function(err, data){<br>            if(err){<br>                reject(err)<br>            } else {<br>                resolve(data)<br>            }<br>        })<br>    })<br>   }</p>
<p>   ReadFile(‘./data/a.txt’)<br>   .then(function(data){<br>    console.log(data)<br>   })</p>
<p>   ========================</p>
<p>   //promise封装ajax中get请求<br>   function pGet(url, callback){<br>    return new Promise(function(resolve, reject){<br>        var xhr = new XMLHttpRequest()<br>        xhr.onload = function(){<br>            callback &amp;&amp; callback(JSON.parse(xhr.responseText))<br>            resolve(JSON.parse(xhr.responseText))<br>        }<br>        xhr.onerror = function(err){<br>            reject(err)<br>        }<br>        xhr.open(“get”, url, true) //为true则是异步执行<br>        xhr.send()<br>    })<br>   }</p>
<p>手写promise</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myPromise(constructor)&#123;</span><br><span class="line">    let self=this;</span><br><span class="line">    self.status=&quot;pending&quot; //定义状态改变前的初始状态</span><br><span class="line">    self.value=undefined;//定义状态为resolved的时候的状态</span><br><span class="line">    self.reason=undefined;//定义状态为rejected的时候的状态</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class="line">          self.value=value;</span><br><span class="line">          self.status=&quot;resolved&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class="line">          self.reason=reason;</span><br><span class="line">          self.status=&quot;rejected&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //捕获构造异常</span><br><span class="line">    try&#123;</span><br><span class="line">       constructor(resolve,reject);</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">       reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同时再myPromise的原型上定义链式调用的then方法：</span><br><span class="line"></span><br><span class="line">myPromise.prototype.then=function(onFullfilled,onRejected)&#123;</span><br><span class="line">   let self=this;</span><br><span class="line">   switch(self.status)&#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之实现读写文件操作</title>
    <url>/2019/08/29/Node.js%E4%B9%8B%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="用nodejs实现读取文件操作"><a href="#用nodejs实现读取文件操作" class="headerlink" title="用nodejs实现读取文件操作"></a>用nodejs实现读取文件操作</h2><span id="more"></span>
<pre><code> const fs = require(&quot;fs&quot;)
 
//fs 核心模块提供了一个fs.readFile方法，用来读取指定目录下的文件

//fs.readFile有三个参数
// 1. 读取文件的路径
// 2. 读取文件的编码格式
// 3. 当文件读取完成，调用这个callback回调函数来读取文件的结果

fs.readFile(&#39;./data/hello.txt&#39;,&#39;utf-8&#39;,function(err,data)&#123;
    if(err)&#123;
        console.log(err)    //第一个参数是err对象
        return
    &#125; else &#123;
        console.log(data)   //第二个参数才是data数据    
    &#125;
&#125;)
</code></pre>
<h2 id="用nodejs实现写入文件操作"><a href="#用nodejs实现写入文件操作" class="headerlink" title="用nodejs实现写入文件操作"></a>用nodejs实现写入文件操作</h2><pre><code>const fs = require(&#39;fs&#39;)

let msg = &#39;hello world&#39;

//fs.writeFile有三个参数
// 1. 第一个参数为写入的文件路径
// 2. 第二个参数为写入的内容
// 3. 第三个参数为可选参数，表示写文件的编码格式
// 4. 第四个参数为回调函数，回调函数只有一个参数err，判断是否写入成功。

fs.writeFile(&#39;./data/hello.txt&#39;,msg,&#39;utf-8&#39;,function(err)&#123;
    if(err)&#123;
        console.log(&#39;写入错误&#39; + err)
    &#125; else &#123;
        console.log(&#39;ok&#39;)
    &#125;
&#125;)
</code></pre>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React</title>
    <url>/2019/07/01/React/</url>
    <content><![CDATA[<h2 id="React的基本认识"><a href="#React的基本认识" class="headerlink" title="React的基本认识"></a>React的基本认识</h2><ul>
<li>Fecebook开源的一个js库</li>
<li>一个用来动态构建用户界面的js库</li>
<li>React的特点：<ul>
<li>声明式编程</li>
<li>组件化编程</li>
<li>高效</li>
<li>单向数据流</li>
<li>支持客户端与服务端渲染</li>
</ul>
</li>
<li>React高效的原因<ul>
<li>虚拟DOM，不直接操作DOM(批量更新，减少更新的次数)</li>
<li>高效的DOM Diff算法，最小化页面重绘(减小页面更新的区域)</li>
</ul>
</li>
</ul>
<h2 id="React中的生命周期函数"><a href="#React中的生命周期函数" class="headerlink" title="React中的生命周期函数"></a>React中的生命周期函数</h2><p>生命周期函数是指组件在某一时刻自动执行的函数</p>
<span id="more"></span>
<img src="https://raw.githubusercontent.com/foolishmax/static/master/images/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.png"/>

<h3 id="初始化过程（Initialization）"><a href="#初始化过程（Initialization）" class="headerlink" title="初始化过程（Initialization）"></a>初始化过程（Initialization）</h3><ul>
<li>在constructor()里面初始化Props和State属性。</li>
<li>getDefaultProps()可以设置组件的默认属性值。</li>
</ul>
<h3 id="挂载过程（Mounting）"><a href="#挂载过程（Mounting）" class="headerlink" title="挂载过程（Mounting）"></a>挂载过程（Mounting）</h3><ul>
<li>componentWillMount(): 在组件即将被挂载到页面的时刻自动执行。</li>
<li>render(): 将组件挂载到页面。</li>
<li>componentDidMount(): 组件被挂载到页面之后立即执行。</li>
</ul>
<h3 id="更新过程（Updation）"><a href="#更新过程（Updation）" class="headerlink" title="更新过程（Updation）"></a>更新过程（Updation）</h3><ul>
<li>componentWillReceiveProps()（在16.4版本中废弃，不推荐使用）：<br>  一个组件从父组件接受参数，如果这个组件第一次存在父组件中不会执行，已经存在才会执行，<br>  如果没有Props属性则直接跳过。</li>
<li>shouldComponentUpdate():<br>  组件更新前检查是否需要更新组件，返回布尔类型。此生命周期函数可以强制关闭不需要更新的子组件<br>  来提高渲染性能。</li>
<li>componentWillUpdate():<br>  组件更新之前自动执行。前提是shouldComponentUpdate()执行并返回true</li>
<li>render():<br>   将组件更新到页面</li>
<li>componentDidUpdate():<br>   组件更新完成之后立即执行。</li>
</ul>
<h3 id="移除过程（Unmounting）"><a href="#移除过程（Unmounting）" class="headerlink" title="移除过程（Unmounting）"></a>移除过程（Unmounting）</h3><ul>
<li>componentWillUnmount():<br>  当组件即将从页面中移除时执行。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>React中的render() 也是生命周期函数，而constructor()并不是生命周期函数。</li>
<li>所有的组件都有生命周期函数。</li>
<li>除了render()函数，其他函数都可以不写，因为除了render()函数其他函数都是继承自<br>  React中内置的。</li>
<li>AJAX请求一般都是放在componentDidMount()里面。</li>
</ul>
<h2 id="React状态提升"><a href="#React状态提升" class="headerlink" title="React状态提升"></a>React状态提升</h2><ul>
<li><p>所谓状态提升，就是将  各个子组件的公共state提升到它们的父组件进行统一存储、处理<br>(单一数据源)，然后将父组件处理后的数据或者函数props到各个子组件中。</p>
</li>
<li><p>如果子组件要修改父组件中state该怎么办？</p>
<ul>
<li>做法就是将父组件中负责setState的函数，以props的形式传给子组件，然后子组件<br>需要改变state时调用即可。</li>
</ul>
</li>
</ul>
<h2 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h2><ul>
<li>React Router包装了BrowserRouter和HashRouter两个组件。<ul>
<li>BrowserRouter使用HTML5的history API(pushState、replaceState等)实现<br>UI和URL的同步</li>
<li>HashRouter使用URL的hash实现应用的UI和URL同步</li>
</ul>
</li>
</ul>
<h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><ul>
<li><p>useState</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用法：</span><br><span class="line"></span><br><span class="line">//useState唯一的参数就是初始state</span><br><span class="line">//返回一个数组，第一项state，第二项更新state的函数</span><br><span class="line">const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">//函数式更新</span><br><span class="line">//如果新的state需要通过使用以前的state计算得出，可以将函数传递给setState。</span><br><span class="line">//例如：</span><br><span class="line">setCount((count) =&gt; &#123;</span><br><span class="line">    return count + 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//惰性初始化state，对复杂初始数据，initialState可以是一个函数</span><br><span class="line">//函数或initialState参数只会在组件的初始渲染中起作用</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [&#123;name, number&#125;,setValue] = useState(() =&gt; &#123;</span><br><span class="line">        return &#123;name:&#x27;计数器&#x27;,number:0&#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;name&#125;:&#123;number&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setValue(&#123;number: number + 1&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">--------------</span><br><span class="line">//官网例子</span><br><span class="line">const [state, setState] = useState(() =&gt; &#123;</span><br><span class="line">    const initialState = someExpensiveComputation(props);</span><br><span class="line">    return initialState;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//useState的初始值，只在第一次有效</span><br><span class="line">//按照有序的方式使用useState不得在循环判断等条件语句中使用</span><br><span class="line">//useState不会自动合并更新对象，需使用扩展符&#123;...obj,name:&#x27;lisi&#x27;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>useEffect</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//基本使用</span><br><span class="line">//useEffect有两个参数：function(执行项)，array(依赖项)</span><br><span class="line">useEffect(() =&gt; &#123;&#125;,[name]);</span><br><span class="line"></span><br><span class="line">//如果依赖项为空数组，只会在第一次挂载后执行，类似componentDidMount</span><br><span class="line">useEffect(() =&gt; &#123;&#125;,[]);</span><br><span class="line"></span><br><span class="line">//清除副作用，模拟componentUnMount</span><br><span class="line">//通过返回一个函数来指定如何清除副作用，防止内存泄漏，函数会在组件卸载前执行</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    let timer = setInterVal(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;定时器&quot;);</span><br><span class="line">    &#125;,1000)</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        clearInterval(timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[name])</span><br><span class="line"></span><br><span class="line">//注意：可以在组件中多次使用useEffect</span><br><span class="line">//Hook 允许我们按照代码的用途分离他们，react将按照effect声明的顺序依次调用组件中的每一个effect</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>useContext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//父组件创建上下文</span><br><span class="line">const Context = createContext();</span><br><span class="line">//并将数据传递给子组件</span><br><span class="line">const [num, setNum] = useState(0);</span><br><span class="line">&lt;Context.Provider value=&#123;&#123;num, setNum&#125;&#125;&gt;</span><br><span class="line">    &lt;Children /&gt;</span><br><span class="line">&lt;/Context.Provider&gt;</span><br><span class="line"></span><br><span class="line">//子组件接收</span><br><span class="line">const &#123;num, setNum&#125; = useContext(Context);</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    setNum(num + 1);</span><br><span class="line">&#125;,[])</span><br><span class="line">&lt;p&gt;&#123;num&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>useReducer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//基础使用</span><br><span class="line">const initialState = &#123; count: 0 &#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action)&#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case &#x27;increment&#x27;:</span><br><span class="line">            return &#123;count:state.count + 1&#125;;</span><br><span class="line">        case &#x27;decrement&#x27;:</span><br><span class="line">            return &#123;count:state.count - 1&#125;;</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function MyUseReducer() &#123;</span><br><span class="line">    const [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            count: &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type:&#x27;decrement&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type:&#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//惰性初始化</span><br><span class="line">//稍加改造</span><br><span class="line">const initialCount = 0;</span><br><span class="line"></span><br><span class="line">function init(initialCount) &#123;</span><br><span class="line">  return &#123;count: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#x27;increment&#x27;:</span><br><span class="line">      return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#x27;decrement&#x27;:</span><br><span class="line">      return &#123;count: state.count - 1&#125;;</span><br><span class="line">    case &#x27;reset&#x27;:</span><br><span class="line">      return init(action.payload);</span><br><span class="line">    default:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function MyUseReducer() &#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, initialCount , init);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;》》</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之特性</title>
    <url>/2019/08/29/Node.js%E4%B9%8B%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么?"></a>Node.js是什么?</h3><ul>
<li><p>Node.js是一个JavaScript运行时环境，可以解析和执行js代码。</p>
<span id="more"></span></li>
<li><p>构建于 Chrome 的V8引擎之上</p>
</li>
<li><p>没有BOM、DOM，有EcmaScript语法。</p>
</li>
<li><p>node中有很多具名的核心模块</p>
<ul>
<li>fs 文件操作模块</li>
<li>http 服务器构建模块</li>
<li>path 路径模块</li>
<li>os 操作系统信息模块</li>
</ul>
</li>
<li><p>在核心模块中提供了一些服务器级别的操作API</p>
<ul>
<li>文件读写</li>
<li>网络服务的构建</li>
<li>网络通信</li>
<li>http服务器<!--more-->
<h3 id="node都有哪些特性？"><a href="#node都有哪些特性？" class="headerlink" title="node都有哪些特性？"></a>node都有哪些特性？</h3></li>
</ul>
</li>
<li><p>单线程</p>
<ul>
<li>不会为每个用户连接创建一个新的线程，仅仅使用一个线程，减少了操作系统的线程创建<br>和销毁的时间开销。缺点就是一个用户造成线程的崩溃会导致整个服务的崩溃。</li>
<li>减少内存的开销</li>
</ul>
</li>
<li><p>事件驱动 event-driven</p>
<ul>
<li>node中一个时刻只能执行一个事件回调函数，但是执行过程中，可以转而处理<br>其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。</li>
</ul>
</li>
<li><p>非阻塞I/O</p>
<ul>
<li>I/O数据传输操作会阻塞代码的执行，极大降低了程序的执行效率,因为一个线程只能处理<br>一项任务，要想提高吞吐量必须通过多线程。非阻塞I/O机制，可以将异步操作的处理<br>代码放在回调函数中，从而提高了程序的执行效率。</li>
</ul>
</li>
</ul>
<h3 id="浏览器的进程和线程"><a href="#浏览器的进程和线程" class="headerlink" title="浏览器的进程和线程"></a>浏览器的进程和线程</h3><ul>
<li>一个程序可以有多个进程</li>
<li>一个进程可以有多个线程</li>
<li>进程在执行u欧城中拥有独立的内存单元，而多个线程共享内存。</li>
<li>多个线程之间可以相互通信</li>
<li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口</li>
<li>线程不能独立执行，必须依存在应用程序中</li>
</ul>
<h3 id="Node-js适合开发什么？"><a href="#Node-js适合开发什么？" class="headerlink" title="Node.js适合开发什么？"></a>Node.js适合开发什么？</h3><ul>
<li>善于I/O,不善于计算，因为Node.js最擅长的就是任务调度，不适合于利用CPU进行过多的运算的程序。</li>
<li>当应用程序需要处理大量并发的I/O,而在向客户端发出响应之前，应用程序内部不需要<br>进行非常复杂处理的时候，Node.js非常合适。</li>
<li>Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。<ul>
<li>用户表单</li>
<li>考试系统</li>
<li>聊天室</li>
<li>图文直播</li>
</ul>
</li>
</ul>
<h3 id="nodejs能做什么？"><a href="#nodejs能做什么？" class="headerlink" title="nodejs能做什么？"></a>nodejs能做什么？</h3><ul>
<li>Node.js可以生成动态页面内容</li>
<li>Node.js可以创建，打开，读取，写入，删除和关闭服务器上的文件</li>
<li>Node.js可以收集表单数据</li>
<li>Node.js可以添加，删除，修改数据库中的数据</li>
</ul>
<h3 id="服务端渲染和客户端渲染的区别"><a href="#服务端渲染和客户端渲染的区别" class="headerlink" title="服务端渲染和客户端渲染的区别"></a>服务端渲染和客户端渲染的区别</h3><ul>
<li>客户端渲染不利于SEO搜索引擎优化</li>
<li>服务器渲染可以被爬虫抓取</li>
<li>例如：京东商品列表是服务端渲染，用户评论是客户端渲染（提高用户体验）</li>
</ul>
<h4 id="小补充：使用cnpm"><a href="#小补充：使用cnpm" class="headerlink" title="小补充：使用cnpm"></a>小补充：使用cnpm</h4><ul>
<li>方法一 安装cnpm<ul>
<li><code>npm install --global cnpm</code></li>
</ul>
</li>
<li>方法二 改变registry<ul>
<li><code>npm install jquery --registry=https://registry.npm.taobao.org</code></li>
</ul>
</li>
<li>方法三 加入配置选项<ul>
<li><code>npm config set registry https://registry.npm.taobao.org</code></li>
<li><code>npm config list</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/2019/08/23/TypeScript/</url>
    <content><![CDATA[<h3 id="什么是-TypeScript？"><a href="#什么是-TypeScript？" class="headerlink" title="什么是 TypeScript？"></a>什么是 TypeScript？</h3><span id="more"></span>

<ul>
<li><p>TypeScript 是 JavaScript 的超集，任何合法的 js 程序都是合法的 TypeScript 程序</p>
</li>
<li><p>TypeScript 通过向 JavaScript 增加可选的静态类型声明把 JavaScript 变成强类型程序<br>语言</p>
</li>
<li><p>提供静态类型声明可约束函数、变量、属性等程序实体</p>
</li>
</ul>
<h3 id="为什么要使用-TypeScript？"><a href="#为什么要使用-TypeScript？" class="headerlink" title="为什么要使用 TypeScript？"></a>为什么要使用 TypeScript？</h3><ol>
<li><p>提供了静态类型系统，大大增强了代码的可读性以及可维护性</p>
</li>
<li><p>提供最新和不断发展的 javascript 特性，能让我们建立 更健壮的组件</p>
</li>
<li><p>TS 具有防患于未然的静态检查，以及干净利落的只能提示</p>
</li>
</ol>
<h3 id="TypeScript-中的数据类型"><a href="#TypeScript-中的数据类型" class="headerlink" title="TypeScript 中的数据类型"></a>TypeScript 中的数据类型</h3><blockquote>
<p>typescript 中为了使编写的代码更规范，更利于维护，增加了类型校验，在 typescript 中<br>主要提供了以下数据类型：</p>
</blockquote>
<ul>
<li>布尔类型 bolean</li>
<li>数字类型 number</li>
<li>字符串类型 string</li>
<li>数组类型 array</li>
<li>元组类型 tuple</li>
<li>枚举类型 enum</li>
<li>任意类型 any</li>
<li>null 和 undefined</li>
<li>void 类型</li>
<li>never 类型</li>
</ul>
<blockquote>
<p>typescript 中为了使编写的代码更规范，更有利于维护，增加了类型校验，写 ts 代码必须指定类型</p>
</blockquote>
<h3 id="未声明类型的变量-如果变量在声明的时候，未指定其类型，那么他会被识别为任意类"><a href="#未声明类型的变量-如果变量在声明的时候，未指定其类型，那么他会被识别为任意类" class="headerlink" title="未声明类型的变量: 如果变量在声明的时候，未指定其类型，那么他会被识别为任意类"></a>未声明类型的变量: 如果变量在声明的时候，未指定其类型，那么他会被识别为任意类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let something;</span><br><span class="line"></span><br><span class="line">something = &#x27;seven&#x27;</span><br><span class="line"></span><br><span class="line">something = 7</span><br><span class="line">//不会报错</span><br></pre></td></tr></table></figure>

<h3 id="如果没有明确的指定类型，那么-typescript-会依照类型推论的规则推导出一个规则"><a href="#如果没有明确的指定类型，那么-typescript-会依照类型推论的规则推导出一个规则" class="headerlink" title="如果没有明确的指定类型，那么 typescript 会依照类型推论的规则推导出一个规则"></a>如果没有明确的指定类型，那么 typescript 会依照类型推论的规则推导出一个规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = &#x27;seven&#x27;</span><br><span class="line">num = 7</span><br><span class="line">//会报错</span><br><span class="line">//上面代码等价于：</span><br><span class="line">let num:string = &#x27;seven&#x27;</span><br><span class="line">num = 7</span><br><span class="line">//typescript自动推测出num属于string类型</span><br></pre></td></tr></table></figure>

<h3 id="联合类型：表示取值可以为多种类型中的一种"><a href="#联合类型：表示取值可以为多种类型中的一种" class="headerlink" title="联合类型：表示取值可以为多种类型中的一种"></a>联合类型：表示取值可以为多种类型中的一种</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let flag:string | number</span><br><span class="line">flag = &#x27;seven&#x27;</span><br><span class="line">flag = 7</span><br><span class="line">//联合类型使用 | 分隔每个类型，表示允许flag为string类型或者number类型</span><br><span class="line">---------------------------------------</span><br><span class="line">//访问联合类型的属性或者方法</span><br><span class="line">//当typescript不确定一个联合类型的变量到底是哪个类型的时候，</span><br><span class="line">我们只能访问联合类型的所有类型中共有的属性和方法</span><br><span class="line"></span><br><span class="line">function getLength(something:string|number):number&#123;</span><br><span class="line">    return something.length</span><br><span class="line">&#125;</span><br><span class="line">//上面代码会报错，因为length不是string和number共有的属性</span><br><span class="line"></span><br><span class="line">//可以访问共有属性toString()</span><br><span class="line">function getString(something:string|number):string &#123;</span><br><span class="line">    return something.toString()</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------</span><br><span class="line">//联合属性在赋值的时候，会根据类型推论的规则推断出一个类型</span><br><span class="line">let a:string|number</span><br><span class="line">a = &#x27;seven&#x27;</span><br><span class="line">console.log(a.length) //5，a被推断为string，有length属性</span><br><span class="line">a = 7</span><br><span class="line">console.log(a.length) //编译时报错，被推断为number，无length属性</span><br></pre></td></tr></table></figure>

<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//数组类型定义(不允许出现其他类型，数组方法参数也有限制，</span><br><span class="line">如push(&#x27;7&#x27;)会报错，不能为字符串)</span><br><span class="line">let arr:number[] = [1,2,3]</span><br><span class="line">let arr:(number | string)[] = [1,&#x27;1&#x27;,2]</span><br><span class="line">---------------------------------</span><br><span class="line">//数组泛型</span><br><span class="line">let arr:Array&lt;number&gt; = [1,2,3]</span><br><span class="line">----------------------------------</span><br><span class="line">//用接口表示数组</span><br><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index:number]:number</span><br><span class="line">&#125;</span><br><span class="line">let arr:NumberArray = [1,2,3]</span><br><span class="line">//NumberArray表示，只要index的类型时number，那么值的类型也必须时number</span><br><span class="line">-----------------------------------</span><br><span class="line">//any在数组中的应用</span><br><span class="line">let arr:any[] = [&#x27;hello&#x27;, 24, &#123;a:1&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//函数声明（不允许输入多余或者少于要求的参数）</span><br><span class="line">function sum(x:number, y: number):number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">sum(1,2) //right</span><br><span class="line">sum(1,2,3) //false</span><br><span class="line">sum(1) //false</span><br><span class="line">----------------------------------------------</span><br><span class="line">//函数表达式</span><br><span class="line">let sum:(x:number, y: number) =&gt; number = function(x:number, y:number):number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line">//可选参数（使用 ? 表示可选的参数，只能放在参数的最后，后面不允许出现必须参数）</span><br><span class="line">function buildName(firstName:string, lastName?:string):string &#123;</span><br><span class="line">    if (lastName) &#123;</span><br><span class="line">        return firstName + &#x27; &#x27; + lastName</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return firstName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;tom&#x27;, &#x27;cat&#x27;)</span><br><span class="line">let tom = buildName(&#x27;tom&#x27;)</span><br><span class="line">--------------------------------------------------</span><br><span class="line">//参数默认值（typescript会将添加了默认值的参数识别为可选参数）</span><br><span class="line">    function buildName(firstName:string, lastName:string = &#x27;cat&#x27;):string &#123;</span><br><span class="line">        if (lastName) &#123;</span><br><span class="line">            return firstName + &#x27; &#x27; + lastName</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return firstName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tomcat = buildName(&#x27;tom&#x27;, &#x27;cat&#x27;)</span><br><span class="line">    let tom = buildName(&#x27;tom&#x27;)</span><br><span class="line">----------------------------------------------------</span><br><span class="line">//剩余参数，可以使用...rest的方式获取函数中的剩余参数</span><br><span class="line">function push(array: any[], ...items:any[]) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let a = []</span><br><span class="line">push(a, 1,2,3,4)</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">//重载：允许一个函数接受不同数量或者类型的参数时，做出不同的处理</span><br><span class="line">//例如，数字或者字符串的反转输出</span><br><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型（注意点）"><a href="#泛型（注意点）" class="headerlink" title="泛型（注意点）"></a>泛型（注意点）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type A1 = &#x27;x&#x27; extends &#x27;x&#x27; ? string : number; // string</span><br><span class="line">type A2 = &#x27;x&#x27; | &#x27;y&#x27; extends &#x27;x&#x27; ? string : number; // number</span><br><span class="line"></span><br><span class="line">type P&lt;T&gt; = T extends &#x27;x&#x27; ? string : number;</span><br><span class="line">type A3 = P&lt;&#x27;x&#x27; | &#x27;y&#x27;&gt; // ?</span><br></pre></td></tr></table></figure>

<p>这里的<em>extends</em>是指<strong>类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集</strong>。<br>P 是带参数 T 的泛型类型，A1 和 A2 的形式一样，结果也很好理解，A3 是泛型类型 P 传入参数<br>**’x’ | ‘y’**得到的类型，如果将 <strong>‘x’ | ‘Y’</strong> 代入泛型类的表达式，那应该会得到和 A2 类型的形式完全一样的结果，这里直接给结论了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type P&lt;T&gt; = T extends &#x27;x&#x27; ? string : number;</span><br><span class="line">type A3 = P&lt;&#x27;x&#x27; | &#x27;y&#x27;&gt; // A3的类型是 string ｜ number</span><br></pre></td></tr></table></figure>

<p>结果是不是出人意料？原因就是<strong>分配条件类型</strong>,在 TS 中对于 extends 关键字的条件类型（即上面的三元表达式类型），如果<em>extends</em>前面的参数是一个(裸类型)泛型类型，当传入该参数的是联合类型，则使用分配律计算最终结果。</p>
<p><em>分配律</em>是指，将联合型类的联合项拆分成单项，分别代入条件类型，然后将每个单项代入，再将得到的结果联合起来，得到最终的结果。</p>
<ul>
<li>特殊的 never</li>
</ul>
<p>那么，我们在看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type A1 = never extends &#x27;x&#x27; ? string : number;</span><br><span class="line"></span><br><span class="line">type P&lt;T&gt; = T extends &#x27;x&#x27; ? string : number;</span><br><span class="line"></span><br><span class="line">type A2 = P&lt;never&gt; // never</span><br></pre></td></tr></table></figure>

<p>上面的例子中，A2 和 A1 的结果竟然不一样，看起来<em>never</em>并不是一个联合类型啊，所以直接代入条件类型获取的结果应该和 A1 相同才对啊？</p>
<p>实际上，<strong>never 被认为是空的联合类型</strong>，never 是一个没有联合项的联合类型，所以还是满足上面的分配律，又因为没有联合项可以分配，所以*P<T>*的表达式根本就没有执行，所以 A2 的定义就类似于永远没有返回的函数一样，是 never 类型。</p>
<ul>
<li>如何防止条件判断中的分配</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type P&lt;T&gt; = [T] extends [&#x27;x&#x27;] ? string : number;</span><br><span class="line"></span><br><span class="line">type A1 = P&lt;&#x27;x&#x27; | &#x27;y&#x27;&gt;; // number</span><br><span class="line"></span><br><span class="line">type A2 = P&lt;never&gt; // string</span><br></pre></td></tr></table></figure>

<p>在条件判断类型的定义中，将泛型参数使用 <strong>[]</strong> 括起来，即可阻断条件判断类型的分配，此时，传入的 T 的类型就会被当作一个整体，不再分配。</p>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2019/07/29/Vue/</url>
    <content><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h4 id="vue的特点（优点）"><a href="#vue的特点（优点）" class="headerlink" title="vue的特点（优点）"></a>vue的特点（优点）</h4><ul>
<li>vue关注视图层，用数据操作的方式代替了dom操作</li>
<li>vue通过响应式的数据绑定实现了数据和视图之间的更新交互</li>
<li>vue通过组件化开发让工程结构更加明确，更易于维护</li>
<li>vue通过虚拟DOM，优化了DOM操作，实现了性能提高</li>
<li>vue拥有自己的vue-cli脚手架工具，对良好的工程化性能</li>
</ul>
<h4 id="Vue的双向数据绑定原理是什么？"><a href="#Vue的双向数据绑定原理是什么？" class="headerlink" title="Vue的双向数据绑定原理是什么？"></a>Vue的双向数据绑定原理是什么？</h4><pre><code>vue.js 是采用 数据劫持 结合 发布-订阅者 模式的方式，通过Object.defineProperty()
来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：
1.当把一个普通JavaScript对象传给Vue实例当作它的data选项的时候，Vue会遍历它的属性，
用Object.defineProperty劫持各个属性的setter、getter，给这个对象的某一个值赋值，
就会触发setter，就能监听到数据的变化
2. compile解析模板指令，将模板中的变量替换成数据，然后渲染页面视图，并将每个指令对应的
节点添加监听数据的订阅者Watcher，一旦数据由变动，收到通知更新视图
3. 通过Observer来监听model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭
起Observer和Compile之间的桥梁，达到数据变化-&gt;视图更新，视图变化-&gt;数据更新。
</code></pre>
<span id="more"></span>

<h4 id="Proxy-与-Object-defineProperty-优劣对比？"><a href="#Proxy-与-Object-defineProperty-优劣对比？" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比？"></a>Proxy 与 Object.defineProperty 优劣对比？</h4><ul>
<li>Proxy的优势如下：<ul>
<li>Proxy可以监听对象，而Object.defineProperty只能监听属性。</li>
<li>Proxy还可以直接监听数组的变化。</li>
<li>Proxy有多大13种的拦截方法，不限于apply、ownKeys、deletePreperty等，这些<br>都是Object.defineProperty不具备的。</li>
<li></li>
</ul>
</li>
<li>Object.defineProperty的优势：<ul>
<li>兼容性好，支持IE9，而Proxy存在浏览器兼容问题。</li>
</ul>
</li>
</ul>
<h4 id="解释单向数据流和双向数据绑定"><a href="#解释单向数据流和双向数据绑定" class="headerlink" title="解释单向数据流和双向数据绑定"></a>解释单向数据流和双向数据绑定</h4><pre><code>单向数据流： 数据流是单向的，数据流动方向可以追踪，流动单一，追查问题可以更加方便快捷，
缺点就是写起来不太方便，要是UI发生变更就必须创建各种action来维护对应的state

双向数据绑定： 数据之间是相同的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的
场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，添加了出错debug的难度
</code></pre>
<h4 id="请详细说下你对Vue生命周期的理解？"><a href="#请详细说下你对Vue生命周期的理解？" class="headerlink" title="请详细说下你对Vue生命周期的理解？"></a>请详细说下你对Vue生命周期的理解？</h4><pre><code>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后

    beforeCreate 创建前执行（vue实例的挂载元素$el和数据对象data都为undefined，还未初始化）
    
    created 完成创建 （完成了data数据初始化，el还未初始化）
    
    beforeMount 载入前（vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。）
    
    mounted 载入后html已经渲染(vue实例挂载完成，data.message成功渲染。)
    
    beforeUpdate 更新前状态（view层的数据变化前，不是data中的数据改变前）
    
    updated 更新状态后
    
    beforeDestroy 销毁前
    
    destroyed 销毁后 （在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在）
    

说一下每一个阶段可以做的事情
    
    beforeCreate:可以在这里加一个loading事件，在加载实例时触发。
    
    created: 初始化完成时的事件写这里，如果这里结束了loading事件，异步请求也在这里调用。
    
    mounted: 挂载元素，获取到DOM节点
    
    updated: 对数据进行处理的函数写这里。
    
    beforeDestroy: 可以写一个确认停止事件的确认框。
    
</code></pre>
<h4 id="vue-router有哪几种导航钩子？"><a href="#vue-router有哪几种导航钩子？" class="headerlink" title="vue-router有哪几种导航钩子？"></a>vue-router有哪几种导航钩子？</h4><pre><code>三种

1. 全局导航钩子（跳转前进行判断拦截）

    + to: Route:即将要进入的目标 路由对象
    + from: Route:当前导航正要离开的路由
    + next: Function: 一定要调用该方法来resolve这个钩子，执行结果依赖于next方法的调用参数
        - next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。
        
        - next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。
        
        - next(&#39;/&#39;) 或者 next(&#123; path: &#39;/&#39; &#125;): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。
        
        - next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。
       

    router.beforeEach(to, from, next),  //全局前置守卫
    
    router.beforeResolve(to, from, next),   //全局解析守卫，在 2.5.0+ 
    你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 
    类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，
    解析守卫就被调用。
    
    router.afterEach(to, from )    //全局后置守卫，钩子不会接受 next 函数也不会改变导航本身

2. 组件内钩子

    beforeRouteEnter(to, from, next)    //跳转到这个组件时
    
    beforeRouteUpdate(to, from, next)   //当前路由改变，但是该组件被复用时调用
    
    beforeRouteLeave(to, from, next)    //离开这个组件时

3. 单独路由独享组件
    用法同全局守卫，只是将其写进其中一个路由对象中，只在这个路由下起作用。

    beforeEnter(to, from, next)
    
    
完整的导航解析流程：

    1. 导航被触发。
    2. 在失活的组件里调用离开守卫。
    3. 调用全局的 beforeEach 守卫。
    4. 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
    5. 在路由配置里调用 beforeEnter。
    6. 解析异步路由组件。
    7. 在被激活的组件里调用 beforeRouteEnter。
    8. 调用全局的 beforeResolve 守卫 (2.5+)。
    9. 导航被确认。
    10. 调用全局的 afterEach 钩子。
    11. 触发 DOM 更新。
    12. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
    
</code></pre>
<h4 id="动态路由定义和获取？"><a href="#动态路由定义和获取？" class="headerlink" title="动态路由定义和获取？"></a>动态路由定义和获取？</h4><pre><code>在 router 目录下的 index.js 文件中，对 path 属性加上 /:id。

使用 router 对象的 params.id 获取
</code></pre>
<h4 id="key值的作用？"><a href="#key值的作用？" class="headerlink" title="key值的作用？"></a>key值的作用？</h4><pre><code>key是为了高效的实现DOM渲染。
</code></pre>
<h4 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h4><pre><code>1.v-bind绑定一个value属性，监听message
2.v-on指令给当前元素绑定input事件
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--等价于下面--&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot;</span><br><span class="line">    v-bind:value=&quot;message&quot;</span><br><span class="line">    v-on:input=&quot;message=$event.target.value&quot;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-model-修饰符"><a href="#v-model-修饰符" class="headerlink" title="v-model 修饰符"></a>v-model 修饰符</h4><ul>
<li>1.lazy 修饰符<ul>
<li>1.1 默认情况下，v-model默认是在input事件中同步输入框的数据的</li>
<li>1.2 一旦有数据发生改变对应的data中的数据就会自动发生改变</li>
<li>1.3 lazy是修饰符可以让数据在失去焦点或者回车时才会更新</li>
</ul>
</li>
<li>2.number 修饰符<ul>
<li>2.1 默认情况下，在输入框中我们输入数字还是字母，都会被当作字符串类型进行处理</li>
<li>2.2 但是如果我们希望处理的是是数字类型，那么最好直接将内容当作数字处理</li>
<li>2.3 number修饰符可以让输入框中输入的内容自动转成数字类型</li>
</ul>
</li>
<li>3.trim 修饰符（移除的字符包括空格、行终止符、制表符、换行符、回车符、换页符等）<ul>
<li>如果输入的内容首尾有很多空格，通常我们希望将其去除</li>
<li>trim修饰符可以过滤内容左右两边的空格</li>
<li>补充：str.replace(/\s/g, “”); //去除字符串所有空格</li>
</ul>
</li>
</ul>
<h4 id="v-on-修饰符"><a href="#v-on-修饰符" class="headerlink" title="v-on 修饰符"></a>v-on 修饰符</h4><ul>
<li><p>.stop 调用event.stopPropagation()</p>
</li>
<li><p>.prevent 调用event.preventDefault()</p>
</li>
<li><p>.{keyCode|keyAlias} 只当事件是从特定键触发时才触发回调</p>
</li>
<li><p>.native 监听组件根元素的原生事件</p>
</li>
<li><p>.once 只能触发一次回调</p>
</li>
</ul>
<h4 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set"></a>Vue.set</h4><pre><code>//Vue中不允许动态添加根级别的响应式属性，Vue.set方法可以向嵌套对象添加
响应式属性。
//参数一：要修改的对象
//参数二：索引值
//参数三：修改后的值

Vue.set(vm.obj, 2, &#39;b&#39;)
vm.$set(vm.obj, 2, &#39;b&#39;)
</code></pre>
<h4 id="vue-router使用params与query传参有什么区别？"><a href="#vue-router使用params与query传参有什么区别？" class="headerlink" title="vue-router使用params与query传参有什么区别？"></a>vue-router使用params与query传参有什么区别？</h4><pre><code>vue-router可以通过params与query进行传参
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//传递</span><br><span class="line">this.$router.push(&#123;path: &#x27;./xxx&#x27;, params: &#123;xx:xxx&#125;&#125;)</span><br><span class="line">this.$router.push(&#123;path: &#x27;./xxx&#x27;, query: &#123;xx:xxx&#125;&#125;)</span><br><span class="line"></span><br><span class="line">//接受</span><br><span class="line">this.$route.params</span><br><span class="line">this.$route.query</span><br></pre></td></tr></table></figure>
<ul>
<li><p>params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系</p>
</li>
<li><p>params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题</p>
</li>
</ul>
<h4 id="Vue如何取出URL中的"><a href="#Vue如何取出URL中的" class="headerlink" title="Vue如何取出URL中的 #"></a>Vue如何取出URL中的 <code>#</code></h4><pre><code>vue-router 默认使用hash模式，所以路由加载时候，项目中的url会自带#，如果不想使用#，可以使用
vue-router 的另一种模式history

new Router (&#123;
    mode: &#39;history&#39;,
    routes: []
&#125;)
</code></pre>
<h4 id="对MVC、MVVM的理解？"><a href="#对MVC、MVVM的理解？" class="headerlink" title="对MVC、MVVM的理解？"></a>对MVC、MVVM的理解？</h4><pre><code>1. MVC：所有的通信都是单向的

    View传送指令到Controller
    Controller 完成业务逻辑后，要求Model改变状态
    Model将新的数据发送到View，用户得到反馈
    
2.MVVM（类似MVP——Model View Presenter）

    View层：视图层
    Model层：数据层
    ViewModel层：视图模型层
        视图模型层时view和model沟通的桥梁
        一方面实现了Data Binding，数据绑定，将model的改变实时反应到view中
        另一方面实现了DOM Listener，也就是DOM监听，发生事件改变，改变对应的data
       
    一种前端架构模式，model为数据模型，view为视图UI层,view和model之间
    并没有直接的联系，通过viewmodel实现双向数据的绑定。各部分通信都是双向的
    因此开发者只需关注业务层，无需手动操作DOM，无需关心数据状态的同步问题，复杂
    的数据状态维护完全由MVVM来统一管理。
    采用双向数据绑定，View的变动自动反应在ViewModel，反之亦然
</code></pre>
<h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><pre><code>为什么需要虚拟DOM？

    浏览器加载一个HTML文件需要做那些事？
    创建DOM tree ——&gt; 创建CSS tree ——&gt; 构建Render tree ——&gt; 布局Layout ——&gt; 绘制Painting
    如果用传统的原生api或jQuery操作DOM时，浏览器会从构建DOM树开始从头到尾
    执行一边流程，就会浪费掉很多性能。
    
1. state数据

2.（JSX）模板

3. 数据 + 模板生成虚拟DOM（虚拟DOM就是一个JS对象，用来描述真实的DOM）

4. 用虚拟DOM的结构生成真实的DOM来显示

5. state数据发生改变

6. 数据 + 模板生成新的虚拟DOM

7. 比较原始虚拟DOM和新的虚拟DOM的区别，找到不同点
    通过diff算法，将不同的比较内容结果保存到本地的一个js对象中，最终一次性
    的将这个js对象attach应用到DOM树上，通知浏览器执行绘制工作，避免了大量的
    无畏计算。

8. 直接操作DOM，改变内容。
</code></pre>
<h4 id="nextTick的应用场景"><a href="#nextTick的应用场景" class="headerlink" title="nextTick的应用场景"></a>nextTick的应用场景</h4><pre><code>Vue.nextTick 用于延迟执行一段代码，它的回调函数会在DOM更新完成后调用。

在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调
函数中

在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于
徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。

原理：
        nextTick实际上就是创建一个新的宏任务，vue中双向绑定的数据赋值时需要调用
    watcher的update方法(比如某个div绑定了一个数据，那么该div就会生成一个
    watcher，而update的方法就是更新自身的innerHTML，当然中间还有一层虚拟DOM)，
    而watcher的update就是通过nextTick来执行的。
</code></pre>
<h4 id="Vue组件中data为什么必须是函数？"><a href="#Vue组件中data为什么必须是函数？" class="headerlink" title="Vue组件中data为什么必须是函数？"></a>Vue组件中data为什么必须是函数？</h4><pre><code>如果data是一个对象，那么 由于对象本身属于引用类型，当我们修改其中一个属性值的之后，
会影响到所有Vue实例的数据。如果将data作为一个函数返回一个对象，那么每一个实例的data
属性都是独立的，相互不会影响。例如：在同一个组件复用的时候，就类似给每个组件实例
创建了一个私有的数据空间，让各自的组件实例维护各自的数据。
</code></pre>
<h4 id="计算属性computed、watch和事件methods有什么区别？"><a href="#计算属性computed、watch和事件methods有什么区别？" class="headerlink" title="计算属性computed、watch和事件methods有什么区别？"></a>计算属性computed、watch和事件methods有什么区别？</h4><pre><code>computed： 计算属性是会基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时
才会重新求值。

computed属性有两个方法：set、get
`fullName: &#123;
    //赋值
    set: function(newValue)&#123;const names = newValue.split(&#39; &#39;);
    this.firstName = names[0];this.lastName = names[1];&#125;,//一般用不着,使用的时候有参数
    //取值
    get: function()&#123;return this.firstName + &#39; &#39; + this.lastName&#125;
&#125;
`

watch：更多的的是观察作用，类似于某些数据的监听回调，每当监听的数据变化时都
会执行相应的回调进行后续的操作。

method：不管数据是否改变，只要发生重新渲染，methods都会调用执行。
</code></pre>
<ul>
<li>运用场景：<ul>
<li>当需要进行数值计算，并且依赖于其他数据时，应该使用computed，利用computed的<br>缓存特性，避免每次获取值时，都需要重新计算。</li>
<li>当需要在数据变化时执行异步或者开销较大的操作时，使用watch。</li>
</ul>
</li>
</ul>
<h4 id="Vue父子组件之间如何传值？"><a href="#Vue父子组件之间如何传值？" class="headerlink" title="Vue父子组件之间如何传值？"></a>Vue父子组件之间如何传值？</h4><pre><code>父组件从后端获取数据，vue官方推荐使用axios来进行前后端交互，使用
axios.get(),返回一个Promise，然后用.then()在里面写个接收函数来接受返回值ret，
ret的返回值就可以对应的赋值给data里面定义的key-value值。

父传子： 在父组件中使用的子组件标签上通过 v-bind:xxx=&quot;&quot;,然后再回到子组件中，
通过props&#123;list: Array&#125;来接收从父组件传过来的值，接收的值就可以在子组件中使用，
这样就完成了将数据传输到子组件的全过程。

子传父： 子组件向父组件传值一般都是通过事件决定，例如click，当子组件上绑定
被点击事件触发时，可以在这个触发事件的函数中，使用vue自带的
this.$emit(&#39;父组件接收的事件名&#39;， 要传输的参数)，然后再父组件中使用的子组件
标签上通过 @事件名 = &#39;func&#39;，然后再父组件的method中补全这个func，然后func
中将从子组件中传递过来的值赋给父组件的data中，这样就完成了子组件向父组件传值了。

props 数据验证：

`不支持驼峰标识，驼峰需要改成 **-** 连接 的形式`

1.都支持哪数据类型?
    String、Number、Boolean、Array、Object、Date、Function、Symbol
2.props也支持自定义类型：
Vue.component(&#39;my-component&#39;, &#123;
    props: &#123;
        //基础类型检查（&#39;null&#39;匹配任何类型）
        propA: Number,
        //多个可能的值类型
        propB: [String, Number],
        //是否是必填的字符串
        propC: &#123;
            type: String,
            required: true
        &#125;,
        //带有默认值的数字
        propD: &#123;
            type: Number,
            default: 100
        &#125;,
        //对象或数组默认值必须从一个工厂函数获取
        propE: &#123;
            type: Object,
            default: function()&#123;
                return &#123;&#125;
            &#125;
            ========
            type: Array,
            default: function()&#123;
                return []
            &#125;
        &#125;,
        //自定义验证函数
        propF: &#123;
            validate: function(value)&#123;
                return [&#39;success&#39;,&#39;warning&#39;,&#39;danger&#39;].indexOf(value)!== -1
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<h4 id="为什么需要浅拷贝？"><a href="#为什么需要浅拷贝？" class="headerlink" title="为什么需要浅拷贝？"></a>为什么需要浅拷贝？</h4><pre><code>js变量的引用类型在进行复制操作的时候会复制地址，导致两个变量指向同一份数据。

在对一个对象进行操作并且不希望影响原对象的时候，应该先进行拷贝操作。
</code></pre>
<h4 id="父子组件的访问方式"><a href="#父子组件的访问方式" class="headerlink" title="父子组件的访问方式"></a>父子组件的访问方式</h4><ul>
<li><p>父组件访问子组件： </p>
<ul>
<li>$children ——用的比较少</li>
<li>$refs ——用的较多</li>
</ul>
</li>
<li><p>子组件访问父组件：</p>
<ul>
<li>$parent ——用的较少</li>
</ul>
</li>
<li><p>子组件访问根组件：</p>
<ul>
<li>$root ——用的较多</li>
</ul>
</li>
</ul>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><ul>
<li>插槽</li>
<li>具名插槽</li>
<li>作用域插槽：父组件替换插槽的标签，但是内容有子组件来提供。</li>
</ul>
<h4 id="keep-alive-遇见-vue-router"><a href="#keep-alive-遇见-vue-router" class="headerlink" title="keep-alive 遇见 vue-router"></a>keep-alive 遇见 vue-router</h4><ul>
<li><p>keep-alive是vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染</p>
<ul>
<li>两个重要的属性：</li>
<li>include - 字符串或正则表达，只有匹配的组件会被缓存</li>
<li>exclude - 字符串或正则表达，任何匹配的组件不会被缓存</li>
</ul>
</li>
<li><p>router-view 也是一个组件，如果直接被包在keep-aive里面，所有路径匹配的视图组件<br>都会被缓存。</p>
</li>
<li><p>对应两个钩子函数activated和deactivated，当组件被激活时，触发activated，组件<br>被移除时，触发deactivated。</p>
</li>
</ul>
<h4 id="为什么选择axios？"><a href="#为什么选择axios？" class="headerlink" title="为什么选择axios？"></a>为什么选择axios？</h4><ul>
<li><p>axios：ajax i/o system(个人理解)</p>
</li>
<li><p>尤大 在2016-11-3，公告以后vue-resource不再维护，官方推荐新的ajax库用axios。</p>
</li>
<li><p>功能特点</p>
<ul>
<li>在浏览器中发送XMLHttpRequest请求</li>
<li>在node.js中发送http请求</li>
<li>支持Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="谈谈对-Vue-SSR-的理解"><a href="#谈谈对-Vue-SSR-的理解" class="headerlink" title="谈谈对 Vue SSR 的理解"></a>谈谈对 Vue SSR 的理解</h4><ul>
<li><p>SSR大致的意思就是vue在客户端将标签渲染成的整个html片段的工作在服务端<br>完成，服务端形成html片段直接返回给客户端这个过程就交租服务端渲染。</p>
</li>
<li><p>服务端渲染SSR的优缺点：</p>
<ul>
<li>优点：<ul>
<li><p>更好的SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具<br>并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面<br>通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面<br>（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</p>
</li>
<li><p>首屏加载更快：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开<br>始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；<br>SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，<br>所以 SSR 有更快的内容到达时间；</p>
</li>
</ul>
</li>
<li>缺点：<ul>
<li>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个<br>钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中<br>运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA<br>不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：更多的服务器负载：在 Node.js 中渲染完整的应用程序，<br>显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源<br>(CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic )<br>下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="你有对Vue项目进行哪些优化？"><a href="#你有对Vue项目进行哪些优化？" class="headerlink" title="你有对Vue项目进行哪些优化？"></a><a href="https://juejin.im/post/5d548b83f265da03ab42471d">你有对Vue项目进行哪些优化？</a></h4><ul>
<li><p>代码层面的优化：</p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>合理使用 computed 和 watch</li>
<li>v-for 遍历必须为item添加 key，且避免同时使用v-if</li>
<li>长列表性能优化(通过Object.freeze冻结一个对象，之后就不能修改了，避免了Object<br>.defineProperty对数据的劫持)</li>
<li>事件的销毁(在js中使用addEventListener等方式创建的事件不会自动销毁，需要手动<br>移除对这些事件的监听，避免造成内存泄漏)</li>
<li>图片资源懒加载(vue-lazyload插件)</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
</li>
<li><p>Webpack层面的优化</p>
<ul>
<li>webpack对图片进行压缩</li>
<li>多个页面的公共代码抽离成单独的文件</li>
</ul>
</li>
<li><p>基础的Web技术优化</p>
<ul>
<li>开启gzip压缩</li>
<li>浏览器缓存</li>
<li>CDN的使用</li>
<li>使用Chrome Performance查找性能瓶颈</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex &amp; Redux工作流程</title>
    <url>/2019/09/18/Vuex-Redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Vue-核心原理"><a href="#Vue-核心原理" class="headerlink" title="Vue 核心原理"></a>Vue 核心原理</h2><span id="more"></span>

<img src="https://raw.githubusercontent.com/foolishmax/static/master/images/vuex.png" width="450" />

<ul>
<li><p>Store : 统一的状态管理容器对象</p>
</li>
<li><p>Vue Components : Vue组件</p>
</li>
<li><p>dispatch : 操作行为触发方法，是唯一能执行action的方法</p>
</li>
<li><p>actions : 操作行为处理模块。 负责处理Vue Components接收的所有交互行为，</p>
</li>
<li><p>commit : 状态改变提交操作方法，对mutation进行提交，是唯一能执行mutation<br>的方法</p>
</li>
<li><p>mutation : 状态改变操作方法，Vuex中修改state的唯一推荐方法，该方法只能<br>进行同步操作</p>
</li>
<li><p>getter : state对象读取方法，类似computed计算属性。</p>
</li>
</ul>
<blockquote>
<p>过程：Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要<br>改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，<br>重新渲染Vue Components，界面随之更新。</p>
</blockquote>
<h2 id="Redux-核心原理"><a href="#Redux-核心原理" class="headerlink" title="Redux 核心原理"></a>Redux 核心原理</h2><img src="https://raw.githubusercontent.com/foolishmax/static/master/images/redux.png" width="450" />

<ul>
<li><p>只使用redux，流程是这样的：</p>
<blockquote>
<p>component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component</p>
</blockquote>
</li>
<li><p>使用react-redux 之后，流程是这样的：</p>
<blockquote>
<p>component –&gt; actionCreator(data) –&gt; reducer –&gt; component</p>
</blockquote>
</li>
</ul>
<p>store的三大功能：dispatch,subscribe,getState都不需要手动来写了，react-redux帮我们<br>做了这些，同时提供了Provider 和 connect</p>
<ul>
<li><p>注意点:</p>
<ul>
<li>store是唯一的</li>
<li>只有store能够改变自己的内容</li>
<li>reducer必须是一个纯函数（给定固定的输入，一定会有固定的输出，不会产生副作用）</li>
</ul>
</li>
<li><p>核心API</p>
<ul>
<li>createStore(reducer)<ul>
<li>创建store，并将reducer传递给store</li>
</ul>
</li>
<li>store.dispatch(action)<ul>
<li>创建action之后，负责将action传给store</li>
<li>action是一个对象形式，会包含Type(告诉store要做的事情)、Value(参数结果)</li>
</ul>
</li>
<li>store.getState()<ul>
<li>获取store内容</li>
</ul>
</li>
<li>store.subscribe()<ul>
<li>订阅store改变，只要store发生改变，其中的回调函数就会被执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Vuex-和-Redux-的区别？"><a href="#Vuex-和-Redux-的区别？" class="headerlink" title="Vuex 和 Redux 的区别？"></a>Vuex 和 Redux 的区别？</h2><ul>
<li><p>都是状态管理系统，除了具备床柜的状态管理的功能之外，也针对自身框架进行一些优化特性。</p>
</li>
<li><p>状态注入组件：</p>
<ul>
<li>React-Redux: 通过<code>&lt;Provider/&gt;</code>组件拿到store之后，还需要显示指定容器组件，<br>即用connect包装一下该组件。</li>
<li>Vue通过Vue.use(Vuex)将vuex应用为全局的插件，将store传入跟实例，就可以<br>使得store对象运行在任何vue组件中。</li>
</ul>
</li>
<li><p>vuex借鉴redux，通过弱化概念（action、reducer），弱化了dispatch的存在感，<br>任何东西都没做实质性消减，但同时使得整套框架更加易于理解了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB前端性能优化</title>
    <url>/2019/07/17/WEB%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="WEB前端性能优化常见方法"><a href="#WEB前端性能优化常见方法" class="headerlink" title="WEB前端性能优化常见方法"></a>WEB前端性能优化常见方法</h1><p>前端性能优化针对不用资源有不同的性能优化方式</p>
<span id="more"></span>
<ul>
<li><p>内容优化</p>
<ul>
<li>(1)减少HTTP请求数：因为一个完整的请求要经过    DNS寻址，与服务器建立连接，发送数据，<br>等待服务器响应，接受数据等消耗时间成本和资源成本的复杂过程。<ul>
<li>常见解决方法：</li>
</ul>
<ul>
<li>资源和并和压缩：合并多个CSS文件和js文件并使用相应的工具对js、css、图片等进行压缩处理</li>
<li>雪碧图（精灵图）：减少请求数</li>
<li>合理设置http缓存：原则就是能缓存的越多越好，越久越好，通过http header中<br>设置Expires过期时间，或者Last-Modifed进行请求验证</li>
<li>减少http请求头、配置多个域名和CDN加速、使用缓存<br>（HTTP缓存、浏览器缓存、应用缓存）、优化cookie</li>
</ul>
</li>
<li>（2）避免重定向：减少不必要的http跳转</li>
<li>（3）延迟加载组件，预加载组件，图片懒加载</li>
<li>（4）减少DOM元素数量：页面中存在大量DOM元素，会导致JavaScript遍历DOM的效率变慢。</li>
</ul>
</li>
<li><p>服务器优化</p>
<ul>
<li>（1）使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度</li>
<li>（2）Gzip压缩</li>
<li>（3）设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。</li>
<li>（4）提前刷新缓冲区</li>
<li>（5）避免空的图像src</li>
</ul>
</li>
<li><p>Cookie优化</p>
<ul>
<li>（1）减少Cookie的大小</li>
<li>（2）针对Web组件使用域名无关的Cookie</li>
</ul>
</li>
<li><p>CSS优化</p>
<ul>
<li>将CSS代码放在HTML页面的顶部</li>
<li>避免使用CSS表达式</li>
<li>使用<link>来代替@import</li>
<li>避免使用Filters</li>
</ul>
</li>
<li><p>JavaScript优化</p>
<ul>
<li>(1) 将JavaScript脚本放在页面的底部。</li>
<li>(2) 将JavaScript和CSS作为外部文件来引用：在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。</li>
<li>(3) 最小化DOM的访问：使用JavaScript访问DOM元素比较慢。</li>
<li>(4) document.getElement…将获取到的元素长度提取出来</li>
<li>(5) 尽量减少会产生reflow和repaint的操作，因为它们都是需要消耗资源的</li>
<li>(6) 慎用with，with他会修改编译时的词法作用域，修改了执行环境，访问非局部属性的<br>时候，会从指定obj作用域上开始查找，相当于增长了作用域长度，而过长的作用域链会造成<br>查找性能下降。</li>
<li>(7) 慎用eval和Function,需要js引擎将源代码转换成可执行代码，这是很消耗资源的操作，<br>同时，也不利于压缩工具进行压缩。</li>
<li>(8) 减少作用域链的查找，访问非本作用域下的变量，在循环遍历的时候使用局部变量缓存该变量，<br>遍历结束后再重写那个变量，尤其是全局变量处于作用域的最顶端，访问时查找次数最多</li>
</ul>
</li>
<li><p>图像优化</p>
<ul>
<li>(1)优化图片大小</li>
<li>（2）通过CSS    Sprites优化图片</li>
<li>（3）不要在HTML中使用压缩图片</li>
<li>（4）favicon.ico要小而且可缓存</li>
</ul>
</li>
<li><p>robots.txt<br>  搜索引擎蜘蛛访问网站时会第一个访问robots.txt文件，robots.txt用于指导搜索引擎<br>  蜘蛛禁止抓取网站的某些内容和只允许抓取哪些内容，放在站点根目录。</p>
</li>
<li><p>dns-prefetch</p>
<ul>
<li><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.bootcss.com&quot;&gt;</code></li>
<li>使用dns-prefetch对项目中使用的域名进行DNS预解析，减少DNS查询。  </li>
</ul>
</li>
<li><p>URL优化<br>  越短越好<br>  避免太多参数<br>  目录层次尽量少<br>  文件及目录名具有描述性<br>  字母全部小写<br>  连词符使用-而不是_<br>  URL中包括关键字</p>
</li>
<li><p>TDK优化<br>  TDK为title，description，keywords三个的统称。<br>  title：分隔符一般有 ， - _,其中_对百度比较友好，-对谷歌比较友好，title长度pc端一般<br>  30个中文，移动端20个，超过会截断为省略号。</p>
</li>
<li><p>其他<br>  标签语义化<br>  img设置alt属性<br>  不需要跟踪爬行的链接，设置 rel = “nofollow”  </p>
</li>
</ul>
<p>[参考]：（<a href="https://segmentfault.com/a/1190000008829958%EF%BC%89">https://segmentfault.com/a/1190000008829958）</a></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>React深入浅出知识链路</title>
    <url>/2021/10/05/React%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="React框架的关键设计思想：“组件”、“虚拟DOM”"><a href="#React框架的关键设计思想：“组件”、“虚拟DOM”" class="headerlink" title="React框架的关键设计思想：“组件”、“虚拟DOM”"></a>React框架的关键设计思想：“组件”、“虚拟DOM”</h3><h3 id="组件化-工程化思想在框架中的落地"><a href="#组件化-工程化思想在框架中的落地" class="headerlink" title="组件化: 工程化思想在框架中的落地"></a>组件化: 工程化思想在框架中的落地</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“封闭”：在组件自身的渲染工作流中，每个组件都只处理它的内部的渲染逻辑。</span><br><span class="line">“开放”：针对组件间通信来说，React基于“单向数据流”的原则完成组件间的通信。</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="虚拟DOM：核心算法的基石："><a href="#虚拟DOM：核心算法的基石：" class="headerlink" title="虚拟DOM：核心算法的基石："></a>虚拟DOM：核心算法的基石：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组件初始化-&gt;render方法-&gt;生成虚拟DOM-&gt;ReactDOM.render方法-&gt;生成真实DOM</span><br><span class="line"></span><br><span class="line">组件更新-&gt;render方法-&gt;生成新的虚拟DOM-&gt;diff算法-&gt;定位两次虚拟DOM的差异-&gt;批量更新</span><br></pre></td></tr></table></figure>

<h3 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps(nextProps)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果父组件导致子组件重新渲染，即使props没有更改，也会调用此方法，如果只想处理更改，请确保当前值和变更值的比较。---React官方</span><br></pre></td></tr></table></figure>

<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">React组件会根据shouldComponentUpdate的返回值来决定是否执行后面的生命周期进而决定是否对组件进行re-render(重渲染)</span><br></pre></td></tr></table></figure>

<h3 id="getDerivedStateFromProps-新增-不是componentWillMount-废弃-的替代品"><a href="#getDerivedStateFromProps-新增-不是componentWillMount-废弃-的替代品" class="headerlink" title="getDerivedStateFromProps(新增)不是componentWillMount(废弃)的替代品"></a>getDerivedStateFromProps(新增)不是componentWillMount(废弃)的替代品</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getDerivedStateFromProps有且仅有一个用途：使用props来派生/更新state</span><br><span class="line"></span><br><span class="line">static getDerivedStateFromProps(props, state)</span><br><span class="line">1.静态方法，访问不到this</span><br><span class="line">2.参数 props(父组件)和state(自身)</span><br><span class="line">3.对象格式的返回值，用来更新自身state（更新并非覆盖式，而是替换式更新）</span><br><span class="line">4.挂载和更新都会触发此钩子</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">getDerivedStateFromProps是作为一个试图代替componentWillReceiveProps的API出现的。</span><br><span class="line">getDerivedStateFromProps不能完全和componentWillReceiveProps画等号</span><br><span class="line"></span><br><span class="line">原因：getDerivedStateFromProps仅可以代替componentWillReceiveProps来实现基于props派生state，原则来说能且只能做这一件事。</span><br></pre></td></tr></table></figure>

<h3 id="getSnapshotBeforeUpdate-新增-与componentWillUpdate-废弃"><a href="#getSnapshotBeforeUpdate-新增-与componentWillUpdate-废弃" class="headerlink" title="getSnapshotBeforeUpdate(新增)与componentWillUpdate(废弃)"></a>getSnapshotBeforeUpdate(新增)与componentWillUpdate(废弃)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)&#123;&#125;</span><br><span class="line">1. 执行时机在render方法之后，真实DOM更新之前</span><br><span class="line">2.返回值会作为第三个参数传递给componentDidUpdate</span><br></pre></td></tr></table></figure>

<h3 id="Fiber架构（核心：可中断、可恢复、优先级）"><a href="#Fiber架构（核心：可中断、可恢复、优先级）" class="headerlink" title="Fiber架构（核心：可中断、可恢复、优先级）"></a>Fiber架构（核心：可中断、可恢复、优先级）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Fiber是React16对React核心算法的一次重写</span><br><span class="line">2.Fiber会使原本同步的渲染过程变成异步的</span><br><span class="line">3.Fiber会将一个大的更新任务拆解为许多个小任务(工作单元)，这些工作单元有着不同的优先级，react可以根据优先级的高低去实现工作单元的打断和恢复 </span><br><span class="line"></span><br><span class="line">Fiber架构的重要特征就是可以被打断的异步渲染模式，根据能否被打断这一标准，React16的生命周期被划分为render和commit两个阶段</span><br><span class="line">render阶段在执行过程中允许被打断（因为此阶段用户不可见，打断也无影响）</span><br><span class="line">commit阶段总是同步执行（涉及到同步渲染，会影响用户直观体验）</span><br><span class="line"></span><br><span class="line">render阶段是允许暂停、终止和重启的，这就导致render阶段的生命周期都是有可能被重复执行，所以要废弃处于render阶段的一些生命周期：componentWillMount、componenntUpdate、componentWillReceiveProps、shouldComponentUpdate(一般不会在这个生命周期中进行副作用操作，所以相对风险不大，没有被废弃)</span><br><span class="line"></span><br><span class="line">每个更新任务都会被赋予一个优先级</span><br><span class="line">若B任务的优先级高于当前任务A，那么当前处于Reconciler层的A任务就会被中断，当B任务完成后，A任务就会被重新推入Reconciler层，继续它的渲染，这便是所谓的“可恢复”</span><br><span class="line"></span><br><span class="line">Fiber架构对生命周期的影响</span><br><span class="line">react15: render开始-&gt;停不下来的递归计算(同步)-&gt;commit提交渲染</span><br><span class="line">react16: render开始-&gt;工作单元｜工作单元｜工作单元...(异步)-&gt;commit提交渲染</span><br></pre></td></tr></table></figure>

<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UI = render(data) 或 UI = f(data)</span><br><span class="line">React的视图会随着数据的变化而变化</span><br></pre></td></tr></table></figure>

<h3 id="React-Hooks的使用原则"><a href="#React-Hooks的使用原则" class="headerlink" title="React-Hooks的使用原则"></a>React-Hooks的使用原则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.只在React函数中调用Hook</span><br><span class="line">2.不要在循环、条件和嵌套函数中调用Hook(要确保hooks在每次渲染时都保持同样的执行顺序)</span><br><span class="line"></span><br><span class="line">从源码调用流程看原理：Hooks的正常运作，在底层依赖于顺序链表。</span><br><span class="line">mountState首次渲染构建链表并渲染，updateState依次遍历链表并渲染</span><br><span class="line"></span><br><span class="line">hooks的渲染就是通过依次遍历来定位每个hooks的内容，如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然就是不可控的</span><br></pre></td></tr></table></figure>

<h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟DOM本质上是JS和DOM之间的一个映射缓存，在形态上表现为一个能够描述DOM结构及其属性信息的JS对象。</span><br></pre></td></tr></table></figure>

<h3 id="Diff逻辑的拆分与解读"><a href="#Diff逻辑的拆分与解读" class="headerlink" title="Diff逻辑的拆分与解读"></a>Diff逻辑的拆分与解读</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Diff算法性能突破的关键点在于 分层对比</span><br><span class="line">2.类型一致的节点才有继续Diff的必要性</span><br><span class="line">3.key属性的设置，可以帮我们尽可能重用同一层级内的节点</span><br></pre></td></tr></table></figure>

<h3 id="setState异步"><a href="#setState异步" class="headerlink" title="setState异步"></a>setState异步</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setState-&gt;shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate</span><br><span class="line"></span><br><span class="line">批量更新：每来一个setState，就把它塞进一个队列里面存起来，等时机成熟，再把存起来的state结果做合并，最后只针对最后一次最新的state值走一次更新流程</span><br><span class="line"></span><br><span class="line">setState的表现会因为调用的场景不同而不同：</span><br><span class="line">1.在React钩子函数及合成事件中，表现为异步</span><br><span class="line">2.在setTimeout、setInterval等函数中，包括DOM原生事件中，表现为同步。</span><br></pre></td></tr></table></figure>

<h3 id="ReactDOM-render调用栈的逻辑分层"><a href="#ReactDOM-render调用栈的逻辑分层" class="headerlink" title="ReactDOM.render调用栈的逻辑分层"></a>ReactDOM.render调用栈的逻辑分层</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure>

<h3 id="React事件系统"><a href="#React事件系统" class="headerlink" title="React事件系统"></a>React事件系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当事件在具体的DOM节点上被触发后，最终都会冒泡到document上，document上所绑定的统一事件处理程序会将事件分发到具体的组件实例</span><br><span class="line"></span><br><span class="line">react合成事件：在底层抹平了不同浏览器的差异，在上层面向开发者暴漏统一的、稳定的、与DOM原生事件相同的事件接口（原生DOM事件可以通过e.nativeEvent查看）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>TS进阶题目</title>
    <url>/2022/01/17/TS%E8%BF%9B%E9%98%B6%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<ul>
<li>在线 TS 地址 <a href="https://www.typescriptlang.org/">typescript</a></li>
</ul>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><ul>
<li>以下代码为什么会提示错误，应该如何解决上述问题？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  kind: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCustomer&lt;T extends User&gt;(u: T): T &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    id: u.id,</span><br><span class="line">    kind: &#x27;customer&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一种解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  kind: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCustomer&lt;T extends User&gt;(u: T): User &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    id: u.id,</span><br><span class="line">    kind: &#x27;customer&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  kind: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCustomer&lt;t extends User&gt;(u: T): T &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...u,</span><br><span class="line">    id: u.id,</span><br><span class="line">    kind: &#x27;customer&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><ul>
<li>以下函数我们希望参数<em>a</em>和<em>b</em>的类型都是一致的，即<em>a</em>和<em>b</em>同时为<em>number</em>或<em>string</em>类型，当它们的类型不一致时，ts 类型检查器能自动提示对应的错误信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(a: string | number,b: string | number) &#123;</span><br><span class="line">  if (typeof a === &#x27;string&#x27;) &#123;</span><br><span class="line">    return a + &#x27;:&#x27; + b;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2); // OK</span><br><span class="line">f(&#x27;a&#x27;, &#x27;b&#x27;); // OK</span><br><span class="line">f(&#x27;a&#x27;, 2); // Error</span><br><span class="line">f(1, &#x27;b&#x27;); //Error</span><br></pre></td></tr></table></figure>

<p><strong>第一种解决方案</strong></p>
<ul>
<li>函数重载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(a: string, b: string): string;</span><br><span class="line">function f(a: number, b: number): number;</span><br><span class="line">function f(a: string | number, b: string | number): string | number &#123;</span><br><span class="line">  if (typeof a === &#x27;string&#x27;) &#123;</span><br><span class="line">    return a + &#x27;:&#x27; + b;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (a as number) + (b as number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2); // OK</span><br><span class="line">f(&#x27;a&#x27;, &#x27;b&#x27;); // OK</span><br><span class="line">f(1, &#x27;b&#x27;); // Error</span><br><span class="line">f(&#x27;a&#x27;, 2); // Error</span><br></pre></td></tr></table></figure>

<p><strong>第二种解决方案</strong></p>
<ul>
<li>自定义路由守卫</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const isStringArray = (params: string[] | number[]): params is string[] =&gt; typeof params[0] === &#x27;string&#x27;;</span><br><span class="line"></span><br><span class="line">function f(...args: string[] | number[]) &#123;</span><br><span class="line">  if (isStringArray(args)) &#123;</span><br><span class="line">    return args[0] + &#x27;:&#x27; + args[1];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return args[0] + args[1];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2); // OK</span><br><span class="line">f(&#x27;a&#x27;, &#x27;b&#x27;); // OK</span><br><span class="line">f(1, &#x27;b&#x27;); // Error</span><br><span class="line">f(&#x27;a&#x27;, 2); // Error</span><br></pre></td></tr></table></figure>

<p><strong>第三种解决方案</strong></p>
<ul>
<li>范型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f&lt;T extends string | number&gt;(a: T, b: T) &#123;</span><br><span class="line">  if (typeof a === &#x27;string&#x27;) &#123;</span><br><span class="line">    return a + &#x27;:&#x27; + b;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (a as number) + (b as number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2); // OK</span><br><span class="line">f(&#x27;a&#x27;, &#x27;b&#x27;); // OK</span><br><span class="line">f(1, &#x27;b&#x27;); // Error</span><br><span class="line">f(&#x27;a&#x27;, 2); // Error</span><br></pre></td></tr></table></figure>

<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><ul>
<li>实现 SetOptional 工具类型，支持把给定的 keys 对应的属性变为可选，参考<em>Partial<T></em></li>
<li>实现 SetRequired 工具类型，支持把给定的 keys 对应的属性变成必填，参考 <em>Require<T></em></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SetOptional 测试用例</span><br><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b?: string;</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SomeOptional = SetOptional&lt;Foo, &#x27;a&#x27; | &#x27;b&#x27;&gt;</span><br><span class="line"></span><br><span class="line">type SomeOptional = &#123;</span><br><span class="line">  a?: number; //该属性变为可选的</span><br><span class="line">  b?: string; //保持不变</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SetRequired 测试用例</span><br><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b?: string;</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SomeRequired = SetRequired&lt;Foo, &#x27;a&#x27; | &#x27;b&#x27;&gt;</span><br><span class="line"></span><br><span class="line">type SomeRequired = &#123;</span><br><span class="line">  a: number; //保持不变</span><br><span class="line">  b: string; //该属性变为必选的</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<ul>
<li>SetOptional</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b?: string;</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对交叉类型进行扁平化处理</span><br><span class="line">type Simplify&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SetOptional&lt;T, K extends keyof T&gt; = Simplify&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">type SomeOptional = SetOptional&lt;Foo, &#x27;a&#x27; | &#x27;b&#x27;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>SetRequired</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b?: string;</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Simplify&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SetRequired&lt;T, K extends keyof T&gt; = Simplify&lt;Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt; &amp; Required&lt;Pick&lt;T, K&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">type SomeRequired = SetRequired&lt;Foo, &#x27;b&#x27; | &#x27;c&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b?: string;</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Simplely&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SetOptional&lt;T, K extends keyof T&gt; = Simplely&lt;&#123; [X in keyof Omit&lt;T, K&gt;]: T[X]; &#125; &amp; &#123; [P in K]?: T[P] &#125;&gt;;</span><br><span class="line">type SetRequired&lt;T, K extends keyof T&gt; = Simplely&lt;&#123; [X in keyof Omit&lt;T, K&gt;]: T[X]; &#125; &amp; &#123; [P in K]-?: T[P] &#125;&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type SomeOptional = SetOptional&lt;Foo, &#x27;a&#x27; | &#x27;b&#x27;&gt;;</span><br><span class="line">type SomeRequired = SetRequired&lt;Foo, &#x27;b&#x27; | &#x27;c&#x27;&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 3</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Simplify&lt;T&gt; = &#123;</span><br><span class="line">    [P in keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SetOptional&lt;T, K extends keyof T&gt; = Simplify&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt;;</span><br><span class="line"></span><br><span class="line">type SetRequired&lt;T, K extends keyof T&gt; = Simplify&lt;Required&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><ul>
<li><em>Pick&lt;T, K extends keyof T&gt;</em> 的作用是将某个类型中的字属性挑出来，得到包含这个类型部分属性的字类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">  completed: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;</span><br><span class="line"></span><br><span class="line">const todo: TodoPreview = &#123;</span><br><span class="line">  title: &quot;clean room&quot;,</span><br><span class="line">  completed: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题：如何定义一个<em>ConditionalPick</em>工具类型，支持根据指定的<em>Condition</em>条件来生成新的类型，对应的使用示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Example &#123;</span><br><span class="line">  a: string;</span><br><span class="line">  b: string | number;</span><br><span class="line">  c: () =&gt; void;</span><br><span class="line">  d: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type StringKeyOnly = ConditionalPick&lt;Example, string&gt;;</span><br><span class="line">// =&gt; &#123;a: string&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types">神奇的 as</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Example &#123;</span><br><span class="line">  a: string;</span><br><span class="line">  b: string | number;</span><br><span class="line">  c: () =&gt; void;</span><br><span class="line">  d: &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ConditionalPick&lt;T, K&gt; = &#123;</span><br><span class="line">  [P in keyof T as (T[P] extends K ? P : never)]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type StringKeysOnly = ConditionalPick&lt;Example, string&gt;;</span><br><span class="line">// =&gt; &#123;a: string&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><ul>
<li>定义一个工具类型<em>AppendArgument</em>,为已有函数累心增加指定类型的参数，新增的参数名是<em>x</em>，将作为新函数类型的第一个参数，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Fn = (a: number, b: string) =&gt; number;</span><br><span class="line">type AppendArgument&lt;F, A&gt; = // 你的实现代码</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type FinalFn = AppendArgument&lt;Fn, boolean&gt;</span><br><span class="line">// (x: boolean, a: number, b: string) =&gt; number;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<ul>
<li>延伸阅读 <a href="https://mp.weixin.qq.com/s/mkvnJh3fBmL86Vnrv9xAyQ">掌握 TS 这些工具类型，让你开发事半功倍</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type AppendArgument&lt;F extends (...args: any) =&gt; any, A&gt; = (x: A, ...args: Parameters&lt;F&gt;) =&gt; ReturnType&lt;F&gt;</span><br><span class="line"></span><br><span class="line">type Fn = (a: number, b: string) =&gt; number;</span><br><span class="line"></span><br><span class="line">type FinalFn = AppendArgument&lt;Fn, boolean&gt;;</span><br><span class="line">// (x: boolean, a: number, b: string) =&gt; number;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<ul>
<li>延伸阅读 <a href="https://mp.weixin.qq.com/s/JT2N2K5hvQAXN45B2DEbQw">用上这几招，轻松实现 TS 类型提取</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type AppendArgument&lt;F, T&gt; = F extends (...args: infer Args) =&gt; infer Return ? (x: T, ...args: Args) =&gt; Return : never;</span><br><span class="line"></span><br><span class="line">type Fn = (a: number, b: string) =&gt; number;</span><br><span class="line"></span><br><span class="line">type FinalFn = AppendArgument&lt;Fn, boolean&gt;;</span><br><span class="line">// (x: boolean, a: number, b: string) =&gt; number</span><br></pre></td></tr></table></figure>

<h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><ul>
<li>定义一个 NativeFlat 工具类型，支持把数组类型拍平(扁平化),示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type NativeFlat&lt;T extends any[]&gt; = // 实现代码</span><br><span class="line"></span><br><span class="line">//测试用例</span><br><span class="line">type NativeResult = NativeFlat&lt;[[&#x27;a&#x27;],[&#x27;b&#x27;,&#x27;c&#x27;],[&#x27;d&#x27;]]&gt;;</span><br><span class="line">// =&gt; &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>在完成<em>NativeFlat</em>工具类型之后，继续实现<em>DeepFlat</em>工具类型，以支持多维数组类型：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type DeepFlat&lt;T extends any[]&gt; = unknown // 你的实现代码</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type Deep = [[&#x27;a&#x27;], [&#x27;b&#x27;, &#x27;c&#x27;], [[&#x27;d&#x27;]], [[[[&#x27;e&#x27;]]]]];</span><br><span class="line">type DeepTestResult = DeepFlat&lt;Deep&gt;</span><br><span class="line">// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<ul>
<li>NativeFlat</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type NaiveFlat&lt;T extends any[]&gt; = &#123;</span><br><span class="line">  [P in keyof T]: T[P] extends any[] ? T[P][number] : T[P]</span><br><span class="line">&#125;[number]</span><br><span class="line"></span><br><span class="line">type NaiveResult = NaiveFlat&lt;[[&#x27;a&#x27;], [&#x27;b&#x27;, &#x27;c&#x27;], [&#x27;d&#x27;]]&gt;</span><br><span class="line">// NaiveResult的结果： &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>DeepFlat</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Deep = [[&#x27;a&#x27;], [&#x27;b&#x27;, &#x27;c&#x27;], [[&#x27;d&#x27;]], [[[[&#x27;e&#x27;]]]]];</span><br><span class="line"></span><br><span class="line">type DeepFlat&lt;T extends any[]&gt; = &#123;</span><br><span class="line">  [K in keyof T]: T[K] extends any[] ? DeepFlat&lt;T[K]&gt; : T[K]</span><br><span class="line">&#125;[number]</span><br><span class="line"></span><br><span class="line">type DeepTestResult = DeepFlat&lt;Deep&gt;</span><br><span class="line">// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot;</span><br></pre></td></tr></table></figure>

<h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><ul>
<li>使用类型别名定义一个<em>EmptyObject</em>类型，是的该类型只允许空对象赋值：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type EmptyObject = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">const shouldPass: EmptyObject = &#123;&#125;; // OK</span><br><span class="line">const shouldFail: EmptyObject = &#123; // Error</span><br><span class="line">  prop: &quot;TS&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更改以下<em>takeSomeTypeOnly</em>函数类型定义，让参数只允许严格 SomeType 类型的值，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type SomeType = &#123;</span><br><span class="line">  prop: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function takeSomeTypeOnly(x: SomeType) &#123;return x&#125;;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">const x = &#123;prop: &#x27;a&#x27;&#125;;</span><br><span class="line">takeSomeTypeOnly(x); // OK</span><br><span class="line"></span><br><span class="line">const y = &#123;prop: &#x27;a&#x27;, additionalProp: &#x27;x&#x27;&#125;;</span><br><span class="line">takeSomeTypeOnly(y); // Error</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<ul>
<li>EmptyObject</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// type PropertyKey = string | number | symbol;</span><br><span class="line"></span><br><span class="line">type EmptyObject = &#123;</span><br><span class="line">  [K in PropertyKey]: never;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">const shouldPass: EmptyObject = &#123;&#125;; // OK</span><br><span class="line">const shouldFail: EmptyObject = &#123; // Error</span><br><span class="line">  prop: &quot;TS&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>takeSomeTypeOnly</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type SomeType = &#123;</span><br><span class="line">  prop: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Exclusive&lt;T1, T2 extends T1&gt; = &#123;</span><br><span class="line">  [K in keyof T2]: K extends keyof T1 ? T2[K] : never;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function takeSomeTypeOnly&lt;T extends SomeType&gt;(x: Exclusive&lt;SomeType, T&gt;) &#123;return x&#125;;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">const x = &#123;prop: &#x27;a&#x27;&#125;;</span><br><span class="line">takeSomeTypeOnly(x); // OK</span><br><span class="line"></span><br><span class="line">const y = &#123;prop: &#x27;a&#x27;, additionalProp: &#x27;x&#x27;&#125;;</span><br><span class="line">takeSomeTypeOnly(y); // Error</span><br></pre></td></tr></table></figure>

<h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><ul>
<li>定义一个<em>NonEmptyArray</em>工具类型，用于确保数据为非空数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type NonEmptyArray&lt;T&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">const err: NonEmptyArray&lt;string&gt; = []; // Error</span><br><span class="line">const succ: NonEmptyArray&lt;string&gt; = [&#x27;Hello Ts&#x27;]; //Ok</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type NonEmptyArray&lt;T&gt; = [T, ...T[]];</span><br><span class="line"></span><br><span class="line">const err: NonEmptyArray&lt;string&gt; = []; // Error</span><br><span class="line">const succ: NonEmptyArray&lt;string&gt; = [&#x27;Hello Ts&#x27;]; //Ok</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type NonEmptyArray&lt;T&gt; = T[] &amp; &#123;0: T&#125;;</span><br><span class="line"></span><br><span class="line">const err: NonEmptyArray&lt;string&gt; = []; // Error</span><br><span class="line">const succ: NonEmptyArray&lt;string&gt; = [&#x27;Hello Ts&#x27;]; //Ok</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 3</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type NonEmptyArray&lt;T&gt; = &#123;</span><br><span class="line">  [P in number]: T;</span><br><span class="line">&#125; &amp; &#123;</span><br><span class="line">  0: T</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const err: NonEmptyArray&lt;string&gt; = []; // Error</span><br><span class="line">const succ: NonEmptyArray&lt;string&gt; = [&#x27;Hello Ts&#x27;]; //Ok</span><br></pre></td></tr></table></figure>

<h2 id="第九题-没看懂，后面回来在研究"><a href="#第九题-没看懂，后面回来在研究" class="headerlink" title="第九题(没看懂，后面回来在研究)"></a>第九题(没看懂，后面回来在研究)</h2><ul>
<li>定义一个<em>JoinStrArray</em>工具类型，用于根据指定的<code>Separator</code>分隔符，对字符串数据类型进行拼接，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type JoinStrArray&lt;Arr extends string[], Separator extends string, Result extends string = &quot;&quot;&gt; = // 你的实现代码</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type Names = [&quot;Sem&quot;, &quot;Lolo&quot;, &quot;Kaquko&quot;]</span><br><span class="line">type NamesComma = JoinStrArray&lt;Names, &quot;,&quot;&gt; // &quot;Sem,Lolo,Kaquko&quot;</span><br><span class="line">type NamesSpace = JoinStrArray&lt;Names, &quot; &quot;&gt; // &quot;Sem Lolo Kaquko&quot;</span><br><span class="line">type NamesStars = JoinStrArray&lt;Names, &quot;⭐️&quot;&gt; // &quot;Sem⭐️Lolo⭐️Kaquko&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type JoinStrArray&lt;Arr extends string[], Separator extends string, Result extends string = &quot;&quot;&gt; =</span><br><span class="line">    Arr extends [infer El,...infer Rest] ?</span><br><span class="line">            Rest extends string[] ?</span><br><span class="line">            El extends string ?</span><br><span class="line">            Result extends &quot;&quot; ?</span><br><span class="line">            JoinStrArray&lt;Rest, Separator,`$&#123;El&#125;`&gt; :</span><br><span class="line">            JoinStrArray&lt;Rest, Separator,`$&#123;Result&#125;$&#123;Separator&#125;$&#123;El&#125;`&gt; :</span><br><span class="line">            `$&#123;Result&#125;` :</span><br><span class="line">            `$&#123;Result&#125;` :</span><br><span class="line">            `$&#123;Result&#125;`</span><br><span class="line"></span><br><span class="line">type Names = [&quot;Sem&quot;, &quot;Lolo&quot;, &quot;Kaquko&quot;]</span><br><span class="line">type NamesComma = JoinStrArray&lt;Names, &quot;,&quot;&gt; // &quot;Sem,Lolo,Kaquko&quot;</span><br><span class="line">type NamesSpace = JoinStrArray&lt;Names, &quot; &quot;&gt; // &quot;Sem Lolo Kaquko&quot;</span><br><span class="line">type NamesStars = JoinStrArray&lt;Names, &quot;⭐️&quot;&gt; // &quot;Sem⭐️Lolo⭐️Kaquko&quot;</span><br></pre></td></tr></table></figure>

<h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><ul>
<li>实现一个<em>Trim</em>工具类型，用于对字符串字面量类型进行去空格处理，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Trim&lt;V extends string&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type Result = Trim&lt;&#x27;  foolishmax  &#x27;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type TrimLeft&lt;V extends string&gt; = V extends ` $&#123;infer R&#125;` ? TrimLeft&lt;R&gt; : V;</span><br><span class="line">type TrimRight&lt;V extends string&gt; = V extends `$&#123;infer R&#125; `? TrimRight&lt;R&gt; : V;</span><br><span class="line"></span><br><span class="line">type Trim&lt;V extends string&gt; = TrimLeft&lt;TrimRight&lt;V&gt;&gt;;</span><br><span class="line"></span><br><span class="line">type Result = Trim&lt;&#x27;  foolishmax  &#x27;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h2><ul>
<li>实现一个*IsEqual&lt;A, B&gt;*工具类型，用于比较两个类型是否相等，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type IsEqual&lt;A, B&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type E0 = IsEqual&lt;1, 2&gt;; // false</span><br><span class="line">type E1 = IsEqual&lt;&#123;a : 1, &#123;a: 1&#125;&#125;&gt;; // true</span><br><span class="line">type E2 = IsEqual&lt;[1], []&gt;; // false</span><br></pre></td></tr></table></figure>

<p><strong>解决方案（原始方案） 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type IsEqual&lt;A, B&gt; = A extends B ? (B extends A ? true : false) : false;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type E0 = IsEqual&lt;1, 2&gt;; // false</span><br><span class="line">type E1 = IsEqual&lt;&#123;a : 1&#125;, &#123;a: 1&#125;&gt;; // true</span><br><span class="line">type E2 = IsEqual&lt;[1], []&gt;; // false</span><br><span class="line"></span><br><span class="line">// error</span><br><span class="line">type E3 = IsEqual&lt;true, boolean&gt; // boolean</span><br><span class="line">type E4 = IsEqual&lt;1 | 2, 1&gt; // boolean</span><br><span class="line"></span><br><span class="line">这是因为泛型和*extends*两者结合所产生的*distributive conditionial types*效应导致的</span><br></pre></td></tr></table></figure>

<p><strong>解决方案（稍微优化）2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type IsEqual&lt;A, B&gt; = [A] extends [B] ? [B] extends [A] ? true : false : false</span><br><span class="line">或</span><br><span class="line">type IsEqual&lt;A, B&gt; = [A, B] extends [B, A] ? true : false</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type E0 = IsEqual&lt;1, 2&gt;; // false</span><br><span class="line">type E1 = IsEqual&lt;&#123;a : 1&#125;, &#123;a: 1&#125;&gt;; // true</span><br><span class="line">type E2 = IsEqual&lt;[1], []&gt;; // false</span><br><span class="line"></span><br><span class="line">// error</span><br><span class="line">type E3 = IsEqual&lt;any, string&gt; // true</span><br><span class="line">type E4 = IsEqual&lt; &#123; name: string &#125;, &#123; readonly name: string &#125;&gt; // true</span><br><span class="line"></span><br><span class="line">这是因为Ts中any可以赋值为任何类型，任何类型也可以赋值给any，这就意味着any和任意类型之间都是assignable的，对于extends而言就是都可以相互extends的，所以E3是true。</span><br><span class="line"></span><br><span class="line">readonly不会改变assignable。</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 4</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type IsEqual&lt;A, B&gt; =</span><br><span class="line">(&lt;G&gt;() =&gt; G extends A ? 1 : 2) extends</span><br><span class="line">(&lt;G&gt;() =&gt; G extends B ? 1 : 2) ? true : false;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type E0 = IsEqual&lt;1, 2&gt;; // false</span><br><span class="line">type E1 = IsEqual&lt;&#123;a : 1&#125;, &#123;a: 1&#125;&gt;; // true</span><br><span class="line">type E2 = IsEqual&lt;[1], []&gt;; // false</span><br></pre></td></tr></table></figure>

<h2 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h2><ul>
<li>实现一个<em>Head</em>工具类型，用于获取数组类型的第一个类型，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Head&lt;T extends Array&lt;any&gt;&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type H0 = Head&lt;[]&gt; // never</span><br><span class="line">type H1 = Head&lt;[1]&gt; // 1</span><br><span class="line">type H2 = Head&lt;[2,3,4]&gt; // 2</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Head&lt;T extends Array&lt;any&gt;&gt; = T extends [] ? never : T[0];</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type H0 = Head&lt;[]&gt; // never</span><br><span class="line">type H1 = Head&lt;[1]&gt; // 1</span><br><span class="line">type H2 = Head&lt;[2,3,4]&gt; // 2</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Head&lt;T extends Array&lt;any&gt;&gt; = T extends [head: infer H, ...rest: any[]] ? H : never;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type H0 = Head&lt;[]&gt; // never</span><br><span class="line">type H1 = Head&lt;[1]&gt; // 1</span><br><span class="line">type H2 = Head&lt;[2,3,4]&gt; // 2</span><br></pre></td></tr></table></figure>

<h2 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h2><ul>
<li>实现一个<em>Tail</em>工具类型，用于获取数组类型除了第一个类型外，剩余的类型，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Tail&lt;T extends Array&lt;any&gt;&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type T0 = Tail&lt;[]&gt; //[]</span><br><span class="line">type T1 = Tail&lt;[1, 2]&gt; // [2]</span><br><span class="line">type T2 = Tail&lt;[1, 2, 3, 4, 5]&gt; //[2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Tail&lt;T extends Array&lt;any&gt;&gt; = T extends [infer A, ...infer B] ? B : [];</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type T0 = Tail&lt;[]&gt; //[]</span><br><span class="line">type T1 = Tail&lt;[1, 2]&gt; // [2]</span><br><span class="line">type T2 = Tail&lt;[1, 2, 3, 4, 5]&gt; //[2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<h2 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h2><ul>
<li>实现一个<em>Unshift</em>工具类型，用于把指定类型 E 作为第一个元素添加到<em>T</em>数组类型中，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Unshift&lt;T extends any[], E&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type U0 = Unshift&lt;[], 1&gt;; // [1]</span><br><span class="line">type U1 = Unshift&lt;[1, 2, 3], 0&gt;; //[0, 1, 2, 3]</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Unshift&lt;T extends any[], E&gt; = [E, ...T];</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type U0 = Unshift&lt;[], 1&gt;; // [1]</span><br><span class="line">type U1 = Unshift&lt;[1, 2, 3], 0&gt;; //[0, 1, 2, 3]</span><br></pre></td></tr></table></figure>

<h2 id="第十五题"><a href="#第十五题" class="headerlink" title="第十五题"></a>第十五题</h2><ul>
<li>实现一个<em>Shift</em>工具类型，用于移除<em>T</em>数组类型中的第一个类型，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Shift&lt;T extends any[]&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type S0 = Shift&lt;[1, 2, 3]&gt;</span><br><span class="line">type S1 = Shift&lt;[string, number, boolean]&gt;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Shift&lt;T extends any[]&gt; = T extends [infer A, ...infer B] ? B : [];</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type S0 = Shift&lt;[1, 2, 3]&gt;; // [2, 3]</span><br><span class="line">type S1 = Shift&lt;[string, number, boolean]&gt;; // [number, boolean]</span><br><span class="line">type S2 = Shift&lt;[]&gt;; // []</span><br><span class="line">type S3 = Shift&lt;[string]&gt;; // []</span><br></pre></td></tr></table></figure>

<h2 id="第十六题"><a href="#第十六题" class="headerlink" title="第十六题"></a>第十六题</h2><ul>
<li>实现一个<em>Push</em>工具类型，用于把指定类型<em>E</em>作为最后一个元素添加到<em>T</em>数组类型中，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Push&lt;T extends any[], E&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type P0 = Push&lt;[], 1&gt;; // [1]</span><br><span class="line">type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Push&lt;T extends any[], E&gt; = T extends [...infer U] ? [...U, E] : never;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type P0 = Push&lt;[], 1&gt;; // [1]</span><br><span class="line">type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Push&lt;T extends any[], E&gt; = [...T, E];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type P0 = Push&lt;[], 1&gt;; // [1]</span><br><span class="line">type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h2 id="第十七题"><a href="#第十七题" class="headerlink" title="第十七题"></a>第十七题</h2><ul>
<li>实现一个<em>Includes</em>工具类型，用于判断指定的类型<em>E</em>，是否包含在<em>T</em>数组类型中，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Includes&lt;T extends any[], E&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type I0 = Includes&lt;[], 1&gt;; // false</span><br><span class="line">type I1 = Includes&lt;[2, 3], 2&gt;; // true</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Includes&lt;T extends any[], E&gt; = E extends T[number] ? true : false;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type I0 = Includes&lt;[], 1&gt;; // false</span><br><span class="line">type I1 = Includes&lt;[2, 3], 2&gt;; // true</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Includes&lt;T extends any[], E&gt; = T extends [infer A, ...infer R] ? E extends A ? true : Includes&lt;R, E&gt; : false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type I0 = Includes&lt;[], 1&gt;; // false</span><br><span class="line">type I1 = Includes&lt;[2, 3], 2&gt;; // true</span><br></pre></td></tr></table></figure>

<h2 id="第十八题"><a href="#第十八题" class="headerlink" title="第十八题"></a>第十八题</h2><ul>
<li>实现一个<em>UnionToIntersection</em>工具类型，用于把联合类型转换为交叉类型，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type UnionToIntersection&lt;U&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type U0 = UnionToIntersection&lt;string | number&gt;; // never</span><br><span class="line">type U1 = UnionToIntersection&lt;&#123;name: string&#125; | &#123;age: number&#125;&gt;; // &#123;name: string&#125; &amp; &#123;age: number&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<ul>
<li><p><a href="https://www.jianshu.com/p/071b948209f3">逆变协变</a></p>
</li>
<li><p>注释</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Fun&lt;X&gt; = (...args: X[]) =&gt; void;</span><br><span class="line"></span><br><span class="line">let f: Fun&lt;string&gt;</span><br><span class="line">let g: Fun&lt;string | number&gt;</span><br><span class="line"></span><br><span class="line">g = f // this cannot be assigned</span><br><span class="line"></span><br><span class="line">当f赋值给g时，新的g不能使用number类型的参数，我们丢失了g的一部分类型，这就属于 逆变(contra-variance),这个和交集的工作机制类似。</span><br><span class="line"></span><br><span class="line">当我们把逆变位置放在条件类型时：Typescript会创建一个交集，我们从函数参数中infer了一个类型，TypeScript知道我们必须符合逆变的条件，然后TypeScript会自动创建并集中所有的成分的交集。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type UnionToIntersection&lt;U&gt; = (U extends any ? (k: U) =&gt; void : never) extends (k: infer I) =&gt; void ? I : never</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type U0 = UnionToIntersection&lt;string | number&gt; // never</span><br><span class="line">type U1 = UnionToIntersection&lt;&#123; name: string &#125; | &#123; age: number &#125;&gt; // &#123; name: string; &#125; &amp; &#123; age: number; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第十九题"><a href="#第十九题" class="headerlink" title="第十九题"></a>第十九题</h2><ul>
<li>实现一个 <em>OptionalKeys</em> 工具类型，用来获取对象类型中声明的可选属性，示例如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Person = &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  from?: string;</span><br><span class="line">  speak?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type OptionalKeys&lt;T&gt; = // 代码实现</span><br><span class="line">type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Person = &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  from?: string;</span><br><span class="line">  speak?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type OptionalKeys&lt;T&gt; = NonNullable&lt;&#123;</span><br><span class="line">  [P in keyof T]: undefined extends T[P] ? P : never</span><br><span class="line">&#125;[keyof T]&gt;</span><br><span class="line"></span><br><span class="line">type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Person = &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  from?: string;</span><br><span class="line">  speak?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type OptionalKeys&lt;T&gt; = keyof &#123;</span><br><span class="line">  [P in keyof T as undefined extends T[P] ? P : never]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 3</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Person = &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  from?: string;</span><br><span class="line">  speak?: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type OptionalKeys&lt;T&gt; = Exclude&lt;&#123;</span><br><span class="line">    [P in keyof T]: T extends T[P] ? never : T[P]</span><br><span class="line">&#125;[keyof T], undefined&gt;</span><br><span class="line"></span><br><span class="line">type PersonOptionalKeys = OptionalKeys&lt;Person&gt;; // &quot;from&quot; | &quot;speak</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 4</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Person = &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  from?: string;</span><br><span class="line">  speak?: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type OptionalKeys&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T]: (undefined extends T[P] ? P : never)</span><br><span class="line">&#125;[keyof T] &amp; keyof T</span><br><span class="line"></span><br><span class="line">type PersonOptionalKeys = OptionalKeys&lt;Person&gt;; // &quot;from&quot; | &quot;speak</span><br></pre></td></tr></table></figure>

<h2 id="第二十题"><a href="#第二十题" class="headerlink" title="第二十题"></a>第二十题</h2><ul>
<li>实现一个<em>Curry</em>工具类型，用来实现函数类型的柯里化处理，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Curry&lt;</span><br><span class="line">  F extends (...args: any[]) =&gt; any,</span><br><span class="line">  P extends any[] = Parameters&lt;F&gt;,</span><br><span class="line">  R = ReturnType&lt;F&gt;</span><br><span class="line">&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type C0 = Curry&lt;() =&gt; Date&gt;; // () =&gt; Date</span><br><span class="line">type C1 = Curry&lt;(a:number) =&gt; Date&gt;; // (arg: number) =&gt; Date</span><br><span class="line">type C2 = Curry&lt;(a: number, b: string) =&gt; Date&gt;; // (arg: number)=&gt;(arg: string) =&gt; Date</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Curry&lt;</span><br><span class="line">  F extends (...args: any[]) =&gt; any,</span><br><span class="line">  P extends any[] = Parameters&lt;F&gt;,</span><br><span class="line">  R = ReturnType&lt;F&gt;,</span><br><span class="line">&gt; = P extends [infer A, ...infer B]</span><br><span class="line">  ? B extends []</span><br><span class="line">  ? (arg: A) =&gt; R</span><br><span class="line">  : (arg: A) =&gt; Curry&lt;(...arg: B) =&gt; R&gt;</span><br><span class="line">  : F;</span><br><span class="line"></span><br><span class="line">type C0 = Curry&lt;() =&gt; Date&gt;; // () =&gt; Date</span><br><span class="line">type C1 = Curry&lt;(a:number) =&gt; Date&gt;; // (arg: number) =&gt; Date</span><br><span class="line">type C2 = Curry&lt;(a: number, b: string) =&gt; Date&gt;; // (arg: number)=&gt;(arg: string) =&gt; Date</span><br></pre></td></tr></table></figure>

<h2 id="第二十一题"><a href="#第二十一题" class="headerlink" title="第二十一题"></a>第二十一题</h2><ul>
<li>实现一个<em>Merge</em>工具类型，用于把两个类型合成一个新的类型，第二类型（SecondType）的<em>Keys</em>将会覆盖第一种类型（FirstType）的<em>Keys</em>，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Bar = &#123;</span><br><span class="line">  b: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Merge&lt;FirstType, SecondType&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type M = Merge&lt;Foo, Bar&gt;; // &#123;a: number, b: number&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<ul>
<li>将 FirstType 和 SecondType 做交叉类型，并遍历每一个属性；</li>
<li>如果当前属性名在 SecondType 类型中，则使用 SecondType 类型中的当前属性值；</li>
<li>如果当前属性名在 FirstType 类型中，则使用 FirstType 类型中的当前属性值；</li>
<li>否则为 never；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Bar = &#123;</span><br><span class="line">  b: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Merge&lt;FirstType, SecondType&gt; =&#123;</span><br><span class="line">  [K in keyof (FirstType &amp; SecondType)]</span><br><span class="line">  : K extends keyof SecondType</span><br><span class="line">  ? SecondType[K]</span><br><span class="line">  : K extends keyof FirstType</span><br><span class="line">  ? FirstType[K]</span><br><span class="line">  : never&#125;</span><br><span class="line"></span><br><span class="line">type M = Merge&lt;Foo, Bar&gt;; // &#123;a: number, b: number&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<ul>
<li>先将 FirstType 类型中已经有的，和 SecondType 类型中相同的属性删除；</li>
<li>将前面结果和 SecondType 做交叉类型，获得合并后结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Bar = &#123;</span><br><span class="line">  b: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Merge&lt;F, S&gt; = Omit&lt;F, keyof S&gt; &amp; S;</span><br><span class="line"></span><br><span class="line">type M = Merge&lt;Foo, Bar&gt;; // &#123;a: number, b: number&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二十二题"><a href="#第二十二题" class="headerlink" title="第二十二题"></a>第二十二题</h2><ul>
<li>实现一个<em>RequireAtLeastOne</em>工具类型，它将创建一个至少含有一个给定<em>keys</em>的类型，其余<em>keys</em>类型保持原样，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Responder = &#123;</span><br><span class="line">  text?: () =&gt; string;</span><br><span class="line">  json?: () =&gt; string;</span><br><span class="line">  secure?: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RequireAtLeastOne&lt;</span><br><span class="line">  ObjectType,</span><br><span class="line">  KeysType extends keyof ObjectType = keyof ObjectType,</span><br><span class="line">&gt; = 代码实现</span><br><span class="line"></span><br><span class="line">const responder: RequireAtLeastOne&lt;Responder, &#x27;text&#x27;|&#x27;json&#x27;&gt; = &#123;</span><br><span class="line">  json: () =&gt; &#x27;&#123;&quot;message&quot;: &quot;ok&quot;&#125;&#x27;,</span><br><span class="line">  secure: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Responder = &#123;</span><br><span class="line">  text?: () =&gt; string;</span><br><span class="line">  json?: () =&gt; string;</span><br><span class="line">  secure?: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RequireAtLeastOne&lt;</span><br><span class="line">  ObjectType,</span><br><span class="line">  KeysType extends keyof ObjectType = keyof ObjectType,</span><br><span class="line">&gt; = KeysType extends unknown ? ObjectType &amp; &#123;</span><br><span class="line">  [K in KeysType]-?: ObjectType[K]</span><br><span class="line">&#125; : never;</span><br><span class="line"></span><br><span class="line">// 表示当前类型至少包含 &#x27;text&#x27; 或 &#x27;json&#x27; 键</span><br><span class="line">const responder: RequireAtLeastOne&lt;Responder, &#x27;text&#x27; | &#x27;json&#x27;&gt; = &#123;</span><br><span class="line">    json: () =&gt; &#x27;&#123;&quot;message&quot;: &quot;ok&quot;&#125;&#x27;,</span><br><span class="line">    secure: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// @ts-expect-error 因为没有&#x27;text&#x27;和&#x27;json&#x27;中的任何一个，报错</span><br><span class="line">const responder2: RequireAtLeastOne&lt;Responder, &#x27;text&#x27; | &#x27;json&#x27;&gt; = &#123;</span><br><span class="line">    secure: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Responder = &#123;</span><br><span class="line">  text?: () =&gt; string;</span><br><span class="line">  json?: () =&gt; string;</span><br><span class="line">  secure?: boolean;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type RequireAtLeastOne&lt;ObjectType, KeysType extends keyof ObjectType = keyof ObjectType&gt; = &#123;</span><br><span class="line">  [K in keyof ObjectType]: K extends KeysType ? ObjectType &amp; Required&lt;Pick&lt;ObjectType, K&gt;&gt; : never;</span><br><span class="line">&#125;[keyof ObjectType]</span><br><span class="line"></span><br><span class="line">// 表示当前类型至少包含 &#x27;text&#x27; 或 &#x27;json&#x27; 键</span><br><span class="line">const responder: RequireAtLeastOne&lt;Responder, &quot;text&quot; | &quot;json&quot;&gt; = &#123;</span><br><span class="line">  json: () =&gt; &#x27;&#123;&quot;message&quot;: &quot;ok&quot;&#125;&#x27;,</span><br><span class="line">  secure: true,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 3</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Responder = &#123;</span><br><span class="line">  text?: () =&gt; string;</span><br><span class="line">  json?: () =&gt; string;</span><br><span class="line">  secure?: boolean;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type RequireAtLeastOne&lt;ObjectType, KeysType extends keyof ObjectType = KeysType extends unknown</span><br><span class="line">? Omit&lt;ObjectType, KeysType&gt; &amp; Require&lt;Pick&lt;ObjectType, KeysType&gt;&gt;</span><br><span class="line">: never</span><br><span class="line"></span><br><span class="line">// 表示当前类型至少包含 &#x27;text&#x27; 或 &#x27;json&#x27; 键</span><br><span class="line">const responder: RequireAtLeastOne&lt;Responder, &quot;text&quot; | &quot;json&quot;&gt; = &#123;</span><br><span class="line">  json: () =&gt; &#x27;&#123;&quot;message&quot;: &quot;ok&quot;&#125;&#x27;,</span><br><span class="line">  secure: true,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第二十三题"><a href="#第二十三题" class="headerlink" title="第二十三题"></a>第二十三题</h2><ul>
<li>实现一个<em>RemoveIndexSignature</em>工具类型，用于移除已有类型中的索引签名，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">  [key: string]: any;</span><br><span class="line">  [key: number]: any;</span><br><span class="line">  [key: symbol]: any;</span><br><span class="line">  bar(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RemoveIndexSignature&lt;T&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type R = RemoveIndexSignature&lt;Foo&gt;; // &#123;bar: ()=&gt;void;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">  [key: string]: any;</span><br><span class="line">  [key: number]: any;</span><br><span class="line">  [key: symbol]: any;</span><br><span class="line">  bar(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RemoveIndexSignature&lt;T&gt; = &#123;</span><br><span class="line">  [K in keyof T as string extends K ? never : number extends K ? never : symbol extends K ? never : K]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type R = RemoveIndexSignature&lt;Foo&gt;; // &#123;bar: () =&gt; void;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二十四题"><a href="#第二十四题" class="headerlink" title="第二十四题"></a>第二十四题</h2><ul>
<li>实现一个 <code>Mutable</code> 工具类型，用于移除对象类型上所有属性或者部分属性的 <code>readonly</code> 修饰符，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  readonly a: number;</span><br><span class="line">  readonly b: string;</span><br><span class="line">  readonly c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutable&lt;T, Keys extends keyof T = keyof T&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">const mutableFoo: Mutable&lt;Foo, &#x27;a&#x27;&gt; = &#123; a: 1, b: &#x27;2&#x27;, c: true &#125;;</span><br><span class="line"></span><br><span class="line">mutableFoo.a = 3; // ok</span><br><span class="line">mutableFoo.b = &#x27;6&#x27;; // Cannot assign to &#x27;b&#x27; because it is a read-only property.</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  readonly a: number;</span><br><span class="line">  readonly b: string;</span><br><span class="line">  readonly c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutable&lt;T, Keys extends keyof T = keyof T&gt; =</span><br><span class="line">&#123;-readonly [K in Keys]: T[K] &#125; &amp; Pick&lt;T, Exclude&lt;keyof T, Keys&gt;&gt;;</span><br><span class="line"></span><br><span class="line">const mutableFoo: Mutable&lt;Foo, &#x27;a&#x27;&gt; = &#123; a: 1, b: &#x27;2&#x27;, c: true &#125;;</span><br><span class="line"></span><br><span class="line">mutableFoo.a = 3; // ok</span><br><span class="line">mutableFoo.b = &#x27;6&#x27;; // Cannot assign to &#x27;b&#x27; because it is a read-only property.</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  readonly a: number;</span><br><span class="line">  readonly b: string;</span><br><span class="line">  readonly c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutable&lt;T, Keys extends keyof T = keyof T&gt; =</span><br><span class="line">&#123;-readonly [K in Keys]: T[K] : T[K]&#125; &amp; Omit&lt;T, Keys&gt;;</span><br><span class="line"></span><br><span class="line">const mutableFoo: Mutable&lt;Foo, &#x27;a&#x27;&gt; = &#123; a: 1, b: &#x27;2&#x27;, c: true &#125;;</span><br><span class="line"></span><br><span class="line">mutableFoo.a = 3; // ok</span><br><span class="line">mutableFoo.b = &#x27;6&#x27;; // Cannot assign to &#x27;b&#x27; because it is a read-only property.</span><br></pre></td></tr></table></figure>

<h2 id="第二十五题"><a href="#第二十五题" class="headerlink" title="第二十五题"></a>第二十五题</h2><ul>
<li>实现一个 <code>IsUnion</code> 工具类型，判断指定的类型是否为联合类型，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type IsUnion&lt;T, U = T&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type I0 = IsUnion&lt;string|number&gt; // true</span><br><span class="line">type I1 = IsUnion&lt;string|never&gt; // false</span><br><span class="line">type I2 = IsUnion&lt;string|unknown&gt; //false</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type IsUnion&lt;T, U = T&gt; = T extends any ? [U] extends [T] ? false : true : never;</span><br><span class="line"></span><br><span class="line">type I0 = IsUnion&lt;string|number&gt; // true</span><br><span class="line">type I1 = IsUnion&lt;string|never&gt; // false</span><br><span class="line">type I2 = IsUnion&lt;string|unknown&gt; //false</span><br></pre></td></tr></table></figure>

<p>知识点： 1.联合类型作为泛型的时候 extends 会触发分发执行 2.联合类型 T 写成[T]就变成了普通类型，extends 的时候不会分发执行</p>
<p>这里第一步<code>T extends any</code>肯定为真，一个其实就是利用其分发的特性，后面的[T]就是一个联合类型拆开后的某一个，因此如果是联合类型的话<code>[U] extends [T]</code>一定为否</p>
<h2 id="第二十六题"><a href="#第二十六题" class="headerlink" title="第二十六题"></a>第二十六题</h2><ul>
<li>实现一个<code>IsNever</code>工具类型，判断指定的类型是否为<code>never</code>类型，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type IsNever&lt;T&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type I0 = IsNever&lt;never&gt; // true</span><br><span class="line">type I1 = IsNever&lt;never | string&gt; // false</span><br><span class="line">type I2 = IsNever&lt;null&gt; // false</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<ul>
<li>用<code>[]</code>包裹 T，否则泛型参数会被当作一个裸类型处理，走<code>条件式分布类型</code>的判断逻辑，当泛型参数是 any 这种特殊值时，会得到分布后的类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type IsNever&lt;T&gt; = [T] extends [never] ? true : false;</span><br><span class="line"></span><br><span class="line">type I0 = IsNever&lt;never&gt; // true</span><br><span class="line">type I1 = IsNever&lt;never | string&gt; // false</span><br><span class="line">type I2 = IsNever&lt;null&gt; // false</span><br></pre></td></tr></table></figure>

<h2 id="第二十七题"><a href="#第二十七题" class="headerlink" title="第二十七题"></a>第二十七题</h2><ul>
<li>实现一个<code>Reverse</code>工具类型，用于对元祖类型中元素的位置颠倒，并返回该数组，元祖的第一个元素就会变成最后一个，最后一个元素变成第一个。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Reverse&lt;</span><br><span class="line">  T extends any[],</span><br><span class="line">  R extends any[] = []</span><br><span class="line">&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type R0 = Reverse&lt;[]&gt; // []</span><br><span class="line">type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1]</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Reverse&lt;</span><br><span class="line">  T extends any[],</span><br><span class="line">  R extends any[] = []</span><br><span class="line">&gt; = T extends [infer A, ...infer B] ? Reverse&lt;B, [A, ...R]&gt; : R;</span><br><span class="line"></span><br><span class="line">type R0 = Reverse&lt;[]&gt; // []</span><br><span class="line">type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1]</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Reverse&lt;</span><br><span class="line">  T extends any[]</span><br><span class="line">&gt; = T extends [infer A, ...infer B] ? [...Reverse&lt;B&gt;, A] : [];</span><br><span class="line"></span><br><span class="line">type R0 = Reverse&lt;[]&gt; // []</span><br><span class="line">type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1]</span><br></pre></td></tr></table></figure>

<h2 id="第二十八题"><a href="#第二十八题" class="headerlink" title="第二十八题"></a>第二十八题</h2><ul>
<li>实现一个<code>Split</code>工具类型，根据给定的分割符(Delimiter)对包含分割符的字符串进行切割，可用于定义<code>String.prototype.split</code>方法的返回值类型，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Item = `zs, ls, ww`;</span><br><span class="line"></span><br><span class="line">type Split&lt;</span><br><span class="line">  S extends string,</span><br><span class="line">  Delimiter extends string</span><br><span class="line">&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type ElementType = Split&lt;Item, &#x27;,&#x27;&gt;; // [&quot;zs&quot;, &quot;ls&quot;,&quot;ww&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Item = `zs, ls, ww`;</span><br><span class="line"></span><br><span class="line">type Split&lt;</span><br><span class="line">  S extends string,</span><br><span class="line">  Delimiter extends string,</span><br><span class="line">&gt; = S extends `$&#123;infer Key&#125;$&#123;Delimiter&#125;$&#123;infer Rest&#125;`</span><br><span class="line">? [Key, ...Split&lt;Rest, Delimiter&gt;]</span><br><span class="line">: S extends &#x27;&#x27; /* 处理空字符串 */</span><br><span class="line">? []</span><br><span class="line">: [S]</span><br><span class="line"></span><br><span class="line">type ElementType = Split&lt;Item, &#x27;,&#x27;&gt;; // [&quot;zs&quot;, &quot;ls&quot;,&quot;ww&quot;]</span><br><span class="line">type ElementType2 = Split&lt;&#x27;a|b|c||d&#x27;, &#x27;|&#x27;&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot;]</span><br><span class="line">type ElementType3 = Split&lt;&#x27;abcdef&#x27;, &#x27;&#x27;&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="第二十九题"><a href="#第二十九题" class="headerlink" title="第二十九题"></a>第二十九题</h2><ul>
<li>实现一个<code>ToPath</code>工具类型，用于把属性访问<code>(.或[])</code>路径转换为元祖的形式，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ToPath&lt;S extends string&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">ToPath&lt;&#x27;foo.bar.baz&#x27;&gt; // [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span><br><span class="line">ToPath&lt;&#x27;foo[0].bar.baz&#x27;&gt; // [&#x27;foo&#x27;, &#x27;0&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ToPath&lt;S extends string&gt; = S extends `$&#123;infer F&#125;$&#123;`[$&#123;infer D&#125;]`&#125;$&#123;infer R&#125;`</span><br><span class="line">? [...ToPath&lt;F&gt;, ...([D] extends [never] ? [] : [D]), ...ToPath&lt;R&gt;]</span><br><span class="line">: S extends `$&#123;infer F&#125;.$&#123;infer R&#125;`</span><br><span class="line">? [...ToPath&lt;F&gt;, ...ToPath&lt;R&gt;]</span><br><span class="line">: S extends &#x27;&#x27;</span><br><span class="line">? []</span><br><span class="line">: [S]</span><br><span class="line"></span><br><span class="line">type T0 = ToPath&lt;&#x27;foo.bar.baz&#x27;&gt; // [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span><br><span class="line">type T1 = ToPath&lt;&#x27;foo[0].bar.baz&#x27;&gt; // [&#x27;foo&#x27;, &#x27;0&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="第三十题"><a href="#第三十题" class="headerlink" title="第三十题"></a>第三十题</h2><ul>
<li>完善<code>Chainable</code>类型的定义，是的 TS 能成功推断出<code>result</code>变量的类型，调用<code>option</code>方法之后会不断扩展当前对象的类型，使得调用<code>get</code>方法后能获取正确的类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare const config: Chainable</span><br><span class="line"></span><br><span class="line">type Chainable = &#123;</span><br><span class="line">  option(key: string, value: any): any</span><br><span class="line">  get(): any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result = config</span><br><span class="line">  .option(&#x27;age&#x27;, 7)</span><br><span class="line">  .option(&#x27;name&#x27;, &#x27;lolo&#x27;)</span><br><span class="line">  .option(&#x27;address&#x27;, &#123; value: &#x27;XiaMen&#x27; &#125;)</span><br><span class="line">  .get()</span><br><span class="line"></span><br><span class="line">type ResultType = typeof result</span><br><span class="line">// 期望 ResultType 的类型是：</span><br><span class="line">// &#123;</span><br><span class="line">//   age: number</span><br><span class="line">//   name: string</span><br><span class="line">//   address: &#123;</span><br><span class="line">//     value: string</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare const config: Chainable;</span><br><span class="line"></span><br><span class="line">type Chainable&lt;T = &#123;&#125;&gt; = &#123;</span><br><span class="line">  option&lt;K extends string, V extends any&gt;(key: K, value: V): Chainable&lt;&#123; [P in K]: V &#125; &amp; T&gt;;</span><br><span class="line">  get(): T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const result = config.option(&quot;age&quot;, 7).option(&quot;name&quot;, &quot;lolo&quot;).option(&quot;address&quot;, &#123; value: &quot;XiaMen&quot; &#125;).get();</span><br><span class="line"></span><br><span class="line">type ResultType = typeof result;</span><br></pre></td></tr></table></figure>

<h2 id="第三十一题"><a href="#第三十一题" class="headerlink" title="第三十一题"></a>第三十一题</h2><ul>
<li>实现一个<code>Repeat</code>工具类型，用于根据类型变量<code>C</code>的值，重复<code>T</code>类型并以元祖的形式返回新的类型，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Repeat&lt;T, C extends number&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type R0 = Repeat&lt;0, 0&gt;; // []</span><br><span class="line">type R1 = Repeat&lt;1, 3&gt;; // [1, 1, 1]</span><br><span class="line">type R2 = Repeat&lt;number, 2&gt;; // [number, number]</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Repeat&lt;T, C extends number, A extends any[]&gt; = A[&quot;length&quot;] extends C ? A : Repeat&lt;T, C, [...A, T]&gt;;</span><br><span class="line"></span><br><span class="line">type R0 = Repeat&lt;0, 0&gt;; // []</span><br><span class="line">type R1 = Repeat&lt;1, 3&gt;; // [1, 1, 1]</span><br><span class="line">type R2 = Repeat&lt;number, 2&gt;; // [number, number]</span><br></pre></td></tr></table></figure>

<h2 id="第三十二题"><a href="#第三十二题" class="headerlink" title="第三十二题"></a>第三十二题</h2><ul>
<li>实现一个<code>RepeatString</code>工具类型，用于根据类型变量<code>C</code>的值，重复 T 类型并以<code>字符串</code>的形式返回新的类型，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type RepeatString&lt;</span><br><span class="line">  T extends string,</span><br><span class="line">  C extends number,</span><br><span class="line">&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type S0 = RepeatString&lt;&quot;a&quot;, 0&gt;; // &#x27;&#x27;</span><br><span class="line">type S1 = RepeatString&lt;&quot;ab&quot;, 2&gt;; // &#x27;abab&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type RepeatString&lt;</span><br><span class="line">  T extends string,</span><br><span class="line">  C extends number,</span><br><span class="line">  S extends string = &#x27;&#x27;,</span><br><span class="line">  A extends any[] = []</span><br><span class="line">&gt; = A[&quot;length&quot;] extends C</span><br><span class="line">? S</span><br><span class="line">: RepeatString&lt;T, C, `$&#123;S&#125;$&#123;T&#125;`, [...A, T]&gt;</span><br><span class="line"></span><br><span class="line">type S0 = RepeatString&lt;&quot;a&quot;, 0&gt;; // &#x27;&#x27;</span><br><span class="line">type S1 = RepeatString&lt;&quot;ab&quot;, 2&gt;; // &#x27;abab&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="第三十三题"><a href="#第三十三题" class="headerlink" title="第三十三题"></a>第三十三题</h2><ul>
<li>实现一个<code>ToNumber</code>工具类型，用于实现把数值字符串转换为数值类型，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ToNumber&lt;T extends string&gt; = // 代码实现</span><br><span class="line"></span><br><span class="line">type T0 = ToNumber&lt;&quot;0&quot;&gt;; // 0</span><br><span class="line">type T1 = ToNumber&lt;&quot;10&quot;&gt;; // 10</span><br><span class="line">type T2 = ToNumber&lt;&quot;20&quot;&gt;; // 20</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ToNumber&lt;T extends string, S extends any[] = [], L extends number = S[&quot;length&quot;]&gt; =</span><br><span class="line">`$&#123;L&#125;` extends T ? L : ToNumber&lt;T, [...S, 1]&gt;</span><br><span class="line"></span><br><span class="line">type T0 = ToNumber&lt;&quot;0&quot;&gt;; // 0</span><br><span class="line">type T1 = ToNumber&lt;&quot;10&quot;&gt;; // 10</span><br><span class="line">type T2 = ToNumber&lt;&quot;20&quot;&gt;; // 20</span><br></pre></td></tr></table></figure>

<h2 id="第三十四题"><a href="#第三十四题" class="headerlink" title="第三十四题"></a>第三十四题</h2><ul>
<li>实现一个<code>SmallerThan</code>工具类型，用于比较数值类型的大小，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type SmallerThan&lt;</span><br><span class="line">  N extends number,</span><br><span class="line">  M extends number,</span><br><span class="line">&gt; = //代码实现</span><br><span class="line"></span><br><span class="line">type S0 = SmallerThan&lt;0, 1&gt;; // true</span><br><span class="line">type S1 = SmallerThan&lt;2, 0&gt;; // false</span><br><span class="line">type S2 = SmallerThan&lt;8, 10&gt;; // true</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type SmallerThan&lt;</span><br><span class="line">  N extends number,</span><br><span class="line">  M extends number,</span><br><span class="line">  S extends any[] = [],</span><br><span class="line">  L extends number = S[&quot;length&quot;]</span><br><span class="line">&gt; = L extends N</span><br><span class="line">? L extends M ? false : true</span><br><span class="line">: L extends M ? false : SmallerThan&lt;N, M, [...S, 1]&gt;</span><br><span class="line"></span><br><span class="line">type S0 = SmallerThan&lt;0, 1&gt;; // true</span><br><span class="line">type S1 = SmallerThan&lt;2, 0&gt;; // false</span><br><span class="line">type S2 = SmallerThan&lt;8, 10&gt;; // true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>getcomputedstyle和style的区别</title>
    <url>/2019/09/26/getcomputedstyle%E5%92%8Cstyle%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>S</p>
<h2 id="getomputedstyle-和-style-的区别？"><a href="#getomputedstyle-和-style-的区别？" class="headerlink" title="getomputedstyle 和 style 的区别？"></a>getomputedstyle 和 style 的区别？</h2><ul>
<li><p>getComputedStyle方法是只读的，只能获取样式，不能设置；而element.style能读写。</p>
</li>
<li><p>getComputedStyle方法获取的是最终应用在元素上的所有Css属性样式(即使没有css代码)，<br>而element.style只能获取元素style属性中的css样式。</p>
</li>
<li><p>getComputedStyle可以获取伪元素的样式。</p>
</li>
<li><p>兼容性：getComputedStyle方法在IE6~IE8是不支持的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript常用api合集</title>
    <url>/2020/07/17/javascript%E5%B8%B8%E7%94%A8api%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="一、节点"><a href="#一、节点" class="headerlink" title="一、节点"></a>一、节点</h2><h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node.nodeName //返回节点名称，只读</span><br><span class="line">Node.nodeType //返回节点类型的常数值，只读</span><br><span class="line">Node.nodeValue //返回Text或Comment节点的文本值，只读</span><br><span class="line">Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写</span><br><span class="line">Node.baseURI //返回当前网页的绝对路径</span><br><span class="line"></span><br><span class="line">Node.ownerDocument //返回当前节点所在的顶层文档对象，即document</span><br><span class="line">Node.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点</span><br><span class="line">Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点</span><br><span class="line">Node.parentNode //返回当前节点的父节点</span><br><span class="line">Node.parentElement //返回当前节点的父Element节点</span><br><span class="line">Node.childNodes //返回当前节点的所有子节点</span><br><span class="line">Node.firstChild //返回当前节点的第一个子节点</span><br><span class="line">Node.lastChild //返回当前节点的最后一个子节点</span><br><span class="line"></span><br><span class="line">Node.children //返回当前节点的所有Element子节点</span><br><span class="line">Node.firstElementChild //返回当前节点的第一个Element子节点</span><br><span class="line">Node.lastElementChild //返回当前节点的最后一个Element子节点</span><br><span class="line">Node.childElementCount //返回当前节点所有Element子节点的数目</span><br></pre></td></tr></table></figure>
<!--more-->
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node.appendChild(node) //向节点添加最后的子节点</span><br><span class="line">Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点</span><br><span class="line">Node.cloneNode(true) //默认为false(克隆节点),true(克隆节点及其属性，以及后代)</span><br><span class="line">Node.insertBefore(newNode,oldNode) //在指定子节点前插入新的子节点</span><br><span class="line">Node.removeChild(node) //删除节点，在要删除节点的父节点上操作</span><br><span class="line">Node.replaceChild(newChild,oldChild) //替换节点</span><br><span class="line">Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点</span><br><span class="line">Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系</span><br><span class="line">Node.isEqualNode(node) //返回布尔值，用于检查两个节点是否想等，所谓的相等节点，指的的两个节点的类型、属性、子节点都相同</span><br><span class="line">Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个</span><br><span class="line"></span><br><span class="line">ChildNode.remove()  //用于删除当前节点</span><br><span class="line">ChildNode.before()  //在ChildNode前插入元素节点或者文本节点</span><br><span class="line">ChildNode.after()  //在ChildNode后插入元素或文本节点</span><br><span class="line">ChildNode.replaceWith()  //替换该节点的父节点下的子节点，可以为文本或元素对象</span><br></pre></td></tr></table></figure>

<h3 id="Document节点"><a href="#Document节点" class="headerlink" title="Document节点"></a>Document节点</h3><h4 id="Document节点的属性"><a href="#Document节点的属性" class="headerlink" title="Document节点的属性"></a>Document节点的属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.doctype //返回当前文档关联的文档类型定义(DTD)</span><br><span class="line">document.documentElement //返回当前文档的根节点(html)</span><br><span class="line">document.defaultView //返回document对象所在的window对象</span><br><span class="line">document.body //返回当前文档的&lt;body&gt;节点</span><br><span class="line">document.head //返回当前文档的&lt;head&gt;节点</span><br><span class="line">document.activeElement //返回当前文档中获得焦点的那个元素</span><br><span class="line"></span><br><span class="line">document.links //返回当前文档的所有a元素</span><br><span class="line">document.forms //返回页面中所有表单元素</span><br><span class="line">document.images //返回页面中所有图片元素</span><br><span class="line">document.embeds //返回网页中所有嵌入对象</span><br><span class="line">document.scripts //返回当前文档的所有脚本</span><br><span class="line">document.styleSheets //返回当前网页的所有样式表</span><br><span class="line"></span><br><span class="line">document.documentURI //表示当前文档的网址</span><br><span class="line">document.URI //返回当前文档的网址</span><br><span class="line">document.domain //返回当前文档的域名</span><br><span class="line">document.lastModified //返回当前文档最后修改的时间戳</span><br><span class="line">document.location //返回location对象，提供当前文档的URL信息</span><br><span class="line">document.referrer //返回当前文档的访问来源</span><br><span class="line">document.title //返回当前文档的标题</span><br><span class="line">document.characterSet //属性返回渲染当前文档的字符集，比如UTF-8</span><br><span class="line">document.readyState //返回当前文档的状态</span><br><span class="line">document.designMode //控制当前文档是否可编辑，可读写</span><br><span class="line">document.compatMode //返回浏览器处理文档的模式</span><br><span class="line">document.cookie //用来操作Cookie</span><br></pre></td></tr></table></figure>

<h3 id="Document节点的方法"><a href="#Document节点的方法" class="headerlink" title="Document节点的方法"></a>Document节点的方法</h3><h4 id="读写方法"><a href="#读写方法" class="headerlink" title="读写方法"></a>读写方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.open() //用于新建并打开一个文档</span><br><span class="line">document.close() //关闭open方法所新建的文档</span><br><span class="line">document.write() //用于向当前文档写入内容</span><br><span class="line">document.writeIn() //用于向当前文档写入内容，尾部添加换行符</span><br></pre></td></tr></table></figure>

<h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.querySelector(selectors) //接收一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点</span><br><span class="line">document.querySelectorAll(selectors) //接收一个CSS选择器作为参数，返回所有匹配该选择器的元素节点</span><br><span class="line">document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素</span><br><span class="line">document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素</span><br><span class="line">document.getElementsByName(name) //用于选择拥有name属性的HTML元素(比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;object&gt;等)</span><br><span class="line">document.getElementById(id) //返回匹配指定id属性的元素节点</span><br><span class="line">document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点</span><br></pre></td></tr></table></figure>

<h4 id="生成节点"><a href="#生成节点" class="headerlink" title="生成节点"></a>生成节点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.createElement(tagName) //用来生成HTML元素节点</span><br><span class="line">document.createTextNode(text) //用来生成文本节点</span><br><span class="line">document.createAttribute(name) //生成一个新的属性对象节点，并返回</span><br><span class="line">document.createDocumentFragment() //生成一个DocumentFragment对象</span><br></pre></td></tr></table></figure>

<h4 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用</span><br><span class="line">document.addEventListener(type,listener,capture) //注册事件</span><br><span class="line">document.removeEventListener(type,listener,capture) //注销事件</span><br><span class="line">document.dispatchEvent(event) //触发事件</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点</span><br><span class="line">document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点</span><br><span class="line">document.importNode(externalNode,deep) //从外部文档拷贝指定节点，插入当前文档</span><br></pre></td></tr></table></figure>

<h3 id="Element节点"><a href="#Element节点" class="headerlink" title="Element节点"></a>Element节点</h3><h4 id="Element节点的属性"><a href="#Element节点的属性" class="headerlink" title="Element节点的属性"></a>Element节点的属性</h4><h5 id="特性属性"><a href="#特性属性" class="headerlink" title="特性属性"></a>特性属性</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.attributes //返回当前元素节点的所有属性节点</span><br><span class="line">Element.id //返回指定元素的id属性，可读写</span><br><span class="line">Element.tagName //返回指定元素的大写标签名</span><br><span class="line">Element.innerHTML //返回该元素包含的HTML代码，可读写</span><br><span class="line">Element.outerHTML //返回该元素节点的所有HTML代码，包括自身和所有子元素，可读写</span><br><span class="line">Element.className //返回当前元素的class属性，可读写</span><br><span class="line">Element.classList //返回当前元素节点的所有class集合</span><br><span class="line">Element.dataset //返回元素节点中所有data-*属性</span><br></pre></td></tr></table></figure>

<h5 id="尺寸属性"><a href="#尺寸属性" class="headerlink" title="尺寸属性"></a>尺寸属性</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.clientHeight //返回元素节点可见部分的高度</span><br><span class="line">Element.clientWidth //返回元素节点可见部分的宽度</span><br><span class="line">Element.clientLeft //返回元素节点左边框的宽度</span><br><span class="line">Element.clientTop //返回元素节点顶部边框的宽度</span><br><span class="line"></span><br><span class="line">Element.scrollHeight //返回元素节点的总高度</span><br><span class="line">Element.scrollWidth //返回元素节点的总宽度</span><br><span class="line">Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值，通过设置这个属性可以改变元素滚动的位置</span><br><span class="line">Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值</span><br><span class="line"></span><br><span class="line">Element.offsetHeight //返回元素的垂直高度(包含border，padding)</span><br><span class="line">Element.offsetWidth //返回元素的水平宽度(包含border，padding)</span><br><span class="line">Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移</span><br><span class="line">Element.offsetTop //返回水平位移</span><br><span class="line"></span><br><span class="line">Element.style //返回元素节点的行内样式</span><br></pre></td></tr></table></figure>

<h5 id="节点相关属性"><a href="#节点相关属性" class="headerlink" title="节点相关属性"></a>节点相关属性</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.children //包括当前元素节点的所有子元素</span><br><span class="line">Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数</span><br><span class="line">Element.firstElementChild //返回当前节点的第一个Element子节点</span><br><span class="line">Element.lastElementChild //返回当前节点的最后一个Element子节点</span><br><span class="line">Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点</span><br><span class="line">Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML元素节点</span><br><span class="line">Element.offsetParent //返回当前元素节点的最靠近、并且CSS的position属性不等于static的父元素</span><br></pre></td></tr></table></figure>

<h4 id="Element节点的方法"><a href="#Element节点的方法" class="headerlink" title="Element节点的方法"></a>Element节点的方法</h4><h5 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getBoundingClientRect() //获取元素位置</span><br><span class="line">getClientRects() //返回当前元素在页面上的矩形区域</span><br></pre></td></tr></table></figure>

<h5 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.getAttribute() //读取指定属性</span><br><span class="line">Element.setAttribute() //设置指定属性</span><br><span class="line">Element.hasAttribute() //返回一个布尔值，表示当前元素节点是否有指定属性</span><br><span class="line">Element.removeAttribute() //移除指定属性</span><br></pre></td></tr></table></figure>

<h5 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.querySelector() </span><br><span class="line">Element.querySelectorAll()</span><br><span class="line">Element.getElementByTagName()</span><br><span class="line">Element.getElementByClassName()</span><br></pre></td></tr></table></figure>

<h5 id="事件方法-1"><a href="#事件方法-1" class="headerlink" title="事件方法"></a>事件方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.addEventListener() //添加事件的回调函数</span><br><span class="line">Element.removeEventListener() //移除事件监听函数</span><br><span class="line">Element.dispatchEvent() //触发事件</span><br><span class="line"></span><br><span class="line">//ie8</span><br><span class="line">Element.attachEvent(oneventName,listener)</span><br><span class="line">Element.detachEvent(oneventName,listener)</span><br><span class="line"></span><br><span class="line">//event对象</span><br><span class="line">var event = window.event||event</span><br><span class="line"></span><br><span class="line">//事件的目标节点</span><br><span class="line">var target = event.target || event.srcElement</span><br><span class="line"></span><br><span class="line">//事件代理</span><br><span class="line">ul.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">    if(event.target.tagName.toLowerCase() === &#x27;li&#x27;)&#123;</span><br><span class="line">        console.log(event.target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域</span><br><span class="line"></span><br><span class="line">//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。</span><br><span class="line">Element.insertAdjacentHTML(where, htmlString); </span><br><span class="line">Element.insertAdjacentHTML(&#x27;beforeBegin&#x27;, htmlString); // 在该元素前插入  </span><br><span class="line">Element.insertAdjacentHTML(&#x27;afterBegin&#x27;, htmlString); // 在该元素第一个子元素前插入 </span><br><span class="line">Element.insertAdjacentHTML(&#x27;beforeEnd&#x27;, htmlString); // 在该元素最后一个子元素后面插入 </span><br><span class="line">Element.insertAdjacentHTML(&#x27;afterEnd&#x27;, htmlString); // 在该元素后插入</span><br><span class="line"></span><br><span class="line">Element.remove()  //用于将当前元素节点从DOM中移除</span><br><span class="line">Element.focus()   //用于将当前页面的焦点，转移到指定元素上</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二、CSS操作"><a href="#二、CSS操作" class="headerlink" title="二、CSS操作"></a>二、CSS操作</h2><h3 id="类名操作"><a href="#类名操作" class="headerlink" title="类名操作"></a>类名操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ie8以下</span><br><span class="line">Element.className  //获取元素节点的类名</span><br><span class="line">Element.className += &#x27; &#x27; + newClassName  //新增一个类名</span><br><span class="line"></span><br><span class="line">//判断是否有某个类名</span><br><span class="line">function hasClass(element,className)&#123;</span><br><span class="line">  return new RegExp(className,&#x27;gi&#x27;).test(element.className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除class</span><br><span class="line">function removeClass(element,className)&#123;</span><br><span class="line">  element.className = element.className.replace(new RegExp(&#x27;(^|\\b)&#x27; + className.split(&#x27; &#x27;).join(&#x27;|&#x27;) + &#x27;(\\b|$)&#x27;, &#x27;gi&#x27;),&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ie10 </span><br><span class="line">element.classList.add(className)  //新增</span><br><span class="line">element.classList.remove(className)  //删除</span><br><span class="line">element.classList.contains(className)  //是否包含</span><br><span class="line">element.classList.toggle(className)  //toggle class</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="style操作"><a href="#style操作" class="headerlink" title="style操作"></a>style操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.setAttribute(&#x27;style&#x27;,&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">element.style.backgroundColor = &#x27;red&#x27;</span><br><span class="line"></span><br><span class="line">element.style.cssText //用来读写或删除整个style属性</span><br><span class="line"></span><br><span class="line">element.style.setProperty(propertyName,value)  //设置css属性</span><br><span class="line">element.style.getPropertyValue(property)  //获取css属性</span><br><span class="line">element.style.removeProperty(property)  //删除css属性</span><br><span class="line">操作非内联样式</span><br><span class="line">//ie8</span><br><span class="line">element.currentStyle[attrName]</span><br><span class="line">//ie9+</span><br><span class="line">window.getComputedStyle(el,null)[attrName] </span><br><span class="line">window.getComputedStyle(el,null).getPropertyValue(attrName)</span><br><span class="line">//伪类</span><br><span class="line">window.getComputedStyle(el,&#x27;:after&#x27;)[attrName]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><h4 id="生成实例对象"><a href="#生成实例对象" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var o = new Object()
</code></pre>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><pre><code>Object.prototype //返回原型对象
</code></pre>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>Object.keys(o) //遍历对象的可枚举属性
Object.getOwnPropertyName(o) //遍历对象不可枚举的属性
</code></pre>
<h4 id="对象实例的方法"><a href="#对象实例的方法" class="headerlink" title="对象实例的方法"></a>对象实例的方法</h4><pre><code>valueOf() //返回当前对象对应的值
toString() //返回当前对象对应的字符串形式
toLocaleString() //返回当前对象对应的本地字符串形式
hasOwnProperty() //判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性
isPrototypeof() //判断当前对象是否为另一个对象的原型
propertyIsEnumerable() //判断某个属性是否可枚举
</code></pre>
<h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><h4 id="生成实例对象-1"><a href="#生成实例对象-1" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var a = new Array()
</code></pre>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><pre><code>a.length //长度
</code></pre>
<h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h4><pre><code>Array.isArray(a) //用来判断一个值是否为数组
</code></pre>
<h4 id="Array实例的方法"><a href="#Array实例的方法" class="headerlink" title="Array实例的方法"></a>Array实例的方法</h4><pre><code>a.valueof()   //返回数组本身
a.toString()  //返回数组的字符串形式
a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。
pop()   //用于删除数组的最后一个元素，并返回该元素
join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。
concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。
shift()  //用于删除数组的第一个元素，并返回该元素。
unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。
reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组
slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。
splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。
sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。
map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。
map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。
forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。
filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。
some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。
every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。
reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）
reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）
indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置
lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。
</code></pre>
<h3 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h3><h4 id="生成对象"><a href="#生成对象" class="headerlink" title="生成对象"></a>生成对象</h4><pre><code>var n = new Number()
</code></pre>
<h4 id="Number对象的属性"><a href="#Number对象的属性" class="headerlink" title="Number对象的属性"></a>Number对象的属性</h4><pre><code>Number.POSITIVE_INFINITY：正的无限，指向Infinity。
Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。
Number.NaN：表示非数值，指向NaN。
Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。
Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。
Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。
Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。
</code></pre>
<h4 id="Number对象实例的方法"><a href="#Number对象实例的方法" class="headerlink" title="Number对象实例的方法"></a>Number对象实例的方法</h4><pre><code>toString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。
toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。
toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。
toPrecision()  //用于将一个数转为指定位数的有效数字。
</code></pre>
<h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><h4 id="生成实例对象-2"><a href="#生成实例对象-2" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var s = new String()
</code></pre>
<h4 id="String对象的属性"><a href="#String对象的属性" class="headerlink" title="String对象的属性"></a>String对象的属性</h4><pre><code>s.length //返回字符串的长度
</code></pre>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><pre><code>s.chatAt(index)   //返回指定位置的字符
s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。
s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）
s.concat(s2)  //用于连接两个字符串
s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。
s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。
s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。
s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 
s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。
s.trim()  //用于去除字符串两端的空格，返回一个新字符串
s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。
s.toUpperCase()  //全部转为大写
s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。
s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。
s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。
s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。
s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。
</code></pre>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><pre><code>Math.E：常数e。
Math.LN2：2的自然对数。
Math.LN10：10的自然对数。
Math.LOG2E：以2为底的e的对数。
Math.LOG10E：以10为底的e的对数。
Math.PI：常数Pi。
Math.SQRT1_2：0.5的平方根。
Math.SQRT2：2的平方根。
</code></pre>
<h4 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h4><pre><code>Math.abs()：返回参数的绝对值  
Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。
Math.floor()：向下取整  
Math.max(n,n1,...)：可接受多个参数，返回最大值  
Math.min(n,n1,..)：可接受多个参数，返回最小值  
Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。
Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。
Math.log()：返回以e为底的自然对数值。
Math.exp()：返回e的指数，也就是常数e的参数次方。
Math.round()：四舍五入  
Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。
</code></pre>
<h4 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h4><pre><code>Math.sin()：返回参数的正弦  
Math.cos()：返回参数的余弦  
Math.tan()：返回参数的正切  
Math.asin()：返回参数的反正弦（弧度值）  
Math.acos()：返回参数的反余弦（弧度值）  
Math.atan()：返回参数的反正切（弧度值）
</code></pre>
<h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><pre><code>JSON.stringify()   
//用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。
//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。
//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。

JSON.parse()   //用于将JSON字符串转化成对象。
</code></pre>
<h3 id="console对象"><a href="#console对象" class="headerlink" title="console对象"></a>console对象</h3><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><pre><code>console.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。
console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。
console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。
console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；
console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈
console.table()  //可以将复合类型的数据转为表格显示。
console.count()  //用于计数，输出它被调用了多少次。
console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。
console.dirxml()  //用于以目录树的形式，显示DOM节点。
console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。

//这两个方法用于计时，可以算出一个操作所花费的准确时间。
console.time()
console.timeEnd()
//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。

console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。
console.profileEnd()  //用来结束正在运行的性能测试器。

console.group()
console.groupend()
//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。
console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。

console.trace()  //显示当前执行的代码在堆栈中的调用路径。
console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js引擎的预编译和执行</title>
    <url>/2019/08/13/js%E5%BC%95%E6%93%8E%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="var-的变量提升底层原理"><a href="#var-的变量提升底层原理" class="headerlink" title="var 的变量提升底层原理"></a>var 的变量提升底层原理</h2><pre><code>JavaScript引擎，不是逐条解释执行javascript代码，而是按照代码块一段段解释执行，
所谓代码块就是script标签分割的代码块。
</code></pre>
<span id="more"></span>
<pre><code>js引擎的工作方式分为：预编译和执行代码两个阶段。

1）常见的编译型语言编译阶段：词法分析（生成词法单元）——&gt;语法分析（抽象语法树）——&gt;(语义检查，代码优化)——&gt;代码生成

2）对于解释型语言来说，通过词法分析和语法分析得到抽象语法树之后就开始执行了，在JavaScript
解释器在构造语法树的时候，如果无法构造，就会报语法错误，并结束整个代码块的执行。
而在整个编译阶段，会把“一等公民”function和var创建的变量进行提升。（其中函数提升在变量
提成之前）

3）JavaScript语法采用的是词法作用域，也就是javascript的变量和函数作用域是在定义时
决定的，函数调用时决定的是执行期上下文和作用域链，所以js解释器只需要静态分析就能确定每个
变量、函数的作用域，这种作用域也称为静态作用域。
</code></pre>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ul>
<li><p>全局执行上下文：默认的上下文，任何不再函数内部的代码都在全局上下文中。它会执行两<br>件事：创建一个全局的window对象(浏览器的情况下)，并且设置this的值等于这个全局对象。<br>一个程序只会有一个全局执行上下文。</p>
</li>
<li><p>函数执行上下文：每当函数被调用时，都会为该函数创建一个新的上下文。</p>
</li>
<li><p>Eval函数执行上下文：执行在eval函数内部的代码也会有属于它自己的执行上下文。</p>
<p>  执行栈：JavaScript引擎会以栈的方式来处理多个执行期上下文其他语言叫“调用栈”，<br>  类似于数据结构的栈LIFO(后进先出)，用来存储代码运行时创建的所有执行上下文。<br>  栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。</p>
<p>  当JavaScript引擎第一次遇见脚本时，它会创建一个全局的执行上下文并且压入当前<br>  执行栈，每当引擎遇到一个函数调用，会为该函数创建一个新的执行上下文并压入栈的顶部。</p>
<p>  引擎会执行那些执行上下文位于栈顶的函数，当函数执行结束时，执行上下文从栈顶<br>  弹出，控制流程到达当前栈中的下一个上下文。</p>
<p>  当函数执行时，会创建一个成为 执行期上下文的内部对象。</p>
<p>  执行期上下文就是js代码被解析和执行时的运行环境，函数每次执行都会创建一个独一无二的执行上下文，所以多次调用会产生<br>  多个执行上下文，当函数执行完毕，所产生的执行上下文被销毁。</p>
<p>  执行上下文的生命周期包括三个阶段：</p>
<pre><code>  创建阶段-&gt;执行阶段-&gt;挥手阶段
  
</code></pre>
<p>  创建阶段会创建变量对象(Variable Object)，建立作用域链，确定this指向</p>
<pre><code>  1. 创建Scope chain
  2. 创建AO
  3. 设置this的值
</code></pre>
<p>  创建AO主要做了以下事情：</p>
<pre><code>  1. 创建AO对象
  2. 形参和变量声明存储到AO对象 //赋值为undefined
  3. 将形参和实参相统一
  4. 函数声明的函数名作为AO对象的key，函数体作为value
  
</code></pre>
<p>  执行阶段会完成变量赋值，函数引用，以及执行其他代码。</p>
</li>
<li><p>AO(Active Object) &amp; VO(Variable Object)的区别？</p>
<ul>
<li>VO：未进入执行上下文执行阶段之前，变量对象中的属性都不能访问。</li>
<li>AO：进入执行阶段之后，变量对象转变为活动对象，里面的属性都能访问了。</li>
<li>它们都是同一个对象，只是处于执行上下文的不同生命周期，而且只有处于<br>函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。</li>
</ul>
<p>  如果函数引用了外部变量的值，则JavaScript引擎会为改函数创建一个闭包体（closure），<br>  闭包体是一个完全封闭和独立的作用域，他不会在函数调用完毕后就被js引擎当作垃圾<br>  进行回收，闭包体可以长期存在。</p>
</li>
</ul>
<ul>
<li>执行上下文总结：<ul>
<li>单线程</li>
<li>同步执行，只有栈顶的上下文处于执行中，而其他上下文需要等待</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈，而且其他所有上下文环境<br>都可以直接访问全局上下文的属性</li>
<li>函数的执行上下文的个数没有限制</li>
<li>每次某个函数被调用，就会有新的执行上下文为其创建，即使是调用的自身函数，也是如此。</li>
</ul>
</li>
</ul>
<h2 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h2><pre><code>同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入Event Table
并注册函数。

当指定的事情完成时（例如定时器执行完毕，获取数据结束等），Event Table会将这个函数移入Event Queue

主线程内的任务执行完毕为空，会去Event Queue（事件队列）读取对应的函数，进入主线程执行。

上述过程不断重复，称为Event Loop（事件轮询）
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>异步加载js</title>
    <url>/2019/08/14/js%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%BA%BF%E5%92%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjs/</url>
    <content><![CDATA[<h2 id="js加载-浏览器加载-时间线"><a href="#js加载-浏览器加载-时间线" class="headerlink" title="js加载(浏览器加载)时间线"></a>js加载(浏览器加载)时间线</h2><pre><code>理论：它是根据js出生的那一刻开始记录的一系列浏览器按照顺序做的事，

就是加载顺序及一些优化
</code></pre>
 <span id="more"></span>

<ul>
<li><p>创建Document对象，开始解析web页面，这个阶段document.readyState = ‘loading’</p>
</li>
<li><p>遇见link外部css，创建线程 加载，并继续解析文档</p>
</li>
<li><p>遇见script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成</p>
</li>
</ul>
<p>并执行该脚本，然后继续解析文档</p>
<ul>
<li>遇见script外部js，并且设置了async、defer，浏览器创建线程 加载，并继续解析文档，对于</li>
</ul>
<p>async属性的脚本，加载完成后立即执行。（异步加载禁止使用document.write(),它会清除文档流）</p>
<ul>
<li><p>遇见img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档</p>
</li>
<li><p>文档解析完成，document.readyState = ‘interactive’</p>
</li>
<li><p>文档解析完成后，所有设置defer的脚本会按照顺序执行。（也禁止使用document.write()）</p>
</li>
<li><p>之后document对象触发DOMContentLoaded事件，标志程序执行从同步脚本执行阶段，转化为</p>
</li>
</ul>
<p>事件驱动阶段</p>
<ul>
<li>当所有async的脚本加载并执行后、img等加载完成后，document.readyState = ‘complete’,</li>
</ul>
<p>这是window对象触发load事件。</p>
<ul>
<li>…</li>
</ul>
<h2 id="异步加载js"><a href="#异步加载js" class="headerlink" title="异步加载js"></a>异步加载js</h2><pre><code>javascript 异步加载的三种方案:
</code></pre>
<ul>
<li>defer 异步加载，但要等到dom文档全部解析完成才会被执行，只有IE能用，可以将js代码写在</li>
</ul>
<p>script标签内部。</p>
<ul>
<li>async 异步加载，加载完就执行，async只能加载 外部脚本，不能把js写在script标签中，执行</li>
</ul>
<p>时也不会阻塞页面。</p>
<ul>
<li>动态创建 script，插入到dom中，加载完毕后callback。<br>简单实例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var script = document.createElement(&#x27;script&#x27;)</span><br><span class="line"></span><br><span class="line">script.type = &#x27;text/javascript&#x27;</span><br><span class="line"></span><br><span class="line">script.src = demo.js</span><br><span class="line"></span><br><span class="line">script.onload = function() &#123; //兼容性很好，除了IE</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.head.appendChild(script)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>动态加载函数封装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function asyncLoaded(url,callback)&#123;</span><br><span class="line">    var script = document.createElement(&quot;script&quot;);</span><br><span class="line">//  script.src = url;   假如说网速非常好，直接执行完成了，后面就监听不到状态的改变了</span><br><span class="line">    if(script.readyState)&#123;</span><br><span class="line">        script.onreadystatechange = function()&#123;</span><br><span class="line">            if(script.readyState == &quot;complete&quot; || script.readyState ==&quot;loaded&quot;)&#123;</span><br><span class="line">//  执行某个函数</span><br><span class="line">                callback()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        script.onload = function()&#123;</span><br><span class="line">//  执行某个函数</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = url;    //异步的过程</span><br><span class="line">    document.head.appendChild(script)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncLoaded(&#x27;demo.js&#x27;, function()&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>get和post请求的区别？</title>
    <url>/2019/09/07/get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<ul>
<li>get 和 post的请求区别？<span id="more"></span>
<ul>
<li>区别一：<ul>
<li>get重点是从服务器上获取资源</li>
<li>post重点是向服务器发送数据</li>
</ul>
</li>
<li>区别二：<ul>
<li>get传输数据通过url请求，以field（字段）=value的形式放在url后，用“？”连接，<br>多个请求数据间用“&amp;”连接，过程用户可见。</li>
<li>post传输数据放在请求体（request body）中发送给服务器，用户不可见。</li>
</ul>
</li>
<li>区别三：<ul>
<li>get传输数据大小有限制（根本原因是卢兰其地址栏对输入的url有最大长度限制，<br>超过会截断），但效率较高</li>
<li>post可以传输大量数据，所以上传文件用post方式</li>
</ul>
</li>
<li>区别四：<ul>
<li>get请求不安全，因为参数直接暴露在url上，并且会保存在浏览器的历史记录中，<br>不能用来传递敏感信息。</li>
<li>post较get安全性较高。</li>
</ul>
</li>
<li>区别五：<ul>
<li>get方式只能支持ASCII字符，向服务传的中文字符可能会乱码。</li>
<li>post支持标准字符集，可以正确传递中文字符。</li>
</ul>
</li>
<li>区别六：<ul>
<li>get在浏览器回退是无害的，而post会再次提交请求。</li>
</ul>
</li>
<li>区别七<ul>
<li>get请求会被浏览器主动cache（缓存），而post不会除非手动设置。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie封装以及元素拖拽记录位置</title>
    <url>/2019/08/08/cookie%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%83%E7%B4%A0%E6%8B%96%E6%8B%BD%E8%AE%B0%E5%BD%95%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="cookie封装以及元素拖拽记录位置"><a href="#cookie封装以及元素拖拽记录位置" class="headerlink" title="cookie封装以及元素拖拽记录位置"></a>cookie封装以及元素拖拽记录位置</h2><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #demo&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            left: 100px;</span><br><span class="line">            top: 100px;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height:100px;</span><br><span class="line">            background: orange;</span><br><span class="line">            color: #fff;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;demo&quot;&gt;demo&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var oDemo = document.getElementById(&#x27;demo&#x27;);</span><br><span class="line">        var manageCookie = &#123;</span><br><span class="line">            setCookie: function (key, value, date) &#123;//增，改</span><br><span class="line">                var oDate = new Date();</span><br><span class="line">                oDate.setDate(oDate.getDate() + date);</span><br><span class="line">                document.cookie = key + &#x27;=&#x27; + value + &#x27;;expires=&#x27; + oDate;</span><br><span class="line">                return this;</span><br><span class="line">            &#125;,</span><br><span class="line">            removeCookie: function (key) &#123;//删</span><br><span class="line">                this.setCookie(key, &#x27;&#x27;, -1 );</span><br><span class="line">                return this;</span><br><span class="line">            &#125;,</span><br><span class="line">            getCookie: function (key, callback) &#123;//查</span><br><span class="line">                </span><br><span class="line">                var allCookie = document.cookie;</span><br><span class="line">                var cookieArr = allCookie.split(&#x27;; &#x27;);</span><br><span class="line">                cookieArr.forEach(function (ele) &#123;</span><br><span class="line">                    var item = ele.split(&#x27;=&#x27;);</span><br><span class="line">                    if(item[0] == key) &#123;</span><br><span class="line">                        callback?callback(item[1]):&#x27;&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                return this; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var dragFun = &#123;</span><br><span class="line">            init: function () &#123;</span><br><span class="line">                //入口函数</span><br><span class="line">                this.dom = oDemo;</span><br><span class="line">                manageCookie.getCookie(&#x27;position&#x27;, function (data) &#123;</span><br><span class="line">                    if(data) &#123;</span><br><span class="line">                        var dataArr = data.split(&#x27;&amp;&#x27;);</span><br><span class="line">                        oDemo.style.left = dataArr[0] + &#x27;px&#x27;;</span><br><span class="line">                        oDemo.style.top = dataArr[1] + &#x27;px&#x27;;</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;)</span><br><span class="line">                dragFun.bindEvent();</span><br><span class="line">            &#125;,</span><br><span class="line">            bindEvent: function() &#123;</span><br><span class="line">                //绑定事件</span><br><span class="line">                this.dom.onmousedown = this.oDemoDown.bind(this);</span><br><span class="line">            &#125;,</span><br><span class="line">            oDemoDown: function () &#123;</span><br><span class="line">                //鼠标按下触发的函数</span><br><span class="line">                this.disX = event.clientX - this.dom.offsetLeft;</span><br><span class="line">                this.disY = event.clientY - this.dom.offsetTop;</span><br><span class="line">                document.onmousemove = this.oDemoMove.bind(this);</span><br><span class="line">                document.onmouseup = this.oDemoUp.bind(this);</span><br><span class="line">            &#125;,</span><br><span class="line">            oDemoMove: function () &#123;</span><br><span class="line">                //鼠标移动</span><br><span class="line">                this.newLeft = event.clientX - this.disX;</span><br><span class="line">                this.newTop = event.clientY - this.disY;</span><br><span class="line">                this.dom.style.left = this.newLeft + &#x27;px&#x27;;</span><br><span class="line">                this.dom.style.top = this.newTop + &#x27;px&#x27;;</span><br><span class="line">            &#125;,</span><br><span class="line">            oDemoUp: function () &#123;</span><br><span class="line">                //鼠标抬起</span><br><span class="line">                document.onmousemove = null;</span><br><span class="line">                document.onmouseup = null;</span><br><span class="line"></span><br><span class="line">                var positionStr = this.newLeft + &#x27;&amp;&#x27; + this.newTop;</span><br><span class="line"></span><br><span class="line">                manageCookie.setCookie(&#x27;position&#x27;, positionStr, 3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dragFun.init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>简单拖拽封装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function drag (elem) &#123;</span><br><span class="line">    var disX,</span><br><span class="line">        disY;</span><br><span class="line">    elem.onmousedown = function(e) &#123;</span><br><span class="line">        disX = e.pageX - parseInt(div.style.left)</span><br><span class="line">        disY = e.pageY - parseInt(div.style.top)</span><br><span class="line">        document.onmousemove = function(e) &#123;</span><br><span class="line">            var event = e|| window.event</span><br><span class="line">            div.style.left = e.pageX - disX + &quot;px&quot;</span><br><span class="line">            div.style.top = e.pageY - disY + &quot;px&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        document.onmouseup = function() &#123;</span><br><span class="line">            div.onmousemove = null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>js严格模式</title>
    <url>/2019/08/21/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="使用严格模式"><a href="#使用严格模式" class="headerlink" title="使用严格模式"></a>使用严格模式</h2><ul>
<li>在脚本 <strong>顶层</strong> 中添加 ‘use strict’<span id="more"></span></li>
</ul>
<h2 id="为什么使用严格模式？"><a href="#为什么使用严格模式？" class="headerlink" title="为什么使用严格模式？"></a>为什么使用严格模式？</h2><ul>
<li><p>消除js语法的一些不合理、不严谨之处，减少一些怪异行为</p>
</li>
<li><p>提高编译器效率，增加运行速度</p>
</li>
<li><p>为未来新版的JavaScript做好铺垫</p>
</li>
</ul>
<h2 id="严格模式和正常模式比较："><a href="#严格模式和正常模式比较：" class="headerlink" title="严格模式和正常模式比较："></a>严格模式和正常模式比较：</h2><ul>
<li><p>严格模式下，不允许给为声明的变量赋值。</p>
</li>
<li><p>严格模式下不允许使用with</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!function () &#123;</span><br><span class="line">	&#x27;use strict&#x27;;</span><br><span class="line">	with(&#123; x: 1 &#125;) &#123;</span><br><span class="line">		console.log(x);  //SyntaxError</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line">// !function()&#123;&#125;() 表示：解释器在解释语句时，如果以function开头，就会理解为函数声明，</span><br><span class="line">//而前面加一个&quot;!&quot;可以让解释器理解为函数表达式，这样就可以立即调用了。</span><br></pre></td></tr></table></figure></li>
<li><p>严格模式下，eval变成了独立作用域</p>
</li>
<li><p>一般函数调用，this默认指向全局对象，在严格模式下，this指向undefined</p>
</li>
<li><p>严格模式下，对arguments对象有很多限制，如不能给arguments赋值，不再支持arguments.callee和arguments.caller</p>
</li>
<li><p>严格模式下，删除参数名、函数名会报错。非严格模式下返回false，静态失败（不报错也没效果）</p>
</li>
<li><p>严格模式下，给不可扩展（Object.preventExtensions(obj)）对象的新属性赋值会报错.<br>非严格模式下，静态失败。</p>
</li>
<li><p>严格模式下，修改不可写（Object.defineProperty(obj, ‘a’, {writable: false})）的属性报错。<br>非严格模式下，静态失败。</p>
</li>
<li><p>严格模式下，删除不可配置（Object.defineProperty(obj, ‘a’, {configurable: false})）的属性报错。<br>非严格模式下，静态失败。</p>
</li>
<li><p>严格模式下，给只读属性赋值会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!function()&#123;</span><br><span class="line">    &#x27;use strict&#x27;</span><br><span class="line">    var obj = &#123;get x() &#123;return 12;&#125;&#125;</span><br><span class="line">    obj.x = 5  //TypeError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>严格模式下，禁止写八进制字面量。</p>
</li>
<li><p>严格模式下，对象的属性名重复设置会报错。非严格模式下，后者覆盖前者。</p>
</li>
<li><p>严格模式下，禁止设置五种基本类型的属性。（null.bbb = ‘xxx’ //TypeError）</p>
</li>
<li><p>严格模式下，不能使用一些保留的关键字（如static、puclic、private、protected、interface）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>lerna开发</title>
    <url>/2021/11/01/lerna%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="创建-npm-私服"><a href="#创建-npm-私服" class="headerlink" title="创建 npm 私服"></a>创建 npm 私服</h2><ul>
<li>verdaccio 是一个简单、零配置的本地私有化 npm 仓库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install verdaccio -g</span><br><span class="line"></span><br><span class="line">verdaccio</span><br><span class="line">http://localhost:4873</span><br><span class="line">npm adduser --registry http://localhost:4873/</span><br><span class="line">npm publish --registry http://localhost: 4873/</span><br></pre></td></tr></table></figure>

<h2 id="lerna-常用命令"><a href="#lerna-常用命令" class="headerlink" title="lerna 常用命令"></a>lerna 常用命令</h2><p>项目初始化<br>| 命令 | 说明 |<br>| — | — |<br>| lerna init –independent | 初始化项目 |</p>
<p>创建包<br>| 命令 | 说明 |<br>| — | — |<br>| lerna create module-1 | 创建 package |<br>| lerna add | 安装依赖 |<br>| lerna link | 链接依赖 |</p>
<p>开发和测试<br>| 命令 | 说明 |<br>| — | — |<br>| lerna exec | 执行 shell 脚本 |<br>| lerna run | 执行 npm 命令 |<br>| lerna clean | 清空依赖|<br>| lerna bootstrap | 重新安装依赖 |</p>
<p>package 依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.给指定package安装依赖</span><br><span class="line">$ lerna add lodash packages/module-1</span><br><span class="line">$ lerna add lodash --scope=module-1</span><br><span class="line">$ lerna add lodash **/module-1</span><br><span class="line">$yarn workspace module-1 add lodash</span><br><span class="line"></span><br><span class="line">2.给所有package安装依赖</span><br><span class="line">$ lerna add lodash</span><br><span class="line"></span><br><span class="line">3.workspace之间的依赖</span><br><span class="line">$ lerna add module-2 packages/module-1</span><br><span class="line">$ lerna add module-2 --scope module-1</span><br></pre></td></tr></table></figure>

<p>发布</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lerna publish</span><br></pre></td></tr></table></figure>

<h2 id="lerna-json"><a href="#lerna-json" class="headerlink" title="lerna.json"></a>lerna.json</h2><ul>
<li>version: 当前仓库的版本，independent mode 请设置为 <strong>independent</strong>.<ul>
<li>lerna 对于包的管理有两种模式：固定模式 fixed、独立模式 independent。</li>
<li>固定模式所有包是统一的版本号，每次升级所有包统一更新，无论这个包内容是否改变。 *具体体现在 lerna 的配置文件中 lerna.json 中永远会存在一个确定版本号：{“version”: “0.0.1”}</li>
<li>独立模式，每个包都是单独的版本号，每次 lerna 触发发布命令，每个包的版本都会单独变化，具体体现在 lerna 的配置文件 lerna.json 中没有一个确定的版本号，而是{“version”:”independent”}</li>
</ul>
</li>
<li>npmClient: 指定运行的客户端程序 默认为 npm</li>
<li>ignoreChanges: 一个不包含在<strong>lerna changed/publish</strong>的 glob 数组，使用这个阻止发布不必要的更新，比如修复<strong>README.md</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;useWorkspaces&quot;: true, // 使用 workspaces 配置。此项为 true 的话，将使用 package.json 的 &quot;workspaces&quot;，下面的 &quot;packages&quot; 字段将不生效</span><br><span class="line">    &quot;version&quot;: &quot;0.1.0&quot;, // 所有包版本号，独立模式-&quot;independent&quot;</span><br><span class="line">    &quot;npmClient&quot;: &quot;cnpm&quot;, // npm client，可设置为 cnpm、yarn 等</span><br><span class="line">    &quot;packages&quot;: [ // 包所在目录，可指定多个</span><br><span class="line">        &quot;packages/*&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;command&quot;: &#123; // lerna 命令相关配置</span><br><span class="line">        &quot;publish&quot;: &#123; // 发布相关</span><br><span class="line">            &quot;ignoreChanges&quot;: [ // 指定文件或目录的变更，不触发 publish</span><br><span class="line">                &quot;.gitignore&quot;,</span><br><span class="line">                &quot;*.log&quot;,</span><br><span class="line">                &quot;*.md&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;bootstrap&quot;: &#123; // bootstrap 相关</span><br><span class="line">            &quot;ignore&quot;: &quot;npm-*&quot;,  // 不受 bootstrap 影响的包</span><br><span class="line">            &quot;npmClientArgs&quot;: [ // bootstr 执行参数</span><br><span class="line">                &quot;--no-package-lock&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CRA-lerna-react-typescript-项目搭建"><a href="#CRA-lerna-react-typescript-项目搭建" class="headerlink" title="CRA + lerna + react + typescript 项目搭建"></a>CRA + lerna + react + typescript 项目搭建</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.create-react-app demo --template typescript</span><br><span class="line"></span><br><span class="line">2.cd demo</span><br><span class="line"></span><br><span class="line">3.npm run eject</span><br><span class="line"></span><br><span class="line">4.lerna init</span><br><span class="line"></span><br><span class="line">5.lerna create builder-script</span><br><span class="line"></span><br><span class="line">6.自定义builder-scripts脚本命令</span><br><span class="line"></span><br><span class="line">7.自定义 eslintrc、tsconfig、webpack等配置项</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>lerna</category>
      </categories>
      <tags>
        <tag>lerna</tag>
      </tags>
  </entry>
  <entry>
    <title>call、apply、bind三者比较及实现</title>
    <url>/2019/08/14/call%E3%80%81apply%E3%80%81bind%E4%B8%89%E8%80%85%E6%AF%94%E8%BE%83%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="apply、call、bind三者比较"><a href="#apply、call、bind三者比较" class="headerlink" title="apply、call、bind三者比较"></a>apply、call、bind三者比较</h4><span id="more"></span>
<pre><code>1. apply、call、bind三者都是用来改变函数的this对象的指向的

2. apply、call、bind三者第一个参数都是this要指向的对象，也就是指向指定的上下文

3. apply、call、bind三者都可以利用后续参数进行传参

4. bind返回对应函数，可以稍后调用执行；apply、call则是立即调用

5.apply、call的接受参数不同，call将参数按顺序传递进去，apply则采用参数数组的形式
</code></pre>
<h4 id="实现call"><a href="#实现call" class="headerlink" title="实现call"></a>实现call</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.call2 = function () &#123;</span><br><span class="line"></span><br><span class="line">    //改变this指向，将目标函数作为这个对象的属性</span><br><span class="line">    var context = arguments[0] || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line">    </span><br><span class="line">    //利用arguments类数组对象实现参数不定长</span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将不定长的参数传递给函数</span><br><span class="line">    var result = eval(&#x27;context.fn(&#x27; + args.join(&#x27;,&#x27;) +&#x27;)&#x27;);</span><br><span class="line">    // context.fn(...args)</span><br><span class="line"></span><br><span class="line">    //不能增加对象的属性，所以结尾要删除delete</span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现apply"><a href="#实现apply" class="headerlink" title="实现apply"></a>实现apply</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.apply2 = function (context, arr) &#123;</span><br><span class="line">    var context = Object(context) || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        var args = [];</span><br><span class="line">        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&#x27;arr[&#x27; + i + &#x27;]&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind2 = function (context) &#123;</span><br><span class="line">    if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    var self = this;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    var fNOP = function () &#123;&#125;;</span><br><span class="line">    var fbound = function () &#123;</span><br><span class="line">        self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line">    &#125;</span><br><span class="line">    fNOP.prototype = this.prototype;</span><br><span class="line">    fbound.prototype = new fNOP();</span><br><span class="line">    return fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bind(fn, obj) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return fn.apply(obj, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>git commit提示Your branch is up-to-date with &#39;origin/master&#39;</title>
    <url>/2019/09/21/git-commit%E6%8F%90%E7%A4%BAYour-branch-is-up-to-date-with-origin-master/</url>
    <content><![CDATA[<h3 id="git-commit提示Your-branch-is-up-to-date-with-‘origin-master’"><a href="#git-commit提示Your-branch-is-up-to-date-with-‘origin-master’" class="headerlink" title="git commit提示Your branch is up-to-date with ‘origin/master’"></a>git commit提示Your branch is up-to-date with ‘origin/master’</h3><ul>
<li><p>新建一个分支</p>
<blockquote>
<p>git branch newbranch</p>
</blockquote>
</li>
<li><p>然后检查分支是否创建成功</p>
<blockquote>
<p>git branch</p>
</blockquote>
</li>
<li><p>切换到新的分支</p>
<blockquote>
<p>git checkout newbranch</p>
</blockquote>
</li>
<li><p>将改动提交到新的分支上</p>
<blockquote>
<p>git add .<br>git commit -m “0.0.1”</p>
</blockquote>
</li>
<li><p>然后可以检查是否成功</p>
<blockquote>
<p>git status</p>
</blockquote>
</li>
<li><p>然后切换到主分支</p>
<blockquote>
<p>git checkout master</p>
</blockquote>
</li>
<li><p>然后将新分支提交的改动合并到主分支上</p>
<blockquote>
<p>git merge newbanch</p>
</blockquote>
</li>
<li><p>push到仓库</p>
<blockquote>
<p>git push -u origin master</p>
</blockquote>
</li>
<li><p>最后还可以删除这个分支</p>
<blockquote>
<p>git branch -D newbranch</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>new 的过程都干了什么</title>
    <url>/2019/08/13/new-%E7%9A%84%E8%BF%87%E7%A8%8B%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h4 id="new的过程"><a href="#new的过程" class="headerlink" title="new的过程"></a>new的过程</h4><span id="more"></span>
<pre><code>- 新生成一个对象
- 链接到原型（继承该函数的原型）
- 绑定this（将原型中的属性和方法加入到this引用的对象中）
- 返回新对象
</code></pre>
<p>自己实现一个new：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function create() &#123;</span><br><span class="line">    // 创建一个空的对象</span><br><span class="line">    let obj = new Object()</span><br><span class="line">    // 获得构造函数</span><br><span class="line">    let Con = [].shift.call(arguments)</span><br><span class="line">    // 设置新对象的__proto__属性指向构造函数的prototype属性</span><br><span class="line">    obj.__proto__ = Con.prototype</span><br><span class="line">    // 绑定 this，函数中this指向新实例对象。</span><br><span class="line">    let result = Con.apply(obj, arguments)</span><br><span class="line">    // 确保 new 出来的是个对象</span><br><span class="line">    return typeof result === &#x27;object&#x27; ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// 简洁版的new实现过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function newFunc(constructor)&#123;</span><br><span class="line">  //第一步：创建一个空对象obj </span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">   //第二步：将构造函数 constructor的原型对象赋给obj的原型</span><br><span class="line">    obj.__proto__ = constructor.prototype;</span><br><span class="line">  //第三步：将构造函数 constructor中的this指向obj,并立即执行构造函数内部的操作</span><br><span class="line">    constructor.apply(obj);</span><br><span class="line">  //第四步：返回这个对象</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>null和undefined的区别</title>
    <url>/2019/08/13/null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h2><p><code>null表示空对象，即此处为一个空值</code><br>    <span id="more"></span><br>典型用法：</p>
<ul>
<li>作为函数的参数</li>
<li>作为对象原型链的终点</li>
</ul>
<p><code>undefined 表示缺少值，即此处应该有一个值，但是还没有赋值</code></p>
<p>典型用法：</p>
<ul>
<li>变量被声明，但还未赋值，为undefined</li>
<li>调用函数时，应该提供的参数没有提供，为undefined</li>
<li>对象没有赋值的属性，该属性的值为undefined</li>
<li>函数没有返回值时，默认返回undefined</li>
</ul>
<p><code>undefined 和 null转换为Boolean都会自动转换为false</code></p>
<p><code>Number(null) ——&gt; 0   null + 5 = 5 </code></p>
<p><code>Number(undefined) ——&gt; NaN   undefined + 5 = NaN </code></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack配置工程师</title>
    <url>/2021/10/27/webpack%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    <content><![CDATA[<p>构建 webpack 知识体系分为下面三个层级： 1.基础–会配置 2.进阶–能优化 3.深入–懂原理</p>
<h2 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h2><h3 id="1-简单配置"><a href="#1-简单配置" class="headerlink" title="1.简单配置"></a>1.简单配置</h3><p>该部分需掌握：<br>1.Webpack 常规配置项有哪些？ 2.常用 loader 有哪些？如何配置？ 3.常用插件 plugin 有哪些？如何配置？<br>4.Babel 如何配置？Babel 插件如何使用？</p>
<h4 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h4><p>需要现在本地安装<strong>webpack</strong>及<strong>webpack-cli</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<h4 id="1-2-开始工作"><a href="#1-2-开始工作" class="headerlink" title="1.2 开始工作"></a>1.2 开始工作</h4><p>webpack 在 4 以后就支持 0 配置打包，我们可以测试一下 1.新建 webpack-work 项目，新建 <code>./src/index.js</code>文件，写一段简单的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = &#x27;hello foolishmax&#x27;;</span><br><span class="line">console.log(a);</span><br><span class="line">module.exports = a;</span><br></pre></td></tr></table></figure>

<p>2.直接运行<code>npx webpack</code>，启动打包<br><img src="../images/md_img/webpack-mode-error.png" alt="webpack-mode-error">)</p>
<p>打包完成，会有一个提示：<code>The &#39;mode&#39; option has not been set,...</code></p>
<p>意思就是我们没有配置 mode（告知 webpack 使用相应模式的内置优化，默认为<code>production</code>，另外还有<code>development</code>、<code>none</code>）</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>development</td>
<td>开发模式，打包更加快速，省了代码优化步骤</td>
</tr>
<tr>
<td>production</td>
<td>生产模式，打包比较慢，开启 tree-shaking 和压缩代码</td>
</tr>
<tr>
<td>none</td>
<td>不使用任何默认优化选项</td>
</tr>
</tbody></table>
<p>webpack.config.js 中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-配置文件"><a href="#1-3-配置文件" class="headerlink" title="1.3 配置文件"></a>1.3 配置文件</h4><p>虽然可以零配置打包，但是实际工作中，还是需要使用配置文件的方式来满足不同项目的需求。 1.跟路径下创建配置文件<code>webpack.config.js</code> 2.新增基本配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;, // 模式</span><br><span class="line">  entry: &#x27;./src/index.js&#x27;, // 打包入口地址</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;, // 输出文件名</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;) // 输出文件目录</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-4-loader"><a href="#1-4-loader" class="headerlink" title="1.4 loader"></a>1.4 loader</h4><p>这里我们把入口文件改成 css 文件，看下打包结果如何 1.新增<code>./src/main.css</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding: 0 20px;</span><br><span class="line">  max-width: 800px;</span><br><span class="line">  background: #f4f8fb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.修改 entry 配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./src/main.css&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.运行打包命令： <code>npx webpack</code><br><img src="../images/md_img/webpack-loader.png" alt="loader"><br>这里的报错信息是因为：webpack 默认支持处理 js 文件，其他类型都处理不了，需要借助 loader 来对不同类型的文件进行处理。</p>
<p>4.安装<code>css-loader</code>来处理 CSS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install css-loader -D</span><br></pre></td></tr></table></figure>

<p>5.配置资源加载模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./src/main.css&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.css&#x27;,</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [ // 转换规则</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.css$/, // 匹配所有css文件</span><br><span class="line">        use: &#x27;css-loader&#x27;, //对应的loader名称</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.重新运行打包命令<code>npx webpack</code>,就可以打包成功了</p>
<p>总结：loader 就是将 webpack 不认识的内容转化为认识的内容</p>
<h4 id="插件（plugin）"><a href="#插件（plugin）" class="headerlink" title="插件（plugin）"></a>插件（plugin）</h4><p>插件可以贯穿 webpack 打包的生命周期，执行不同的任务</p>
<p>1.新建<code>./src/index.html</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>如果想要打包后的资源文件，例如 js 或者 css 文件可以自动引入到 html 中，就需要使用插件<code>html-webpack-plugin</code>来做这件事情。</p>
<p>2.本地安装 <code>html-webpack-plugin</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>3.配置插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [ // 转换规则</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.css$/, // 匹配所有css文件</span><br><span class="line">        use: &#x27;css-loader&#x27;, //对应的loader名称</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/index.html&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行一下打包，打开 dist 目录下的 index.html 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到它自动引入打包好的 bundle.js</p>
<h4 id="1-6-自动清空打包目录"><a href="#1-6-自动清空打包目录" class="headerlink" title="1.6 自动清空打包目录"></a>1.6 自动清空打包目录</h4><p>每次打包的时候，打包目录都会遗留上次打包的文件，为了保持打包目录的纯净，打包前需将上次打包目录清空。</p>
<p>1.安装 <code>clean-webpack-plugin</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>2.配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">const &#123;CleanWebpackPlugin&#125; = require(&#x27;clean-webpack-plugin&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/index.html&#x27;,</span><br><span class="line">    &#125;),</span><br><span class="line">    new CleanWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-7-区分环境"><a href="#1-7-区分环境" class="headerlink" title="1.7 区分环境"></a>1.7 区分环境</h4><p>本底环境</p>
<ul>
<li>需要更快的构建速度</li>
<li>需要打印 debug 信息</li>
<li>需要 live reload 或者 hot reload 功能</li>
<li>需要 sourcemap 方便定位问题</li>
<li>…</li>
</ul>
<p>生产环境：</p>
<ul>
<li>需要更小的包体积，代码压缩+tree-shaking</li>
<li>需要进行代码分割</li>
<li>需要压缩图片体积</li>
<li>…</li>
</ul>
<p><a href="https://juejin.cn/post/7023242274876162084#heading-6">掘金</a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>var、let、const区别</title>
    <url>/2019/07/29/var%E3%80%81let%E3%80%81const%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="JavaScript中var、let和const的区别？"><a href="#JavaScript中var、let和const的区别？" class="headerlink" title="JavaScript中var、let和const的区别？"></a>JavaScript中var、let和const的区别？</h2><span id="more"></span>
<pre><code>1. JavaScript有两种作用域：全局作用域和方法作用域，没有块级作用域。

2. var在全局声明为全局变量，在函数内声明就是局部变量。

3. let是ES6新增的一个命令，用来声明局部变量。

4. var存在变量提升，可以在变量声明之前使用，返回undefined。let存在暂时性死区，在变量声明之前
使用，会提示ReferenceError。

5. 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不
可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

6. let不允许在同一个作用域内重复声明同一个变量。

7. const 和 let 相同，声明也只在当前的块级作用域生效。同样也不会声明提升，
也存在暂时死区，只能在声明之后使用，且和 let 一样不得重复声明，不能重新赋值。

8. const 所不能改变的并不是值，而是变量指向的那个内存地址所保存的值不能变动，
对于简单类型（数值、字符串、布尔值），值就保存在变量所指向的内存地址中，
因此等同于常量。而对于复合类型（数组、对象），变量指向的内存地址，保
存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的
（即总指向一个固定的地址）。
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js继承的几种实现方式</title>
    <url>/2019/08/13/js%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="js继承的几种实现方式"><a href="#js继承的几种实现方式" class="headerlink" title="js继承的几种实现方式"></a>js继承的几种实现方式</h4><p>首先，我们需要定义一个父类：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义一个动物类</span><br><span class="line">function Animal (name) &#123;</span><br><span class="line">//属性</span><br><span class="line">	this.name = name || &#x27;Animal&#x27;;</span><br><span class="line">	//实例方法</span><br><span class="line">	this.sleep = function() &#123;</span><br><span class="line">	console.log(this.name + &#x27;i&#x27;m sleeping&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//原型方法</span><br><span class="line">Animal.prototype.eat = function(food) &#123;</span><br><span class="line">	console.log(this.name + &#x27;i&#x27;m eating&#x27; + food)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>原型链继承</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent2 () &#123;</span><br><span class="line">	this.name = &#x27;parent2&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function Child2 () &#123;</span><br><span class="line">	this.sex = &#x27;male&#x27;</span><br><span class="line">&#125;</span><br><span class="line">//第一种写法</span><br><span class="line">Child2.prototype = new Parent2()</span><br><span class="line">//第二种写法(创建一个新的Child2.prototype对象关联到Parent2.prototype)</span><br><span class="line">//但是现在没有了Child2.prototype.constructor了</span><br><span class="line">//Child2.prototype = Object.create(Parent2.prototype)</span><br><span class="line">//第三种写法（ES6） </span><br><span class="line">//Object.setPrototypeOf(Child2.prototype, Parent.prototype)</span><br><span class="line">console.log(new Child2())</span><br><span class="line"></span><br><span class="line">//缺点就是：实例化子类的时候无法给父类传递参数</span><br></pre></td></tr></table></figure></li>
<li><strong>构造函数继承</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// js没有构造函数，但是一个普通函数，使用new调用的时候，它就会构造一个对象</span><br><span class="line">//函数不是构造函数，准确来说是 带new的函数调用</span><br><span class="line">function Parent1 () &#123;</span><br><span class="line">	this.name = &#x27;parent1&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Parent1.prototype.say = function()&#123;&#125;;</span><br><span class="line">function Child1() &#123;</span><br><span class="line">	Parent1.call(this)</span><br><span class="line">	this.sex = &#x27;male&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Child1())</span><br><span class="line"></span><br><span class="line">//缺点就是：不能继承原型链上的属性或方法</span><br></pre></td></tr></table></figure></li>
<li>实例继承</li>
<li>拷贝继承</li>
<li><strong>组合继承</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Cat(name) &#123;</span><br><span class="line">	Animal.call(this)</span><br><span class="line">	this.name = name || &#x27;tom&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line">//第二种写法：Cat.prototype = Animal.prototype</span><br><span class="line">//如果没有Cat.prototype = new Animal()这一行，Cat.prototype.constructo</span><br><span class="line">是指向Cat的，加了这一行，Cat.prototype.constructor 指向了Animal，这显然</span><br><span class="line">会导致继承链的紊乱，因此必须手动纠正。</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line">//Cat.prototype = Animal.prototype</span><br><span class="line">// Text code</span><br><span class="line">var cat = new Cat()</span><br><span class="line">console.log(cat.name)</span><br><span class="line">console.log(cat.sleep())</span><br><span class="line">console.log(cat instanceof Animal)	//true</span><br><span class="line">console.log(cat instanceof Cat)	//true</span><br></pre></td></tr></table></figure></li>
<li><strong>寄生组合继承</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Cat(name) &#123;</span><br><span class="line">	Animal.call(this);</span><br><span class="line">	this.name = name || &#x27;Tom&#x27;</span><br><span class="line">&#125;</span><br><span class="line">(function()&#123;</span><br><span class="line">	// 创建一个没有实例的类</span><br><span class="line">	var Super = function() &#123;</span><br><span class="line">	    Super.prototype = Animal.prototype;</span><br><span class="line">	&#125;</span><br><span class="line">	//将实例作为子类的原型</span><br><span class="line">	Cat.prototype = new Super();</span><br><span class="line">&#125;)();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line">// Text Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name)</span><br><span class="line">console.log(cat.sleep)</span><br><span class="line">console.log(cat instanceof Animal)		//true</span><br><span class="line">console.log(cat instanceof Cat)		//true</span><br></pre></td></tr></table></figure></li>
<li><strong>extends继承</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用extends实现继承，必须添加super关键字定义子类的constructor，</span><br><span class="line">这里的super()相当于Animal.prototype.constructor.call(this)</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是事件代理，它的原理是什么？</title>
    <url>/2019/08/13/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%83%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="什么是事件代理，它的原理是什么？"><a href="#什么是事件代理，它的原理是什么？" class="headerlink" title="什么是事件代理，它的原理是什么？"></a>什么是事件代理，它的原理是什么？</h2><ul>
<li><p>事件代理：通俗来说就是将元素的事件委托给它的父级或者更外层元素处理</p>
</li>
<li><p>原理：利用事件冒泡机制实现</p>
</li>
<li><p>优点：</p>
<ul>
<li>只需将同类元素的事件委托给父级或者更外层的元素，不需要给所有元素都绑定事件</li>
<li>减少内容空间占用，提升性能</li>
<li>动态新增的元素无需重新绑定事件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是FOUC？如何避免？</title>
    <url>/2019/07/17/%E4%BB%80%E4%B9%88%E6%98%AFFOUC%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="什么是FOUC？如何避免？"><a href="#什么是FOUC？如何避免？" class="headerlink" title="什么是FOUC？如何避免？"></a>什么是FOUC？如何避免？</h2><span id="more"></span>
<h4 id="一、为什么会有白屏和FOUC呢？"><a href="#一、为什么会有白屏和FOUC呢？" class="headerlink" title="一、为什么会有白屏和FOUC呢？"></a>一、为什么会有白屏和FOUC呢？</h4><blockquote>
<p>浏览器再渲染的时候没有请求到或请求时间过长造成的，那么浏览器怎么应对的呢？</p>
<ul>
<li>白屏：CSS全部载入解析完成后渲染展示页面，如果没有加载完，就会出现白屏。</li>
<li>FOUC(Flash of Unstyled Content)无样式内容闪烁：用户定义样式表加载之前浏览器<br>使用默认样式显示文档，用户样式表加载渲染之后，再重新显示文档，造成页面闪烁。</li>
</ul>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><blockquote>
<ul>
<li>使用link标签将样式表放在顶部<head>标签中，防止白屏问题出现。</li>
<li>将JS放在<body>标签底部，原因如下：<ul>
<li>脚本会阻塞后面内容的呈现</li>
<li>脚本会阻塞其后组件的下载</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3源码调试</title>
    <url>/2022/01/02/vue3%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="vue3-源码调试步骤"><a href="#vue3-源码调试步骤" class="headerlink" title="vue3 源码调试步骤"></a>vue3 源码调试步骤</h2><h3 id="clone-项目"><a href="#clone-项目" class="headerlink" title="clone 项目"></a>clone 项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/vuejs/vue-next.git</span><br></pre></td></tr></table></figure>

<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn --ignore-scripts</span><br></pre></td></tr></table></figure>

<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改<strong>package.json</strong>中的 scripts 下 dev 的配置，后面添加 <em>–sourcemap</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;node scripts/dev.js&quot;</span><br><span class="line">// ⬇</span><br><span class="line">&quot;dev&quot;: &quot;node scripts/dev.js --sourcemap&quot;</span><br></pre></td></tr></table></figure>

<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn run dev</span><br></pre></td></tr></table></figure>

<p>当终端出现<strong>waiting for changes…<strong>表示编译成功，可以</strong>ctrl+c</strong>结束进程查看源码了</p>
<p>打包完成之后，examples 下面的文件会引用 dist 文件下的文件（dist 文件是我们刚才编译后生成的文件）<br><img src="../images/md_img/vue3-dist.jpg" alt="vue3-dist"></p>
<h3 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h3><p>我们直接在<strong>package/vue/examples</strong>目录下添加<strong>demo/test.html</strong>文件，并引用**../../dist/vue.global.js**文件就可以使用 vue3 了，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;../../dist/vue.global.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;template id=&quot;foo&quot;&gt;</span><br><span class="line">      &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      const App = &#123;</span><br><span class="line">        template: &#x27;#foo&#x27;,</span><br><span class="line">        data: function () &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            name: &#x27;foolishmax&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Vue.createApp(App).mount(&#x27;#app&#x27;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来在浏览器中打开就可以进行 vue3 的代码调试了。</p>
<p><img src="../images/md_img/vue3-debugger.jpg" alt="vue3-debugger"></p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是DOCTYPE及其作用？</title>
    <url>/2019/07/06/%E4%BB%80%E4%B9%88%E6%98%AFDOCTYPE%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="什么是DOCTYPE及其作用？"><a href="#什么是DOCTYPE及其作用？" class="headerlink" title="什么是DOCTYPE及其作用？"></a>什么是DOCTYPE及其作用？</h2><ul>
<li><p>DOCTYPE是document type（文档类型）的缩写。</p>
<span id="more"></span></li>
<li><p>写法：<!DOCTYPE html>(声明了浏览器就会进入标准模式，按照W3C标准渲染页面)</p>
</li>
<li><p>DOCTYPE的作用：</p>
<ul>
<li>DOCTYPE是用来声明文档类型和DTD规范的，校验文件和代码的合法性。</li>
<li>告诉浏览器通过哪种规范（文档类型，DTD）来解析文档。</li>
</ul>
</li>
<li><p>DTD（document type definition）文档类型定义是一系列的语法规则，用来定义XML<br>  或HTML的文件类型。浏览器会根据它来判断文档类型，决定使用哪种协议来解析，以及切换<br>  浏览器的模式。</p>
</li>
<li><p>浏览器模式</p>
<p>  为了能够很好的显示满足标准的页面，又能最大程度兼容不合法的HTML，浏览器厂商会提供两种<br>  浏览器模式。</p>
<ul>
<li>标准模式：根据W3C标准来渲染页面。</li>
<li>混杂模式（兼容模式、怪异模式）：浏览器采用更加宽松、向后兼容的方式来渲染页面。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>渲染机制类</category>
      </categories>
      <tags>
        <tag>渲染机制类</tag>
      </tags>
  </entry>
  <entry>
    <title>元数据&lt;meta&gt;</title>
    <url>/2019/09/07/%E5%85%83%E6%95%B0%E6%8D%AE-meta/</url>
    <content><![CDATA[<h2 id="有哪些常见的meta标签？"><a href="#有哪些常见的meta标签？" class="headerlink" title="有哪些常见的meta标签？"></a>有哪些常见的meta标签？</h2><span id="more"></span>
<ul>
<li>指定文档编码<ul>
<li><code>&lt;meta charset = &quot;UTF-8&quot;&gt;</code></li>
</ul>
</li>
<li>name 属性<ul>
<li><code>1.&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;：在移动设备浏览器上，禁用缩放（zooming） 功能，用户只能滚动屏幕。</code></li>
<li><code>2.&lt;meta name=”description” content=””&gt;：告诉搜索引擎，当前页面的主要内容是xxx。</code></li>
<li><code>3.&lt;meta name=”keywords” content=””&gt;：告诉搜索引擎，当前页面的关键字。</code></li>
<li><code>4.&lt;meta name=”author” content=””&gt;：告诉搜索引擎，标注网站作者是谁。</code></li>
<li><code>5.&lt;meta name=”copyright” content=””&gt;：标注网站的版权信息。</code></li>
</ul>
</li>
<li>http-equiv 属性<ul>
<li><code>1.&lt;meta http-equiv=”Set-Cookie” content=”cookievalue=xxx;  expires=Friday,12-Jan-2001 18:18:18 GMT; path=/”&gt;:如果网页过期， 那么存盘的cookie将被删除。必须使用GMT的时间格式。</code></li>
<li><code>2.&lt;meta http-equiv=&#39;expires&#39; content=&#39;时间&#39; &gt;：用于设定网页的到期时间。  一旦网页过期，必须到服务器上重新传输。</code></li>
<li><code>3.&lt;meta http-equiv=”Refresh” content=”5;URL”&gt;：告诉浏览器在  【数字】秒后跳转到【一个网址】</code></li>
<li><code>4.&lt;meta http-equiv=”content-Type” content=”text/html; charset=utf-8″&gt;：  设定页面使用的字符集。</code></li>
<li><code>5.&lt;meta http-equiv=”Pragma” content=”no-cache”&gt;：禁止浏览器从本地   计算机的缓存中访问页面内容。访问者将无法脱机浏览。</code></li>
<li><code>6.&lt;meta http-equiv=”Window-target” content=”_top”&gt;：用来防止  别人在iframe(框架)里调用自己的页面，这也算是一个非常实用的属性。</code></li>
<li><code>7.&lt;meta http-equiv=&#39;X-UA-Compatible&#39; content=&#39;IE=edge,chrome=1&#39;&gt;   :强制浏览器按照特定的版本标准进行渲染。但不支持IE7及以下版本。如果是  ie浏览器就用最新的ie渲染，如果是双核浏览器就用chrome内核。</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的了解ES6吗？</title>
    <url>/2020/10/07/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3ES6%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="你真的了解ES6吗？"><a href="#你真的了解ES6吗？" class="headerlink" title="你真的了解ES6吗？"></a>你真的了解ES6吗？</h2><h3 id="下面的代码输出什么？"><a href="#下面的代码输出什么？" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">       resolve(2)</span><br><span class="line">       console.log(3)</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">    reject(&#x27;error&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err =&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 1 error 3</span><br><span class="line">//要点分析：</span><br><span class="line">// + promise 创建之后会立即执行</span><br><span class="line">// + 状态一旦改变就不会在变，也就是reject与resolve只会执行其中一个</span><br><span class="line">// + 异步队列的执行顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="下面的代码输出什么？-1"><a href="#下面的代码输出什么？-1" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(2);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(3);</span><br><span class="line">            resolve(4);</span><br><span class="line">        &#125;, 0)</span><br><span class="line">        resolve(5);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(6);</span><br><span class="line">    p.then((arg) =&gt; &#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then((arg) =&gt; &#123;</span><br><span class="line">    console.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(7);</span><br><span class="line"></span><br><span class="line">// 1 2 7 5 6 3</span><br><span class="line">//要点解析：</span><br><span class="line">// + promise创建立即执行，依次输出1 2</span><br><span class="line">// + 执行同步任务，输出 7</span><br><span class="line">// + 在执行上一步的时候已经将p.then 以及 first.then 加入到微任务执行队列，所以依次输出 5 6</span><br><span class="line">// + 最后执行宏任务 setTimeout，输出 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="下面的代码输出什么？-2"><a href="#下面的代码输出什么？-2" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">.then(2)</span><br><span class="line">.then(Promise.resolve(3))</span><br><span class="line">.then(console.log)</span><br><span class="line"></span><br><span class="line">// 答案： 1</span><br><span class="line">// + 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。</span><br><span class="line">// + then方法接收的参数是函数！！！，而如果传递的并非是一个函数就会导致前一个Promise的结果穿透到下面。</span><br></pre></td></tr></table></figure>

<h3 id="const-和-Object-freeze-有什么区别？"><a href="#const-和-Object-freeze-有什么区别？" class="headerlink" title="const 和 Object.freeze 有什么区别？"></a>const 和 Object.freeze 有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//const 声明一个常量，一旦声明，常量的值就不能改变，对于复杂的数据类型，比如对象是可以修改其属性的。const实际保证的不是变量的值，而是变量指向的内存地址所指向的数据不能改变</span><br><span class="line"></span><br><span class="line">//Object.freeze适用于对象值，使得对象不可变，即不能改变对象属性，但是如果对象的属性值仍是复杂数据类型，那么是可以修改成功的。</span><br></pre></td></tr></table></figure>

<h3 id="for…in和for…of"><a href="#for…in和for…of" class="headerlink" title="for…in和for…of"></a>for…in和for…of</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//对于纯对象的遍历，for...in更合适</span><br><span class="line">const obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: [],</span><br><span class="line">    c: function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">for( let key in obj) &#123;</span><br><span class="line">    console.log(key);// a b c</span><br><span class="line">    console.log(obj[key]); //1 [] function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对于数组遍历，如果不需要知道索引，for...of迭代更合适，还可以中断</span><br><span class="line">const arr = [3, 5, 7];</span><br><span class="line">for(let i of arr)&#123;</span><br><span class="line">    console.log(i);//3 5 7</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数组遍历如果需要知道索引forEach()更合适</span><br><span class="line">arr.forEach((value, index) =&gt; &#123;</span><br><span class="line">    console.log(value);//3 5 7</span><br><span class="line">    console.log(index);//0 1 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//for...in对于数组遍历，会遍历得到索引值，可以通过数组索引取得对应得值，但是，for...in不仅可以枚举数组自身，还会枚举数组的原型(可通过arr.hasOwnProperty(i)去除)以及数组对象本身属性值。</span><br><span class="line"></span><br><span class="line">//for...of可以迭代字符串</span><br><span class="line">let str = &#x27;foo&#x27;</span><br><span class="line">for(let value of str) &#123;</span><br><span class="line">    console.log(value); // &quot;f&quot; &quot;o&quot; &quot;o&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//for...of可以直接迭代arguments类数组对象</span><br><span class="line">(function()&#123;</span><br><span class="line">    for(let arg of arguments) &#123;</span><br><span class="line">        console.log(arg);//1 2 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(1, 2, 3);</span><br><span class="line"></span><br><span class="line">//for...of 还可以迭代NodeList这类DOM集合</span><br><span class="line">let elements = document.querySelectorAll(&#x27;body&#x27;);</span><br><span class="line">for(let element of elements) &#123;</span><br><span class="line">    console.log(element.tagName); //&quot;BODY&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//for...of迭代Map</span><br><span class="line">let mapData = new Map([[&#x27;a&#x27;,1],[&#x27;b&#x27;,2]]);</span><br><span class="line">for(let [key, value] of mapData) &#123;</span><br><span class="line">    console.log(value); //1 2 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//for...of迭代Set</span><br><span class="line">let setData = new Set([1, 2, 3, 2, 1]);</span><br><span class="line">for(let value of setData) &#123;</span><br><span class="line">    console.log(value);//1 2 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于substring、substr和slice、splice的用法和区别</title>
    <url>/2019/06/06/%E5%85%B3%E4%BA%8Esubstring%E3%80%81substr%E5%92%8Cslice%E3%80%81splice%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="substring和substr"><a href="#substring和substr" class="headerlink" title="substring和substr"></a>substring和substr</h1><ul>
<li><strong>substring</strong> 和 <strong>substr</strong>都是针对字符串的，都是返回一个副本，而不是再原来字符串上直接操作的。<span id="more"></span>
<h4 id="关于substring（）"><a href="#关于substring（）" class="headerlink" title="关于substring（）"></a>关于substring（）</h4></li>
</ul>
<ul>
<li>substring（start, stop）表示从start开始到stop之间的新字符串，含头不含尾。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;follish&#x27;</span><br><span class="line">console.log(str.substring(1, 5)) //&quot;olli&quot;</span><br><span class="line">console.log(str.substring(1, 5), str) //&quot;olli follish&quot;</span><br></pre></td></tr></table></figure>
<!--more--></li>
<li>其中start是必填项，stop不填，表示从start处截取到字符串结尾，上代码：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;</span><br><span class="line">console.log(str.substring(1)) //&quot;123456789&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果start比stop大，再方法执行前会先交换这两个参数，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substring(8,4))//&quot;4567&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果start 和 stop相等，会返回一个空的字符串，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substring(6,6))//&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果 start 和 stop 为负数，则在方法执行之前会先将负数变为0，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substring(-2,6))//&quot;012345&quot;</span><br><span class="line">console.log(str.substring(2,-6))//&quot;01&quot;</span><br><span class="line">console.log(str.substring(-2,-6))//&quot;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="关于substr（）"><a href="#关于substr（）" class="headerlink" title="关于substr（）"></a>关于substr（）</h4></li>
<li>substr(start, length)表示返回从start开始包含length长度的新字符串，包含start且不修改原字符串，如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substr(1,5))//&quot;12345&quot; length为5</span><br><span class="line">console.log(str.substr(2,6),str)//&quot;234567&quot; &quot;0123456789&quot;</span><br></pre></td></tr></table></figure></li>
<li>其中start是必填项，如果length不填，表示从start截取到字符串结尾，例如<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substr(1))//&quot;123456789&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果 start 为负数，那么start = str.length + start ,例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substr(-1))//&quot;9&quot;</span><br><span class="line">console.log(str.substr(-6,3))//&quot;456&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果length的值为0或负数，则返回空字符串，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substr(1,0))//&quot;&quot;</span><br><span class="line">console.log(str.substr(-1,-1))//&quot;&quot;</span><br><span class="line">console.log(str.substr(-1,0))//&quot;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="关于slice"><a href="#关于slice" class="headerlink" title="关于slice()"></a>关于slice()</h4></li>
<li>重点声明一下，substring、substr只能操作字符串，splice只能操作数组，而最🐮🍺的就是<strong>slice</strong>既可操作数组又可以操作字符串。</li>
<li>slice(start, stop)表示截取从下标start到stop之间的元素，并返回新数组不改变原数组（字符串），类似与substring，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">    arr = [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(str.slice(1,6))//&quot;12345&quot;</span><br><span class="line">console.log(arr.slice(1,6))//[1,2,3,4,5]</span><br></pre></td></tr></table></figure></li>
<li>start是必填项，如果stop不填，表示从start处截取到结尾，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">    arr = [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(str.slice(1))//&quot;123456789&quot;</span><br><span class="line">console.log(arr.slice(1))//[1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></li>
<li>如果 start 比 stop 大，或者两者相等，则截取的内容为空，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">    arr = [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(str.slice(3,3))//&quot;&quot;</span><br><span class="line">console.log(arr.slice(3,3))//[]</span><br><span class="line">console.log(str.slice(6,5))//&quot;&quot;</span><br><span class="line">console.log(arr.slice(6,5))//[]</span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>：如果start或者stop为负数，那么负数的选项从数组尾部开始算起，最后一个数字为-1，倒数第二个数字为-2，依次类推，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;0123456789&quot;;</span><br><span class="line">console.log(str.slice(6,-1))//&quot;678&quot;</span><br><span class="line">console.log(str.slice(-6,-1))//&quot;45678&quot;</span><br><span class="line">console.log(str.slice(-6,8))//&quot;4567&quot;</span><br></pre></td></tr></table></figure>
<h4 id="关于splice"><a href="#关于splice" class="headerlink" title="关于splice()"></a>关于splice()</h4></li>
<li>splice只能操作数组，splice(start, length, items)表示从下标start出截取length长度的元素后，在start处为原数组添加items，并返回截取的数组，splice会直接修改原数组：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(arr.splice(1,3,2,3,4))//[1,2,3]</span><br><span class="line">console.log(arr);//[0,2,3,4,4,5,6,7,8,9] 原数组被截取走了1,2,3，并加入了2,3,4</span><br></pre></td></tr></table></figure></li>
<li>其中start和length都是必填项，items为选填项，如果length为0或负数，则返回空数组，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(arr.splice(1,0,2,3,4))//[]</span><br><span class="line">console.log(arr);//[0,2,3,4,1,2,3,4,5,6,7,8,9] 直接在原数组下标0处并加入了2,3,4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(arr.splice(1,-9,2,3,4))//[]</span><br><span class="line">console.log(arr);//[0,2,3,4,1,2,3,4,5,6,7,8,9] 直接在原数组下标0处并加入了2,3,4</span><br></pre></td></tr></table></figure></li>
<li>如果start为负数，也是从右往左截取，最后一位为-1，倒数第二位为-2，以此类推，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(arr.splice(-1,1,2,3,4))//[9]</span><br><span class="line">console.log(arr);//[0,1,2,3,4,5,6,7,8,2,3,4] 从右往左截取1位，也就是9，并加入2,3,4</span><br></pre></td></tr></table></figure>
<img src="http://vamknight.com/01.jpg" alt="寡姐最美"><br>【参考链接】：<a href="https://www.cnblogs.com/echolun/p/7646025.html">https://www.cnblogs.com/echolun/p/7646025.html</a></li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>凡事预则立，不预则废</title>
    <url>/2021/03/28/%E5%87%A1%E4%BA%8B%E9%A2%84%E5%88%99%E7%AB%8B%EF%BC%8C%E4%B8%8D%E9%A2%84%E5%88%99%E5%BA%9F/</url>
    <content><![CDATA[<h3 id="凡事预则立，不预则废"><a href="#凡事预则立，不预则废" class="headerlink" title="凡事预则立，不预则废"></a>凡事预则立，不预则废</h3><p>凡事预则立，不预则废</p>
]]></content>
  </entry>
  <entry>
    <title>内存泄漏</title>
    <url>/2019/10/11/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h2 id="造成内存泄漏的原因？"><a href="#造成内存泄漏的原因？" class="headerlink" title="造成内存泄漏的原因？"></a>造成内存泄漏的原因？</h2><ul>
<li>意外的全局变量<ul>
<li>无法被回收</li>
</ul>
</li>
<li>定时器<ul>
<li>未被正确关闭，导致所引用的外部变量无法被释放</li>
</ul>
</li>
<li>事件监听<ul>
<li>没有正确销毁</li>
</ul>
</li>
<li>闭包<ul>
<li>会导致父级中的变量无法被释放</li>
</ul>
</li>
<li>DOM引用<ul>
<li>DOM被删除时，内存中的引用未被正确清空</li>
</ul>
</li>
</ul>
<h2 id="如何查看内存变化情况？"><a href="#如何查看内存变化情况？" class="headerlink" title="如何查看内存变化情况？"></a>如何查看内存变化情况？</h2><ul>
<li>使用Chrome的Performance面板进行内存标记，可视化查看内存变化情况，找出异常点。</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>从浏览器输入网站最终页面渲染完成的全过程解析</title>
    <url>/2019/06/29/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E7%AB%99%E6%9C%80%E7%BB%88%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="从浏览器输入网站最终页面渲染完成，发生了什么？"><a href="#从浏览器输入网站最终页面渲染完成，发生了什么？" class="headerlink" title="从浏览器输入网站最终页面渲染完成，发生了什么？"></a>从浏览器输入网站最终页面渲染完成，发生了什么？</h2><span id="more"></span>
<ul>
<li><p>在浏览器输入URL（Uniform Resource Locator,统一资源定位符），也就是网址。</p>
<ul>
<li>网址分为三部分：举例 <code>https://www.zhihu.com/people/oliver-8-10/activities</code><ul>
<li>协议部分  <code>https</code></li>
<li>网络地址部分  <code>www.zhihu.com</code>(每个域名背后都有一个对应的IP地址，分为三种<br>局域网IP、公网IP、本机IP)</li>
<li>资源路径部分  <code>/people/oliver-8-10/activities</code></li>
</ul>
</li>
</ul>
</li>
<li><p>DNS（Domain Name System域名系统）解析: 将域名地址解析为ip地址</p>
<ul>
<li>查找浏览器本地缓存（格式化检查以及确认是哪种协议，默认为http协议）</li>
<li>查找系统缓存（本地host文件查找对应ip）</li>
<li>查找本地路由器缓存解析</li>
<li>查找网络服务商DNS缓存（也是先检查缓存，若没有或过期则到根域名服务商上查找<br>对应ip）</li>
</ul>
<p>  <strong>至于为什么一定要拿到ip，因为我们的tcp/ip协议只能识别ip</strong></p>
</li>
<li><p>根据IP地址与服务器建立联系（TCP连接，TCP三次握手）</p>
<p>  (客户端拿到ip地址之后，想要进行通信就要先和服务器取得联系，看对方在不在，通常<br>  是由三次握手来实现)</p>
<ul>
<li>第一次握手：建立连接时，客户端发送一个syn包（syn=1）到服务器，并进入SYN_SEND<br>状态，等待服务器确认。</li>
<li>第二次握手：服务器收到syn包之后，回复给客户端一个SYN+ACK报文段，然后服务器端<br>进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务器的SYN+ACK报文段之后，向服务器发送ACK报文段，发送之后<br>客户端和服务器都进入ESTABLISHED（已建立）状态，完成TCP三次握手。（第三次握手，是为了防止<br>已经失效的连接请求报文段突然传到服务端而产生错误。没有第三次的client的确认，server端<br>会一直等待，浪费资源）</li>
</ul>
</li>
<li><p>发送请求</p>
<ul>
<li>请求报文： HTTP协议的通信内容<ul>
<li>请求头</li>
<li>请求行 :请求方法、请求URL、请求HTTP协议及版本</li>
<li>请求主体</li>
</ul>
</li>
</ul>
</li>
<li><p>接受响应</p>
<ul>
<li>响应报文<ul>
<li>响应头</li>
<li>响应行</li>
<li>响应主体</li>
</ul>
</li>
</ul>
</li>
<li><p>数据传输完毕之后，要断开TCP连接，TCP四次挥手</p>
<ul>
<li>第一次分手：客户端向服务端发送一个FIN报文段，告诉服务端表示没有数据要发送了，<br>客户端进入FIN_WAIT_1状态。</li>
<li>第二次分手：服务端接受到客户端的FIN报文段，返回一个ACK报文段表示已经知道客户端<br>没有数据要发送了，服务端进入FIN_WAIT_2状态。</li>
<li>第三次分手：服务端向客户端发送一个FIN报文段，请求关闭连接，同时服务端进入CLOSE_WAIT<br>状态</li>
<li>第四次分手：客户端接受到服务端的FIN报文段，向服务端发送一个ACK报文段，然后客户<br>端进入TIME_WAIT状态，服务端接受ACK报文段后，关闭连接；过了一段时间后，客户端没有<br>收到回复，证明服务端已正常关闭，然后客户端也关闭连接。</li>
</ul>
</li>
<li><p>页面渲染</p>
<ul>
<li>浏览器根据服务端返回的HTML通过深度遍历解析成一个DOM树。</li>
<li>将CSS解析成一个CSS规则树。</li>
<li>根据DOM树和CSS规则树构建出一个Rendering树。</li>
<li>最后就是通过Rendering树，浏览器就知道每个节点和各个节点css的关系，再算出每个节点<br>再屏幕的具体位置，将内容从上而下的渲染出来。</li>
</ul>
</li>
<li><p>浏览器渲染流程</p>
<ul>
<li>浏览器的主线程：Browser进程<ul>
<li>负责下载资源</li>
<li>创建销毁renderer进程</li>
<li>负责将renderer进程生成的位图渲染到页面上</li>
<li>与用户交互</li>
</ul>
</li>
<li>浏览器内核：renderer进程<ul>
<li>js引擎线程<ul>
<li>由一个主线程和多个web worker线程组成，web worker线程不能操作dom</li>
</ul>
</li>
<li>GUI线程<ul>
<li>用于解析html生成DOM树，解析CSS生成CSSOM，布局layout、绘制paint，<br>回流和重绘依赖该线程。</li>
</ul>
</li>
<li>事件线程<ul>
<li>当事件触发时，该线程将事件的回调函数放入callback queue(任务队列)<br>中，等待js引擎处理</li>
</ul>
</li>
<li>定时触发线程<ul>
<li>setTimeout和setInterval由该线程来计时，计时结束，将回调函数放入任务队列。</li>
</ul>
</li>
<li>http请求线程<ul>
<li>每有一个http请求就开一个该线程，每当检测到状态编程就会产生一个状态<br>变更事件，如果这个事件都由对应的回调函数，将这个函数放入到任务队列。</li>
</ul>
</li>
<li>任务队列轮询线程<ul>
<li>用于轮询监听任务队列</li>
</ul>
</li>
</ul>
</li>
<li>事件<ul>
<li>DOMContentLoaded<ul>
<li>当初始的HTML文档被完全加载和解析完成(script脚本执行完，所属的script<br>脚本之前的样式表加载解析完成)之后，DOMContentLoaded事件被触发。</li>
</ul>
</li>
<li>onLoad<ul>
<li>所有资源加载完成触发window的onLoad事件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全</title>
    <url>/2019/10/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><ul>
<li>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，<br>最终达到欺骗服务器执行恶意的SQL命令</li>
</ul>
<h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ul>
<li>xss：跨站脚本攻击(Cross Site Scripting),攻击者通过注入非法的html标签<br>或者JavaScript代码，从而当用户浏览该网页时，控制用户浏览器。</li>
<li>xss主要分为三类：<ul>
<li>DOM xss<ul>
<li>DOM即文本对象模型，DOM通常代表在html、xhtml和xml中的对象，使用DOM<br>可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器<br>解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端<br>的事情。</li>
</ul>
</li>
<li>反射型 xss<ul>
<li>反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请<br>求时，XSS代码出现在URL中 ，最后输入提交到服务器，服务器解析后在响应内容<br>中出现这段XSS代码，最后浏览器解析执行。</li>
</ul>
</li>
<li>存储型 xss<ul>
<li>存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS<br>和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。<br>允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS<br>代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中<br>最典型的例子就是留言板。</li>
</ul>
</li>
</ul>
</li>
<li>主要影响：<ul>
<li>利用虚假输入表单骗取用户个人信息</li>
<li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或者图片</li>
</ul>
</li>
<li>防御措施：<ul>
<li>设置httpOnly：在cookie中设置HttpOnly属性后，js脚本将无法读取到cookie的信息。</li>
<li>输入检查，对于用户输入进行格式检查。<ul>
<li>移除用户上传的DOM属性，如onerror事件等。</li>
<li>移除用户上传的style节点、script节点、iframe节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><ul>
<li><p>csrf：跨站请求伪造(Cross-Site Request Forgeries)，冒充用户发起请求，完成<br>一些违背用户意愿的事情。</p>
</li>
<li><p>防御措施</p>
<ul>
<li>Token验证：<ul>
<li>第一步：后端随机产生一个token，把这个token保存在session状态中，同时<br>后端把token交给前端页面；</li>
<li>第二步：前端页面提交请求时，把token加入到请求数据或者头信息中，一起<br>传给后端；</li>
<li>后端验证前端传来的token与session是否一致，一致则合法，否则非法请求。</li>
</ul>
</li>
<li>Referer check：请求来源验证，但是不能保证100%有效，因为服务器并不是什么<br>时候都能取到Referer，而且低版本浏览器存在伪造Referer的风险。</li>
<li>验证码：强制用户必须和应用进行交互，完成最终请求，但用户体验比较差。</li>
</ul>
</li>
</ul>
<h4 id="clickjacking"><a href="#clickjacking" class="headerlink" title="clickjacking"></a>clickjacking</h4><ul>
<li><p>clickjacking: 点击劫持，利用透明的按钮或连接做成陷阱，覆盖在web页面之上，然后<br>诱使用户在不知的情况下，点击那个链接访问内容的一种攻击手段。又称为界面伪装。</p>
</li>
<li><p>大概有两种方式：</p>
<ul>
<li>攻击者使用一个透明iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，<br>此时用将在不知情的情况下点击透明的iframe页面。</li>
<li>攻击者使用一张图片覆盖在网页，遮挡网页原有的位置含义。</li>
</ul>
</li>
<li><p>防御措施：</p>
<ul>
<li>X-FRAME-OPTIONS 响应头是用来给浏览器指示允许一个页面可否在<code>&lt;frame&gt;</code>,<br><code>&lt;iframe&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记。网站可以使用此功能，来确保自己网站<br>内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。</li>
</ul>
</li>
</ul>
<h5 id="控制台注入代码"><a href="#控制台注入代码" class="headerlink" title="控制台注入代码"></a>控制台注入代码</h5>]]></content>
      <categories>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>常见设计模式</title>
    <url>/2019/09/27/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h3><ul>
<li><p>单例模式</p>
</li>
<li><p>构造函数模式</p>
</li>
<li><p>建造者模式</p>
</li>
<li><p>工厂模式</p>
</li>
<li><p>代理模式</p>
</li>
<li><p>命令模式</p>
</li>
<li><p>观察者模式</p>
</li>
<li><p>适配器模式</p>
</li>
<li><p>职责链模式</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串去重</title>
    <url>/2019/08/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<h2 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h2><h4 id="for遍历"><a href="#for遍历" class="headerlink" title="for遍历"></a>for遍历</h4><span id="more"></span>
<pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var flag;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        flag = 1;
        var newLen = newStr.length;
        for(var j=0; j&lt;newLen; j++)&#123;
            if(str[i] == newStr[j])&#123;
                flag = 0;
                break;
            &#125;
        &#125;
        if(flag)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr; 
&#125;
</code></pre>
<h4 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法"></a>indexOf方法</h4><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(newStr.indexOf(str[i])==-1)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h4 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h4><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(newStr.search(str[i])==-1)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h4 id="对象属性法"><a href="#对象属性法" class="headerlink" title="对象属性法"></a>对象属性法</h4><pre><code>function removeRepeatStr(str)&#123;
    var obj = &#123;&#125;;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(!obj[str[i]])&#123;
            newStr = newStr + str[i];
            obj[str[i]] = 1;//注意，这里的1是给对象属性赋值，这个值可以任意取。意思是把每个遍历的字符作为对象属性并赋值保存，保证该属性的唯一性
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>掘金面经笔记</title>
    <url>/2019/09/13/%E6%8E%98%E9%87%91%E9%9D%A2%E7%BB%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="如何监听未处理的异常"><a href="#如何监听未处理的异常" class="headerlink" title="如何监听未处理的异常"></a>如何监听未处理的异常</h3><span id="more"></span>
<ul>
<li>try…catch<ul>
<li>无法捕捉到语法错误，只能捕捉运行时错误</li>
<li>可以拿到出错的信息(出错的文件，行号，列号)</li>
</ul>
</li>
<li>window.onerror<ul>
<li>由于try…catch只能捕获块里面的错误，全局的一些错误可以用window.onerror来捕获</li>
</ul>
</li>
</ul>
<h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3><ul>
<li>http是一种一种广泛使用的网络协议，是一个客户端和服务器请求和应答的标准。</li>
<li>http工作在TCP协议的80端口，https工作在TCP协议的443端口</li>
<li>http协议运行在TCP协议之上，所有的传输内容都是明文，https运行在SSL/TLS之上，<br>SSL/TLS运行在TCP之上，所有的传输内容都是经过加密的。</li>
<li>https是以安全为目标的http通道，是http的安全版。是http加上SSL层对传输的信息和url做了一些加密处理，更加安全</li>
</ul>
<h3 id="为什么https不会被截取信息"><a href="#为什么https不会被截取信息" class="headerlink" title="为什么https不会被截取信息"></a>为什么https不会被截取信息</h3><ul>
<li>完成TCP三次同步握手</li>
<li>客户端验证服务器数字证书，通过，进入步骤3 </li>
<li>DH算法协商对称加密算法的密钥、hash算法的密钥</li>
<li>SSL安全加密隧道协商完成</li>
<li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；<br>用协商的hash算法进行数据完整性保护，保证数据不被篡改</li>
</ul>
<h3 id="浏览器如何缓存"><a href="#浏览器如何缓存" class="headerlink" title="浏览器如何缓存"></a>浏览器如何缓存</h3><ul>
<li>html meta标签控制缓存<ul>
<li><code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cahce&quot;&gt;</code> //告诉浏览器当前页面不被缓存</li>
</ul>
</li>
<li>http头信息控制缓存<ul>
<li>Expires ——&gt; 过期时间</li>
<li>Cache-Control 响应头信息(no-cache、no-store、max-age、public)</li>
</ul>
</li>
</ul>
<h3 id="TCP协议如何保证传输的可靠性"><a href="#TCP协议如何保证传输的可靠性" class="headerlink" title="TCP协议如何保证传输的可靠性"></a>TCP协议如何保证传输的可靠性</h3><ul>
<li>校验和</li>
<li>确认应答 + 序列号</li>
<li>超时重传</li>
<li>流浪控制</li>
<li>拥塞控制</li>
<li>TCP的连接管理</li>
<li>滑动窗口</li>
</ul>
<h3 id="UDP-amp-TCP-的区别"><a href="#UDP-amp-TCP-的区别" class="headerlink" title="UDP &amp; TCP 的区别"></a>UDP &amp; TCP 的区别</h3><ul>
<li><p>相同点：</p>
<ul>
<li>UDP协议 和 TCP协议 都是运输层协议</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li>UDP特点：<ul>
<li>无连接 —— 知道对端的IP和端口号就直接进行传输，不需要建立连接</li>
<li>不可靠 —— 没有确认机制，没有重传机制，即使因为网络故障无法发送到<br>对方，UDP协议也不会给应用层返回任何错误信息</li>
<li>面向数据报</li>
<li>传输速 度块</li>
</ul>
</li>
<li>TCP特点：<ul>
<li>面向连接，在客户端和服务器进行交换数据前，必须先在双方之间建立一个<br>TCP连接</li>
<li>可靠传输，具有确认应答机制、超时重传机制、拥塞控制、流量控制、<br>滑动窗口机制、延迟应答等。</li>
<li>面向字节流</li>
</ul>
</li>
</ul>
</li>
<li><p>UDP的响应速度优于TCP，安全性和数据可靠性不如TCP</p>
</li>
<li><p>UDP一般用在网络负担非常重，但对响应速度要求高，数据类型都是短消息的情况下</p>
</li>
</ul>
<h3 id="样式导入方式及优先级？"><a href="#样式导入方式及优先级？" class="headerlink" title="样式导入方式及优先级？"></a>样式导入方式及优先级？</h3><ul>
<li>引入方式<ul>
<li>行内样式</li>
<li>内联式</li>
<li>外链式</li>
<li>导入式: @import url(reset.css)</li>
</ul>
</li>
<li>各种方式的优先级<ul>
<li>行内样式 &gt; 外链式 &gt; 内联式 &gt; @import导入式</li>
</ul>
</li>
</ul>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC(block formatting context)翻译为“块级格式化上下文”，它会生成独立的渲染区域<br>(不影响外面的元素，同时也不受外部元素的影响)，它有一下规则：</p>
<ul>
<li>内部的box会在垂直方向上一个接一个的放置。</li>
<li>内部box在垂直方向上的距离由margin决定，同属一个BFC内的相邻box会发生margin重叠。</li>
<li>BFC的区域不会与float box发生重叠。</li>
<li>计算BFC的高度时，浮动元素也参与计算(清除浮动)</li>
</ul>
<p>触发BFC的条件：</p>
<ul>
<li>float属性不为none</li>
<li>position为absolute或者fixed</li>
<li>display为inline-block、table-cell、table-caption、flex、inline-flex</li>
<li>overflow不为visible</li>
</ul>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>同步和异步的区别，怎么异步加载javascript</title>
    <url>/2019/08/13/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjavascript/</url>
    <content><![CDATA[<h2 id="同步和异步的区别，怎么异步加载javascript"><a href="#同步和异步的区别，怎么异步加载javascript" class="headerlink" title="同步和异步的区别，怎么异步加载javascript?"></a>同步和异步的区别，怎么异步加载javascript?</h2><ul>
<li><p>同步模式<br>  同步模式，又称阻塞模式，javascript在默认情况下是会阻塞加载的，当前面的 </p>
<p>  javascript 请求没有处理和执行完时，会阻止浏览器的后续处理</p>
</li>
<li><p>异步模式<br>  异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理</p>
</li>
<li><p>异步加载JavaScript</p>
<ul>
<li>动态添加script标签</li>
<li>defer</li>
<li>async</li>
</ul>
<p>  defer属性和async都是属于 script 标签上面的属性，两者都能实现 JavaScript 的</p>
<p>  异步加载。不同之处在于：async 在异步加载完成的时候就马上开始执行了，defer 会等到</p>
<p>   html 加载完毕之后再执行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序</title>
    <url>/2019/10/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><h4 id="文件主要目录及文件作用"><a href="#文件主要目录及文件作用" class="headerlink" title="文件主要目录及文件作用"></a>文件主要目录及文件作用</h4> <span id="more"></span>
<ul>
<li>component 组件文件夹<ul>
<li>navBar 底部组件<ul>
<li>navBar.js 底部组件的js代码</li>
<li>navBar.json 底部组件的配置文件</li>
<li>navBar.wxml 底部组件的html代码</li>
<li>navBar.wxss 底部组件的css代码</li>
</ul>
</li>
</ul>
</li>
<li>pages 页面文件夹<ul>
<li>index 首页<ul>
<li>index.js 首页的js代码</li>
<li>index.json 首页的配置文件</li>
<li>index.wxml 首页的html代码</li>
<li>index.wxss 首页的css代码</li>
</ul>
</li>
</ul>
</li>
<li>public 图片文件夹</li>
<li>utils 工具文件夹<ul>
<li>api.js 控制api的文件</li>
<li>md5.js 工具：MD5加密文件</li>
<li>timestamp.js 工具：事件戳文件</li>
</ul>
</li>
<li>app.json 设置全局的基础数据等</li>
<li>app.wxss 公共样式，可通过import导入更多</li>
<li>project.config.json 项目配置文件</li>
</ul>
<h4 id="微信小程序生命周期"><a href="#微信小程序生命周期" class="headerlink" title="微信小程序生命周期"></a>微信小程序生命周期</h4><ul>
<li>onLoad(): 页面加载时触发，一个页面只会调用一次，可以在onLoad中获取打开当前页面<br>所调用的query参数。</li>
<li>onShow(): 页面显示/切入前台时触发，每次打开页面都会调用一次。</li>
<li>onReady(): 页面初次渲染完成时触发，一个页面只会调用一次。</li>
<li>onHide(): 页面隐藏/切入后台时触发，当navigateTo或底部tab切换时调用。</li>
<li>onUnload(): 页面卸载时触发。</li>
</ul>
<h4 id="app-json是对当前小程序的全局配置，讲述三个配置各个项的含义"><a href="#app-json是对当前小程序的全局配置，讲述三个配置各个项的含义" class="headerlink" title="app.json是对当前小程序的全局配置，讲述三个配置各个项的含义?"></a>app.json是对当前小程序的全局配置，讲述三个配置各个项的含义?</h4><ul>
<li>pages字段：用于描述当前小程序所有页面路径，为了让微信客户端知道当前小程序页面<br>定义在那个目录。</li>
<li>window字段：小程序所有页面的顶部背景颜色，文字颜色定义等。</li>
<li>tab字段：小程序全局顶部tab或底部tab。</li>
</ul>
<h4 id="小程序的wxss和css有哪些不一样的地方？"><a href="#小程序的wxss和css有哪些不一样的地方？" class="headerlink" title="小程序的wxss和css有哪些不一样的地方？"></a>小程序的wxss和css有哪些不一样的地方？</h4><ul>
<li>新像素单位rpx</li>
<li>样式可直接使用import导入</li>
</ul>
<h4 id="小程序wxml和标准的html的异同？"><a href="#小程序wxml和标准的html的异同？" class="headerlink" title="小程序wxml和标准的html的异同？"></a>小程序wxml和标准的html的异同？</h4><p>都是用来描述页面的结构，都是由标签、属性等构成。</p>
<ul>
<li>标签名字不一样，且小程序标签更少，单一标签更多。</li>
<li>多了一些wx:if这样的属性和双大括号这样的表达式。</li>
<li>wxml只能在微信小程序开发者工具中预览，html可以在浏览器内预览。</li>
<li>组件封装不同，wxml对组件进行了重新封装。</li>
<li>小程序运行在JS Core内，没有DOM树和window对象，小程序无法使用window对象和document<br>对象。</li>
</ul>
<h4 id="小程序wxss和css的异同？"><a href="#小程序wxss和css的异同？" class="headerlink" title="小程序wxss和css的异同？"></a>小程序wxss和css的异同？</h4><p>都是用来描述页面的样子</p>
<ul>
<li>wxss具有css大部分的特性，也做了一些扩充和修改。</li>
<li>wxss新增了尺寸单位，wxss在底层支持新的尺寸单位rpx。</li>
<li>wxss仅支持部分css选择器。</li>
<li>wxss提供全局样式和局部样式。</li>
</ul>
<h4 id="小程序页面间有哪些传递数据的方法？"><a href="#小程序页面间有哪些传递数据的方法？" class="headerlink" title="小程序页面间有哪些传递数据的方法？"></a>小程序页面间有哪些传递数据的方法？</h4><ul>
<li>使用全局变量实现数据传递</li>
<li>页面跳转或重定向时，使用url带参数传递数据</li>
<li>使用组件模板template传递参数</li>
<li>使用数据库传递数据</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>手写JS代码</title>
    <url>/2019/07/17/%E6%89%8B%E5%86%99JS%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="手写防抖（Debouncing）和节流（Throttling）"><a href="#手写防抖（Debouncing）和节流（Throttling）" class="headerlink" title="手写防抖（Debouncing）和节流（Throttling）"></a>手写防抖（Debouncing）和节流（Throttling）</h2><h3 id="防抖（Debouncing）实现"><a href="#防抖（Debouncing）实现" class="headerlink" title="防抖（Debouncing）实现"></a>防抖（Debouncing）实现</h3><ul>
<li>典型例子：限制<code>鼠标连击</code>触发、<code>监听用户输入</code>。<blockquote>
<p><strong>解释</strong>：当一次事件发生后，事件处理器要等一定阀值的时间，如果这段时间过去后，再也没有事件发生，就处理最后一次发生的事件。如果还差<code>0.01</code>秒到达指定事件，这是又有一次事件触发，那么之前的等待作废，需要重新再次等待指定时间。</p>
</blockquote>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//防抖动函数</span><br><span class="line">function debounce(fn, wait = 50, immediate) &#123;</span><br><span class="line"></span><br><span class="line">	let timer;</span><br><span class="line">	</span><br><span class="line">	return function() &#123;</span><br><span class="line">	</span><br><span class="line">		if (immediate) &#123;</span><br><span class="line">		</span><br><span class="line">		fn.apply(this, arguments)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (timer) clearTimeout(timer)</span><br><span class="line">		</span><br><span class="line">		timer = setTimeout() =&gt; &#123;</span><br><span class="line">		</span><br><span class="line">			fn.apply(this, arguments)</span><br><span class="line">			</span><br><span class="line">		&#125;,wait)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="节流（Throttling）实现"><a href="#节流（Throttling）实现" class="headerlink" title="节流（Throttling）实现"></a>节流（Throttling）实现</h4><blockquote>
<p><strong>解释</strong>：可以理解为事件再一个管道中传输，加上这个节流阀之后，事件的流速就会减慢，节流可以将一个函数的调用频率限制再一定阀值内，例如 1s ，那么 1s 内这个函数一定不会被调用两次。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//简单的节流函数</span><br><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">	let prev = new Date();</span><br><span class="line">	return function() &#123; 	</span><br><span class="line">	    const args = arguments;   </span><br><span class="line">		const now = new Date();</span><br><span class="line">		if (now - prev &gt; wait) &#123;</span><br><span class="line">			fn.apply(this, args);</span><br><span class="line">			prev = new Date();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="手写一个JS深拷贝"><a href="#手写一个JS深拷贝" class="headerlink" title="手写一个JS深拷贝"></a>手写一个JS深拷贝</h4><ul>
<li>著名乞丐版<blockquote>
<p>var newObj = JSON.parse ( JSON.stringify ( someObj ) );</p>
</blockquote>
</li>
<li>面试够用版<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">	if (typeof obj == &quot;object&quot;) &#123;</span><br><span class="line">		//复杂数据类型</span><br><span class="line">		var result = obj.constructor == Array ? [] : &#123;&#125;;</span><br><span class="line">		for (let i in obj) &#123;</span><br><span class="line">			result[i] = typeof obj[i] == &quot;object&quot; ? deepCopy(obj[i] : obj[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	//简单数据类型</span><br><span class="line">		var result = obj</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="手写一个Promise"><a href="#手写一个Promise" class="headerlink" title="手写一个Promise"></a>手写一个Promise</h4></li>
<li>三种状态 <code>pending | fulfilled(resolved) | rejected</code></li>
<li>当处于 <code>pending</code> 状态的时候，可以转移到 <code>fulfilled(resolved)</code>或者<code>rejected</code>状态</li>
<li>当处于<code>fulfilled(resolved)</code>状态或者<code>rejected</code>状态时候，就不可变。</li>
<li>必须有一个<code>then</code>的异步执行方法，<code>then</code>接受两个参数<code>onFulfilled、onRejected</code></li>
</ul>
<p><strong>基础版</strong> 代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myPromise(constructor)&#123;</span><br><span class="line">    let self=this;</span><br><span class="line">    self.status=&quot;pending&quot; //定义状态改变前的初始状态</span><br><span class="line">    self.value=undefined;//定义状态为resolved的时候的状态</span><br><span class="line">    self.reason=undefined;//定义状态为rejected的时候的状态</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class="line">          self.value=value;</span><br><span class="line">          self.status=&quot;resolved&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class="line">          self.reason=reason;</span><br><span class="line">          self.status=&quot;rejected&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //捕获构造异常</span><br><span class="line">    try&#123;</span><br><span class="line">       constructor(resolve,reject);</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">       reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同时再myPromise的原型上定义链式调用的then方法：</span><br><span class="line"></span><br><span class="line">myPromise.prototype.then=function(onFullfilled,onRejected)&#123;</span><br><span class="line">   let self=this;</span><br><span class="line">   switch(self.status)&#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现-instanceof"><a href="#实现-instanceof" class="headerlink" title="实现 instanceof"></a>实现 instanceof</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function instanceof (left, right) &#123;</span><br><span class="line">	let proto = left.__proto__;</span><br><span class="line">	let prototype = right.prototype</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		if (proto === null) return false</span><br><span class="line">		if (proto === prototype) return true</span><br><span class="line">		proto = proto.__proto__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="js函数柯里化"><a href="#js函数柯里化" class="headerlink" title="js函数柯里化"></a>js函数柯里化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//求和</span><br><span class="line">let add = function (a, b, c) &#123;</span><br><span class="line">	return a + b +c</span><br><span class="line">&#125;</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">	//闭包</span><br><span class="line">	//缓存除函数fn之外的所有参数</span><br><span class="line">	let args = Array.prototype.slice.call(arguments, 1)</span><br><span class="line">	return function() &#123;</span><br><span class="line">		//连接已经缓存的老的参数和新传入的参数（就是把每次传入的参数都先保存下来，但是并不执行）</span><br><span class="line">		let newArgs = args.concat(Array.from(arguments))</span><br><span class="line">		if (newArgs.length &lt; fn.length) &#123;</span><br><span class="line">			return curry.call(this, fn, ...newArgs)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">		//调用</span><br><span class="line">		return fn.apply(this, newArgs)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let f = curry(add)</span><br><span class="line">console.log(&#x27;柯里化&#x27;,f(1)(2)(3))</span><br><span class="line">console.log(&#x27;柯里化&#x27;,f(1, 2)(3))</span><br><span class="line">console.log(&#x27;柯里化&#x27;,f(1, 2, 3))</span><br></pre></td></tr></table></figure>
<h4 id="原生js封装ajax"><a href="#原生js封装ajax" class="headerlink" title="原生js封装ajax"></a>原生js封装ajax</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ajax(options) &#123;</span><br><span class="line">	var xhr = null;</span><br><span class="line">	var params = formsParams(options, data);</span><br><span class="line">	//创建对象</span><br><span class="line">	if (window.XMLHttpRequest()) &#123;</span><br><span class="line">		xhr = new XMLHttpRequest()</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	//连接</span><br><span class="line">	if (options.type === &quot;GET&quot;) &#123;</span><br><span class="line">		xhr.open(options.type, options.url + &quot;?&quot; +params, options.async);</span><br><span class="line">		xhr.send(null)</span><br><span class="line">	&#125; else if (options.type === &quot;POST&quot;) &#123;</span><br><span class="line">		xhr.open(options.type, options.url, options.async);</span><br><span class="line">		xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">		xhr.send(params);</span><br><span class="line">	&#125;</span><br><span class="line">	//判断状态</span><br><span class="line">	xhr.onreadystateChange = function() &#123;</span><br><span class="line">		if (xhr.readyState === 4 &amp;&amp; xhr.status ===200) &#123;</span><br><span class="line">			options.success(xhr.responseText);</span><br><span class="line">		&#125;</span><br><span class="line">	function formParams(data) &#123;</span><br><span class="line">		var arr = [];</span><br><span class="line">		for (var prop in data) &#123;</span><br><span class="line">			arr.push(prop + &quot;=&quot; + data[prop]);</span><br><span class="line">		&#125;</span><br><span class="line">		return arr.join(&quot;&amp;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//调用</span><br><span class="line">ajax(&#123;</span><br><span class="line">	url: &quot;time.php&quot;,</span><br><span class="line">	type: &quot;POST&quot;,</span><br><span class="line">	async: true,</span><br><span class="line">	data: &#123;</span><br><span class="line">		name: &quot;Tom&quot;,</span><br><span class="line">		age: 18</span><br><span class="line">	&#125;,</span><br><span class="line">	success: function(data) &#123;</span><br><span class="line">		console.log(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>简化版：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 1. 创建连接 **/</span><br><span class="line">var xhr = null;</span><br><span class="line">xhr = new XMLHttpRequest()</span><br><span class="line">/** 2. 连接服务器 **/</span><br><span class="line">xhr.open(&#x27;get&#x27;, url, true)</span><br><span class="line">/** 3. 发送请求 **/</span><br><span class="line">xhr.send(null);</span><br><span class="line">/** 4. 接受请求 **/</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">	if(xhr.readyState == 4)&#123;</span><br><span class="line">		if(xhr.status == 200)&#123;</span><br><span class="line">			success(xhr.responseText);</span><br><span class="line">		&#125; else &#123; </span><br><span class="line">			/** false **/</span><br><span class="line">			fail &amp;&amp; fail(xhr.status);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化版封装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function get(url, callback) &#123;</span><br><span class="line">    var oReq = new XMLHttpRequest()</span><br><span class="line">    oReq.onload = function() &#123;</span><br><span class="line">        callback(oReq.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">    oReq.open(&quot;get&quot;, url, true)</span><br><span class="line">    oReq.send()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get(&#x27;data.json&#x27;, function(data) &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="手写jsonp"><a href="#手写jsonp" class="headerlink" title="手写jsonp"></a>手写jsonp</h4><p>跨域通信的几种方式：jsonp、hash、postMessage、webSocket、CORS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function (window,document) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    var jsonp = function (url,data,callback) &#123;</span><br><span class="line"></span><br><span class="line">        // 1.将传入的data数据转化为url字符串形式</span><br><span class="line">        // &#123;id:1,name:&#x27;zhangsan&#x27;&#125; =&gt; id=1&amp;name=zhangsan</span><br><span class="line">        var dataString = url.indexof(&#x27;?&#x27;) == -1? &#x27;?&#x27;: &#x27;&amp;&#x27;;</span><br><span class="line">        for(var key in data)&#123;</span><br><span class="line">            dataString += key + &#x27;=&#x27; + data[key] + &#x27;&amp;&#x27;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 2 处理url中的回调函数</span><br><span class="line">        // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span><br><span class="line">        var cbFuncName = &#x27;my_json_cb_&#x27; + Math.random().toString().replace(&#x27;.&#x27;,&#x27;&#x27;);</span><br><span class="line">        dataString += &#x27;callback=&#x27; + cbFuncName;</span><br><span class="line"></span><br><span class="line">        // 3.创建一个script标签并插入到页面中</span><br><span class="line">        var scriptEle = document.createElement(&#x27;script&#x27;);</span><br><span class="line">        scriptEle.src = url + dataString;</span><br><span class="line"></span><br><span class="line">        // 4.挂载回调函数</span><br><span class="line">        window[cbFuncName] = function (data) &#123;</span><br><span class="line">            callback(data);</span><br><span class="line">            // 处理完回调函数的数据之后，删除jsonp的script标签</span><br><span class="line">            document.body.removeChild(scriptEle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5.append到页面中</span><br><span class="line">        document.body.appendChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用</span><br><span class="line">    window.$jsonp = jsonp;</span><br><span class="line"></span><br><span class="line">&#125;)(window,document)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>简化版JSONP</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var script = document.createElement(&#x27;script&#x27;)</span><br><span class="line"> script.type = &#x27;text/javascript&#x27;</span><br><span class="line"> </span><br><span class="line"> //传参一个回调函数名给后端，方便后端返回时执行这个前端定义的回调函数</span><br><span class="line"> script.src = &#x27;http://www.xxx.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span><br><span class="line"> document.body.appendChild(script)</span><br><span class="line"> </span><br><span class="line"> //回调执行函数</span><br><span class="line"> function handleCallbak(res) &#123;</span><br><span class="line">     alert(JSOn.stringify(res))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现一个new操作符"><a href="#实现一个new操作符" class="headerlink" title="实现一个new操作符"></a>实现一个new操作符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function New(func) &#123;</span><br><span class="line">    var res = &#123;&#125;;</span><br><span class="line">    if (func.prototype !== null) &#123;</span><br><span class="line">        res.__proto__ = func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));</span><br><span class="line">    if ((typeof ret === &quot;object&quot; || typeof ret === &quot;function&quot;) &amp;&amp; ret !== null) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">var obj = New(A, 1, 2);</span><br><span class="line">// equals to</span><br><span class="line">var obj1 = new A(1, 2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 简洁版的new实现过程</span><br><span class="line"></span><br><span class="line">function newFunc(constructor)&#123;</span><br><span class="line">      //第一步：创建一个空对象obj </span><br><span class="line">        var obj = &#123;&#125;;</span><br><span class="line">       //第二步：将构造函数 constructor的原型对象赋给obj的原型</span><br><span class="line">        obj.__proto__ = constructor.prototype;</span><br><span class="line">      //第三步：将构造函数 constructor中的this指向obj,并立即执行构造函数内部的操作</span><br><span class="line">        constructor.apply(obj);</span><br><span class="line">      //第四步：返回这个对象</span><br><span class="line">        return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现call"><a href="#实现call" class="headerlink" title="实现call"></a>实现call</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.call2 = function (context) &#123;</span><br><span class="line"></span><br><span class="line">    //改变this指向，将目标函数作为这个对象的属性</span><br><span class="line">    var context = context || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line">    </span><br><span class="line">    //利用arguments类数组对象实现参数不定长</span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将不定长的参数传递给函数</span><br><span class="line">    var result = eval(&#x27;context.fn(&#x27; + args +&#x27;)&#x27;);</span><br><span class="line">    // obj.fn(...args)</span><br><span class="line"></span><br><span class="line">    //不能增加对象的属性，所以结尾要删除delete</span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现apply"><a href="#实现apply" class="headerlink" title="实现apply"></a>实现apply</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.apply2 = function (context, arr) &#123;</span><br><span class="line">    var context = Object(context) || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        var args = [];</span><br><span class="line">        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&#x27;arr[&#x27; + i + &#x27;]&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind2 = function (context) &#123;</span><br><span class="line">    if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    var self = this;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    var fNOP = function () &#123;&#125;;</span><br><span class="line">    var fbound = function () &#123;</span><br><span class="line">        self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line">    &#125;</span><br><span class="line">    fNOP.prototype = this.prototype;</span><br><span class="line">    fbound.prototype = new fNOP();</span><br><span class="line">    return fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之排序</title>
    <url>/2019/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h4 id="五大算法"><a href="#五大算法" class="headerlink" title="五大算法"></a>五大算法</h4><ul>
<li><p>贪心算法</p>
</li>
<li><p>分治算法</p>
</li>
<li><p>动态规划</p>
</li>
<li><p>回溯法</p>
</li>
<li><p>分支限界法</p>
</li>
</ul>
<span id="more"></span>

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bubleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (let outer = len ; outer &gt;= 2; outer--) &#123;</span><br><span class="line">        for(let inner = 0; inner &lt;=outer - 1; inner++) &#123;</span><br><span class="line">            if(arr[inner] &gt; arr[inner + 1]) &#123;</span><br><span class="line">                [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function selectSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for(let i = 0 ;i &lt; len - 1; i++) &#123;</span><br><span class="line">        for(let j = i ; j&lt;len; j++) &#123;</span><br><span class="line">            if(arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                [arr[i],arr[j]] = [arr[j],arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function insertSort(arr) &#123;</span><br><span class="line">    for(let i = 1; i &lt; arr.length; i++) &#123;  //外循环从1开始，默认arr[0]是有序段</span><br><span class="line">        for(let j = i; j &gt; 0; j--) &#123;  //j = i,将arr[j]依次插入有序段中</span><br><span class="line">            if(arr[j] &lt; arr[j-1]) &#123;</span><br><span class="line">                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    if(arr.length &lt;= 1) &#123;</span><br><span class="line">        return arr;  //递归出口</span><br><span class="line">    &#125;</span><br><span class="line">    var left = [],</span><br><span class="line">        right = [],</span><br><span class="line">        current = arr.splice(0,1); </span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if(arr[i] &lt; current) &#123;</span><br><span class="line">            left.push(arr[i])  //放在左边</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(arr[i]) //放在右边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return quickSort(left).concat(current,quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建列表类</span><br><span class="line">function ArrayList() &#123;</span><br><span class="line">    this.array = []</span><br><span class="line">    //方法</span><br><span class="line">    //插入方法</span><br><span class="line">    ArrayList.prototype.insert = function(item)&#123;</span><br><span class="line">        this.array.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    //toString 方便测试</span><br><span class="line">    ArrayList.prototype.toString = function()&#123;</span><br><span class="line">        return this.array.join(&#x27;-&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--var arr = new ArrayList()--&gt;</span><br><span class="line">&lt;!--arr.insert(1)--&gt;</span><br><span class="line">&lt;!--arr.insert(2)--&gt;</span><br><span class="line">&lt;!--arr.insert(3)--&gt;</span><br><span class="line"></span><br><span class="line">//实现排序算法</span><br><span class="line">//冒泡排序</span><br><span class="line">ArrayList.prototype.bubbleSort = function () &#123;</span><br><span class="line">    // 1.获取数组的长度</span><br><span class="line">    var length = this.array.length</span><br><span class="line"></span><br><span class="line">    // 2.反向循环, 因此次数越来越少</span><br><span class="line">    for (var i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        // 3.根据i的次数, 比较循环到i位置</span><br><span class="line">        for (var j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            // 4.如果j位置比j+1位置的数据大, 那么就交换</span><br><span class="line">            if (this.array[j] &gt; this.array[j+1]) &#123;</span><br><span class="line">                // 交换</span><br><span class="line">                this.swap(j, j+1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList.prototype.swap = function (m, n) &#123;</span><br><span class="line">    var temp = this.array[m]</span><br><span class="line">    this.array[m] = this.array[n]</span><br><span class="line">    this.array[n] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//选择排序</span><br><span class="line">ArrayList.prototype.selectionSort = function () &#123;</span><br><span class="line">    // 1.获取数组的长度</span><br><span class="line">    var length = this.array.length</span><br><span class="line"></span><br><span class="line">    // 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span><br><span class="line">    for (var i = 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">        // 3.内层循环: 从i+1位置开始, 和后面的内容比较</span><br><span class="line">        var min = i</span><br><span class="line">        for (var j = min + 1; j &lt; length; j++) &#123;</span><br><span class="line">            // 4.如果i位置的数据大于j位置的数据, 那么记录最小的位置</span><br><span class="line">            if (this.array[min] &gt; this.array[j]) &#123;</span><br><span class="line">                min = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 5.交换min和i位置的数据</span><br><span class="line">        this.swap(min, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//插入排序</span><br><span class="line">ArrayList.prototype.insertionSort = function () &#123;</span><br><span class="line">    // 1.获取数组的长度</span><br><span class="line">    var length = this.array.length</span><br><span class="line"></span><br><span class="line">    // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span><br><span class="line">    for (var i = 1; i &lt; length; i++) &#123;</span><br><span class="line">        // 3.记录选出的元素, 放在变量temp中</span><br><span class="line">        var j = i</span><br><span class="line">        var temp = this.array[i]</span><br><span class="line"></span><br><span class="line">        // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span><br><span class="line">        while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) &#123;</span><br><span class="line">            this.array[j] = this.array[j-1]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5.将选出的j位置, 放入temp元素</span><br><span class="line">        this.array[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//希尔排序</span><br><span class="line">ArrayList.prototype.shellSort = function () &#123;</span><br><span class="line">    // 1.获取数组的长度</span><br><span class="line">    var length = this.array.length</span><br><span class="line"></span><br><span class="line">    // 2.根据长度计算增量</span><br><span class="line">    var gap = Math.floor(length / 2)</span><br><span class="line"></span><br><span class="line">    // 3.增量不断变量小, 大于0就继续排序</span><br><span class="line">    while (gap &gt; 0) &#123;</span><br><span class="line">        // 4.实现插入排序</span><br><span class="line">        for (var i = gap; i &lt; length; i++) &#123;</span><br><span class="line">            // 4.1.保存临时变量</span><br><span class="line">            var j = i</span><br><span class="line">            var temp = this.array[i]</span><br><span class="line"></span><br><span class="line">            // 4.2.插入排序的内层循环</span><br><span class="line">            while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) &#123;</span><br><span class="line">                this.array[j] = this.array[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 4.3.将选出的j位置设置为temp</span><br><span class="line">            this.array[j] = temp</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        // 5.重新计算新的间隔</span><br><span class="line">        gap = Math.floor(gap / 2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//快速排序</span><br><span class="line"> // 选择枢纽</span><br><span class="line"> ArrayList.prototype.median = function (left, right) &#123;</span><br><span class="line">     // 1.求出中间的位置</span><br><span class="line">     var center = Math.floor((left + right) / 2)</span><br><span class="line"> </span><br><span class="line">     // 2.判断并且进行交换</span><br><span class="line">     if (this.array[left] &gt; this.array[center]) &#123;</span><br><span class="line">         this.swap(left, center)</span><br><span class="line">     &#125;</span><br><span class="line">     if (this.array[center] &gt; this.array[right]) &#123;</span><br><span class="line">         this.swap(center, right)</span><br><span class="line">     &#125;</span><br><span class="line">     if (this.array[left] &gt; this.array[right]) &#123;</span><br><span class="line">         this.swap(left, right)</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     // 3.巧妙的操作: 将center移动到right - 1的位置.</span><br><span class="line">     this.swap(center, right - 1)</span><br><span class="line"> </span><br><span class="line">     // 4.返回pivot</span><br><span class="line">     return this.array[right - 1]</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 快速排序实现</span><br><span class="line"> ArrayList.prototype.quickSort = function () &#123;</span><br><span class="line">     this.quickSortRec(0, this.array.length - 1)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ArrayList.prototype.quickSortRec = function (left, right) &#123;</span><br><span class="line">     // 0.递归结束条件</span><br><span class="line">     if (left &gt;= right) return</span><br><span class="line"> </span><br><span class="line">     // 1.获取枢纽</span><br><span class="line">     var pivot = this.median(left, right)</span><br><span class="line"> </span><br><span class="line">     // 2.开始进行交换</span><br><span class="line">     // 2.1.记录左边开始位置和右边开始位置</span><br><span class="line">     var i = left</span><br><span class="line">     var j = right - 1</span><br><span class="line">     // 2.2.循环查找位置</span><br><span class="line">     while (true) &#123;</span><br><span class="line">         while (this.array[++i] &lt; pivot) &#123; &#125;</span><br><span class="line">         while (this.array[--j] &gt; pivot) &#123; &#125;</span><br><span class="line">         if (i &lt; j) &#123;</span><br><span class="line">               // 2.3.交换两个数值</span><br><span class="line">             this.swap(i, j)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             // 2.4.当i&lt;j的时候(一定不会=, 看下面解释中的序号3), 停止循环因为两边已经找到了相同的位置</span><br><span class="line">             break</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     // 3.将枢纽放在正确的位置</span><br><span class="line">     this.swap(i, right - 1)</span><br><span class="line"> </span><br><span class="line">     // 4.递归调用左边</span><br><span class="line">     this.quickSortRec(left, i - 1)</span><br><span class="line">     this.quickSortRec(i + 1, right)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 封装ArrayList</span><br><span class="line"> function ArrayList() &#123;</span><br><span class="line">     this.array = []</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.insert = function (item) &#123;</span><br><span class="line">         this.array.push(item)</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.toString = function () &#123;</span><br><span class="line">         return this.array.join()</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.bubbleSort = function () &#123;</span><br><span class="line">         // 1.获取数组的长度</span><br><span class="line">         var length = this.array.length</span><br><span class="line"> </span><br><span class="line">         // 2.反向循环, 因此次数越来越少</span><br><span class="line">         for (var i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">             // 3.根据i的次数, 比较循环到i位置</span><br><span class="line">             for (var j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                 // 4.如果j位置比j+1位置的数据大, 那么就交换</span><br><span class="line">                 if (this.array[j] &gt; this.array[j+1]) &#123;</span><br><span class="line">                     // 交换</span><br><span class="line">                     this.swap(j, j+1)</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.selectionSort = function () &#123;</span><br><span class="line">         // 1.获取数组的长度</span><br><span class="line">         var length = this.array.length</span><br><span class="line"> </span><br><span class="line">         // 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span><br><span class="line">         for (var i = 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">             // 3.内层循环: 从i+1位置开始, 和后面的内容比较</span><br><span class="line">             var min = i</span><br><span class="line">             for (var j = min + 1; j &lt; length; j++) &#123;</span><br><span class="line">                 // 4.如果i位置的数据大于j位置的数据, 记录最小的位置</span><br><span class="line">                 if (this.array[min] &gt; this.array[j]) &#123;</span><br><span class="line">                     min = j</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             this.swap(min, i)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.insertionSort = function () &#123;</span><br><span class="line">         // 1.获取数组的长度</span><br><span class="line">         var length = this.array.length</span><br><span class="line"> </span><br><span class="line">         // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span><br><span class="line">         for (var i = 1; i &lt; length; i++) &#123;</span><br><span class="line">             // 3.记录选出的元素, 放在变量temp中</span><br><span class="line">             var j = i</span><br><span class="line">             var temp = this.array[i]</span><br><span class="line"> </span><br><span class="line">             // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span><br><span class="line">             while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) &#123;</span><br><span class="line">                 this.array[j] = this.array[j-1]</span><br><span class="line">                 j--</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             // 5.将选出的j位置, 放入temp元素</span><br><span class="line">             this.array[j] = temp</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.shellSort = function () &#123;</span><br><span class="line">         // 1.获取数组的长度</span><br><span class="line">         var length = this.array.length</span><br><span class="line"> </span><br><span class="line">         // 2.根据长度计算增量</span><br><span class="line">         var gap = Math.floor(length / 2)</span><br><span class="line"> </span><br><span class="line">         // 3.增量不断变量小, 大于0就继续排序</span><br><span class="line">         while (gap &gt; 0) &#123;</span><br><span class="line">             // 4.实现插入排序</span><br><span class="line">             for (var i = gap; i &lt; length; i++) &#123;</span><br><span class="line">                 // 4.1.保存临时变量</span><br><span class="line">                 var j = i</span><br><span class="line">                 var temp = this.array[i]</span><br><span class="line"> </span><br><span class="line">                 // 4.2.插入排序的内存循环</span><br><span class="line">                 while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) &#123;</span><br><span class="line">                     this.array[j] = this.array[j - gap]</span><br><span class="line">                     j -= gap</span><br><span class="line">                 &#125;</span><br><span class="line"> </span><br><span class="line">                 // 4.3.将选出的j位置设置为temp</span><br><span class="line">                 this.array[j] = temp</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             // 5.重新计算新的间隔</span><br><span class="line">             gap = Math.floor(gap / 2)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.swap = function (m, n) &#123;</span><br><span class="line">         var temp = this.array[m]</span><br><span class="line">         this.array[m] = this.array[n]</span><br><span class="line">         this.array[n] = temp</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     // 选择枢纽</span><br><span class="line">     ArrayList.prototype.median = function (left, right) &#123;</span><br><span class="line">         // 1.求出中间的位置</span><br><span class="line">         var center = Math.floor((left + right) / 2)</span><br><span class="line"> </span><br><span class="line">         // 2.判断并且进行交换</span><br><span class="line">         if (this.array[left] &gt; this.array[center]) &#123;</span><br><span class="line">             this.swap(left, center)</span><br><span class="line">         &#125;</span><br><span class="line">         if (this.array[center] &gt; this.array[right]) &#123;</span><br><span class="line">             this.swap(center, right)</span><br><span class="line">         &#125;</span><br><span class="line">         if (this.array[left] &gt; this.array[right]) &#123;</span><br><span class="line">             this.swap(left, right)</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         // 3.巧妙的操作: 将center移动到right - 1的位置.</span><br><span class="line">         this.swap(center, right - 1)</span><br><span class="line"> </span><br><span class="line">         // 4.返回pivot</span><br><span class="line">         return this.array[right - 1]</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     // 快速排序实现</span><br><span class="line">     ArrayList.prototype.quickSort = function () &#123;</span><br><span class="line">         this.quickSortRec(0, this.array.length - 1)</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.quickSortRec = function (left, right) &#123;</span><br><span class="line">         // 0.递归结束条件</span><br><span class="line">         if (left &gt;= right) return</span><br><span class="line"> </span><br><span class="line">         // 1.获取枢纽</span><br><span class="line">         var pivot = this.median(left, right)</span><br><span class="line"> </span><br><span class="line">         // 2.开始进行交换</span><br><span class="line">         var i = left</span><br><span class="line">         var j = right - 1</span><br><span class="line">         while (true) &#123;</span><br><span class="line">             while (this.array[++i] &lt; pivot) &#123; &#125;</span><br><span class="line">             while (this.array[--j] &gt; pivot) &#123; &#125;</span><br><span class="line">             if (i &lt; j) &#123;</span><br><span class="line">                 this.swap(i, j)</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 break</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         // 3.将枢纽放在正确的位置</span><br><span class="line">         this.swap(i, right - 1)</span><br><span class="line"> </span><br><span class="line">         // 4.递归调用左边</span><br><span class="line">         this.quickSortRec(left, i - 1)</span><br><span class="line">         this.quickSortRec(i + 1, right)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之哈希表</title>
    <url>/2019/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建HashTable构造函数</span><br><span class="line">function HashTable() &#123;</span><br><span class="line">    // 定义属性</span><br><span class="line">    this.storage = []</span><br><span class="line">    this.count = 0</span><br><span class="line">    this.limit = 8</span><br><span class="line"></span><br><span class="line">    // 定义相关方法</span><br><span class="line">    // 判断是否是质数</span><br><span class="line">    HashTable.prototype.isPrime = function (num) &#123;</span><br><span class="line">        var temp = parseInt(Math.sqrt(num))</span><br><span class="line">        // 2.循环判断</span><br><span class="line">        for (var i = 2; i &lt;= temp; i++) &#123;</span><br><span class="line">            if (num % i == 0) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取质数</span><br><span class="line">    HashTable.prototype.getPrime = function (num) &#123;</span><br><span class="line">        while (!isPrime(num)) &#123;</span><br><span class="line">            num++</span><br><span class="line">        &#125;</span><br><span class="line">        return num</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 哈希函数</span><br><span class="line">    HashTable.prototype.hashFunc = function(str, max) &#123;</span><br><span class="line">        // 1.初始化hashCode的值</span><br><span class="line">        var hashCode = 0</span><br><span class="line"></span><br><span class="line">        // 2.霍纳算法, 来计算hashCode的数值</span><br><span class="line">        for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">            hashCode = 37 * hashCode + str.charCodeAt(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3.取模运算</span><br><span class="line">        hashCode = hashCode % max</span><br><span class="line">        return hashCode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入数据方法</span><br><span class="line">    HashTable.prototype.put = function (key, value) &#123;</span><br><span class="line">        // 1.获取key对应的index</span><br><span class="line">        var index = this.hashFunc(key, this.limit)</span><br><span class="line"></span><br><span class="line">        // 2.取出数组(也可以使用链表)</span><br><span class="line">        // 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ]  [ [k,v] ] ]</span><br><span class="line">        var bucket = this.storage[index]</span><br><span class="line"></span><br><span class="line">        // 3.判断这个数组是否存在</span><br><span class="line">        if (bucket === undefined) &#123;</span><br><span class="line">            // 3.1创建桶</span><br><span class="line">            bucket = []</span><br><span class="line">            this.storage[index] = bucket</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4.判断是新增还是修改原来的值.</span><br><span class="line">        var override = false</span><br><span class="line">        for (var i = 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            var tuple = bucket[i]</span><br><span class="line">            if (tuple[0] === key) &#123;</span><br><span class="line">                tuple[1] = value</span><br><span class="line">                override = true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5.如果是新增, 前一步没有覆盖</span><br><span class="line">        if (!override) &#123;</span><br><span class="line">            bucket.push([key, value])</span><br><span class="line">            this.count++</span><br><span class="line"></span><br><span class="line">            if (this.count &gt; this.limit * 0.75) &#123;</span><br><span class="line">                var primeNum = this.getPrime(this.limit * 2)</span><br><span class="line">                this.resize(primeNum)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取存放的数据</span><br><span class="line">    HashTable.prototype.get = function (key) &#123;</span><br><span class="line">        // 1.获取key对应的index</span><br><span class="line">        var index = this.hashFunc(key, this.limit)</span><br><span class="line"></span><br><span class="line">        // 2.获取对应的bucket</span><br><span class="line">        var bucket = this.storage[index]</span><br><span class="line"></span><br><span class="line">        // 3.如果bucket为null, 那么说明这个位置没有数据</span><br><span class="line">        if (bucket == null) &#123;</span><br><span class="line">            return null</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4.有bucket, 判断是否有对应的key</span><br><span class="line">        for (var i = 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            var tuple = bucket[i]</span><br><span class="line">            if (tuple[0] === key) &#123;</span><br><span class="line">                return tuple[1]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5.没有找到, return null</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除数据</span><br><span class="line">    HashTable.prototype.remove = function (key) &#123;</span><br><span class="line">        // 1.获取key对应的index</span><br><span class="line">        var index = this.hashFunc(key, this.limit)</span><br><span class="line"></span><br><span class="line">        // 2.获取对应的bucket</span><br><span class="line">        var bucket = this.storage[index]</span><br><span class="line"></span><br><span class="line">        // 3.判断同是否为null, 为null则说明没有对应的数据</span><br><span class="line">        if (bucket == null) &#123;</span><br><span class="line">            return null</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4.遍历bucket, 寻找对应的数据</span><br><span class="line">        for (var i = 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            var tuple = bucket[i]</span><br><span class="line">            if (tuple[0] === key) &#123;</span><br><span class="line">                bucket.splice(i, 1)</span><br><span class="line">                this.count--</span><br><span class="line"></span><br><span class="line">                // 缩小数组的容量</span><br><span class="line">                if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;</span><br><span class="line">                    var primeNum = this.getPrime(Math.floor(this.limit / 2))</span><br><span class="line">                    this.resize(primeNum)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return tuple[1]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5.来到该位置, 说明没有对应的数据, 那么返回null</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // isEmpty方法</span><br><span class="line">    HashTable.prototype.isEmpty = function () &#123;</span><br><span class="line">        return this.count == 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // size方法</span><br><span class="line">    HashTable.prototype.size = function () &#123;</span><br><span class="line">        return this.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 哈希表扩容</span><br><span class="line">    HashTable.prototype.resize = function (newLimit) &#123;</span><br><span class="line">        // 1.保存旧的数组内容</span><br><span class="line">        var oldStorage = this.storage</span><br><span class="line"></span><br><span class="line">        // 2.重置属性</span><br><span class="line">        this.limit = newLimit</span><br><span class="line">        this.count = 0</span><br><span class="line">        this.storage = []</span><br><span class="line"></span><br><span class="line">        // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中</span><br><span class="line">        oldStorage.forEach(function (bucket) &#123;</span><br><span class="line">            // 1.bucket为null, 说明这里面没有数据</span><br><span class="line">            if (bucket == null) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 2.bucket中有数据, 那么将里面的数据重新哈希化插入</span><br><span class="line">            for (var i = 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">                var tuple = bucket[i]</span><br><span class="line">                this.put(tuple[0], tuple[1])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%EF%BC%88Stack%EF%BC%89/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><span id="more"></span>
<ul>
<li><p>我们知道数组是一种线性结构，可以在数组的任意位置插入或删除数据。但有些时候，我们为了实现某种功能，必须对这种 任意性 加以限制，而我们的栈和队列就是比较常见的 <strong>受限的线性结构</strong>。</p>
</li>
<li><p>栈是一种<strong>先进后出</strong>或**后进先出(LIFO Last In First Out)**的数据结构，栈内的元素只能通过列表的一端访问，这一端称为栈顶，因为<br>数据只能在栈顶添加或删除，所以只要数据的保存满足“先进后出或后进先出”的原理，都优先考虑使用栈。</p>
</li>
<li><p>栈的结构示意图：</p>
<img src="https://raw.githubusercontent.com/foolishmax/static/master/blogPic/%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<!--more--></li>
<li><p>栈常见有哪些操作？</p>
</li>
</ul>
<ul>
<li>push（element）：添加一个新元素到栈顶位置。</li>
<li>pop（）：移除栈顶的元素，同时返回被移除的元素。</li>
<li>peek（）：返回栈顶的元素，不对栈做任何修改。</li>
<li>isEmpty（）：如果栈里没有任何元素返回true，否则返回false。</li>
<li>size（）：返回栈里的元素个数，类似数组中的length。</li>
<li>toString（）：将栈结构的内容以字符形式返回。</li>
</ul>
<ul>
<li>栈常见操作的封装：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Stack() &#123;</span><br><span class="line">    this.items = []</span><br><span class="line">    //将元素压入栈</span><br><span class="line">    Stack.prototype.push = function(element) &#123;</span><br><span class="line">        this.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    //从栈中移除元素</span><br><span class="line">    Stack.prototype.pop = function() &#123;</span><br><span class="line">        return this.items.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    //查看栈顶元素</span><br><span class="line">    Stack.prototype.peek = function() &#123;</span><br><span class="line">        return this.items[this.items.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">    //判断栈是否为空</span><br><span class="line">    Stack.prototype.isEmpty = function() &#123;</span><br><span class="line">        return this.items.length == 0</span><br><span class="line">    &#125;</span><br><span class="line">    //判断栈中元素个数</span><br><span class="line">    Stack.prototype.size = function() &#123;</span><br><span class="line">        return this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    //toString方法</span><br><span class="line">    Stack.prototype.toString = function() &#123;</span><br><span class="line">        var resultString = &#x27;&#x27;</span><br><span class="line">        for (var i = 0; i&lt; this.items.length; i++) &#123;</span><br><span class="line">            resultString += this.items[i] + &#x27; &#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//栈的使用</span><br><span class="line">var s = new Stack()</span><br><span class="line">s.push(23)</span><br><span class="line">alert(s)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//函数十进制转为二进制</span><br><span class="line">function dec2bin(decNumber) &#123;</span><br><span class="line">    //定义栈对象</span><br><span class="line">    var stack = new Stack()</span><br><span class="line">    while (decNumber &gt; 0) &#123;</span><br><span class="line">        //获取余数放入栈中</span><br><span class="line">        stack.push(decNumber % 2)</span><br><span class="line">        //获取除后的结果,作为下次操作的对象</span><br><span class="line">        decNumber = Math.floor(decNumber / 2)</span><br><span class="line">    &#125;</span><br><span class="line">    //从栈中取出0和1</span><br><span class="line">    var binaryString = &#x27;&#x27;</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        binaryString += stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    return binaryString</span><br><span class="line">&#125;</span><br><span class="line">//调用函数</span><br><span class="line">alert(dec2bin(100))</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构与算法</title>
    <url>/2019/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="什么是数据结构与算法？"><a href="#什么是数据结构与算法？" class="headerlink" title="什么是数据结构与算法？"></a>什么是数据结构与算法？</h2><ul>
<li>数据结构就是在计算机中，存储和组织数据的方式。<span id="more"></span>
<ul>
<li>常见的数据结构：<img src="http://vamknight.com/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<!--more--></li>
</ul>
</li>
<li>算法（Algorithm）的定义：<ul>
<li>算法就是解决问题的方法/步骤，数据结构的实现离不开算法。<ul>
<li>一个有限指令集，每条指令的描述不依赖于语言</li>
<li>接受一些输入（有些情况不需要输入）</li>
<li>产生输出</li>
<li>一定在有限步骤之后终止</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>队列（Queue）</title>
    <url>/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89/</url>
    <content><![CDATA[<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><span id="more"></span>
<ul>
<li><p>队列是一种受限的线性表，先进先出（FIFO First In First Out）。</p>
<ul>
<li>它只允许在表的前端（front）进行删除操作</li>
<li>在表的后端（rear）进行插入操作<!--more--></li>
</ul>
</li>
<li><p>常见应用场景：</p>
<ul>
<li>队列主要用在和时间有关的地方，特别是操作系统中，队列是实现多任务的重要机制。</li>
<li>消息机制可以通过队列来实现，进程调度也是使用队列来实现。<img src="https://raw.githubusercontent.com/foolishmax/static/master/blogPic/%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></li>
</ul>
</li>
<li><p>队列有哪些常见的操作呢？</p>
<ul>
<li>enqueue(element): 向队列尾部添加一个（或多个）新的项。</li>
<li>dequeue(): 移除队列的第一项，并返回被移除的元素。</li>
<li>front(): 返回队列中第一个元素，队列不做任何改动。</li>
<li>isEmpty(): 如果队列中不包含任何元素，返回true，否则返回false。</li>
<li>size(): 返回队列包含的元素个数，与数组length类似。</li>
<li>toString(): 将队列中的内容，转成字符串形式。</li>
</ul>
</li>
<li><p>队列常见操作的封装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//封装队列</span><br><span class="line">function Queue() &#123;</span><br><span class="line">    //属性</span><br><span class="line">    this.items = []</span><br><span class="line">    //将元素加入到队列中</span><br><span class="line">    Queue.prototype.enqueue = function(element) &#123;</span><br><span class="line">        this.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    //从队列中删除前端元素</span><br><span class="line">    Queue.prototype.dequeue = function() &#123;</span><br><span class="line">        return this.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    //查看前端的元素</span><br><span class="line">    Queue.prototype.front = function() &#123;</span><br><span class="line">        return this.items[0]</span><br><span class="line">    &#125;</span><br><span class="line">    //查看队列是否为空</span><br><span class="line">    Queue.prototype.isEmpty = function() &#123;</span><br><span class="line">        return this.items.length == 0</span><br><span class="line">    &#125;</span><br><span class="line">    //查看队列中元素的个数</span><br><span class="line">    Queue.prototype.size = function() &#123;</span><br><span class="line">        return this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    //toString方法</span><br><span class="line">    Queue.prototype.toString = function() &#123;</span><br><span class="line">        var resultString = &#x27;&#x27;</span><br><span class="line">        for (var i = 0; i&lt; this.items.length; i++) &#123;</span><br><span class="line">            resultString += this.items[i] + &#x27; &#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用队列函数</span><br><span class="line">var queue = new Queue()</span><br><span class="line">queue.enqueue(20)</span><br><span class="line">alert(queue)</span><br></pre></td></tr></table></figure></li>
<li><p>面试题： 击鼓传花</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//面试题: 击鼓传花</span><br><span class="line">function passGame(nameList, num) &#123;</span><br><span class="line">    //创建一个队列结构</span><br><span class="line">    var queue = new Queue()</span><br><span class="line">    //将所有人加入到队列中</span><br><span class="line">    for(var i = 0; i &lt; nameList.length; i++) &#123;</span><br><span class="line">        queue.enqueue(nameList[i])</span><br><span class="line">    &#125;</span><br><span class="line">    //开始数数字</span><br><span class="line">    while (queue.size() &gt; 1) &#123;</span><br><span class="line">        //不是num重新加入队列末尾</span><br><span class="line">        //是num从队列中删除</span><br><span class="line">        for (var i = 0; i&lt; num - 1; i++) &#123;</span><br><span class="line">            queue.enqueue(queue.dequeue())</span><br><span class="line">        &#125;</span><br><span class="line">        queue.dequeue()</span><br><span class="line">    &#125;</span><br><span class="line">    return queque.front()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装优先队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//封装优先级队列</span><br><span class="line">function PriorityQueue() &#123;</span><br><span class="line">    //内部创建一个构造类</span><br><span class="line">    function QueueElement(element, priority) &#123;</span><br><span class="line">        this.element = element</span><br><span class="line">        this.priority = priority</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //属性</span><br><span class="line">    this.items = []</span><br><span class="line">    </span><br><span class="line">    //实现队列元素的插入</span><br><span class="line">    PriorityQueue.prototype.enqueue = function(element, priority) &#123;</span><br><span class="line">        //创建QueueElement对象</span><br><span class="line">        var queueElement = new QueueElement(element, priority)</span><br><span class="line">        </span><br><span class="line">        //判断为队列是否为空</span><br><span class="line">        if (this.items.length == 0) &#123;</span><br><span class="line">            this.items.push(queueElement)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var added = false</span><br><span class="line">            for (var i = 0; i &lt; this.items.length; i++) &#123;</span><br><span class="line">                if (queueElement.priority &lt; this.items[i].priority) &#123;</span><br><span class="line">                    this.items.splice(i, 0, queueElement)</span><br><span class="line">                    added = true</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!added) &#123;</span><br><span class="line">                this.items.push(queueElement)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        //从队列中删除前端元素</span><br><span class="line">    PriorityQueue.prototype.dequeue = function() &#123;</span><br><span class="line">        return this.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    //查看前端的元素</span><br><span class="line">    PriorityQueue.prototype.front = function() &#123;</span><br><span class="line">        return this.items[0]</span><br><span class="line">    &#125;</span><br><span class="line">    //查看队列是否为空</span><br><span class="line">    PriorityQueue.prototype.isEmpty = function() &#123;</span><br><span class="line">        return this.items.length == 0</span><br><span class="line">    &#125;</span><br><span class="line">    //查看队列中元素的个数</span><br><span class="line">    PriorityQueue.prototype.size = function() &#123;</span><br><span class="line">        return this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    //toString方法</span><br><span class="line">    PriorityQueue.prototype.toString = function() &#123;</span><br><span class="line">        var resultString = &#x27;&#x27;</span><br><span class="line">        for (var i = 0; i&lt; this.items.length; i++) &#123;</span><br><span class="line">            resultString += this.items[i].element + &#x27;-&#x27; + this.items[i].priority + &#x27; &#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试代码</span><br><span class="line">var pq = new PriorityQueue()</span><br><span class="line">pq.enqueue(&#x27;a&#x27;,10)</span><br><span class="line">pq.enqueue(&#x27;b&#x27;,100)</span><br><span class="line">pq.enqueue(&#x27;c&#x27;,50)</span><br><span class="line">alert(pq)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li><p>什么是链表？</p>
<ul>
<li>链表的元素在内存中不必是连续的空间，链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。<span id="more"></span></li>
</ul>
</li>
<li><p>相对于数组，链表都有哪些优势？</p>
<ul>
<li>内存空间不是比是连续的. 可以充分利用计算机的内存. 实现灵活的内存动态管理。</li>
<li>链表不必在创建时就确定大小, 并且大小可以无限的延伸下去。</li>
<li>链表在插入和删除数据时, 时间复杂度可以达到O(1). 相对数组效率高很多。</li>
</ul>
</li>
<li><p>相对于数组，链表都有哪些缺点？</p>
<ul>
<li>链表访问任何一个位置的元素时, 都需要从头开始访问.(无法跳过第一个元素访问任何一个元素)。</li>
<li>无法通过下标直接访问元素, 需要从头一个个访问, 直到找到对应的问题。<!--more--></li>
</ul>
</li>
<li><p>链表的数据结构：</p>
<img src="http://vamknight.com/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png"></li>
<li><p>链表有哪些常见操作？</p>
<ul>
<li>append(element)：向列表尾部添加一个新的项</li>
<li>insert(position, element)：向列表的特定位置插入一个新的项。</li>
<li>update(position, element): 修改某一个位置上的元素。</li>
<li>remove(element)：从列表中移除一项。</li>
<li>indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。</li>
</ul>
<p>  // 链表中的属性<br>  this.length = 0<br>  this.head = null</p>
<p>  // 链表尾部追加元素方法<br>  LinkedList.prototype.append = function (element) {</p>
<pre><code>  // 1.根据新元素创建节点
  var newNode = new Node(element)

  // 2.判断原来链表是否为空
  if (this.head === null) &#123; /
</code></pre>
<ul>
<li><p>removeAt(position)：从列表的特定位置移除一项。<br>this.next = null<br>}<br>/ 链表尾空</p>
<pre><code>  this.head = newNode
</code></pre>
<p>  } else { // 链表不为空</p>
<pre><code>  // 2.1.定义变量, 保存当前找到的节点
  var current = this.head
  while (current.next) &#123;
      current = current.next
  &#125;

  // 2.2.找到最后一项, 将其next赋值为node
  current.next = newNode
</code></pre>
<p>  }</p>
<p>  // 3.链表长度增加1<br>  this.length++<br>}</p>
</li>
</ul>
<p>  // 链表的toString方法<br>  LinkedList.prototype.toString = function () {</p>
<pre><code>  // 1.定义两个变量
  var current = this.head
  var listString = &quot;&quot;

  // 2.循环获取链表中所有的元素
  while (current) &#123;
      listString += &quot;,&quot; + current.element
      current = current.next
  &#125;

  // 3.返回最终结果
  return listString.slice(1)
</code></pre>
<p>  }</p>
<p>  // 根据下标删除元素<br>  LinkedList.prototype.insert = function (position, element) {</p>
<pre><code>  // 1.检测越界问题: 越界插入失败
  if (position &lt; 0 || position &gt; this.length) return false

  // 2.定义变量, 保存信息
  var newNode = new Node(element)
  var current = this.head
  var previous = null
  index = 0

  // 3.判断是否列表是否在第一个位置插入
  if (position == 0) &#123;
      newNode.next = current
      this.head = newNode
  &#125; else &#123;
      while (index++ &lt; position) &#123;
          previous = current
          current = current.next
      &#125;

      newNode.next = current
      previous.next = newNode
  &#125;

  // 4.length+1
  this.length++

  return true
</code></pre>
<p>  }</p>
<p>  //update方法<br>  LinkedList.prototype.update = function (position, newData) {</p>
<pre><code>  if (position &lt; 0 || position &gt;= this.length) return  null
  
  var current = this.head
  var index = 0
  while (index++ &lt; position) &#123;
      current = current.next
  &#125;
  current.data = newData
  return true
</code></pre>
<p>  }</p>
<p>  // 根据位置移除节点<br>  LinkedList.prototype.removeAt = function (position) {</p>
<pre><code>  // 1.检测越界问题: 越界移除失败, 返回null
  if (position &lt; 0 || position &gt;= this.length) return null

  // 2.定义变量, 保存信息
  var current = this.head
  var previous = null
  var index = 0

  // 3.判断是否是移除第一项
  if (position === 0) &#123;
      this.head = current.next
  &#125; else &#123;
      while (index++ &lt; position) &#123;
          previous = current
          current = current.next
      &#125;

      previous.next = current.next
  &#125;

  // 4.length-1
  this.length--

  // 5.返回移除的数据
  return current.element
</code></pre>
<p>  }</p>
<p>  // 根据元素获取链表中的位置<br>  LinkedList.prototype.indexOf = function (element) {</p>
<pre><code>  // 1.定义变量, 保存信息
  var current = this.head
  index = 0

  // 2.找到元素所在的位置
  while (current) &#123;
      if (current.element === element) &#123;
          return index
      &#125;
      index++
      current = current.next
  &#125;

  // 3.来到这个位置, 说明没有找到, 则返回-1
  return -1
</code></pre>
<p>  }</p>
<p>  // 根据元素删除信息<br>  LinkedList.prototype.remove = function (element) {</p>
<pre><code>  var index = this.indexOf(element)
  return this.removeAt(index)
</code></pre>
<p>  }</p>
<p>  // 判断链表是否为空<br>  LinkedList.prototype.isEmpty = function () {</p>
<pre><code>  return this.length == 0
</code></pre>
<p>  }</p>
<p>  // 获取链表的长度<br>  LinkedList.prototype.size = function () {</p>
<pre><code>  return this.length
</code></pre>
<p>  }</p>
<p>  // 获取第一个节点<br>  LinkedList.prototype.getFirst = function () {</p>
<pre><code>  return this.head.element
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 以上操作的都是单向链表，下面来认识一下双向链表。</span><br><span class="line">- 单向链表的缺点：</span><br><span class="line">    + 只能从头遍历到尾，也就是链表的相连的过程是单向的，实现的原理是上一个链表中有一个指向下一个的引用。</span><br><span class="line">    + 我们可以轻松的到达下一个节点，但是回到上一个节点是很难的，只能从头遍历。</span><br><span class="line">    + 但是，实际开发中，经常会遇到回到上一个节点的情况。</span><br><span class="line">- 双向链表：</span><br><span class="line">    + 既可以从头遍历到尾，又可以从尾遍历到头。</span><br><span class="line">    + 也就是链表相连的过程是双向的。</span><br><span class="line">    + 实现的原理就是既有先前连接的引用，也有一个向后连接的引用。</span><br><span class="line">    + 双向链表可以有效的解决单向链表的问题。</span><br><span class="line">- 双向链表的一些缺点：</span><br><span class="line">    + 每次在插入或删除某一个节点时，需要处理四个引用，实现起来比较复杂。</span><br><span class="line">    + 相对于单向链表占用的内存更大一些。</span><br><span class="line">    </span><br><span class="line">- 双向链表的结构图：</span><br><span class="line">&lt;img src=&quot;http://vamknight.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png&quot;&gt;</span><br><span class="line"></span><br><span class="line">- 双向链表的特点：</span><br><span class="line">    + 可以使用一个head和一个tail分别指向头部和尾部的节点。</span><br><span class="line">    + 每个节点都是由三部分组成：前一个节点的指针（prev）、保存的元素（item）、后一个节点的指针（next）。</span><br><span class="line">    + 双向链表的第一个节点的prev是null。</span><br><span class="line">    + 双向链表的最后一个节点的next是null。</span><br><span class="line"></span><br><span class="line">- 双向链表都有哪些常见操作？</span><br><span class="line">    + append(element)：向列表尾部添加一个新的项</span><br><span class="line">    </span><br><span class="line">    + insert(position, element)：向列表的特定位置插入一个新的项。</span><br><span class="line">    </span><br><span class="line">    + update(position, element): 修改某一个位置上的元素。</span><br><span class="line">    </span><br><span class="line">    + get(position): 获取对应位置的元素。</span><br><span class="line">    </span><br><span class="line">    + remove(element)：从列表中移除一项。</span><br><span class="line">    </span><br><span class="line">    + indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。</span><br><span class="line">    </span><br><span class="line">    + removeAt(position)：从列表的特定位置移除一项。</span><br><span class="line">    </span><br><span class="line">    + isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。</span><br><span class="line">    </span><br><span class="line">    + size()：返回链表包含的元素个数。与数组的length属性类似。</span><br><span class="line">    </span><br><span class="line">    + toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。</span><br><span class="line">    </span><br><span class="line">    + forwardString(): 返回正向遍历的节点字符串形式。</span><br><span class="line">    </span><br><span class="line">    + backwardString(): 返回反向遍历的节点字符串形式。</span><br><span class="line"></span><br><span class="line">- 双向链表常见方法的封装：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// 创建双向链表的构造函数<br>function DoublyLinkedList() {<br>  // 创建节点构造函数<br>  function Node(element) {</p>
<pre><code>  this.element = element
  this.next = null
  this.prev = null // 新添加的
</code></pre>
<p>  }</p>
<p>  // 定义属性<br>  this.length = 0<br>  this.head = null<br>  this.tail = null // 新添加的</p>
<p>  // 定义相关操作方法<br>  // 在尾部追加数据<br>  DoublyLinkedList.prototype.append = function (element) {</p>
<pre><code>  // 1.根据元素创建节点
  var newNode = new Node(element)

  // 2.判断列表是否为空列表
  if (this.head == null) &#123;
      this.head = newNode
      this.tail = newNode
  &#125; else &#123;
      this.tail.next = newNode
      newNode.prev = this.tail
      this.tail = newNode
  &#125;

  // 3.length+1
  this.length++
</code></pre>
<p>  }</p>
<p>  // 在任意位置插入数据<br>  DoublyLinkedList.prototype.insert = function (position, element) {</p>
<pre><code>  // 1.判断越界的问题
  if (position &lt; 0 || position &gt; this.length) return false

  // 2.创建新的节点
  var newNode = new Node(element)

  // 3.判断插入的位置
  if (position === 0) &#123; // 在第一个位置插入数据
      // 判断链表是否为空
      if (this.head == null) &#123;
          this.head = newNode
          this.tail = newNode
      &#125; else &#123;
          this.head.prev = newNode
          newNode.next = this.head
          this.head = newNode
      &#125;
  &#125; else if (position === this.length) &#123; // 插入到最后的情况
      // 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么?
      this.tail.next = newNode
      newNode.prev = this.tail
      this.tail = newNode
  &#125; else &#123; // 在中间位置插入数据
      // 定义属性
      var index = 0
      var current = this.head
      var previous = null

      // 查找正确的位置
      while (index++ &lt; position) &#123;
          previous = current
          current = current.next
      &#125;

      // 交换节点的指向顺序
      newNode.next = current
      newNode.prev = previous
      current.prev = newNode
      previous.next = newNode
  &#125;

  // 4.length+1
  this.length++

  return true
</code></pre>
<p>  }</p>
<p>  // 根据位置删除对应的元素<br>  DoublyLinkedList.prototype.removeAt = function (position) {</p>
<pre><code>  // 1.判断越界的问题
  if (position &lt; 0 || position &gt;= this.length) return null

  // 2.判断移除的位置
  var current = this.head
  if (position === 0) &#123;
      if (this.length == 1) &#123;
          this.head = null
          this.tail = null
      &#125; else &#123;
          this.head = this.head.next
          this.head.prev = null
      &#125;
  &#125; else if (position === this.length -1) &#123;
      current = this.tail
      this.tail = this.tail.prev
      this.tail.next = null
  &#125; else &#123;
      var index = 0
      var previous = null

      while (index++ &lt; position) &#123;
          previous = current
          current = current.next
      &#125;

      previous.next = current.next
      current.next.prev = previous
  &#125;

  // 3.length-1
  this.length--

  return current.element
</code></pre>
<p>  }</p>
<p>  // 根据元素获取在链表中的位置<br>  DoublyLinkedList.prototype.indexOf = function (element) {</p>
<pre><code>  // 1.定义变量保存信息
  var current = this.head
  var index = 0

  // 2.查找正确的信息
  while (current) &#123;
      if (current.element === element) &#123;
          return index
      &#125;
      index++
      current = current.next
  &#125;

  // 3.来到这个位置, 说明没有找到, 则返回-1
  return -1
</code></pre>
<p>  }</p>
<p>  // 根据元素删除<br>  DoublyLinkedList.prototype.remove = function (element) {</p>
<pre><code>  var index = this.indexOf(element)
  return this.removeAt(index)
</code></pre>
<p>  }</p>
<p>  // 判断是否为空<br>  DoublyLinkedList.prototype.isEmpty = function () {</p>
<pre><code>  return this.length === 0
</code></pre>
<p>  }</p>
<p>  // 获取链表长度<br>  DoublyLinkedList.prototype.size = function () {</p>
<pre><code>  return this.length
</code></pre>
<p>  }</p>
<p>  // 获取第一个元素<br>  DoublyLinkedList.prototype.getHead = function () {</p>
<pre><code>  return this.head.element
</code></pre>
<p>  }</p>
<p>  // 获取最后一个元素<br>  DoublyLinkedList.prototype.getTail = function () {</p>
<pre><code>  return this.tail.element
</code></pre>
<p>  }</p>
<p>  // 遍历方法的实现<br>  // 正向遍历的方法<br>  DoublyLinkedList.prototype.forwardString = function () {</p>
<pre><code>  var current = this.head
  var forwardStr = &quot;&quot;

  while (current) &#123;
      forwardStr += &quot;,&quot; + current.element
      current = current.next
  &#125;

  return forwardStr.slice(1)
</code></pre>
<p>  }</p>
<p>  // 反向遍历的方法<br>  DoublyLinkedList.prototype.reverseString = function () {</p>
<pre><code>  var current = this.tail
  var reverseStr = &quot;&quot;

  while (current) &#123;
      reverseStr += &quot;,&quot; + current.element
      current = current.prev
  &#125;

  return reverseStr.slice(1)
</code></pre>
<p>  }</p>
<p>  // 实现toString方法<br>  DoublyLinkedList.prototype.toString = function () {</p>
<pre><code>  return this.forwardString()
</code></pre>
<p>  }<br>}<br>~~~</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>本地存储</title>
    <url>/2019/09/30/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<ul>
<li><p>客户端的本地存储：</p>
<ul>
<li><p>localStorage</p>
<span id="more"></span>
<ul>
<li>生命周期永久生效，除非手动删除，否则关闭页面也会存在</li>
<li>可以在同一浏览器多窗口共享</li>
<li>以键值对的形式存储使用</li>
<li>方法：<ul>
<li>存储数据：localStorage.setItem(key, value)</li>
<li>获取数据：localStorage.getItem(key)</li>
<li>删除数据：localStorage.removeItem(key)</li>
<li>删除所有数据：localStorage.clear()</li>
</ul>
</li>
</ul>
</li>
<li><p>sessionStorage </p>
<ul>
<li>声明周期为关闭浏览器窗口</li>
<li>在同一个窗口中数据可以共享</li>
<li>以键值对的形式存储</li>
<li>方法：<ul>
<li>存储数据：sessionStorage.setItem(key, value)</li>
<li>获取数据：sessionStorage.getItem(key)</li>
<li>删除数据：sessionStorage.removeItem(key)</li>
<li>删除所有数据：sessionStorage.clear()</li>
</ul>
  <a href='https://www.cnblogs.com/pengc/p/8714475.html'>localStorage和sessionStorage</a>  <a href='https://www.cnblogs.com/8023-CHD/p/11067141.html'>cookie和session</a></li>
</ul>
</li>
<li><p>IndexDB 离线存储，当网络断开，可以从浏览器中读取数据，用来做一些离线应用</p>
</li>
<li><p>Cookie </p>
<ul>
<li>包含字段<ul>
<li>name: cookie名称</li>
<li>value: 值</li>
<li>domain: cookie生效的域名</li>
<li>path: cookie生效的路径</li>
<li>expires/max-age: cookie过期时间</li>
<li>size: 大小</li>
<li>HttpOnly: 用户端不可更改</li>
</ul>
</li>
<li>存储用户信息，通过在客户端记录信息确定用户身份，最大为4kb</li>
<li>会话Cookie，若不设置过期时间，表示这个cookie的生命周期为浏览器会话期间，浏览器<br>关闭，cookie就消失，会话cookie会保存在内存中而不是硬盘上。</li>
<li>持久Cookie，若设置了过期时间，浏览器会把cookie保存在硬盘上，关闭浏览器仍然有效直到<br>超过设定的过期时间。</li>
<li>cookie数据始终在同源的http请求中携带(即使不需要)，即会在浏览器和服务器之间来回传递。</li>
<li>Cookie具有不可跨域名性，例如浏览器访问百度不会带上谷歌的cookie</li>
</ul>
</li>
</ul>
</li>
<li><p>服务端的存储：</p>
<ul>
<li>Session<ul>
<li>Session 服务器端一种记录客户端状态的机制</li>
<li>cookie数据存放在客户的浏览器上，session将数据存放在服务器端</li>
<li>Session相对Cookie来说比较安全，别人可以分析本地存放的cookie进行cookie欺骗</li>
<li>Session会在一定时间内保存在服务器上，访问量较多的时候会比较占用服务器的性能，<br>考虑到减轻服务器性能方面的时候，应当使用cookie</li>
<li>可以将登陆等重要信息保存在session，其他信息放在cookie中</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本地存储</category>
      </categories>
      <tags>
        <tag>本地存储</tag>
      </tags>
  </entry>
  <entry>
    <title>日期</title>
    <url>/2019/07/18/%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><span id="more"></span>
<pre><code>Date.now()  //获取当前时间毫秒数
var dt = new Date() //构造一个实例对象
dt.getTime()    //获取毫秒数
dt.getFullYear() //年
dt.getMonth()   //月（0-11）
dt.getDate()    //日 （0-31）
dt.getHours()   //小时（0-23）
dt.getMinutes() //分钟（0-59）
dt.getSeconds() //秒（0-59）
dt.getDay()     //星期几（0-6）
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2019/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><span id="more"></span>
<ul>
<li>集合通常是由一组无序的，不能重复的元素构成。可以看成是一种特殊的数组，特殊之处在于里<br>面的元素没有顺序就意味着不能通过下标值进行访问，不能重复意味着相同的对象在同一个集合中只能存<br>在一份。<!-- more --></li>
<li>集合都有哪些常见的操作方法呢？<ul>
<li>add(value)：向集合添加一个新的项。</li>
<li>remove(value)：从集合移除一个值。</li>
<li>has(value)：如果值在集合中，返回true，否则返回false。</li>
<li>clear()：移除集合中的所有项。</li>
<li>size()：返回集合所包含元素的数量。与数组的length属性类似。</li>
<li>values()：返回一个包含集合中所有值的数组。</li>
</ul>
</li>
<li>集合之间都有哪些操作呢？<ul>
<li>并集：对于两个给定的集合，返回一个包含两个集合中所有元素的新集合。</li>
<li>交集：对于两个给定的集合，返回一个包含两个集合中公有元素的新集合。</li>
<li>差集：对于两个给定的集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的新集合。</li>
<li>子集：验证一个给定集合是否是另一个集合的子集。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/foolishmax/static/master/blogPic/%E9%9B%86%E5%90%88%E5%85%B3%E7%B3%BB.png">
    
    
<ul>
<li>集合封装的完整代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 封装集合的构造函数</span><br><span class="line">function Set() &#123;</span><br><span class="line">    // 使用一个对象来保存集合的元素</span><br><span class="line">    this.items = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 集合的操作方法</span><br><span class="line">    // 判断集合中是否有某个元素</span><br><span class="line">    Set.prototype.has = function (value) &#123;</span><br><span class="line">        return this.items.hasOwnProperty(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 向集合中添加元素</span><br><span class="line">    Set.prototype.add = function (value) &#123;</span><br><span class="line">        // 1.判断集合中是否已经包含了该元素</span><br><span class="line">        if (this.has(value)) return false</span><br><span class="line"></span><br><span class="line">        // 2.将元素添加到集合中</span><br><span class="line">        this.items[value] = value</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从集合中删除某个元素</span><br><span class="line">    Set.prototype.remove = function (value) &#123;</span><br><span class="line">        // 1.判断集合中是否包含该元素</span><br><span class="line">        if (!this.has(value)) return false</span><br><span class="line"></span><br><span class="line">        // 2.包含该元素, 那么将元素删除</span><br><span class="line">        delete this.items[value]</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空集合中所有的元素</span><br><span class="line">    Set.prototype.clear = function () &#123;</span><br><span class="line">        this.items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取集合的大小</span><br><span class="line">    Set.prototype.size = function () &#123;</span><br><span class="line">        return Object.keys(this.items).length</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        考虑兼容性问题, 使用下面的代码</span><br><span class="line">        var count = 0</span><br><span class="line">        for (var value in this.items) &#123;</span><br><span class="line">            if (this.items.hasOwnProperty(value)) &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取集合中所有的值</span><br><span class="line">    Set.prototype.values = function () &#123;</span><br><span class="line">        return Object.keys(this.items)</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        考虑兼容性问题, 使用下面的代码</span><br><span class="line">        var keys = []</span><br><span class="line">        for (var value in this.items) &#123;</span><br><span class="line">            keys.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">        return keys</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //集合之间的操作</span><br><span class="line">    //并集</span><br><span class="line">    Set.prototype.union = function (otherSet) &#123;</span><br><span class="line">        //this:集合对象A</span><br><span class="line">        //otherSet:集合对象B</span><br><span class="line">        //1.创建新的集合</span><br><span class="line">        var unionSet = new Set()</span><br><span class="line">        </span><br><span class="line">        //2.将A集合中所有的元素添加到新集合中</span><br><span class="line">        var values = this.values()</span><br><span class="line">        for(var i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            unionSet.add(values[i])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //3.取出B集合中的元素，判断是否需要添加到新集合</span><br><span class="line">        values = otherSet.values()</span><br><span class="line">        for(var i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            unionSet.add(values[i])</span><br><span class="line">        &#125;</span><br><span class="line">        return unionSet</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //交集</span><br><span class="line">        Set.prototype.intersection = function (otherSet) &#123;</span><br><span class="line">            var intersectionSet = new Set()</span><br><span class="line">            var values = this.values()</span><br><span class="line">            //取出A集合一个个元素，判断是否同时存在于B中，存在B中，则添加到新集合中</span><br><span class="line">            for (var i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">                var item = values[i]</span><br><span class="line">                if (otherSet.has(item)) &#123;</span><br><span class="line">                    intersectionSet.add(item)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return intersectionSet</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    //差集</span><br><span class="line">    Set.prototype.difference = function (otherSet) &#123;</span><br><span class="line">        var differenceSet = new Set()</span><br><span class="line">        var values = this.values()</span><br><span class="line">        //取出A集合一个个元素，判断是否同时存在于B中，不存在B中，则添加到新集合中</span><br><span class="line">        for (var i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            var item = values[i]</span><br><span class="line">            if (!otherSet.has(item)) &#123;</span><br><span class="line">                differenceSet.add(item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return differenceSet</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 子集</span><br><span class="line">    Set.prototype.subset = function (otherSet) &#123;</span><br><span class="line">        var values = this.values()</span><br><span class="line">        for (var i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            var item = values[i]</span><br><span class="line">            if (!otherSet.has(item)) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组去重的6种方法</title>
    <url>/2019/06/18/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>终于，石墨烯的PPT完成了一小部分，感觉自己高中的化学都白学了，什么sp²杂化轨道全忘完了，回来继续学习我的前端学习之旅。<br>今天来总结一下，前端高频面试题，数组去重！！！</p>
<h2 id="1-直接遍历法"><a href="#1-直接遍历法" class="headerlink" title="1.直接遍历法"></a>1.直接遍历法</h2><span id="more"></span>
<ul>
<li>利用JavaScript的<code>indexOf</code>方法，新建一个数组 newArr，<br>用这个数组去判断旧数组中的每一个数是否等于-1,如果是，说明该数在新数组中不存在，则将其添加进新数组，遍历完后就能将数组去重并保存至新建的数组中。<!--more-->
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var newArr = []</span><br><span class="line">    for (var i = 0;i &lt; arr.length;i++) &#123;</span><br><span class="line">        if (newArr.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">            newArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique(arr))</span><br><span class="line"></span><br><span class="line">----------------------------------------------------</span><br><span class="line"></span><br><span class="line">原型链：</span><br><span class="line"></span><br><span class="line">Array.prototype.unique = function() &#123;</span><br><span class="line">    var arr = []</span><br><span class="line">    for(var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        if (arr.indexOf(this[i]) == -1) &#123;</span><br><span class="line">            arr.push(this[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(arr.unique())</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-reduce-函数"><a href="#2-reduce-函数" class="headerlink" title="2.reduce 函数"></a>2.reduce 函数</h2><ul>
<li>使用数组的<code>reduce</code>方法结合<code>indexOf</code>两个方法实现数组去重，<br>来自MDN的解释：reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数<br>(升序执行)，将其结果汇总为单个返回值。<br>mozilla 官方对 reduce 的解释是 arr.reduce(callback[, initialValue])<br>方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。简单点讲就是<br>对数组中的每一个数作用一个函数，这个回调函数就是第一个参数 callback ,第二个参数是传<br>入的初始值，不传则使用数组中的第一个元素，注意在没有初始值的空数组上调用 reduce 将报错。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique2(arr) &#123;</span><br><span class="line">    return arr.reduce (function(prev, next) &#123;</span><br><span class="line">        if(prev.indexOf(next) === -1) &#123;</span><br><span class="line">            prev.push(next)</span><br><span class="line">        &#125;</span><br><span class="line">        return prev</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique2(arr))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-相邻比较"><a href="#3-相邻比较" class="headerlink" title="3.相邻比较"></a>3.相邻比较</h2><ul>
<li>利用数组的 sort() 函数，这个函数原本是对数组进行排序的，但在这里我们不用它进行排序，<br>而只是让它将重复的元素聚拢起来，接着我们比较相邻的两个数，如果相等，则跳过；如果不相等，<br>我们就将其添加进新数组里，这样得到的数组就是去重后的数组。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique3(arr)&#123;</span><br><span class="line">  var newArr = [arr[0]];</span><br><span class="line">  arr.sort();</span><br><span class="line">  for(var i=1;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(arr[i] !== arr[i-1])&#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique3(arr))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-下标指针遍历（不太理解）"><a href="#4-下标指针遍历（不太理解）" class="headerlink" title="4.下标指针遍历（不太理解）"></a>4.下标指针遍历（不太理解）</h2><ul>
<li>利用数组的下标指针，来确定是否是相同的元素，如果是的话，就让其指针递增跳过，然后不断把不重复的数组保存至新数组中。<br>代码嵌套了两层循环，分别有 i 和 j 两指针，其中 j 总是比 i 大 1，通过判断数组中这个数<br>与它后面的数是否相等，如果相等，则说明这个数重复了，我们便将指针 i 和 j 继续往后运行，<br>然后用 j = ++i 保持 j 比 i 大 1。最后一直把不重复的指针 i 对应的元素添加进数组。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique4()&#123;</span><br><span class="line">  var newArr = [];</span><br><span class="line">  for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    for(var j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">      if(arr[i] === arr[j])&#123;</span><br><span class="line">        j = ++i;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    newArr.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique4(arr))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-临时对象存储"><a href="#5-临时对象存储" class="headerlink" title="5.临时对象存储"></a>5.临时对象存储</h2><ul>
<li>借用一个临时对象来存储数组元素，判断数组中的元素是否在对象中，如果不存在，就将该数添加进数组，并在临时对象中做标记。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique5(arr)&#123;</span><br><span class="line">  var newArr = [];</span><br><span class="line">  var temp = &#123;&#125;;</span><br><span class="line">  for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(!temp[arr[i]])&#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">      temp[arr[i]] = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique5(arr))</span><br></pre></td></tr></table></figure>

<h2 id="6-简单粗暴法"><a href="#6-简单粗暴法" class="headerlink" title="6.简单粗暴法"></a>6.简单粗暴法</h2><ul>
<li>利用 ES6 中的 Set 集合里元素唯一的特性，先将数组转换为集合，这样里面的元素就是唯一的了，再用 Array.from 方法将集合转回数组返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique6(arr)&#123;</span><br><span class="line">  //return Array.from(new Set(arr));</span><br><span class="line">  </span><br><span class="line">  return [...new Set(arr)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique6(arr))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>比较Vue和React？</title>
    <url>/2019/06/30/%E6%AF%94%E8%BE%83Vue%E5%92%8CReact%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="比较Vue和React的相同点和不同点？"><a href="#比较Vue和React的相同点和不同点？" class="headerlink" title="比较Vue和React的相同点和不同点？"></a>比较Vue和React的相同点和不同点？</h2><span id="more"></span>
<ul>
<li>相同点<ul>
<li>都有组件化开发和Virtual DOM</li>
<li>都支持props进行父子组件间的数据通信</li>
<li>都支持数据驱动视图，不直接操作真实DOM，状态数据更新页面则自动更新</li>
<li>都支持服务端渲染</li>
<li>都支持原生应用的开发方案，React有React Native，Vue有Weex<!--more--></li>
</ul>
</li>
<li>不同点<ul>
<li>数据绑定： Vue实现了数据的双向绑定，React数据流动是单向的</li>
<li>React推荐的组件写法为JSX，也就是把HTML和CSS全部写进Javascript中，即“all in js”<br>Vue推荐的组件写法是webpack+vue-loader的单文件组件格式，即html、css、js写在同一个<br>文件</li>
<li>state对象在react应用中不可变，需要使用setState方法更新状态；在vue中state对象不是<br>必须的，数据由data属性在vue对象中管理</li>
<li>virtual DOM不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树，<br>而对于React而言，每当应用的状态被改变时，全部组件都会重新渲染，所以react会需要<br>shouldComponentUpdate这个生命周期函数方法进行控制。</li>
<li>React严格上只针对MVC的view层，Vue则是MVVM模式。</li>
</ul>
</li>
</ul>
<h2 id="前端框架使用Vue还是React？清晰比较两者差异"><a href="#前端框架使用Vue还是React？清晰比较两者差异" class="headerlink" title="前端框架使用Vue还是React？清晰比较两者差异"></a>前端框架使用Vue还是React？清晰比较两者差异</h2><h4 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h4><ul>
<li>vue<ul>
<li>vue由尤雨溪开发，独立团队维护，大部分子项目交给团队成员打理，Vue核心库依然<br>主要由尤雨溪亲自维护。</li>
</ul>
</li>
<li>react<ul>
<li>React起源于Facebook的内部项目，在建设instagram(图片分享)的时候，为了处理<br>数据流且考虑性能方面的问题，因该公司对市场上所有框架都不满意，就决定自己写一套，<br>用来架构Instagram的网站。并在2013年5月开源。</li>
</ul>
</li>
</ul>
<h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><ul>
<li>vue<ul>
<li>vue是一款渐进式框架，采用自底向上增量开发的设计。在声明式渲染(视图模板引擎)<br>的基础上，通过添加组件系统(component)、客户端路由(vue-router)、状态管理(vuex)<br>来构建一个完整的框架。</li>
</ul>
</li>
<li>react<ul>
<li>react主张函数式编程，所以推崇纯组件，数据不可变，单向数据流，</li>
</ul>
</li>
</ul>
<h4 id="编写语法"><a href="#编写语法" class="headerlink" title="编写语法"></a>编写语法</h4><ul>
<li>vue<ul>
<li>vue推荐的做法是webpack + vue-loader的单文件格式，vue保留了html、css、js<br>分离的写法，数据绑定使用mustache风格，样式直接使用css，在<code>&lt;style&gt;</code>标签提供<br>了一个可选的scoped属性，用开控制css仅对当前组件生效还是全局生效。</li>
</ul>
</li>
<li>react<ul>
<li>react推荐的做法是JSX + inline style，也就是把HTML和CSS全都写进JavaScript<br>中，即“all in js”，react没有模板，直接就是一个渲染函数，返回一个虚拟DOM树，<br>在render()编写的JSX语法最终会被编译成原生JavaScript。</li>
</ul>
</li>
</ul>
<h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><ul>
<li>vue<ul>
<li>vue提供了CLI脚手架，可以帮助我们非常容易地构建项目，全局安装后用vue create<br>命令创建新项目，可以让用户自定义选择需要安装的模板。</li>
</ul>
</li>
<li>react<ul>
<li>react提供了create-react-app，但只提供一个构建单页面应用的默认选项。</li>
</ul>
</li>
</ul>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><ul>
<li>vue<ul>
<li>vue实现双向数据绑定，view的变化能实时让model改变，而model的变化也能实时<br>更新到view</li>
<li>vue采用数据劫持 + 发布-订阅模式，通过Object.defineProperty对数据进行操作，<br>为数据动态添加getter和setter方法，当获取数据的时候会触发对应的getter方法，<br>当设置数据的时候会触发对应的setter方法，从而进一步触发vm的watcher方法，然后<br>对数据进行更改，vm则进一步触发视图更新操作。</li>
</ul>
</li>
<li>react<ul>
<li>react是单向数据流，react中属性是不允许更改的，状态是允许更改的。react中组件<br>不允许通过this.state这种方法直接更改组件的状态。自身设置的状态，可以通过setState<br>进行更改。</li>
<li>setState是异步的，导致获取dom可能拿到的还是之前的内容，所以需要在setState<br>第二个参数(回调函数)中获取更新后的内容。</li>
</ul>
</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul>
<li>vue<ul>
<li>vue中每个组件内部自动实现了shouldComponentUpdate的优化，在vue中里面由于<br>依赖追踪系统的存在，当任意数据变动的时候，Vue的每一个组件都能精确的知道自己是<br>否需要重绘。而在react中需要我们手动去优化其性能，但s是当数据特别多的时候vue中<br>的watcher也会特别多，从而造成页面卡顿，所以一般大西瓜项目会倾向于react。</li>
</ul>
</li>
<li>react<ul>
<li>当props或state发生改变的时候会触发shouldComponentUpdate生命周期函数，它<br>是用来控制组件是否被重新渲染的，如果它返回true，则执行render函数，更新组件；<br>如果它返回false，则不会触发重新渲染的过程。</li>
<li>如果希望更新之前和之前的状态进行一个对比，这个时候需要重写shouldCompnentUpdate<br>来避免不必要的dom操作，对比当前的props或state和更新后的nextProps或nextState，<br>返回true时，组件更新；返回false，不更新，节省性能。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue、React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝、浅拷贝</title>
    <url>/2019/07/29/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h2><span id="more"></span>
<pre><code>浅拷贝：只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。

深拷贝：会创造一个一模一样的对象，新旧对象不共享内存，修改新对象不会影响原对象。

浅拷贝实现：
    1.自定义函数
    function shallowCopy (initialObj) &#123;
        var obj = &#123;&#125;
        for (var prop in initialObj) &#123;
            if (initialObj.hasOwnProperty(prop)) &#123;
                obj[prop] = initialObj[prop]
            &#125;
        &#125;
        return obj
    &#125;
    
    2.ES6 的Object.assign()  //目标对象只有一层的时候，就是深拷贝
    let newObj = Object.assign(&#123;&#125;, obj)
    
    3.ES6 的对象扩展（当数组或对象只有一层的时候，扩展运算符就相当于深拷贝）
    let newObj = &#123;...obj&#125;
    
深拷贝实现
    1.JSON.stringify 和 JSON.parse
    let newObj = JSON.parse(JSON.stringify(obj))
    
    2.lodash函数库的_.cloneDeep方法
    var _ = require(&#39;lodash&#39;)
    var newObj = _.cloneDeep(obj)
    
    3.slice方法实现数组深拷贝
    let arr1 = [1,2,3,4]
    let arr2 = arr1.slice(0)
    arr1[0] = 5
    console.log(arr1) //[5,2,3,4]
    console.log(arr2) //[1,2,3,4]
    
    4.concat实现数据深拷贝
    let arr1 = [1,2,3,4]
    let arr2 = arr1.concat()
    arr1[0] = 5
    console.log(arr1) //[5,1,2,3]
    console.log(arr2) //[1,2,3,4]
    
    5.自己封装
    function deepClone(obj) &#123;
        let objClone = Array.isArray(obj) ? [] : &#123;&#125;;
        if (obj &amp;&amp; typeof obj === &quot;object&quot;) &#123;
            // for...in 会把继承的属性一起遍历
            for (let key in obj) &#123;
                // 判断是不是自有属性，而不是继承属性
                if (obj.hasOwnProperty(key)) &#123;
                    //判断ojb子元素是否为对象或数组，如果是，递归复制
                    if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123;
                        objClone[key] = this.deepClone(obj[key]);
                    &#125; else &#123;
                        //如果不是，简单复制
                        objClone[key] = obj[key];
                    &#125;
                &#125;
            &#125;
        &#125;
        return objClone;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器是怎么对HTML5的离线存储资源进行管理和加载的？</title>
    <url>/2019/10/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%B9HTML5%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E5%92%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="浏览器是怎么对HTML5的离线存储资源进行管理和加载的？"><a href="#浏览器是怎么对HTML5的离线存储资源进行管理和加载的？" class="headerlink" title="浏览器是怎么对HTML5的离线存储资源进行管理和加载的？"></a>浏览器是怎么对HTML5的离线存储资源进行管理和加载的？</h2><ul>
<li><p>在线的情况下：浏览器发现html头部有manifest属性，会请求manifest文件，如果是<br>第一次访问app，浏览器会根据manifest文件的内容下载相应的资源并进行离线缓存。如果<br>已经离线存储了，浏览器会使用离线的资源加载页面，然后浏览器会比对新的manifest文件<br>与旧的manifest文件，如果文件没有发生改变，就不要做任何操作，如果文件改变，就会重新<br>下载文件中的资源并进行离线存储。</p>
</li>
<li><p>离线的情况下：浏览器就直接使用离线存储的资源。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器关闭清除token</title>
    <url>/2021/05/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%97%AD%E6%B8%85%E9%99%A4token/</url>
    <content><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>浏览器关闭会出发 <strong>beforeunload</strong> ，<strong>unload</strong> 这两个事件。</li>
<li>浏览器刷新也会触发，还会触发<strong>load</strong>事件</li>
</ul>
<h2 id="如何清除token"><a href="#如何清除token" class="headerlink" title="如何清除token"></a>如何清除token</h2><ul>
<li><p>方案一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.onbeforeunload = function () &#123;</span><br><span class="line">    localStorage.removeItem(&quot;token&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点： 刷新也会清空token</p>
</li>
<li><p>方案二</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.onunload = function() &#123;</span><br><span class="line">    localStorage.setItem(&quot;lastTime&quot;,new Date().getTime())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">    let lastTime = localStorage.getItem(&quot;lastTime&quot;);</span><br><span class="line">    const interval = 3 * 1000;</span><br><span class="line">    // 如果时间间隔大于3s，则清除token</span><br><span class="line">    if (!lastTime || new Date().getTime() - lastTime &gt; interval) &#123;</span><br><span class="line">        localStorage.remove(&quot;token&quot;);</span><br><span class="line">        console.log(&quot;remove token&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;time is less than not remove token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>补充<br>  可以使用sessionStorage代替localStorage来存储token，当关闭浏览器时会自动清除token，sessionStorage不是持久化的本地存储，而是会话级别的存储，而localStorage是持久化的本地存储，除非主动删除数据，否则数据是不会过期的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>token</category>
      </categories>
      <tags>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客学习知识总结-1</title>
    <url>/2019/07/06/%E7%89%9B%E5%AE%A2%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-1/</url>
    <content><![CDATA[<h2 id="牛客学习知识总结"><a href="#牛客学习知识总结" class="headerlink" title="牛客学习知识总结"></a>牛客学习知识总结</h2><span id="more"></span>
<ul>
<li><p>超链接</p>
<ul>
<li>a标签的href的属性值是url，里面必须包含协议，没有协议就会解析成相对路径。</li>
</ul>
</li>
<li><p>HTTP状态码分类：</p>
<ul>
<li>1** 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2** 成功，操作被成功接受并处理。<ul>
<li>200 服务端成功处理了请求并返回内容</li>
</ul>
</li>
<li>3** 重定向，需要进一步的操作以完成请求<ul>
<li>301 永久重定向</li>
<li>302 临时重定向</li>
<li>304 资源未被修改，返回一个304状态吗然后从本地缓存中加载请求的资源</li>
</ul>
</li>
<li>4** 客户端错误，请求包含语法错误或无法完成请求。<ul>
<li>404 （页面丢失）未找到资源</li>
<li>403 服务器拒绝请求</li>
<li>408 （请求超时） 服务器等候请求时发生超时</li>
</ul>
</li>
<li>5** 服务器错误，服务器在处理请求的过程中发生错误<ul>
<li>503 服务器暂时不可用</li>
<li>504 服务器内部错误<!--more--></li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP协议的特征：</p>
<ul>
<li>C/S(客户端/服务器)模式：只要客户端和服务器知道如何处理数据内容，任何类型的数据<br>都可以通过HTTP来发送，客户端和服务器指定合适的MIME-type内容类型。</li>
<li>简单快速</li>
<li>灵活</li>
<li>无连接：限制每次连接只处理一个请求，收到客户的应答后即断开连接，可以节省传输时间。</li>
<li>无状态：对于事物处理没有记忆能力，意味着如果后续处理需要前面的信息，则必须重传，<br>这样就会导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就会很快。</li>
</ul>
</li>
<li><p>get 和 post的请求区别？</p>
<ul>
<li>区别一：<ul>
<li>get重点是从服务器上获取资源</li>
<li>post重点是向服务器发送数据</li>
</ul>
</li>
<li>区别二：<ul>
<li>get传输数据通过url请求，以field（字段）=value的形式放在url后，用“？”连接，<br>多个请求数据间用“&amp;”连接，过程用户可见。</li>
<li>post传输数据放在请求体（request body）中发送给服务器，用户不可见。</li>
</ul>
</li>
<li>区别三：<ul>
<li>get传输数据大小有限制，但效率较高</li>
<li>post可以传输大量数据，所以上传文件用post方式</li>
</ul>
</li>
<li>区别四：<ul>
<li>get请求不安全，因为参数直接暴露在url上，不能用来传递敏感信息。</li>
<li>post较get安全性较高。</li>
</ul>
</li>
<li>区别五：<ul>
<li>get方式只能支持ASCII字符，向服务传的中文字符可能会乱码。</li>
<li>post支持标准字符集，可以正确传递中文字符。</li>
</ul>
</li>
<li>区别六：<ul>
<li>get在浏览器回退是无害的，而post会再次提交请求。</li>
</ul>
</li>
<li>区别七<ul>
<li>get请求会被浏览器主动cache（缓存），而post不会除非手动设置。</li>
</ul>
</li>
</ul>
</li>
<li><p>iframe有哪些缺点？</p>
<ul>
<li>iframe会阻塞主页面的onload事件</li>
<li>通过oIframe.contentWindow寻找子window对象</li>
<li>通过window.parent寻找父级窗体</li>
<li>通过window.top寻找顶级窗体</li>
<li>window.location.hash 解决父页面向子页面传值</li>
<li>window.name 解决子页面向父页面传值</li>
<li>不利于SEO，搜索引擎的检索程序无法解读这种页面（百度spider不收录，浏览器对iframe框架的兼容问题）</li>
<li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>
<li>如果需要使用iframe，最好通过javascript动态给iframe添加src属性值。</li>
</ul>
</li>
<li><p>xhtml和html有什么区别？</p>
<ul>
<li>性能方面 <ul>
<li>XHTML兼容性好，兼容各大浏览器、手机以及PDA，使浏览器可以快速正确编译网页</li>
</ul>
</li>
<li>书写习惯方面<ul>
<li>HTML标签不区分大小写，XHTML所有标签必须小写</li>
<li>XHTML必须成双成对</li>
<li>HTML对标签顺序要求不严格，XHTML标签顺序必须正确</li>
<li>等等</li>
</ul>
</li>
</ul>
</li>
<li><p>html和xml的区别？</p>
<ul>
<li>xml被设计用来传输和存储数据，其焦点是数据的内容</li>
<li>html被设计用来显示数据，其焦点是数据的外观</li>
<li>html旨在显示信息，而xml旨在传输信息</li>
<li>xml在定义标记时区分大小写，而html不区分大小写</li>
</ul>
</li>
<li><p>link和@import的区别：</p>
</li>
</ul>
<p><strong>两者都是外部引用CSS的方式，但有一定的区别</strong></p>
<pre><code>+ link是XHTML标签，除了加载CSS外，还可以加载其他文件；@import只能加载CSS。

+ 解析到link时，页面会同步加载Css；@import在页面加载完后加载Css。

+ link是XHTML标签，无兼容问题；@import是在**CSS2.1**之后提出的，只有再IE5以上才能识别。

+ link可以js动态引入，@import不行

+ @import的最佳写法： @import url(style.css),其他写法：@import &#39;style.css&#39;、
@import &quot;style.css&quot;、@import url(&#39;style.css&#39;)、@import url(&quot;style.css&quot;)
</code></pre>
<ul>
<li>viewport</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  // width            设置viewport宽度，为一个正整数，或字符串‘device-width’</span><br><span class="line">  // device-width     设备宽度</span><br><span class="line">  // height           设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置</span><br><span class="line">  // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数</span><br><span class="line">  // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数</span><br><span class="line">  // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数</span><br><span class="line">  // user-scalable    是否允许手动缩放</span><br></pre></td></tr></table></figure>

<ul>
<li><p>单行文本溢出省略号</p>
<p>  overflow: hidden;</p>
<p>  text-overflow:ellipsis;</p>
<p>  white-space: nowrap;</p>
</li>
<li><p>多行文本溢出省略号</p>
<p>  display: -webkit-box;</p>
<p>  -webkit-box-orient: vertical;</p>
<p>  -webkit-line-clamp: 3;</p>
<p>  overflow: hidden;</p>
</li>
<li><p>换行标签</p>
<p>  word-wrap: break-word</p>
</li>
</ul>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title>说一下浏览器的缓存机制</title>
    <url>/2019/07/10/%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><span id="more"></span>
<pre><code>缓存可以简单高效的提高性能优化，对于一个数据请求来说，分为网络请求、后端处理、浏览器
响应三个步骤，浏览器缓存可以优化网络请求和响应部分。比如：直接换用缓存而不发起请求，
或者发起请求但后端存储的数据和前端一致，就没有必要将数据回传，这样就减少的响应数据，
使得缓存文件可以重复利用，减少带宽，减低网络负荷。
</code></pre>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><pre><code>网络请求会先从缓存位置上面查找缓存，如果都没有命中，才会去请求网络资源，从缓存位置
分为四种，并且各自有优先级：
- Service Worker
- Memory Cache
- Disk Cache
- Push Cache
</code></pre>
<h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Service Worker 是运行在浏览器背后的独立线程，一般可以用<br>来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为<br>Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。<br>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、<br>如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册<br> Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问<br> 的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，<br> 否则就去请求数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数<br> 获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级<br> 去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显<br> 示我们是从 Service Worker 中获取的内容。</p>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面<br>上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，<br>可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就<br>被释放了。</p>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之<br> Memory Cache 胜在容量和存储时效性上。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会<br>根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源<br>已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不<br>会再次去请求数据。</p>
<h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种<br>缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，<br>并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中<br>的缓存指令。</p>
<p><code>如果以上四种缓存都没有命中的话，只能发起网络请求来获取资源了。 为了性能上的考虑，大部分接口都应该选择好缓存策略， 浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置HTTP Header来实现的。</code></p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><pre><code>强缓存：不会向服务器发送请求，直接从缓存中读取资源，可以通过HTTP Header实现：Expires
和Cache-Control。
+ Expires：缓存过期时间，用来指定资源到期的时间，是服务端的具体的时间点，结合Last-modified
使用，Expires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

+ Cache-Control：和多个指令配合使用，实现资源缓存。

+ Expires和Cache-Control同时存在，Cache-Control优先级高于Expires。
</code></pre>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><pre><code>协商缓存就是强缓存失效后，浏览器携带缓存表示向服务器发起请求，由服务器根据缓存表示决定
是否使用缓存的过程，主要有以下两种情况：
+ 协商缓存生效，返回304和Not Modified

+ 协商缓存失效，返回200和请求结果。

+ 协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。

+ ETag是服务器响应请求时，返回当前资源文件的一个唯一标识（有服务器生成），只要资源有变化
，ETag就会重新生成。
</code></pre>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><pre><code>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用
缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和
Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，
那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；
生效则返回304，继续使用缓存
</code></pre>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>简单说一下原型链</title>
    <url>/2019/07/16/%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="简单说下原型链"><a href="#简单说下原型链" class="headerlink" title="简单说下原型链"></a>简单说下原型链</h2><span id="more"></span>
<ul>
<li><p>原型链是由原型对象组成的，每个对象都有__proto__属性，指向了创建该对象的构造函数的<br>原型，__proto__将对象连接起来组成了原型链。</p>
</li>
<li><p>原型链：用来实现继承和共享属性的有限对象链。</p>
</li>
<li><p>每个对象都有__proto__（隐式原型）属性，指向创建该对象的构造函数的原型。其实<br>这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能<br>访问到，所以使用 <em>proto</em> 来访问。</p>
</li>
<li><p>对象的隐式原型等于对象的构造函数的显式原型：obj.<strong>proto</strong> === Object.prototype</p>
</li>
<li><p>访问属性的时候，js引擎会调用内部的默认。。。。。。[[Get]]操作，[[Get]]操作首先会检查对象本身是否包含这个属性<br>如果对象没有这个属性，则对象可以通过__proto__来寻找不属于该对象的属性，<strong>proto</strong><br>将对象和原型连接起来形成原型链</p>
</li>
<li><p>Function.prototype 和 Object.prototype是两个特殊的对象，他们由引擎创建。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对闭包的理解？</title>
    <url>/2019/07/17/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="说说你对闭包的理解？"><a href="#说说你对闭包的理解？" class="headerlink" title="说说你对闭包的理解？"></a>说说你对闭包的理解？</h2><span id="more"></span>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ul>
<li><p>函数可以记住并访问所在的词法作用域，就产生了闭包。或简单理解为：定义在一个函数内部的<br>函数，内部函数持有外部函数内变量或参数的引用。</p>
</li>
<li><p>内部函数被保存在全局，内部函数依赖外部函数，外部函数参数和变量不会被垃圾回收机制回收，<br>这些变量会始终存在于内存中。</p>
</li>
</ul>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译<br>阶段由编译器完成，将代码编译成可执行代码，这个阶段作用域规则会确定。执行阶段由js<br>引擎完成，主要任务是执行可执行代码，执行期上下文在这个阶段创建。</li>
<li>编译器<ul>
<li>语法分析</li>
<li>词法分析</li>
<li>可执行代码生成</li>
<li>作用域规则确定</li>
<li>…</li>
</ul>
</li>
<li>js引擎<ul>
<li>执行上下文</li>
<li>代码执行</li>
<li>垃圾回收</li>
<li>…</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">    return bar</span><br><span class="line">&#125;</span><br><span class="line">var baz = foo()</span><br><span class="line">baz() //2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//也可以是作为参数传递给外部函数</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    baz(bar)</span><br><span class="line">&#125;</span><br><span class="line">function baz(fn) &#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">//也可以间接的分配给全局变量</span><br><span class="line">var fn</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    fn = bar</span><br><span class="line">&#125;</span><br><span class="line">function baz() &#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">baz()</span><br></pre></td></tr></table></figure>

<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li><p>可以读取函数内部的变量</p>
</li>
<li><p>柯里化</p>
</li>
<li><p>封装对象的私有属性和私有方法（收敛权限）,例如模块实例</p>
</li>
<li><p>模块的两个特征：</p>
<ul>
<li>为了创建一个内部作用域而调用了一个包装函数</li>
<li>包装函数必须至少一个对内部函数的引用，这样就会创建涵盖整个函数内部作用域的闭包<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = (function CoolModule()&#123;</span><br><span class="line">    var something = &quot;cool&quot;</span><br><span class="line">    var another = [1, 2, 3]</span><br><span class="line">    </span><br><span class="line">    function doSomething() &#123;</span><br><span class="line">        console.log(something)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function doAnother() &#123;</span><br><span class="line">        console.log(another.join(&#x27;!&#x27;))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">foo.doSomething()   //cool</span><br><span class="line">foo.doAnother()     //1!2!3</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>避免污染全局变量</p>
</li>
</ul>
<h4 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h4><ul>
<li>会增大内存使用量，容易造成内存泄漏。</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>在退出函数前，将不使用的局部变量全部删除。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>获取唯一id的三种方法</title>
    <url>/2022/01/04/%E8%8E%B7%E5%8F%96%E5%94%AF%E4%B8%80id%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const UUID = (len = 32) =&gt; &#123;</span><br><span class="line">  return &quot;xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx&quot;</span><br><span class="line">    .replace(/[xy]/g, function replace(c) &#123;</span><br><span class="line">      /* eslint-disable no-bitwise */</span><br><span class="line">      const r = (Math.random() * 16) | 0;</span><br><span class="line">      const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8;</span><br><span class="line"></span><br><span class="line">      return v.toString(16);</span><br><span class="line">    &#125;)</span><br><span class="line">    .substring(0, len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="nanoid"><a href="#nanoid" class="headerlink" title="nanoid"></a>nanoid</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const nanoid = (t = 21) =&gt; &#123;</span><br><span class="line">  let e = &quot;&quot;,</span><br><span class="line">    r = crypto.getRandomValues(new Uint8Array(t));</span><br><span class="line">  for (; t--; ) &#123;</span><br><span class="line">    let n = 63 &amp; r[t];</span><br><span class="line">    e +=</span><br><span class="line">      n &lt; 36</span><br><span class="line">        ? n.toString(36)</span><br><span class="line">        : n &lt; 62</span><br><span class="line">        ? (n - 26).toString(36).toUpperCase()</span><br><span class="line">        : n &lt; 63</span><br><span class="line">        ? &quot;_&quot;</span><br><span class="line">        : &quot;-&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原生方法"><a href="#原生方法" class="headerlink" title="原生方法"></a>原生方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const id = URL.createObjectURL(new Blob()).substr(-36)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2019/06/29/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%AE%83/</url>
    <content><![CDATA[<h2 id="什么是跨域？解决跨域的方法有哪些"><a href="#什么是跨域？解决跨域的方法有哪些" class="headerlink" title="什么是跨域？解决跨域的方法有哪些?"></a>什么是跨域？解决跨域的方法有哪些?</h2><span id="more"></span>
<ul>
<li><p>同源策略</p>
<ul>
<li>是一种浏览器的安全策略</li>
<li>协议、域名、端口号必须完全一致</li>
<li>不同源的客户端脚本在没有明确的授权的情况下，不能读取对方的资源</li>
</ul>
</li>
<li><p>跨域</p>
<ul>
<li>指一个域下的文档或脚本尝试去请求另一个域下的资源。</li>
</ul>
</li>
</ul>
<!-- more -->

<ul>
<li><p>解决跨域</p>
<ul>
<li>jsonp</li>
<li>postMessage 跨域</li>
<li>WebSocket 协议跨域</li>
<li>CORS（跨域资源共享，服务端设置Access-Control-Allow-Origin，前端无需设置，<br>若要带cookie请求，前后端都要设置）</li>
<li>nginx 反向代理接口跨域</li>
<li>document.domain(两个页面通过js强制设置document.domain为基础主域，针对基础域名相同的情况)</li>
<li>window.name + iframe</li>
<li>location.hash + iframe</li>
<li>…</li>
</ul>
</li>
<li><p>实现jsonp跨域</p>
<ul>
<li>通常为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一台独立域名<br>的服务器上，在html页面中再通过响应的标签从不同域名加载静态资源。jsonp就是利用此<br>原理，动态创建script，再请求一个带参网址实现跨域通信</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var script = document.createElement(&#x27;script&#x27;)</span><br><span class="line">    script.type = &#x27;text/javascript&#x27;</span><br><span class="line">    </span><br><span class="line">    //传参一个回调函数名给后端，方便后端返回时执行这个前端定义的回调函数</span><br><span class="line">    script.src = &#x27;http://www.xxx.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">    </span><br><span class="line">    //回调执行函数</span><br><span class="line">    function handleCallbak(res) &#123;</span><br><span class="line">        alert(JSOn.stringify(res))</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>阻止冒泡以及默认事件</title>
    <url>/2019/07/29/%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E4%BB%A5%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="如何阻止冒泡"><a href="#如何阻止冒泡" class="headerlink" title="如何阻止冒泡?"></a>如何阻止冒泡?</h2><span id="more"></span>
<pre><code>W3C的方法e.stopPropagation(),IE使用e.cancelBubble = true;

封装：
    //阻止冒泡行为
    function stopBubble(e) &#123;
        //如果提供了事件对象，则这是一个非IE浏览器
        if (e &amp;&amp; e.stopPropagation) e.stopPropagation()
        //IE的方法
        else window.event.cancelBubble = true
    &#125;
    
</code></pre>
<h2 id="如何阻止默认事件？"><a href="#如何阻止默认事件？" class="headerlink" title="如何阻止默认事件？"></a>如何阻止默认事件？</h2><pre><code>W3C的方法是e.preventDefault(),IE使用e.returnValue = false

封装：
    //阻止浏览器的默认行为
    function stopDefault (e) &#123;
        if (e &amp;&amp; e.preventDefault) e.preventDefault()
        //IE中阻止默认事件的方法
        else window.event.returnValue = false
        return false
    &#125;
</code></pre>
<h2 id="补充：事件绑定的封装"><a href="#补充：事件绑定的封装" class="headerlink" title="补充：事件绑定的封装"></a>补充：事件绑定的封装</h2><pre><code>function addEvent(element,type,handle) &#123;
    if(element.addEventListener)&#123;
        element.addEventListener(type,handle,false);
    &#125;else if(element.attachEvent)&#123;
        element.attachEvent(&#39;on&#39;+type,function () &#123;
            handle.call(element);
        &#125;)
    &#125;else &#123;
        element[&#39;on&#39;+type] = handle;
    &#125;
&#125;
</code></pre>
<h2 id="JS如何设置获取盒子模型对应的宽和高？"><a href="#JS如何设置获取盒子模型对应的宽和高？" class="headerlink" title="JS如何设置获取盒子模型对应的宽和高？"></a>JS如何设置获取盒子模型对应的宽和高？</h2><ul>
<li><p>dom.style.width/height</p>
</li>
<li><p>dom.currentStyle.width/height (ie支持)</p>
</li>
<li><p>window.getComputedStyle(dom).width/height</p>
</li>
<li><p>dom.getBoundingClientRect().width/height</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>面试居中问题</title>
    <url>/2019/07/29/%E9%9D%A2%E8%AF%95%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>##如何居中一个元素？</p>
<h4 id="行级元素水平居中-单行文本水平居中"><a href="#行级元素水平居中-单行文本水平居中" class="headerlink" title="行级元素水平居中(单行文本水平居中)"></a>行级元素水平居中(单行文本水平居中)</h4><pre><code>text-align: center;
</code></pre>
<span id="more"></span>
<h4 id="块级元素水平居中"><a href="#块级元素水平居中" class="headerlink" title="块级元素水平居中"></a>块级元素水平居中</h4><pre><code>1.宽度固定，自身设置  margin: 0 auto;
2.宽度不固定： 父元素设置 text-align: center;
             自身设置：display: inline-block;
</code></pre>
<h4 id="行级元素垂直居中-单行文本垂直居中"><a href="#行级元素垂直居中-单行文本垂直居中" class="headerlink" title="行级元素垂直居中(单行文本垂直居中)"></a>行级元素垂直居中(单行文本垂直居中)</h4><pre><code>line-height: height;
</code></pre>
<h4 id="行级元素垂直居中-多行文本垂直居中"><a href="#行级元素垂直居中-多行文本垂直居中" class="headerlink" title="行级元素垂直居中(多行文本垂直居中)"></a>行级元素垂直居中(多行文本垂直居中)</h4><pre><code>1.父元素设置 display: table; //table是块状元素成为一个块级表格
2.子元素设置 display: table-cell;  //子元素设置成表格单元格
           vertical-align: middle; //使表格内容垂直居中显示
</code></pre>
<h4 id="实现元素的水平垂直居中"><a href="#实现元素的水平垂直居中" class="headerlink" title="实现元素的水平垂直居中"></a>实现元素的水平垂直居中</h4><pre><code>方法一： margin: auto;

    父元素：position: relative;
           width: 300px;
           height: 300px;
           border: 1px solid red;
           
    子元素：position: absolute;
           width: 100px;
           height: 100px;
           margin: auto;
           top: 0;
           left: 0;
           right: 0;
           bottom: 0;
           
方法二： 负margin法
    .box &#123;
            width: 400px;
            height: 200px;
            position: relative;
            background: red;
        &#125;
    .content &#123;
        width: 200px;
        height: 100px;
        position: absolute;
        top: 50%;
        left: 50%;
        
        &lt;!--margin-left: -100px;//宽高已知--&gt;
        &lt;!--margin-top: -50px;--&gt;
        
        transform: translate(-50%, -50%);//宽高未知
        background: green;
    &#125;
    
方法三： flex布局
    .box &#123;
        width: 400px;
        height: 200px;
        background: red;
        display: flex;
        justify-content: center;    //控制水平方向的居中
        align-items: center;    //控制垂直方向的居中
    &#125;
    .content &#123;
        width: 200px;
        height: 100px;
        background: green;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>简书面经笔记（一）</title>
    <url>/2019/07/28/%E7%AE%80%E4%B9%A6%E9%9D%A2%E7%BB%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前端面经笔记-一"><a href="#前端面经笔记-一" class="headerlink" title="前端面经笔记(一)"></a>前端面经笔记(一)</h2><span id="more"></span>
<h4 id="如何判断一个对象是否为数组"><a href="#如何判断一个对象是否为数组" class="headerlink" title="如何判断一个对象是否为数组"></a>如何判断一个对象是否为数组</h4><pre><code>1. Array.prototype.isPrototypeOf(obj)方法，判断Array.prototype是不是在obj的原型链中，
如果在，则返回true，否则返回false。

2. obj instanceof Array

3. Object.prototype.toString.call(obj); //(===&quot;[object Array]&quot;)

4.Array.isArray(obj)
</code></pre>
<h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><pre><code>1.macro-task(宏任务)：包括整体代码script、setTimeout、setInterval
2.micro-task(微任务)：Promise.then、process.nextTick

    
</code></pre>
<h4 id="Http的持久连接和管线化"><a href="#Http的持久连接和管线化" class="headerlink" title="Http的持久连接和管线化"></a>Http的持久连接和管线化</h4><pre><code>1. 什么是持久连接？
    HTTP1.1规定了默认保持持久连接，数据传输完成也保持TCP连接不断开，等待同域名下
    继续使用这个通道传输数据,在一个TCP连接上传输多个HTTP请求和响应。
    
    持久连接避免了重新建立连接，大大减少了建立和关闭连接的消耗和延迟，HTTP的连接是建立
    在TCP协议之上的，建立一条TCP连接需要三次握手，TCP连接关闭需要四次挥手，这些都需要时间。
    
2. 什么是管线化？
    持久连接：
        请求1 ——&gt; 响应1 ——&gt; 请求2 ——&gt; 响应2
    管线化：
        请求1 ——&gt; 请求2 ——&gt; 响应1 ——&gt; 响应2
        
    管线化机制需要通过持久化连接完成。
    
    持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后，
    才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。
    实现并行发送请求。
    
    只有GET和HEAD请求可以进行管线化，而POST有所限制。
    
    初次建立连接不应启动管线机制，因为对方服务器不一定支持HTTP1.1版本的协议。
    
</code></pre>
<h4 id="为什么利用多个域名来存储网站资源会更有效？"><a href="#为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="为什么利用多个域名来存储网站资源会更有效？"></a>为什么利用多个域名来存储网站资源会更有效？</h4><pre><code>1.CDN 是构建在网络之上的内容分发网络，可以使用户就近获取资源，减低网络拥塞，提高用户
访问的响应效率以及命中率。

2.突破浏览器的并发限制，同一时间针对同一域名下的请求有一定的数量限制，超过限定数目
的请求会被阻塞。

3.节约cookie带宽

4.减少主域名的连接数，优化页面响应速度

5.防止不必要的安全问题
</code></pre>
<h4 id="CSS权重（156进制）"><a href="#CSS权重（156进制）" class="headerlink" title="CSS权重（156进制）"></a>CSS权重（156进制）</h4><pre><code>1. ！import  权值：infinite 无穷大

2. 内联样式， 权值1000

3. ID选择器， 权值： 100

4. 类、伪类、属性选择器， 权值： 10

5.标签、伪元素选择器， 权值： 1

6.通配符选择器 *，子选择器 &gt;,相邻选择器 +，权值： 0

权值相等，后来居上
</code></pre>
<h4 id="html5的新特性"><a href="#html5的新特性" class="headerlink" title="html5的新特性"></a>html5的新特性</h4><pre><code>1. 添加了video、radio标签
2. 添加了canvas画布和svg渲染矢量图片
3. 添加了一些语义化的标签 header、footer、main、section...
4. input的type值新添加了很多属性（email，search，color，number...）
5. 添加了地理位置定位功能 Geolocation API
6. 添加了web Storage存储功能，localStorage和sessionStorage
7. 使用html5，通过创建cache manifest文件，可以轻松地创建web应用的离线版本
8. web worker创造多线程环境，是运行在后台的javaScript。
9。 服务端推送（EventSource用于接受服务端发送事件通知）
</code></pre>
<h4 id="CSS3新添加的特性？"><a href="#CSS3新添加的特性？" class="headerlink" title="CSS3新添加的特性？"></a>CSS3新添加的特性？</h4><pre><code>1. 媒体查询
2. transform，transition，translate，scale，rotate等相关动画效果
3. box-shadow，text-shadow等特效
4. CSS3 @font-face规则，可以引入任意字体
5. CSS3 @keyframes规则，创建动画(配合animation使用)
6. 2D、3D转化
7. 添加了border-radius、border-image、column-count、resize、box-sizing
、outline-offset等属性
</code></pre>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><pre><code>基本数据类型：Null、Undefined、String、Boolean、Number
ES6：Symbol
ES10：Bigint（可以突破安全整数限制，安全的存储和操作最大整数之外的整数，不会损失精度）
</code></pre>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题分享——作用域</title>
    <url>/2019/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var num1 = 55;</span><br><span class="line">var num2 = 66;</span><br><span class="line"></span><br><span class="line">function f1 (num, num1) &#123;</span><br><span class="line">    //形参num, num1相当于在函数内进行了一下声明：</span><br><span class="line">    //var num</span><br><span class="line">    //var num1</span><br><span class="line">    num = 100;</span><br><span class="line">    num1 = 100;</span><br><span class="line">    num2 = 100; //相当于在全局内进行了声明</span><br><span class="line">    console.log(num); //100</span><br><span class="line">    console.log(num1); //100</span><br><span class="line">    console.log(num2); //100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(num1, num2);//num1 = 55; num2 = 66;</span><br><span class="line">console.log(num1); //55</span><br><span class="line">console.log(num2); //100</span><br><span class="line">console.log(num); //报错</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">55</span><br><span class="line">100</span><br><span class="line">Uncaught ReferenceError: num is not defined</span><br></pre></td></tr></table></figure>

<h4 id="创建10个标签，点击的时候弹出来对面的下标序号"><a href="#创建10个标签，点击的时候弹出来对面的下标序号" class="headerlink" title="创建10个标签，点击的时候弹出来对面的下标序号"></a>创建10个<a>标签，点击的时候弹出来对面的下标序号</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    (function(i)&#123;</span><br><span class="line">        var a = document.createElement(&#x27;a&#x27;)</span><br><span class="line">        a.innerHTML = i + &#x27;&lt;br&gt;&#x27;</span><br><span class="line">        a.addEventListener(&#x27;click&#x27;, function(e) &#123;</span><br><span class="line">            e.preventDefault()</span><br><span class="line">            alert(i)</span><br><span class="line">        &#125;)</span><br><span class="line">        document.body.appendChild(a)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="闭包实际应用中主要用于封装变量，收敛权限"><a href="#闭包实际应用中主要用于封装变量，收敛权限" class="headerlink" title="闭包实际应用中主要用于封装变量，收敛权限"></a>闭包实际应用中主要用于封装变量，收敛权限</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isFirstLoad() &#123;</span><br><span class="line">    var _list = []</span><br><span class="line">    return function (val) &#123;</span><br><span class="line">        if (_list.indexOf &gt;= 0) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _list.push(val)</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//执行</span><br><span class="line">var firstLoad = isFirstLoad()</span><br><span class="line">firstLoad(10)   //true</span><br><span class="line">firstLoad(10)   //false</span><br><span class="line">firstLoad(20)   //true</span><br><span class="line">firstLoad(20)   //false</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>深度封装typeof判断</title>
    <url>/2019/08/04/%E6%B7%B1%E5%BA%A6%E5%B0%81%E8%A3%85typeof%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h2 id="深度封装typeof判断"><a href="#深度封装typeof判断" class="headerlink" title="深度封装typeof判断"></a>深度封装typeof判断</h2><span id="more"></span>
<pre><code>function myTypeof(val) &#123;
    var type = typeof(val)
    var res = &#123;
        &#39;[object Object]&#39; : &#39;object&#39;,
        &#39;[object Array]&#39; : &#39;array&#39;,
        &#39;[object Number]&#39; : &#39;object number&#39;,
        &#39;[object String]&#39; : &#39;object string&#39;,
        &#39;[object Boolean]&#39; : &#39;object boolean&#39;
    &#125;
    if (val === null) &#123;
        return &#39;null&#39;
    &#125; else if (type == &#39;object&#39;) &#123;
        var str = Object.prototype.toString.call(val)
        return res[str]
    &#125; else &#123;
        return type
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>值类型和引用类型的传递</title>
    <url>/2019/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="值类型和引用类型的传递"><a href="#值类型和引用类型的传递" class="headerlink" title="值类型和引用类型的传递"></a>值类型和引用类型的传递</h2><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age, salary) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f1(person) &#123;</span><br><span class="line">    person.name = &quot;ls&quot;;</span><br><span class="line">    person = new Person(&quot;aa&quot;, 18, 10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person(&quot;zs&quot;, 18, 1000);</span><br><span class="line">console.log(p.name); //zs</span><br><span class="line">f1(p);</span><br><span class="line">console.log(p.name); //ls</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题分享——冒泡排序</title>
    <url>/2019/06/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="JS冒泡排序详解"><a href="#JS冒泡排序详解" class="headerlink" title="JS冒泡排序详解"></a>JS冒泡排序详解</h2><span id="more"></span>
<ul>
<li>说明：<ul>
<li>时间复杂度指的是一个算法执行所消耗的时间。—— O（n*n）</li>
<li>空间复杂度指执行一个程序所需内存的大小。—— O（1）</li>
<li>稳定性，如果a = b,a在b的前面，排序后a仍然在b的前面。——（稳定）</li>
<li>不稳定性，如果a = b,a在b的前面，排序后可能会交换位置。<!--more--></li>
</ul>
</li>
<li>原理：<ul>
<li>依次比较相邻的两个值，如果后面的比前面的小，则将小的元素排到前面。依照这个规则<br>进行多次并且递减的迭代，直到顺序正确。</li>
</ul>
</li>
<li>冒泡排序的写法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sortArr (arr) &#123;</span><br><span class="line">    for (i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        for (j = 0; j &lt;arr.length - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                var temp = arr[j]</span><br><span class="line">                arr[j] = arr[j + 1]</span><br><span class="line">                arr[j + 1] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [2, 5, 6, 3, 3, 2, 9, 4]</span><br><span class="line">console.log(sortArr(arr))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>打乱数组</title>
    <url>/2019/08/07/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h2><span id="more"></span>
<pre><code>1. 常见的sort打乱数组的方法

function shuffle(arr) &#123;
   return arr.sort (function () &#123;
        return Math.random() - 0.5
    &#125;)
&#125;
var arr = [1,2,3,4,5,6,7]
shuffle(arr)

更加简洁的ES6写法

function shuffle(arr) &#123;
    return arr.sort(() =&gt; Math.random() - 0.5)
&#125;

但是这种写法有问题，并不能真正地随机打乱数组，经过大量的实验发现
每个元素仍然有很大的几率出现在它原来的位置附近。

2.洗牌算法
    从最后一个数据开始往前，每次随机一个位置，将两者的位置进行交换，直到数组交换完毕。


ES6实现：

function shuffle(arr) &#123;
    let i =  arr.length;
    while(i) &#123;
        let j = Math.floor(Math.random() * i--);
        [arr[j], arr[i]] = [arr[i], arr[j]];
    &#125;
    return arr
&#125;

var arr = [1,2,3,4,5,6,7]
shuffle(arr)
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题分享——反转数组</title>
    <url>/2019/06/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="JS基础：反转数组"><a href="#JS基础：反转数组" class="headerlink" title="JS基础：反转数组"></a>JS基础：反转数组</h2><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">for (var i = 0; i &lt; arr.length / 2; i++) &#123;</span><br><span class="line">    var temp = arr[i]</span><br><span class="line">    arr[i] = arr[arr.length - 1 - i]</span><br><span class="line">    arr[arr.length - 1 - i] = temp</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr)</span><br><span class="line"></span><br><span class="line">//JS反转函数：reverse()</span><br><span class="line">arr.reverse()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题目手写部分</title>
    <url>/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%89%8B%E5%86%99%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="手写部分"><a href="#手写部分" class="headerlink" title="手写部分"></a>手写部分</h1><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// indexOf</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    let res = [];</span><br><span class="line">    </span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if(res.indexOf(arr[i]) &lt; 0) &#123;</span><br><span class="line">            res.push(arrp[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// includes</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    let res = [];</span><br><span class="line">    </span><br><span class="line">    for (let item of arr) &#123;</span><br><span class="line">        if(!res.includes(item)) &#123;</span><br><span class="line">            res.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 利用filter</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    const res  = arr.filter(function(item, index, array)&#123;</span><br><span class="line">        return array.indexOf(item) === index;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 利用Es6中的Set数据结构(扩展运算符)</span><br><span class="line">const unique = arr =&gt; [...new Set(arr)];</span><br><span class="line"></span><br><span class="line">// Array.form 方法将set结构转换为数组</span><br><span class="line">const unique = arr =&gt; Array.from(new Set(arr));</span><br></pre></td></tr></table></figure>

<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1,[2,[3]]]</span><br><span class="line"></span><br><span class="line">// let res = arr.flat(Infinity)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// let res = JSON.parse(&quot;[&quot;+JSON.stringify(arr).replace(/\[|\]/g,&quot;&quot;) + &quot;]&quot;)</span><br><span class="line"></span><br><span class="line">function flatArr(arr) &#123;</span><br><span class="line">    let res = arr.reduce((accu, curr) =&gt; &#123;</span><br><span class="line">        return accu.concat(Array.isArray(curr) ? flatArr(curr) : curr)</span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatArr(arr))</span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 只考虑对象类型</span><br><span class="line">function shallowCopy(obj) &#123;</span><br><span class="line">    if (typeof obj !== &#x27;object&#x27;) return;</span><br><span class="line">    let newObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    if(obj === null) return obj;</span><br><span class="line">    if(obj instanceof Date) return new Date(obj);</span><br><span class="line">    if(obj instanceof RegExp) return new RegExp(obj); </span><br><span class="line">    </span><br><span class="line">    for (let key in obj) &#123;</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Object.assign()</span><br><span class="line">// arr.slice(0)</span><br><span class="line">// arr.concat()</span><br><span class="line">// 扩展运算符</span><br></pre></td></tr></table></figure>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 只考虑普通对象属性，不考虑内置对象和函数</span><br><span class="line">function deepCone(obj) &#123;</span><br><span class="line">    if (typeof obj !== &#x27;object&#x27;) return;</span><br><span class="line">    let newObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    if(obj === null) return obj;</span><br><span class="line">    if(obj instanceof Date) return new Date(obj);</span><br><span class="line">    if(obj instanceof RegExp) return new RegExp(obj); </span><br><span class="line">    </span><br><span class="line">    for(let key in obj) &#123;</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = typeof obj[key] === &#x27;object&#x27; ? deepClone(obj[key]) : obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JSON.parse(JSON.stringify())</span><br><span class="line">// lodash: _.cloneDeep()</span><br></pre></td></tr></table></figure>

<h2 id="实现一个compose-组合-函数"><a href="#实现一个compose-组合-函数" class="headerlink" title="实现一个compose(组合)函数"></a>实现一个compose(组合)函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function compose(...fn) &#123;</span><br><span class="line">    if(!fn.length) return (v) =&gt; v;</span><br><span class="line">    if(fn.length === 1) return fn[0];</span><br><span class="line">    </span><br><span class="line">    return fn.reduce((accu, curr) =&gt; (...args) =&gt; accu(curr(...args)) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">function fn1(x) &#123;</span><br><span class="line">  return x + 1;</span><br><span class="line">&#125;</span><br><span class="line">function fn2(x) &#123;</span><br><span class="line">  return x + 2;</span><br><span class="line">&#125;</span><br><span class="line">function fn3(x) &#123;</span><br><span class="line">  return x + 3;</span><br><span class="line">&#125;</span><br><span class="line">function fn4(x) &#123;</span><br><span class="line">  return x + 4;</span><br><span class="line">&#125;</span><br><span class="line">const res = compose(fn1, fn2, fn3, fn4);</span><br><span class="line">console.log(res(5)); // 5+4+3+2+1=15</span><br></pre></td></tr></table></figure>


<h2 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.assign = function(target, ...source) &#123;</span><br><span class="line">    if (target === null || target === undefined) &#123;</span><br><span class="line">        throw new TypeError(&quot;Cannot convert undefined or null to object&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let result = Object(target);</span><br><span class="line">    </span><br><span class="line">    source.forEach(function(obj)&#123;</span><br><span class="line">        if (obj !== null) &#123;</span><br><span class="line">            for (let key in obj) &#123;</span><br><span class="line">                if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                    result[key] = obj[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function debounce (func, wait) &#123;</span><br><span class="line">    let timeout;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        </span><br><span class="line">        timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">            func.apply(this, arguments)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 搜索联想，用户在不断输入时，用防抖来节约请求资源</span><br><span class="line">// window触发resize的时候</span><br></pre></td></tr></table></figure>

<h2 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    const previous = 0;</span><br><span class="line">    </span><br><span class="line">    return function() &#123;</span><br><span class="line">        const now = +new Date();</span><br><span class="line">        if(now - previous  &gt; wait) &#123;</span><br><span class="line">            func.apply(this, arguments);</span><br><span class="line">            </span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 鼠标不断点击触发，可以使其单位时间内只触发以此</span><br><span class="line">// 监听滚动事件</span><br><span class="line">// 防止高频点击提交</span><br></pre></td></tr></table></figure>

<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">    // 需要柯里化的函数fn，也可以支持初始参数的传入</span><br><span class="line">    </span><br><span class="line">    return function() &#123;</span><br><span class="line">        //参数缓存在args里面,合并上次参数和本次参数</span><br><span class="line">        args = [...args, ...arguments]</span><br><span class="line">        </span><br><span class="line">        // 判断参数个数，不够继续递归</span><br><span class="line">        if (args.length &lt; fn.length) &#123;</span><br><span class="line">            return curry(fn, ...args)   </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //参数足够返回函数执行结果</span><br><span class="line">            return fn.apply(null, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar(a, b, c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const f = curry(bar)</span><br><span class="line"></span><br><span class="line">console.log(f(1)(2)(3),f(1,2)(3),f(1,2,3))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="如何把字符串中大小写取反"><a href="#如何把字符串中大小写取反" class="headerlink" title="如何把字符串中大小写取反"></a>如何把字符串中大小写取反</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;LiBoShi&quot;;</span><br><span class="line"></span><br><span class="line">str = str.replace(/[a-zA-Z]/g, content =&gt; &#123;</span><br><span class="line">    return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="从S中查找T字符串，找到返回索引值，没有则返回-1，类似indexOf"><a href="#从S中查找T字符串，找到返回索引值，没有则返回-1，类似indexOf" class="headerlink" title="从S中查找T字符串，找到返回索引值，没有则返回-1，类似indexOf"></a>从S中查找T字符串，找到返回索引值，没有则返回-1，类似indexOf</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 普通方法</span><br><span class="line">function myIndexOf(T) &#123;</span><br><span class="line">    let index = -1;</span><br><span class="line">    for(let i = 0; i &lt;= this.length - T.length; i++) &#123;</span><br><span class="line">        if (this.substr(i, T.length) === T) &#123;</span><br><span class="line">             return index = i;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String.prototype.myIndexOf = myIndexOf;</span><br><span class="line">// 正则方法</span><br><span class="line">function myIndexOf(T) &#123;</span><br><span class="line">    let reg = new RegExp(T);</span><br><span class="line">    let res = reg.exec(this);</span><br><span class="line">    </span><br><span class="line">    return res === null ? -1 : res.index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myCall = function(context, ...args) &#123;</span><br><span class="line">    const ctx = context || window;</span><br><span class="line">    const fn = Symbol();</span><br><span class="line">    </span><br><span class="line">    ctx[fn] = this;</span><br><span class="line">    </span><br><span class="line">    const res = ctx[fn](...args);</span><br><span class="line">    </span><br><span class="line">    delete ctx[fn];</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">let obj = &#123;</span><br><span class="line">    desc: function(from, to) &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125;来自$&#123;from&#125;去往$&#123;to&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person = &#123;</span><br><span class="line">    name: &#x27;lbs&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.desc.myCall(person, &quot;北京&quot;,&quot;上海&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myApply = function(context, args=[]) &#123;</span><br><span class="line">    const ctx = context || window;</span><br><span class="line">    const fn = Symbol();</span><br><span class="line">    </span><br><span class="line">    ctx[fn] = this;</span><br><span class="line">    const res = ctx[fn](...args);</span><br><span class="line">    </span><br><span class="line">    delete ctx[fn];</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind = function(content, ...args) &#123;</span><br><span class="line">    const fn = this;</span><br><span class="line">    </span><br><span class="line">    return function newFn(...newFnArgs) &#123;</span><br><span class="line">        // 检测 New</span><br><span class="line">        // 如果当前函数的this指向的是构造函数中的this 则判定为new 操作</span><br><span class="line">        if (this instanceof newFn) &#123;</span><br><span class="line">            return new fn(...args, ...newFnArgs);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        return fn.myApply(context, [...args, ...newFnArgs]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过left.__proto__.__proto__这种方式从下往上的获取原型对象</span><br><span class="line">2. 通过Object.create(null)的实例是没有原型链</span><br><span class="line">3. 有原型链的实例的尽头都是Object</span><br><span class="line"></span><br><span class="line">function instanceof(left, right) &#123;</span><br><span class="line">    if(!left.__proto__) return false;</span><br><span class="line">    if(right === Object || left.__proto__ === right.prototype) return true;</span><br><span class="line">    </span><br><span class="line">    return instanceof(left.__proto__, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写Object-is"><a href="#手写Object-is" class="headerlink" title="手写Object.is"></a>手写Object.is</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function is(x, y) &#123;</span><br><span class="line">    if (x===y) &#123;</span><br><span class="line">        // x,y都为0，但是1 / +0 = +Infinity,1 / -0 = -Infinity 是不一样的</span><br><span class="line">        return x !== 0 || y !== 0 || 1 / x === 1 / y;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //NaN === NaN = false是不对的，做一个拦截操作</span><br><span class="line">        return x !== x &amp;&amp; y !== y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ajax(method, url, headers, body) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let req = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            req = new XMLHttpRequest();</span><br><span class="line">        &#125; catch&#123;</span><br><span class="line">            req = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        req.open(method, url);</span><br><span class="line">        </span><br><span class="line">        for(let key in headers) &#123;</span><br><span class="line">            req.setRequestHeader(key, headers[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        req.onreadystatechange(() =&gt; &#123;</span><br><span class="line">            if(req.readystate ===4) &#123;</span><br><span class="line">                if(req.status &gt;= 200 &amp;&amp; req.status &lt;= 300) &#123;</span><br><span class="line">                    resolve(req.responseText);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    reject(req);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        req.send(body)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 执行async函数，返回的都是Promise对象</span><br><span class="line">async function test1 () &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">async function test2() &#123;</span><br><span class="line">    return Promise.resolve(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(test1(),test2());</span><br><span class="line"></span><br><span class="line">// Promise.then 成功的情况对应的就是await</span><br><span class="line">async function test3() &#123;</span><br><span class="line">    const p = Promise.resolve(3);</span><br><span class="line">    p.then((data) =&gt; console.log(data));</span><br><span class="line">    </span><br><span class="line">    const data = await p;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test3();</span><br><span class="line"></span><br><span class="line">// Promise.catch 异常对应 try...catch</span><br><span class="line">async function test4() &#123;</span><br><span class="line">    const p = Promise.reject(&quot;异常了&quot;);</span><br><span class="line">    </span><br><span class="line">    try&#123;</span><br><span class="line">        const data = await p;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test4();</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.map = function(fn, toThis) &#123;</span><br><span class="line">    const arr = this;</span><br><span class="line">    const result = [];</span><br><span class="line">    const _this = toThis || Object.create(null);</span><br><span class="line">    </span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        const item = fn.call(_this, arr[i], i, arr);</span><br><span class="line">        result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Promise1&#123;</span><br><span class="line">    static PENDING = &#x27;pending&#x27;;</span><br><span class="line">    static FULFILLED = &#x27;fulfilled&#x27;;</span><br><span class="line">    static REJECTED = &#x27;rejected&#x27;;</span><br><span class="line"></span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this.status = Promise.PENDING; //默认状态，进行中</span><br><span class="line">        this.value = null; //成功值</span><br><span class="line">        this.reason = null;  // 失败原因</span><br><span class="line">        // 解决异步问题</span><br><span class="line">        this.onFulfilledCallbacks = [];</span><br><span class="line">        this.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            executor(this.resolve.bind(this), this.reject.bind(this))    </span><br><span class="line">        &#125; catch(e) &#123;</span><br><span class="line">            this.reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        if (this.status === Promise.PENDING) &#123;</span><br><span class="line">            this.status = Promise.FULFILLED;</span><br><span class="line">            this.value = value;</span><br><span class="line"></span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                this.onFulfilledCallbacks.forEach((cb) =&gt; cb((this.value)))    </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        if (this.status === Promise.PENDING) &#123;</span><br><span class="line">            this.status = Promise.REJECTED;</span><br><span class="line">            this.reason = reason;</span><br><span class="line"></span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                this.onRejectedCallbacks.forEach((cb) =&gt; cb(this.reason))    </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        if (typeof onFulfilled !== &#x27;function&#x27;) &#123;</span><br><span class="line">            onFulfilled = () =&gt; this.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (typeof onRejected !== &#x27;function&#x27;) &#123;</span><br><span class="line">            onRejected = () =&gt; this.reason;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">            if (this.status === Promise.PENDING) &#123;</span><br><span class="line">                return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">                    this.onFulfilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">                        this.parse(onFulfilled(this.value), resolve, reject)                        </span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">                return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">                    this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">                        this.parse(onRejected(this.value),resolve,reject)                       </span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;) </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (this.status === Promise.FULFILLED) &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">                        this.parse(onFulfilled(this.value), resolve, reject)                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                    </span><br><span class="line">                &#125;)              </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (this.status === Promise.REJECTED) &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">                        this.parse(onRejected(this.reason), resolve, reject)                        </span><br><span class="line">                    &#125;)</span><br><span class="line"></span><br><span class="line">                &#125;)               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parse(result, resolve, reject) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (result instanceof Promise1) &#123;</span><br><span class="line">                result.then(resolve, reject)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static resolve(value) &#123;</span><br><span class="line">        return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">            if (value instanceof Promise1) &#123;</span><br><span class="line">                value.then(resolve, reject)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static reject(reason) &#123;</span><br><span class="line">        return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static all(promises) &#123;</span><br><span class="line">        const result = [];</span><br><span class="line"></span><br><span class="line">        return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">            promises.forEach((promise) =&gt; &#123;</span><br><span class="line">                promise.then((value) =&gt; &#123;</span><br><span class="line">                    result.push(value);</span><br><span class="line"></span><br><span class="line">                    if (result.length === promises.length) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,reason =&gt; &#123;</span><br><span class="line">                    reject(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static race(promises) &#123;</span><br><span class="line">        return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">            promises.forEach((promise) =&gt; &#123;</span><br><span class="line">                promise.then((value) =&gt; &#123;</span><br><span class="line">                    resolve(value)</span><br><span class="line">                &#125;,(reason) =&gt; &#123;</span><br><span class="line">                    reject(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let aaa = new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;lbs&quot;)</span><br><span class="line">//     reject(&#x27;error&#x27;)</span><br><span class="line">&#125;).then((value) =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">    return &#x27;666&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">aaa.then(() =&gt; &#123;</span><br><span class="line">    console.log(123)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(aaa) </span><br></pre></td></tr></table></figure>

<h2 id="手写event-bus"><a href="#手写event-bus" class="headerlink" title="手写event bus"></a>手写event bus</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class EventEmitter &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.events = &#123;&#125;</span><br><span class="line">        this.maxListeners = maxListeners || Infinity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit(event, ...args) &#123;</span><br><span class="line">        const cbs = this.events[event];</span><br><span class="line"></span><br><span class="line">        if(!cbs) &#123;</span><br><span class="line">            console.log(&quot;没有这个事件函数&quot;);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cbs.forEach(cb =&gt; cb.apply(this, args))</span><br><span class="line"></span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    on(event, cb) &#123;</span><br><span class="line">        if (!this.events[event]) &#123;</span><br><span class="line">            this.events[event] = []</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.maxListeners !== Infinity &amp;&amp; this.events[event].length &gt;= this.maxListeners) &#123;</span><br><span class="line">            console.log(&quot;当事件超过了最大监听数&quot;)</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.events[event].push(cb)</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    once(event, cb) &#123;</span><br><span class="line">        const func = (...args) =&gt; &#123;</span><br><span class="line">            this.off(event, fn);</span><br><span class="line">            cb.apply(this, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.on(event, func)</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    off(event, cb) &#123;</span><br><span class="line">        if (!cb) &#123;</span><br><span class="line">            this.events[event] = null</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.events[event] = this.events[event].filter(item=&gt;item !==cb)</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 构造函数继承</span><br><span class="line">function Person() &#123;</span><br><span class="line">    this.name = &#x27;lbs&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student() &#123;</span><br><span class="line">    Person.call(this)</span><br><span class="line">    this.age = 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const s = new Student()</span><br><span class="line"></span><br><span class="line">// 原型链继承</span><br><span class="line">function Person() &#123;</span><br><span class="line">    this.name = &#x27;lbs&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student() &#123;</span><br><span class="line">    this.age = 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = new Person()</span><br><span class="line"></span><br><span class="line">const s = new Student()</span><br><span class="line">//寄生式组合继承</span><br><span class="line">function Person(obj)&#123;</span><br><span class="line">    this.name = obj.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(obj)&#123;</span><br><span class="line">    Person.call(this, obj);</span><br><span class="line">    this.age = obj.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// object.create()</span><br><span class="line">// 方法创建一个新对象，使用现有的对象来提供新创建对象的__proto__</span><br><span class="line">Student.prototype = Object.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">// 或者：</span><br><span class="line">Student.prototype = Object.create(Person.prototype, &#123;</span><br><span class="line">    constructor: &#123;</span><br><span class="line">        value: Student,</span><br><span class="line">        enumerable: false,</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const student = new Student(&#123;name: &quot;lbs&quot;, age: 18&#125;);</span><br><span class="line"></span><br><span class="line">console.log(student);</span><br></pre></td></tr></table></figure>

<h2 id="createElement手写"><a href="#createElement手写" class="headerlink" title="createElement手写"></a>createElement手写</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const symbolFor = Symbol.for;</span><br><span class="line">const REACT_ELEMENT_TYPE = symbolFor(&#x27;react.element&#x27;);</span><br><span class="line"></span><br><span class="line">const RESERVED_PROPS = &#123;</span><br><span class="line">    key: true,</span><br><span class="line">    ref: true,</span><br><span class="line">    __self: true,</span><br><span class="line">    __source: true,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createElement(type, config, children) &#123;</span><br><span class="line">    const props = &#123;&#125;;</span><br><span class="line">    let key = null;</span><br><span class="line">    </span><br><span class="line">    if (config !== null) &#123;</span><br><span class="line">        key = config.key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (let propName in config) &#123;</span><br><span class="line">        if (!RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">            props[propName] = config[propName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const childrenLength = arguments.length -2;</span><br><span class="line">    if(childrenLength === 1) &#123;</span><br><span class="line">        props.children = children;</span><br><span class="line">    &#125; else if(childrenLength &gt; 1) &#123;</span><br><span class="line">        const childArray = Array(childrenLength);</span><br><span class="line">        </span><br><span class="line">        for(let i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">            childArray[i] = arguments[i + 2];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        props.children = childArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const element = &#123;</span><br><span class="line">        $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line">        type,</span><br><span class="line">        key,</span><br><span class="line">        props</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写正则，验证一个6～16位的字符串，必须同时包含大小写字母和数字"><a href="#编写正则，验证一个6～16位的字符串，必须同时包含大小写字母和数字" class="headerlink" title="编写正则，验证一个6～16位的字符串，必须同时包含大小写字母和数字"></a>编写正则，验证一个6～16位的字符串，必须同时包含大小写字母和数字</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正向预查 ？= 必须</span><br><span class="line">反向预查 ？！必须不</span><br><span class="line">let reg = /(?!^[a-zA-Z]+$)(?!^[0-9]+$)(?!^[a-z0-9]+$)(?!^[A-Z0-9]+$)^[a-zA-Z0-9]&#123;6,16&#125;$/;</span><br><span class="line"></span><br><span class="line">补充：数字、字母、下划线组成字符串，必须有_</span><br><span class="line">let reg = /(?=_)\w/;</span><br><span class="line">let reg = /(?!^[a-zA-Z0-9]+$)^\w&#123;1,10&#125;$/; 限制1-10位</span><br></pre></td></tr></table></figure>

<h2 id="获取所有属性为name，值为value的元素集合"><a href="#获取所有属性为name，值为value的元素集合" class="headerlink" title="获取所有属性为name，值为value的元素集合"></a>获取所有属性为name，值为value的元素集合</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 正则\b单词边界</span><br><span class="line">function getElements(property, value) &#123;</span><br><span class="line">    let elements = document.getElementsByTagName(&#x27;*&#x27;);</span><br><span class="line">    let arr = [];</span><br><span class="line">    </span><br><span class="line">    elements = Array.from(elements);</span><br><span class="line">    elements.forEach(item =&gt; &#123;</span><br><span class="line">        // 当前元素property对应的值</span><br><span class="line">        let itemValue = item.getAttribute(propertype);</span><br><span class="line">        </span><br><span class="line">        if (property === &quot;class&quot;) &#123;</span><br><span class="line">            const reg = new RegExp(`\b$&#123;value&#125;\b`);</span><br><span class="line">            </span><br><span class="line">            if (reg.test(itemValue)) &#123;</span><br><span class="line">                arr.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(itemValue === value) &#123;</span><br><span class="line">            arr.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="英文字母汉字组成的字符串，用正则给英文单词前后加空格"><a href="#英文字母汉字组成的字符串，用正则给英文单词前后加空格" class="headerlink" title="英文字母汉字组成的字符串，用正则给英文单词前后加空格"></a>英文字母汉字组成的字符串，用正则给英文单词前后加空格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;中国hello你好&quot;</span><br><span class="line">let reg = /\b[a-z]+\b/ig;</span><br><span class="line"></span><br><span class="line">str = str.replace(reg, value =&gt; &#123;</span><br><span class="line">    return ` $&#123;value&#125; `;</span><br><span class="line">&#125;).trim(); // 去除首尾空格</span><br></pre></td></tr></table></figure>

<h2 id="js实现斐波那契数列的几种方法"><a href="#js实现斐波那契数列的几种方法" class="headerlink" title="js实现斐波那契数列的几种方法"></a>js实现斐波那契数列的几种方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.递归</span><br><span class="line">function fibonacci(n) &#123;</span><br><span class="line">    if (n === 1 || n === 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.尾递归(每次调用都在收集结果，避免了线性递归不收集结果只依次展开消耗内存的坏处)</span><br><span class="line">function fibonacci(n, res1 = 1, res2 = 1) &#123;</span><br><span class="line">    if (n &lt;= 2) return res2;</span><br><span class="line">    </span><br><span class="line">    return fibonacci(n - 1, res2, res1 + res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 循环</span><br><span class="line">function fibonacci(n) &#123;</span><br><span class="line">    let num1 = 1;</span><br><span class="line">    let num2 = 2;</span><br><span class="line">    let sum = 1;</span><br><span class="line">    </span><br><span class="line">    for(let i = 3; i &lt; n; i++) &#123;</span><br><span class="line">        sum = num1 + num2;</span><br><span class="line">        num1 = num2;</span><br><span class="line">        num2 = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组</span><br><span class="line">function fibonacci(n) &#123;</span><br><span class="line">    const arr = [0,1,1];</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        throw new Error(&#x27;输入的数字不能小于0&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (n &gt;= 3) &#123;</span><br><span class="line">        for(let i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            arr[i] = arr[i - 1] + arr[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return arr[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="并发加载"><a href="#并发加载" class="headerlink" title="并发加载"></a>并发加载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function limitLoad(urls, handler, limit) &#123;</span><br><span class="line">    const sequence = [].concat(urls);</span><br><span class="line">    let promises = [];</span><br><span class="line"></span><br><span class="line">    promises = sequence.splice(0, limit).map((url, index) =&gt; &#123;</span><br><span class="line">        return handler(url).then(() =&gt; &#123;</span><br><span class="line">            return index</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    let p = Promise.race(promises);</span><br><span class="line"></span><br><span class="line">    for(let i = 0; i &lt; sequence.length; i++) &#123;</span><br><span class="line">        p = p.then((res) =&gt; &#123;</span><br><span class="line">            promises[res] = handler(sequence[i]).then(() =&gt; &#123;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">                console.log(promises)</span><br><span class="line">            return Promise.race(promises)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loadImg(url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">//             console.log(url.info + &#x27;---OK!!!&#x27;)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;,url.time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let urls = [</span><br><span class="line">&#123;info: 1,time: 2000&#125;,</span><br><span class="line">&#123;info: 2,time: 1000&#125;,</span><br><span class="line">&#123;info: 3,time: 3000&#125;,</span><br><span class="line">&#123;info: 4,time: 4000&#125;,</span><br><span class="line">&#123;info: 5,time: 5000&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">limitLoad(urls, loadImg, 3)</span><br></pre></td></tr></table></figure>

<h2 id="前端内存处理"><a href="#前端内存处理" class="headerlink" title="前端内存处理"></a>前端内存处理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 内存的生命周期</span><br><span class="line">    内存分配：声明变量、函数对象的时候，js会自动分配内存</span><br><span class="line">    内存使用</span><br><span class="line">    内存回收</span><br><span class="line"></span><br><span class="line">2. js中的垃圾回收机制</span><br><span class="line">    引用计数：缺点循环引用无法清除</span><br><span class="line">    标记清除</span><br><span class="line"></span><br><span class="line">3. 常见内存泄漏</span><br><span class="line">    全局变量（记得手动回收）</span><br><span class="line">    未被清除的定时器</span><br><span class="line">    闭包</span><br><span class="line">    dom的引用</span><br><span class="line"></span><br><span class="line">4. 怎么避免内存泄漏</span><br><span class="line">    减少不必要的全局变量</span><br><span class="line">    使用完数据，及时解除引用</span><br><span class="line"></span><br><span class="line">实现sizeOf，传入object，计算其所占字节大小</span><br><span class="line">number: 8 字节</span><br><span class="line">string: 2 字节</span><br><span class="line">boolean; 4 字节</span><br><span class="line"></span><br><span class="line">const seen = new WeakSet();</span><br><span class="line"></span><br><span class="line">function sizeOfObject(obj) &#123;</span><br><span class="line">    if (obj === null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let bytes = 0;</span><br><span class="line">    const keys = Object.keys(obj);</span><br><span class="line"></span><br><span class="line">    for(let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">        const key = keys[i];</span><br><span class="line">        bytes += calculator(key);</span><br><span class="line"></span><br><span class="line">        if (typeof obj[key] === &#x27;object&#x27; &amp;&amp; obj[key] !== null) &#123;</span><br><span class="line">            if (seen.has(obj[key])) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            seen.add(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes += calculator(obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function calculator(obj) &#123;</span><br><span class="line">    const objType = typeof obj;</span><br><span class="line"></span><br><span class="line">    switch(objType) &#123;</span><br><span class="line">        case &#x27;string&#x27;: &#123;</span><br><span class="line">            return obj.length * 2</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;boolean&#x27;: &#123;</span><br><span class="line">            return 4</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;number&#x27;: &#123;</span><br><span class="line">            return 8</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;object&#x27;: &#123;</span><br><span class="line">            if (Array.isArray(obj)) &#123;</span><br><span class="line">                return obj.map(calculator).reduce((accu, curr) =&gt; &#123;</span><br><span class="line">                    return accu + curr</span><br><span class="line">                &#125;, 0)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return sizeOfObject(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        default: &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数据结构就是在计算机中存储和组织数据的方式。</p>
<p>算法（Algorithm）解决问题的逻辑或步骤</p>
<h2 id="栈-封装"><a href="#栈-封装" class="headerlink" title="栈(封装)"></a>栈(封装)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Stack() &#123;</span><br><span class="line">    this.items = [];</span><br><span class="line">    // 1. 将元素压入栈</span><br><span class="line">    Stack.prototype.push = function (element) &#123;</span><br><span class="line">        this.items.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.从栈中取出元素</span><br><span class="line">    Stack.prototype.pop = function() &#123;</span><br><span class="line">        return this.items.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.查看一下栈顶元素</span><br><span class="line">    Stack.prototype.peek = function() &#123;</span><br><span class="line">        return this.items[this.items.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">    // 4.判断栈是否为空</span><br><span class="line">    Stack.prototype.isEmpty = function() &#123;</span><br><span class="line">        return !this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    // 5.获取栈中元素个数</span><br><span class="line">    Stack.prototype.size = function () &#123;</span><br><span class="line">        return this.item.length;</span><br><span class="line">    &#125;</span><br><span class="line">    // 6. toString方法</span><br><span class="line">    Stack.prototype.toString = function() &#123;</span><br><span class="line">        let res = &quot;&quot;;</span><br><span class="line">        for(let i = 0;i &lt; this.items.length;i++) &#123;</span><br><span class="line">            res += `$&#123;this.items[i]&#125; `;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const stack = new Stack();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 实例：将十进制转换成二进制</span><br><span class="line">function dec2bin(decimalNumber) &#123;</span><br><span class="line">    let stack = new Stack();</span><br><span class="line">    let binary = &#x27;&#x27;;</span><br><span class="line">    </span><br><span class="line">    while(decimalNumber &gt; 0) &#123;</span><br><span class="line">        stack.push(decimalNumber % 2);</span><br><span class="line">        </span><br><span class="line">        decimalNumber = Math.floor(decimalNumber / 2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(!stack.isEmpty()) &#123;</span><br><span class="line">        binary += stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return binary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平衡括号问题"><a href="#平衡括号问题" class="headerlink" title="平衡括号问题"></a>平衡括号问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function check(str) &#123;</span><br><span class="line">    const stack = new Stack()</span><br><span class="line">    const open = &quot;&#123;[(&quot;</span><br><span class="line">    const close = &quot;&#125;])&quot;</span><br><span class="line">    let index = 0</span><br><span class="line">    let balanced = true</span><br><span class="line">    </span><br><span class="line">    while(index &lt; str.length &amp;&amp; balanced) &#123;</span><br><span class="line">        if (open.includes(str[index])) &#123;</span><br><span class="line">            stack.push(str[index])</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            const top = stack.pop()</span><br><span class="line">            if (open.indexOf(top) === close.indexOf(str[index])) &#123;</span><br><span class="line">                balanced = true</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                balanced = false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (balanced &amp;&amp; stack.isEmpty()) &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(&quot;&#123;([][])&#125;&quot;)</span><br><span class="line">check(&quot;&#123;[(])&#125;&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function reverseList(head) &#123;</span><br><span class="line">    if (head === null || head.next === null) return head;</span><br><span class="line"></span><br><span class="line">    let result = reverseList(head.next)</span><br><span class="line"></span><br><span class="line">    head.next.nexd = head</span><br><span class="line">    head.next = null</span><br><span class="line"></span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function binarySearch(elements,value,_start,_end) &#123;</span><br><span class="line">    let end = _end || elements.length - 1;</span><br><span class="line">    let start = _start || 0;</span><br><span class="line">    let povitIndex = Math.floor((start + end) / 2);</span><br><span class="line"></span><br><span class="line">    if (elements[povitIndex] === value) &#123;</span><br><span class="line">        return povitIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (value &lt; elements[povitIndex]) &#123;</span><br><span class="line">        return binarySearch(elements, value, 0, povitIndex - 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return binarySearch(elements, value, povitIndex + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function quickSort(elements) &#123;</span><br><span class="line">    if(elements.length &lt;= 1) &#123;</span><br><span class="line">        return elements</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let pivotIndex = Math.floor(elements.length / 2)</span><br><span class="line">    let [pivot] = elements.splice(pivotIndex,1)</span><br><span class="line">    let left = [];</span><br><span class="line">    let right = [];</span><br><span class="line"></span><br><span class="line">    for(let i = 0; i &lt; elements.length; i++) &#123;</span><br><span class="line">        if (elements[i] &lt; pivot) &#123;</span><br><span class="line">            left.push(elements[i])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(elements[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return quickSort(left).concat([pivot], quickSort(right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let elements = [2,4,3,7,5]</span><br><span class="line"></span><br><span class="line">console.log(quickSort(elements))</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bubbleSort(elements) &#123;</span><br><span class="line">    let elementLength = elements.length;</span><br><span class="line">    </span><br><span class="line">    for(let i = 0; i &lt; elementLength - 1; i++ ) &#123;</span><br><span class="line">        for(let j = 0; j &lt; elementLength - i - 1; j++) &#123;</span><br><span class="line">            if(elements[j] &gt; elements[j + 1]) &#123;</span><br><span class="line">                let temp = elements[j];</span><br><span class="line">                elements[j] = elements[j + 1]</span><br><span class="line">                elements[j + 1] = temp </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(elements)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let elements = [2,4,3,7,5]</span><br><span class="line"></span><br><span class="line">bubbleSort(elements)</span><br><span class="line"></span><br><span class="line">// console.log(elements)</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//满二叉树：每层节点数都达到最大值，第n层节点数为2^(n - 1),总节点数为2^n -1(2的n次方减一)</span><br><span class="line">//完全二叉树：除最后一层外，其他各层节点数都达到最大个数，最后一层所有节点集中在最左边</span><br><span class="line">class Node &#123;</span><br><span class="line">    constructor(value) &#123;</span><br><span class="line">        this.value = value</span><br><span class="line">        this.left = null</span><br><span class="line">        this.right = null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BinarySearchTree &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.root = null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入前比较</span><br><span class="line">    insertNode(node, newNode) &#123;</span><br><span class="line">        // 右侧插入</span><br><span class="line">        if (newNode.value &gt; node.value) &#123;</span><br><span class="line">            if (node.right === null) &#123;</span><br><span class="line">                node.right = newNode                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.insertNode(node.right, newNode)   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (newNode.value &lt; node.value) &#123;</span><br><span class="line">            // 左侧插入</span><br><span class="line">            if (node.left === null) &#123;</span><br><span class="line">                node.left = newNode</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.insertNode(node.left, newNode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入</span><br><span class="line">    insert(value) &#123;</span><br><span class="line">        let newNode = new Node(value);</span><br><span class="line">        if (this.root === null) &#123;</span><br><span class="line">            this.root = newNode</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.insertNode(this.root, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    preOrderTraversalNode(node,callback) &#123;</span><br><span class="line">        if (node === null) return</span><br><span class="line"></span><br><span class="line">        callback(node.value)</span><br><span class="line"></span><br><span class="line">        this.preOrderTraversalNode(node.left, callback)</span><br><span class="line"></span><br><span class="line">        this.preOrderTraversalNode(node.right, callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 先序遍历</span><br><span class="line">    preOrderTraversal(callback) &#123;</span><br><span class="line">        this.preOrderTraversalNode(this.root, callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrderTraversalNode(node, callback) &#123;</span><br><span class="line">        if (node === null) return;</span><br><span class="line"></span><br><span class="line">        this.inOrderTraversalNode(node.left, callback)</span><br><span class="line"></span><br><span class="line">        callback(node.value)</span><br><span class="line"></span><br><span class="line">        this.inOrderTraversalNode(node.right, callback)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 中序遍历</span><br><span class="line">    inOrderTraversal(callback) &#123;</span><br><span class="line">        this.inOrderTraversalNode(this.root, callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    postOrderTraversalNode(node, callback) &#123;</span><br><span class="line">        if (node === null) return;</span><br><span class="line"></span><br><span class="line">        this.postOrderTraversalNode(node.left, callback)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        this.postOrderTraversalNode(node.right, callback)</span><br><span class="line"></span><br><span class="line">        callback(node.value)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 中序遍历</span><br><span class="line">    postOrderTraversal(callback) &#123;</span><br><span class="line">        this.postOrderTraversalNode(this.root, callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最大值</span><br><span class="line">    max() &#123;</span><br><span class="line">        let node = this.root;</span><br><span class="line">        while(node.right !== null) &#123;</span><br><span class="line">            node = node.right</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return node.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 最小值</span><br><span class="line">    min() &#123;</span><br><span class="line">        let node = this.root</span><br><span class="line">        while(node.left !== null) &#123;</span><br><span class="line">            node = node.left</span><br><span class="line">        &#125;</span><br><span class="line">        return node.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 寻找指定值是否存在</span><br><span class="line">    search(val)&#123;</span><br><span class="line">        let node = this.root</span><br><span class="line">        while(node !== null) &#123;</span><br><span class="line">            if(val &lt; node.value) &#123;</span><br><span class="line">                node = node.left</span><br><span class="line">            &#125; else if(val &gt; node.value) &#123;</span><br><span class="line">                node = node.right</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bst = new BinarySearchTree()</span><br><span class="line"></span><br><span class="line">bst.insert(3)</span><br><span class="line">bst.insert(2)</span><br><span class="line">bst.insert(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// bst.preOrderTraversal((nodeValue) =&gt; &#123;</span><br><span class="line">//     console.log(nodeValue)</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// bst.inOrderTraversal((nodeValue) =&gt;&#123;</span><br><span class="line">//     console.log(nodeValue)</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// bst.postOrderTraversal((nodeValue) =&gt;&#123;</span><br><span class="line">//     console.log(nodeValue)</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// console.log(bst.max())</span><br><span class="line">console.log(bst.search(5))</span><br><span class="line"></span><br><span class="line">console.log(bst)</span><br></pre></td></tr></table></figure>

<h2 id="翻转链表-1"><a href="#翻转链表-1" class="headerlink" title="翻转链表"></a>翻转链表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 递归</span><br><span class="line">var reverseList = function (head) &#123;</span><br><span class="line">  if (head === null || head.next === null) return head;</span><br><span class="line"></span><br><span class="line">  let res = reverseList(head.next)</span><br><span class="line"></span><br><span class="line">  head.next.next = head</span><br><span class="line">  head.next = null</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 循环</span><br><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">  let pre = null</span><br><span class="line">  let cur = head;</span><br><span class="line"></span><br><span class="line">  if(cur === null || cur.next === null) &#123;</span><br><span class="line">    return cur</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while(cur) &#123;</span><br><span class="line">    const t = cur.next</span><br><span class="line">    cur.next = pre</span><br><span class="line">    pre = cur</span><br><span class="line">    cur = t</span><br><span class="line">    </span><br><span class="line">    // cur.next = null</span><br><span class="line">    // cur.next.next = cur</span><br><span class="line">    // cur = cur.nexxt</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法1-Two-Sum"><a href="#算法1-Two-Sum" class="headerlink" title="算法1: Two Sum"></a>算法1: Two Sum</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example:</span><br><span class="line">given nums = [2, 7, 11, 15], target = 9</span><br><span class="line">because num[0] + num[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1]</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">function twoSum(nums, target) &#123;</span><br><span class="line">    const map = new Map();</span><br><span class="line">    </span><br><span class="line">    for(let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        const complement = target - nums[i];</span><br><span class="line">        </span><br><span class="line">        if (map.has(complement)) &#123;</span><br><span class="line">            return [map.get(complement), i]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.set(nums[i], i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>装箱：基本类型到引用类型的一个转换<br>拆箱：将引用类型到基本类型的转换（toPrimitive）</p>
<p>编码和解码：<br>escape(str)  unescape(str)<br>encodeURI()  decodeURI()<br>encodeURIComponent()  decodeURIComponent()<br>btoa() atob()</p>
<p>回流：相当与刷新页面<br>重绘： 不刷新，动态更新内容<br>重绘不一定引起回流，回流一定引起重绘</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的reflow和repaint</title>
    <url>/2019/07/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84reflow%E5%92%8Crepaint/</url>
    <content><![CDATA[<h2 id="浏览器的reflow和repaint"><a href="#浏览器的reflow和repaint" class="headerlink" title="浏览器的reflow和repaint"></a>浏览器的reflow和repaint</h2><span id="more"></span>
<ul>
<li>reflow（回流||重排）：当浏览器上某一个位置的布局发生了改变，浏览器会重新从根部开始计算该节点的</li>
</ul>
<p>布局。比如：向页面中添加、删除某一元素等，dom节点的宽高位置改变，只要这些操作影响了</p>
<p>页面的元素位置或大小的变化，都会引起reflow。</p>
<ul>
<li>repaint（重绘）：如果只改变页面元素的颜色、字体等不影响布局的属性时，浏览器会进行repaint。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由上可见，相比repaint操作，reflow的耗时要更多。只要是动态的对页面进行修改，浏览器的reflow</span><br><span class="line"></span><br><span class="line">和repaint的操作就不可避免，我们要做的就是尽可能的减少浏览器的reflow和repaint的次数。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题目总结</title>
    <url>/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="从浏览器地址栏输入url到显示页面的步骤"><a href="#从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤"></a>从浏览器地址栏输入url到显示页面的步骤</h2><pre><code>1. 浏览器查看缓存(浏览器对应的都会有cache文件)。
若请求有缓存且未过期，则取缓存资源提供给客户端，否则发起请求与服务器进行验证。
检验是否过期通常有两个HTTP头：Expires、Cache-control
2.浏览器需要获取域名对应的ip地址，过程如下：
1.本地host文件查找
- 浏览器解析URL获取协议、域名、端口、path路径，然后查看本地硬盘中hosts文件，看是否存在与这个域名对应的规则，如果有就直接使用hosts文件里面的ip地址。
2.路由器缓存
3.ISP DNS(Domain Name System域名系统)(情报局)缓存（互联网提供服务商）-本地DNS服务器以递归方式进行查询缓存记录，
若没有就向跟DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器，
本地DNS服务器把对应关系草存在缓存中（一边下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。
3.客户端发送HTTP请求。
4.TCP传输报文（三次握手四次挥手）
5.向客户端返回资源
6.解析HTML文档，构建DOM树，CSSOM树，下载资源，执行js脚本等。
</code></pre>
<span id="more"></span>

<h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个域名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</span><br></pre></td></tr></table></figure>

<h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">强缓存：（expires、Cache-Control）在过期时间内，浏览器再次加载资源时，不会向服务器发起请求，直接从缓存中读取资源</span><br><span class="line"></span><br><span class="line">协商缓存：向服务器发送请求，服务器会根据请求头（request header）的一些参数（Etag、last-modified）来判断是否命中协商缓存，首先根据Etag的值判断请求的文件有没有被修改，如果Etag一致则没有被修改，命中协商缓存返回304，如果不一致则返回新的资源并带上新的Etag返回200状态码。如果没有Etag值，则对比If-Modified-Since和请求文件的最后修改时间，一致则命中协商缓存返回304，不一致则返回新的last-modified和200状态码</span><br></pre></td></tr></table></figure>

<h2 id="http协议的特点"><a href="#http协议的特点" class="headerlink" title="http协议的特点"></a>http协议的特点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.支持客户/服务器模式</span><br><span class="line">2.简单快速：客户向服务器发送请求时，只需传送请求方法和路径。</span><br><span class="line">3.灵活：http允许传输任意类型的数据对象（Content-Type内容编码类型）</span><br><span class="line"></span><br><span class="line">application/x-www-form-urlencoded 常见post提交数据格式（key-value格式）</span><br><span class="line">application/json</span><br><span class="line"></span><br><span class="line">4.无连接：限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。（原因是早期服务器需要同时面对全世界数十万、上百万的客户端的网页访问，但是每次客户端与服务端传输的数据关联性很低，就会导致大部分通过会很空闲，无端占用资源）</span><br><span class="line"></span><br><span class="line">（解决无连接）Keep-Alive：使客户端到服务端之间的Http连接保持，不会断开，当再次对服务器发送请求时，keep-Alive功能避免了重新建立连接</span><br><span class="line"></span><br><span class="line">5.无状态：Http是一个无状态协议，就是每个请求都是独立的，数据传输完毕不会记录任何信息。缺点就是如果后续处理需要前面的信息，就必须重传，就会导致每次连接传送的数据量增加，如果服务器不需要前面信息的时候应答就会很快。</span><br><span class="line"></span><br><span class="line">（解决无状态）怎样保持http连接状态呢</span><br><span class="line">Cookie（每次http请求的时候，客户端都需要发送响应的cookie信息到服务端，服务端根据cookie判断来自哪个客户端）</span><br><span class="line">服务端生成cookie，客户端保存</span><br><span class="line"></span><br><span class="line">Session</span><br><span class="line">服务端生成一个sessionid，在客户端下次请求的时候在cookie里面记录这个sessionid，然后发送给服务端，服务端再根据cookie中的sessionid来识别客户端返回资源数据。</span><br><span class="line"></span><br><span class="line">禁用cookie怎么办？</span><br><span class="line">url重写，每次http请求的时候，在url后面拼接sid=**参数</span><br><span class="line"></span><br><span class="line">withCredentials:指定在涉及到跨域请求时，是否携带cookie信息，默认为false</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>

<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.存取方式不同： cookie只能保存ASCII字符串，session能够存储任意类型的数据</span><br><span class="line">2.隐私策略不同</span><br><span class="line">3.cookie是存在客户端，session是存在服务器的</span><br><span class="line">4.浏览器的支持不同，浏览器可以禁用cookie</span><br></pre></td></tr></table></figure>

<h2 id="权限身份验证"><a href="#权限身份验证" class="headerlink" title="权限身份验证"></a>权限身份验证</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般都是通过sessionid来进行用户身份验证，sessionid一般会存放在redis中。</span><br><span class="line">1.用户向服务端发送用户名和密码进行登陆</span><br><span class="line">2.服务器验证通过后，服务器为用户创建一个session，并将session信息存储起来</span><br><span class="line">3.服务器向用户返回一个sessionid，写入用户的cookie</span><br><span class="line">4.当用户保持登陆状态时，每次后续请求都会一起发送给后端</span><br><span class="line">5.服务器将存储在cookie中的sessionid和存储在内存或者数据库中的sessin信息进行一个比较，验证用户身份，然后返回响应信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.依赖session的关键业务一定要确保客户端开启了cookie</span><br><span class="line">2.注意session的过期时间</span><br><span class="line"></span><br><span class="line">一般在http header的Authorization字段中添加token</span><br></pre></td></tr></table></figure>

<h2 id="禁用cookie之后session还能用吗？"><a href="#禁用cookie之后session还能用吗？" class="headerlink" title="禁用cookie之后session还能用吗？"></a>禁用cookie之后session还能用吗？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url重写，例如 https://javascript.cn/?session_id=xxx</span><br><span class="line">缺点是安全性降低，可以对sessionid进行一次加密后传输</span><br></pre></td></tr></table></figure>

<h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.url可见性：get参数url可见，post参数url不可见</span><br><span class="line">2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数</span><br><span class="line">3.缓存性：get请求可以缓存，post请求不可以缓存</span><br><span class="line">4.get请求网页回退时，不产生影响，post请求网页回退会重新发请求</span><br><span class="line">5.传输数据：get一般传输数据大小不超过4k，post可以传输大量数据</span><br><span class="line">6.post较get安全性较高，get是不安全的因为url可见，可能会泄漏私密信息</span><br></pre></td></tr></table></figure>

<h2 id="http常见的请求头字段"><a href="#http常见的请求头字段" class="headerlink" title="http常见的请求头字段"></a>http常见的请求头字段</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept: 浏览器可接受的数据类型</span><br><span class="line">Accept-Charset: 浏览器可接受的字符集</span><br><span class="line">Accept-Encoding：浏览器能够进行解码的数据编码方式</span><br><span class="line">Accept-Language： 浏览器所希望的语言种类</span><br><span class="line">Connection：是否需要持久连接，值“Keep-Alive”，HTTP1.1默认进行持久连接</span><br><span class="line">Cookie：cookie信息</span><br><span class="line">content-type</span><br><span class="line">If-Modified-Since：内容被修改才会返回</span><br><span class="line">User-Agent：浏览器类型</span><br><span class="line"></span><br><span class="line">响应头：</span><br><span class="line">content-Length: 表示内容长度</span><br><span class="line">content-type：文档类型</span><br><span class="line">Date：当前时间</span><br><span class="line">Expires：指定缓存过期时间</span><br><span class="line">Last-Modified：文档过期时间</span><br></pre></td></tr></table></figure>

<h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http是超文本传输协议，信息是明文传输，https是更加安全的ssl加密传输协议</span><br><span class="line">http默认是80端口，https默认是443端口</span><br><span class="line">https需要申请CA证书</span><br><span class="line">https是http + ssl/tls（数字证书）进行组合的更加安全的传输协议</span><br><span class="line"></span><br><span class="line">https工作原理（非对称加密）</span><br><span class="line">1.服务端向客户端传递证书作为公钥</span><br><span class="line">2.客户端对证书进行解析，判断证书的办法机构和过期时间等，如果都没有问题，生成一个随机值作为私钥，然后使用证书进行加密发送给服务端</span><br><span class="line">3.服务端解密得到客户端私钥</span><br><span class="line">4.之后双方利用私钥进行加密解密，完成信息的通信</span><br></pre></td></tr></table></figure>

<h2 id="xss（跨域脚本攻击）csrf（跨站请求伪造）"><a href="#xss（跨域脚本攻击）csrf（跨站请求伪造）" class="headerlink" title="xss（跨域脚本攻击）csrf（跨站请求伪造）"></a>xss（跨域脚本攻击）csrf（跨站请求伪造）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csrf: 需要用户先登陆网站A，获取cookie，利用的是网站A本身的漏洞，去请求网站A的api，---进行token验证，referer验证，只接收本站的请求</span><br><span class="line"></span><br><span class="line">xss：向网站A注入js代码，然后执行js代码，篡改网站A的内容，破坏页面正常结构，插入恶意广告。---编码转换</span><br></pre></td></tr></table></figure>

<h2 id="http1-0、http1-1和http2-0的区别"><a href="#http1-0、http1-1和http2-0的区别" class="headerlink" title="http1.0、http1.1和http2.0的区别"></a>http1.0、http1.1和http2.0的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http/1.0 每个请求都要建立一个连接</span><br><span class="line">http/1.1 多了长连接keep-alive，若干个请求需要排队串行化单线程处理，会发生网络请求阻塞问题。</span><br><span class="line">http/2.0 同一个连接可以有多个请求，各个请求直接互不影响（进行了头部压缩和多路复用的优化）</span><br></pre></td></tr></table></figure>

<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单例模式 （class组件中new store创建store实例）</span><br><span class="line">工厂模式 （mobx store中creatLayoutStore）</span><br><span class="line">观察者模式 </span><br><span class="line">发布订阅模式</span><br><span class="line">装饰器模式 （移动、pc配置同步@sync）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* TCP是面向连接的协议，发送数据前先要建立连接，TCP提供可靠的服务，通过TCP建立连接传输的数据不会丢失，没有重复，并且按照顺序到达。</span><br><span class="line">* UDP是无连接的协议，发送数据前不需要建立连接，是不可靠的</span><br><span class="line">* TCP只支持点对点通信，而UDP支持一对一，多对多</span><br><span class="line">* TCP是面向字节流的，UDP是面向报文的</span><br><span class="line">* TCP通信类似打电话，接通后需要确认身份，才可以开始通信</span><br><span class="line">* UDP类似广播直接进行通信</span><br></pre></td></tr></table></figure>

<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用层（应用层就是向用户提供通信服务的活动，提供用户程序接口HTTP、DNS）</span><br><span class="line">传输层（传输层为两台主机上的应用程序提供端到端的通信TCP，UDP）</span><br><span class="line">网络层（网络层实现数据包的选路和转发）</span><br><span class="line">数据链路层（ARP地址解析协议、RARP逆地址解析协议，使用物理地址寻找一台机器）</span><br></pre></td></tr></table></figure>

<h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正向代理是客户端代理，服务端不知道是哪个客户端发起的请求</span><br><span class="line">反向代理是服务端代理，客户端不知道是哪个服务端提供的资源</span><br></pre></td></tr></table></figure>

<h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用层</span><br><span class="line">表示层</span><br><span class="line">会话层</span><br><span class="line"></span><br><span class="line">传输层</span><br><span class="line"></span><br><span class="line">网络层</span><br><span class="line"></span><br><span class="line">数据链路层</span><br><span class="line">物理层</span><br></pre></td></tr></table></figure>

<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>为什么需要三次握手？<br>两次握手第二次结束后，服务端并不能保证客户端已经接收到了第二次的应答信息，如此一来服务器会一直保持通信过程，因为TCP通信会占用端口，造成资源浪费。</p>
<p>防止已失效的连接请求报文段突然又传送到服务端，产生错误。<br>如上述情况，如果client没有再次向server发出确认，server收不到确认就不会建立连接，可以避免server端一直等待浪费资源。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul>
<li><a href="https://blog.csdn.net/rememberyf/article/details/80309148">https://blog.csdn.net/rememberyf/article/details/80309148</a></li>
</ul>
<h2 id="301和302的区别"><a href="#301和302的区别" class="headerlink" title="301和302的区别"></a>301和302的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">301 表示资源被永久移除，浏览器在拿到状态码后跳转到一个新的URL地址，可从相应头的location首部中获取，搜索引擎在抓取新内容的同时也将就地址交换为重定向之后的网址。</span><br><span class="line"></span><br><span class="line">302 表示地址资源还在，仍可以访问，搜索引擎会抓取新的内容而保存旧的地址，seo 302 优于301.</span><br><span class="line"></span><br><span class="line">重定向的原因：</span><br><span class="line">网站调整（改变网页目录结构）</span><br><span class="line">页面被移到一个新地址</span><br><span class="line">页面扩展名改变 .php -&gt;.html</span><br><span class="line">如果不做重定向会返回404页面，会白白流失用户访问量。</span><br><span class="line"></span><br><span class="line">1XX 信息性状态码，表示接受的请求正在处理</span><br><span class="line">2XX 成功状态码，表示请求被正常处理完毕</span><br><span class="line">3XX 重定向状态码，表示需要进行附加操作以完成请求</span><br><span class="line">4XX 客户端错误状态码，表示服务器无法处理请求</span><br><span class="line">    400 Bad Request请求出现语法错误</span><br><span class="line">    401 被请求的页面需要用户名和密码</span><br><span class="line">    403 forbidden 请求页面的访问被禁止</span><br><span class="line">    404 资源未找到</span><br><span class="line">5XX 服务器错误状态码，表示服务器处理请求出错</span><br><span class="line">    502 网关错误</span><br><span class="line">    503 服务器超负载或者停机维护，无法处理请求</span><br><span class="line">    504 网关超时</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul>
<li>cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据cookie追踪用户在不同页面的访问信息。</li>
<li>cookie特点<ul>
<li>1.大小限制，cookie大小限制在4KB以内</li>
<li>2.宽带限制，cookie数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。</li>
<li>3.安全风险，cookie会频繁的在网络中传送，不加密的情况下是有安全风险的。</li>
<li>4.操作复杂<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setCookie(name: string, value: string) &#123;</span><br><span class="line">    const exp = new Date();    </span><br><span class="line">    //过期时间设置为一天</span><br><span class="line">    exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000);</span><br><span class="line">    document.cookie = `$&#123;name&#125;=$&#123;escape(value);expires=$&#123;exp.toString()&#125;&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="localStorage会话存储-和-sessionStorage本地存储"><a href="#localStorage会话存储-和-sessionStorage本地存储" class="headerlink" title="localStorage会话存储 和 sessionStorage本地存储"></a>localStorage会话存储 和 sessionStorage本地存储</h2><ul>
<li>1.存储容量大</li>
<li>2.零宽带，仅存储在本地，不会和服务器发生任何交互行为，不存在网络宽带占用问题。</li>
<li>3.编程接口，提供一套丰富的接口，操作数据更加方便。</li>
<li>4.独立的存储空间，不会造成数据的混乱。</li>
</ul>
<ul>
<li><p>主要区别在于数据存储的 <code>时间范围</code>和<code>页面范围</code></p>
<ul>
<li>sessionStorage: 数据只存储到窗口或标签关闭时，只在当前窗口的当前标签内可见,5M左右，不同浏览器不同大小。</li>
<li>localStorage: 数据会一直存在除非手动清除，数据可被同源(协议、域名、端口号一致)的每个窗口或标签共享,5M左右，不同浏览器不同大小。</li>
</ul>
</li>
<li><p>监测是否支持web Storage</p>
<ul>
<li>1.通过window.sessionStorage,window.localStorage判断浏览器是否支持</li>
<li>2.通过try{}catch{} 执行一下storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。</li>
</ul>
</li>
</ul>
<h2 id="html5的几种存储形式"><a href="#html5的几种存储形式" class="headerlink" title="html5的几种存储形式"></a>html5的几种存储形式</h2><ul>
<li>1.本地存储 localStorage,sessionStorage</li>
<li>2.离线缓存 application cache</li>
<li><ol start="3">
<li>indexedDb,webSQL</li>
</ol>
</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.负载均衡、CDN加速、设置缓存、</span><br><span class="line">2.业务逻辑优化</span><br><span class="line">3.代码程序优化（组件按需加载、图片懒加载，代码压缩）</span><br><span class="line">4.避免重绘回流</span><br><span class="line">重绘：页面元素的样式改变不会影响它在文档流中的位置时发生重绘</span><br><span class="line">回流：DOM尺寸大小结构发生变化时</span><br><span class="line">回流一定会导致重绘</span><br><span class="line">如何避免：</span><br><span class="line">1.避免频繁操作dom，通过创建document.createDocumentFragment()一次性插入需要操作的dom</span><br><span class="line">2.具有复杂动画的Dom元素使用绝对定位，使其脱离文档流</span><br><span class="line">3.合并对于Dom中style样式的操作</span><br><span class="line">4.避免使用css表达式 calc()</span><br></pre></td></tr></table></figure>

<h2 id="fetch和axios"><a href="#fetch和axios" class="headerlink" title="fetch和axios"></a>fetch和axios</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch取消发送</span><br><span class="line">1.创建一个AbortController实例</span><br><span class="line">2.该实例具有signal属性</span><br><span class="line">3.将signal传递给fetch option</span><br><span class="line">4.调用AbortController的abort属性来取消所有使用该信号的fetch</span><br><span class="line"></span><br><span class="line">axios取消发送</span><br><span class="line">1.const cancelToken = axios.CancelToken</span><br><span class="line">2.const source = CancelToken.source()</span><br><span class="line">3.axios.get(&#x27;/xxx&#x27;,&#123;cancelToken: source.token&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="flex常用属性，grid布局"><a href="#flex常用属性，grid布局" class="headerlink" title="flex常用属性，grid布局"></a>flex常用属性，grid布局</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex属性：</span><br><span class="line">1.flex-direction属性，决定主轴方向</span><br><span class="line">2.flex-wrap属性，控制换行</span><br><span class="line">3.flex-flow属性，flex-direction和flex-wrap的简写形式，默认值flex-flow: row  nowrap;</span><br><span class="line">4.justify-content属性，项目主轴上的对齐方式</span><br><span class="line">5.align-item属性，项目在交叉轴上的对齐方式</span><br><span class="line">6.align-content属性，多个轴线的时候在元素在交叉轴的对齐方式，只有一根轴线时不起作用</span><br><span class="line">flex（子元素的属性）：</span><br><span class="line">1.order属性,定义项目的排列顺序，数值越小，排列越靠前，默认为0.</span><br><span class="line">2.align-self属性，允许单个项目与其他项目不一样的对齐方式，会覆盖align-items属性.</span><br><span class="line">3.flex属性，flex-grow、flex-shrink、flex-basis简写，默认为0 1 auto</span><br><span class="line">    auto(1 1 auto)       none(0 0 auto)</span><br><span class="line">4.flex-grow属性，定义项目的放大比例，默认为0，即如果存在剩余空间也不放大，1等分，一个项目为2，其他为1，则前者占据空间是其他的两倍。</span><br><span class="line">5.flex-shrink属性，定义项目的缩小比例，默认为1，空间不足则缩小，如果所有项目都为1，则等比例缩小，如果有的项目为0，则空间不足时为0的不缩小，负值无效</span><br><span class="line">6.flex-basis属性，项目占据的固定空间</span><br></pre></td></tr></table></figure>

<h2 id="padding-bottom实现子元素高度等于父元素宽度问题"><a href="#padding-bottom实现子元素高度等于父元素宽度问题" class="headerlink" title="padding-bottom实现子元素高度等于父元素宽度问题"></a>padding-bottom实现子元素高度等于父元素宽度问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当margin或者padding取值是百分比的时候，无论是left，right或者top，bottom，都是以父元素的width为参考物，进行提前占位</span><br></pre></td></tr></table></figure>


<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在作用域的创建阶段（预编译阶段），会生成js的变量对象（VO对象）供js引擎去访问。</span><br><span class="line">1.创建ao对象</span><br><span class="line">2.找形参和变量声明，作为ao对象的属性名，值为undefined</span><br><span class="line">3.实参和形参相统一</span><br><span class="line">4.找函数声明，如果名字和变量相同则覆盖变量声明</span><br><span class="line">5.解释执行</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.箭头函数中的this是在定义函数的时候绑定的（继承自父执行上下文中的this），而不是执行函数时绑定。</span><br><span class="line">2.箭头函数没有this，所以不能用作构造函数。</span><br></pre></td></tr></table></figure>
<h2 id="Map和Set两种新的数据结构的区别？"><a href="#Map和Set两种新的数据结构的区别？" class="headerlink" title="Map和Set两种新的数据结构的区别？"></a>Map和Set两种新的数据结构的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Map类似Object是一种键值对集合，区别在于Map的键不仅限于字符串，其他各种类型的值都可以作为Map的键</span><br><span class="line"></span><br><span class="line">2.Set是类似数组的一种数据结构，不点在于Set中没有重复的值</span><br></pre></td></tr></table></figure>

<h2 id="你对闭包了解多少？"><a href="#你对闭包了解多少？" class="headerlink" title="你对闭包了解多少？"></a>你对闭包了解多少？</h2><pre><code>解释一下作用域链是如何产生的
解释一下js执行山下文的创建、执行过程
解释一下闭包所产生的变量放在哪里
</code></pre>
<ul>
<li>闭包的定义：闭包就是能够读取其他函数内部变量的函数。</li>
<li>闭包的底层实现原理</li>
<li>js执行上下文：</li>
<li><img src="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70" alt="image"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js运行三部曲</span><br><span class="line">1.语法分析</span><br><span class="line">2.预编译</span><br><span class="line">3.解释执行</span><br><span class="line"></span><br><span class="line">js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。</span><br><span class="line">预编译的环境需要个环境，这个环境就是执行上下文。</span><br><span class="line"></span><br><span class="line">js执行上下文分为三种：</span><br><span class="line">1.全局执行上下文：代码开始执行时首先进入的环境</span><br><span class="line">2.函数执行上下文：函数调用时，会开始执行函数中的代码</span><br><span class="line">3.eval执行上下文：不建议使用</span><br><span class="line"></span><br><span class="line">执行上下文的周期，分为两个阶段</span><br><span class="line">1.创建阶段</span><br><span class="line">    创建词法环境</span><br><span class="line">    生成变量对象VO，建立作用域链</span><br><span class="line">    确认this指向，并绑定this</span><br><span class="line">2.执行阶段</span><br><span class="line">    进行变量赋值，函数引用以及执行代码</span><br><span class="line">    </span><br><span class="line">预编译发生在函数执行前，预编译四部曲：</span><br><span class="line">1.创建AO对象</span><br><span class="line">2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined</span><br><span class="line">3.将形参和实参相统一</span><br><span class="line">4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）</span><br><span class="line">5.最后程序输出变量值的时候，就是从AO对象中拿</span><br><span class="line">（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，</span><br><span class="line">就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包）</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student.__proto__ === Student.prototype</span><br><span class="line">1.每个函数function都由一个prototype，即显式原型。是在定义函数的时候自动添加的，默认是一个空的Object对象</span><br><span class="line">2.每个引用类型都有一个__proto__,即隐式原型。是创建对象时自动添加的，默认值为构造函数的prototype属性值</span><br><span class="line">实例对象的隐式原型 等于 对应构造函数或类的显式原型</span><br><span class="line">能直接操作显式原型，不能直接操作隐式原型</span><br></pre></td></tr></table></figure>

<h2 id="js的new操作符都做了些什么？"><a href="#js的new操作符都做了些什么？" class="headerlink" title="js的new操作符都做了些什么？"></a>js的new操作符都做了些什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建一个空的js对象&#123;&#125;</span><br><span class="line">2. 将空对象的隐式原型__proto__指向构造函数的原型</span><br><span class="line">3. 将空对象作为构造函数的上下文（改变this指向）</span><br><span class="line">4. 对构造函数返回值做判断</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line">function create(fn, ...args) &#123;</span><br><span class="line">    let obj = Object.create(&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">    // obj.__proto__ = fn.prototype;</span><br><span class="line">    Object.setPrototypeOf(obj, fn.prototype);</span><br><span class="line">    </span><br><span class="line">    let result = fn.apply(obj, args);</span><br><span class="line">    </span><br><span class="line">    return result instanceof Object ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">在new的时候，会对构造函数的返回值做一些判断</span><br><span class="line">1. 如果返回值是基础类型数据，则忽略返回值</span><br><span class="line">2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效</span><br></pre></td></tr></table></figure>




<h2 id="calc-support-media各自的含义及用法？"><a href="#calc-support-media各自的含义及用法？" class="headerlink" title="calc, support, media各自的含义及用法？"></a>calc, support, media各自的含义及用法？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@support 主要用于检测浏览器是否支持css的某个属性，相当于条件语句，支持的话写一套样式，</span><br><span class="line">不支持写另外一套样式，例如</span><br><span class="line">    @supports (display: grid) &#123;</span><br><span class="line">      div &#123;</span><br><span class="line">        display: grid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @supports not (display: grid) &#123;</span><br><span class="line">      div &#123;</span><br><span class="line">        float: right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">calc(): 用于动态计算值，支持 + - * / 运算。</span><br><span class="line"></span><br><span class="line">@media查询：可以针对不同的媒体类型定义不同的样式。</span><br></pre></td></tr></table></figure>
<h2 id="什么是会话cookie-什么是持久cookie"><a href="#什么是会话cookie-什么是持久cookie" class="headerlink" title="什么是会话cookie,什么是持久cookie?"></a>什么是会话cookie,什么是持久cookie?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookie是服务器返回的，指定了expire（有效期）的是持久cookie,没有指定的是会话cookie</span><br></pre></td></tr></table></figure>


<h2 id="img标签title和alt属性"><a href="#img标签title和alt属性" class="headerlink" title="img标签title和alt属性"></a>img标签title和alt属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alt: 图片加载失败时，显示在网页上的替代文字</span><br><span class="line">title: 鼠标放在图片上的提示文字</span><br><span class="line"></span><br><span class="line">alt是必须属性，可以为空；title为非必须</span><br></pre></td></tr></table></figure>

<h2 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.let和const</span><br><span class="line">2.模版字符串</span><br><span class="line">3.箭头函数</span><br><span class="line">4.函数可以设置默认参数值</span><br><span class="line">5.扩展运算符</span><br><span class="line">6.对象和数组的解构</span><br><span class="line">7.class</span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载原理"><a href="#图片懒加载原理" class="headerlink" title="图片懒加载原理"></a>图片懒加载原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 浏览器是否发起请求是根据&lt;img /&gt;标签的src属性</span><br><span class="line">2. 所以懒加载的关键是：在图片没有进入可视区域时，</span><br><span class="line">先不给&lt;img /&gt;的src属性赋值，等到图片进入可是区域再给src赋值。</span><br><span class="line"></span><br><span class="line">当图片底边距离页面的偏移（图片高度+图片距离顶部偏移高度）</span><br><span class="line">小于等于</span><br><span class="line">浏览器底边距离页面顶部高度（浏览器一屏高度 + 滚动区域）</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="H5新增了哪些标签？"><a href="#H5新增了哪些标签？" class="headerlink" title="H5新增了哪些标签？"></a>H5新增了哪些标签？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">article、aside、audio、video、footer、header、nav、section</span><br></pre></td></tr></table></figure>

<h2 id="SVG和Canvas的区别？"><a href="#SVG和Canvas的区别？" class="headerlink" title="SVG和Canvas的区别？"></a>SVG和Canvas的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.svg:表示以XML格式定义图像的可伸缩矢量图形。</span><br><span class="line">2.canvas：通过js来绘制2D图形</span><br><span class="line"></span><br><span class="line">svg通过标签fill属性可以调整颜色</span><br></pre></td></tr></table></figure>




<h2 id="AMD-和-CMD的区别"><a href="#AMD-和-CMD的区别" class="headerlink" title="AMD 和 CMD的区别"></a>AMD 和 CMD的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共同点：</span><br><span class="line">1.两者都是框架在推广过程中对模块定义的规范产出</span><br><span class="line">2.都是异步加载模块</span><br><span class="line">不同点：</span><br><span class="line">1.AMD是RequireJs在推广过程中对模块定义的规范产出，CMD是SeaJs在推广过程中对模块定义的规范化产出</span><br><span class="line">2.AMD推崇依赖前置，CMD推崇依赖就近</span><br><span class="line">3.AMD的应用体验好，因为模块提前执行了，CMD性能好，因为只有用户需要的时候才执行</span><br></pre></td></tr></table></figure>


<h2 id="如何实现js倒计时的纠偏？"><a href="#如何实现js倒计时的纠偏？" class="headerlink" title="如何实现js倒计时的纠偏？"></a>如何实现js倒计时的纠偏？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一种通过前端定时向服务端发送请求获取最新的时间差，以此来校准倒计时时间。</span><br><span class="line">2. 通过前端根据偏差时间来自动调整下次间隔的时间来实现，首先以setTimeout递归的方式来实现倒计时，</span><br><span class="line">通过一个变量记录倒计时的秒数，根据秒数和间隔时间计算出此时无偏差时应该显示的时间，</span><br><span class="line">然后拿当前真实时间与这个时间相减，就可以得到时间的偏差大小，因此在设置下一个定时器的时候，</span><br><span class="line">间隔时间减去这个偏差大小就可以纠正时间误差。</span><br></pre></td></tr></table></figure>

<h2 id="js的执行机制"><a href="#js的执行机制" class="headerlink" title="js的执行机制"></a>js的执行机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js是单线程的，处理js任务只能一个一个顺序执行，js中把任务分为了同步任务和异步任务，</span><br><span class="line">同步任务进入主线程先执行，异步任务进入Event Table并注册函数，指定事情完成后，Event Table就会将函数移入到事件队列Event Queque中，等待主线程任务执行完毕，</span><br><span class="line">就会从事件队列中取出对应事件进入主线程执行。</span><br><span class="line"></span><br><span class="line">macro-task（宏任务）：包括整体代码script、setTimeout、setInterval</span><br><span class="line">micro-task（微任务）：Promise.then、process.nextTick</span><br><span class="line">微任务先于宏任务先执行（除了script）执行过程不同任务进入不同的event quue</span><br><span class="line"></span><br><span class="line">js先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，</span><br><span class="line">遇到宏任务放到宏任务事件队列中。</span><br><span class="line"></span><br><span class="line">然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，</span><br><span class="line">等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，</span><br><span class="line">执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，</span><br><span class="line">就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，</span><br><span class="line">以此类推。</span><br></pre></td></tr></table></figure>

<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="请说一下你对React的理解？"><a href="#请说一下你对React的理解？" class="headerlink" title="请说一下你对React的理解？"></a>请说一下你对React的理解？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. react是一个网页的UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</span><br><span class="line">2. react的核心设计思路有三个：</span><br><span class="line">声明式</span><br><span class="line">    命令式：命令程序一步一步的执行操作</span><br><span class="line">    声明式：只需告诉程序我们想要的结果，其他的交给程序去做。</span><br><span class="line">组件化</span><br><span class="line">    将视图拆分和模块复用，做到高内聚低耦合</span><br><span class="line"></span><br><span class="line">通用性</span><br><span class="line">    一次学习，随处编写。RN，react360等，跨平台底层靠虚拟DOM实现</span><br><span class="line">    </span><br><span class="line">3. 缺点</span><br><span class="line">1.没有官方系统解决方案，在开发大型应用时需要向社区寻找并整合解决方案。</span><br><span class="line">2.过于灵活，需要注意代码规范</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="React-lazy懒加载"><a href="#React-lazy懒加载" class="headerlink" title="React.lazy懒加载"></a>React.lazy懒加载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// React.lazy方法可以异步加载组件</span><br><span class="line">const Foo = React.lazy(() =&gt; import(&#x27;../components/Foo&#x27;)</span><br><span class="line"></span><br><span class="line">// React.lazy不能单独使用，需要配合React.suspense,用来包裹异步组件，添加loading效果等。</span><br><span class="line">&lt;React.Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">    &lt;Foo /&gt;</span><br><span class="line">&lt;/React.Suspense&gt;</span><br><span class="line"></span><br><span class="line">React.lazy原理</span><br><span class="line">React.lazy使用import来懒加载组件，import在webpack中最终会调用requireEnsure方法，动态插入script来请求js文件，类似jsonp的形式。</span><br></pre></td></tr></table></figure>

<h2 id="类组件和函数组件之间的区别？"><a href="#类组件和函数组件之间的区别？" class="headerlink" title="类组件和函数组件之间的区别？"></a>类组件和函数组件之间的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相同点：</span><br><span class="line">接受属性返回React元素</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line">    1.编程思想不同：类组件需要创建实例，基于面向对象的方式编程。函数式组件接受输入返回输出，属于函数式编程的思想。</span><br><span class="line">    2.内存占用：类组件需要创建实例，会占用内存，函数组件不需要创建实例，可以节约内存</span><br><span class="line">    3.捕获特性：函数组件具有捕获特性</span><br><span class="line">    4.可测试性：函数组件更方便编写单元测试</span><br><span class="line">    5.状态：类组件有实例可以维护自己的状态，函数组件可以使用useState维护自己的状态</span><br><span class="line">    6.声明周期：类组件有生命周期，可以在生命周期内写逻辑，函数组件可以在useEffect中</span><br><span class="line">    7.逻辑复用：函数组件通过继承实现逻辑复用，函数组件可以通过自定义hooks实现逻辑复用</span><br><span class="line">    8.性能优化：类组件通过shouldComponentUpdate和PureComponent来跳过更新，函数组件通过React.memo</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="当调用setState的时候，发生了什么事？"><a href="#当调用setState的时候，发生了什么事？" class="headerlink" title="当调用setState的时候，发生了什么事？"></a>当调用setState的时候，发生了什么事？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将传递给setState的参数对象合并到组件的当前的状态，react遍历dom节点，计算差异，更新UI。</span><br><span class="line">https://segmentfault.com/a/1190000018250127</span><br></pre></td></tr></table></figure>

<h2 id="为什么setState的参数是一个callback而不是一个对象"><a href="#为什么setState的参数是一个callback而不是一个对象" class="headerlink" title="为什么setState的参数是一个callback而不是一个对象"></a>为什么setState的参数是一个callback而不是一个对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为this.props和this.state的更新可能是异步的，不能依赖它们的值去计算下一个state</span><br><span class="line">(更新状态不要直接修改this.state，虽然状态可以改变，但不会触发组件的更新)</span><br><span class="line"></span><br><span class="line">setState何时同步何时异步？</span><br><span class="line">异步：由React控制的事件处理程序以及生命周期函数中调用setState为异步</span><br><span class="line">同步：React控制之外的原生js绑定的事件、setTimeout/setInterval等。</span><br></pre></td></tr></table></figure>

<h2 id="setState-什么时候同步什么时候异步？"><a href="#setState-什么时候同步什么时候异步？" class="headerlink" title="setState 什么时候同步什么时候异步？"></a>setState 什么时候同步什么时候异步？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">react三个模式：</span><br><span class="line">1.legacy模式： 通过ReactDOM.render(&lt;App /&gt;, rootNode)创建的，当前react的使用方式</span><br><span class="line">2.blocking模式：通过ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;),实验阶段，作为迁移到concurrent模式的第一个步骤</span><br><span class="line">3.concurrent模式，通过ReactDOM.createRoot(rootNode).render(&lt;App /&gt;),实验阶段，未来react的默认开发模式</span><br><span class="line"></span><br><span class="line">setState 只在合成事件（react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件）和钩子函数（生命周期中）是异步的，在原生事件和setTimeout中都是同步的。</span><br><span class="line"></span><br><span class="line">不同模式执行结果不同，legacy模式命中batchedUpadates（批处理）时异步，为命中时同步</span><br><span class="line">concurrent模式都是异步的</span><br><span class="line"></span><br><span class="line">setState异步并不是说内部由异步代码实现，其本身执行过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了“异步”</span><br><span class="line"></span><br><span class="line">可以通过第二个参数的callback回调函数中拿到最新的值，在异步中如果对同一个值进行多次setState，那么setState的批量更新策略会将其覆盖，去最后一次的执行，如果同时setState多个值，会在更新时对其进行合并批量更新。</span><br></pre></td></tr></table></figure>

<h2 id="react渲染机制"><a href="#react渲染机制" class="headerlink" title="react渲染机制"></a>react渲染机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先打开页面会渲染出一颗DOM树，更新数据会生成一颗虚拟DOM树，通过diff算法，</span><br><span class="line">比较两颗DOM树的差异，找到更新的地方进行批量改动。</span><br><span class="line"></span><br><span class="line">diff：计算一棵树形结构到另一颗树形结构的最少操作。</span><br><span class="line"></span><br><span class="line">1.把树形结构按照层级分解，只比较同级元素</span><br><span class="line">2.给列表结构的每个单元添加唯一的 key 属性，方便比较</span><br><span class="line">3.diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。（官方也不推荐）</span><br></pre></td></tr></table></figure>

<h2 id="React-StrictMode-目前有助于："><a href="#React-StrictMode-目前有助于：" class="headerlink" title="React.StrictMode 目前有助于："></a>React.StrictMode 目前有助于：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">识别不安全的生命周期</span><br><span class="line">关于使用过时字符串 ref API 的警告</span><br><span class="line">关于使用废弃的 findDOMNode 方法的警告</span><br><span class="line">检测意外的副作用</span><br><span class="line">检测过时的 context API</span><br></pre></td></tr></table></figure>

<h2 id="虚拟DOM优点"><a href="#虚拟DOM优点" class="headerlink" title="虚拟DOM优点"></a>虚拟DOM优点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 减少不必要的DOM操作</span><br><span class="line">    1.1虚拟dom可以将多次操作合并为一次操作，比如添加100个节点，确是一个一个操作的</span><br><span class="line">    1.2虚拟dom借助dom diff可以将多余的操作省略掉，比如添加100个节点，其中10个是新增的</span><br><span class="line">    </span><br><span class="line">2. 跨平台渲染</span><br><span class="line">    1.因为虚拟dom本质上是一个js对象</span><br><span class="line">    </span><br><span class="line">react虚拟dom结构:</span><br><span class="line"></span><br><span class="line">const vNode = &#123;</span><br><span class="line">    key: null,</span><br><span class="line">    props:&#123;</span><br><span class="line">        children: [</span><br><span class="line">            &#123;type: &#x27;span&#x27;, ....&#125;,</span><br><span class="line">        ],</span><br><span class="line">        className: &#x27;red&#x27;,</span><br><span class="line">        onClick: () =&gt; &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ref: null,</span><br><span class="line">    type: &#x27;div&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建虚拟dom：React.createElement</span><br></pre></td></tr></table></figure>

<h2 id="diff-策略"><a href="#diff-策略" class="headerlink" title="diff 策略"></a>diff 策略</h2><p>`<br>策略一： tree diff<br>1.React对树进行分层比较，两颗虚拟DOM树只会对同一层级的DOM节点进行比较。<br>如果存在跨层级的操作，只会进行创建和删除<br>2.如果节点是组件就进行Component diff<br>3.如果节点是标签就进行Element diff</p>
<p>策略二：component diff<br>如果为非同类型组件的话标记组件为dirty component，替换组件下所有子节点，<br>类型相同更新属性，然后深入组件进行Tree diff（递归遍历对比）</p>
<p>策略三：element diff<br>如果节点是原生标签，则看标签名<br>标签名不同直接替换，相同更新属性，然后进入标签进行Tree diff（递归遍历对比）<br>`</p>
<h2 id="shouldComponentUpdate-nextProps-nextState-是做什么的，（react性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-nextProps-nextState-是做什么的，（react性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)是做什么的，（react性能优化是哪个周期函数？）"></a>shouldComponentUpdate(nextProps, nextState)是做什么的，（react性能优化是哪个周期函数？）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新绘制dom,</span><br><span class="line">由于渲染dom非常消耗性能，合理的调用shouldComponentUpdate方法可以极大的提高性能。</span><br></pre></td></tr></table></figure>

<h2 id="createElement-和-cloneElement有什么区别？"><a href="#createElement-和-cloneElement有什么区别？" class="headerlink" title="createElement 和 cloneElement有什么区别？"></a>createElement 和 cloneElement有什么区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">React.createElement()构建React元素。</span><br><span class="line">接受三个参数，第一个参数为标签名，如div、span等，或者react组件，第二个参数为传入的属性，第三个为组件的子组件。</span><br><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">React.cloneElement(),第一个参数传入react元素不是标签名，第二个参数传入属性，新添加的属性会并入原有的属性，第三个参数为子组件</span><br><span class="line">React.cloneElement(</span><br><span class="line">    element,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h2 id="虚拟DOM的优缺点？"><a href="#虚拟DOM的优缺点？" class="headerlink" title="虚拟DOM的优缺点？"></a>虚拟DOM的优缺点？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优点：</span><br><span class="line">1. 处理了浏览器兼容性问题，避免了用户操作真实DOM</span><br><span class="line">2.内容经过xss处理，可以防范xss攻击</span><br><span class="line">3.跨平台开发</span><br><span class="line">4.更新的时候可以实现差异化更新，减少更新DOM的操作</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1.虚拟DOM需要消耗额外的内存</span><br><span class="line">2.首次渲染不一定会更快</span><br></pre></td></tr></table></figure>

<h2 id="React中创建组件的方式"><a href="#React中创建组件的方式" class="headerlink" title="React中创建组件的方式"></a>React中创建组件的方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">React.createClass()、ES6 class组件 无无状态函数式组件</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="react中key的作用"><a href="#react中key的作用" class="headerlink" title="react中key的作用"></a>react中key的作用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key在react中用于追踪哪些列表中元素被修改、添加或者移除的辅助标识。</span><br><span class="line"></span><br><span class="line">在开发中，需要保证某个元素的key在同级元素中具有唯一性。</span><br><span class="line"></span><br><span class="line">diff算法会借助元素的key值来判断元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染</span><br></pre></td></tr></table></figure>

<h2 id="react优势"><a href="#react优势" class="headerlink" title="react优势"></a>react优势</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 速度快：不直接操作dom，采用虚拟dom的概念</span><br><span class="line">2.跨浏览器兼容，兼容性好</span><br><span class="line">3.一切都是component，代码更加模块化，可维护性高</span><br><span class="line">4.单向数据流，采用Flux单向数据层架构</span><br></pre></td></tr></table></figure>

<h2 id="react事件机制"><a href="#react事件机制" class="headerlink" title="react事件机制"></a>react事件机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">react的事件机制利用了事件委托机制，事件并没有真正的绑定在真实的dom节点上，</span><br><span class="line">而是把事件绑定在结构的最外层document，使用统一的事件监听器，所有事件都由这个监听器统一分发。</span><br><span class="line"></span><br><span class="line">组件挂载和更新时，会将绑定的事件分门别类的放进一个叫EvnentPluginHub的事件池中。</span><br><span class="line"></span><br><span class="line">事件触发时，根据事件产生的Event对象找到触发事件的组件，再通过组件标识和事件类型</span><br><span class="line">从事件池中找到对应的事件监听回调，然后执行相关的监听函数。</span><br></pre></td></tr></table></figure>

<h2 id="异步回调中怎么使用syntheticEvent？"><a href="#异步回调中怎么使用syntheticEvent？" class="headerlink" title="异步回调中怎么使用syntheticEvent？"></a>异步回调中怎么使用syntheticEvent？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在合成事件机制里，一旦事件监听回调执行，合成事件对象就会被销毁，异步回调执行的时候</span><br><span class="line">合成事件对象早就被销毁了。</span><br><span class="line">解决方法：执行event.persist(),通知react不需要回收。</span><br></pre></td></tr></table></figure>

<h2 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">React 16推出Fiber之后，如果要开启async rendering，那么在render函数之前的所有函数都有可能被执行多次</span><br><span class="line"></span><br><span class="line">废弃：</span><br><span class="line">componentWillMount</span><br><span class="line">componentWillReceiveProps(nextProps)</span><br><span class="line">componentWillUpdate(nextProps, nextState)</span><br><span class="line">代替：</span><br><span class="line">静态函数：static getDerivedStateFromProps(nextProps, prevState)</span><br><span class="line"></span><br><span class="line">静态函数：static getDerivedStateFromError(error) // 渲染备用UI</span><br><span class="line">此生命周期return的值会自动调用setState，将值和state合并</span><br><span class="line">运行事件节点：子组件被渲染发生错误后且在页面更新前</span><br><span class="line"></span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) 此生命周期的返回值将作为参数传递给componentDidUpdate()</span><br><span class="line"></span><br><span class="line">componentDidCatch(error, info) // 打印错误信息</span><br><span class="line"></span><br><span class="line">错误边界无法捕获的错误：</span><br><span class="line">1.组件自身的错误</span><br><span class="line">2.异步错误，setTimeout</span><br><span class="line">3.事件中的错误，比如click事件中发生错误</span><br></pre></td></tr></table></figure>

<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 构建action，通过创建一个函数，返回一个对象，需要携带type属性</span><br><span class="line"></span><br><span class="line">2. 构建reducer，用来响应action，然后通过return把数据传回store</span><br><span class="line"></span><br><span class="line">3. 利用createStore来构建store，把reducer作为参数传入</span><br><span class="line"></span><br><span class="line">4. 利用store.subscribe()注册监听</span><br><span class="line"></span><br><span class="line">5. 利用store.dispatch()发送action</span><br><span class="line"></span><br><span class="line">6. 利用store.getState()拿到值</span><br></pre></td></tr></table></figure>

<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><h2 id="ts中type和interface的区别"><a href="#ts中type和interface的区别" class="headerlink" title="ts中type和interface的区别"></a>ts中type和interface的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相同点：</span><br><span class="line">1.都可以描述一个对象和函数</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface SetUser &#123;</span><br><span class="line">    (name: string): void;</span><br><span class="line">&#125;</span><br><span class="line">type User = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">type SetUser = (name: string): void;</span><br><span class="line"></span><br><span class="line">2.扩展与交叉类型</span><br><span class="line">interface可以extends进行类型扩展，type可以通过交叉类型实现interface的extend行为。</span><br><span class="line">interface可以exteds  type，type也可以与interface类型交叉（&amp;符号）</span><br><span class="line">不同点：</span><br><span class="line">1.type可以声明基本类型别名，联合类型，元祖等类型</span><br><span class="line">基本类型别名</span><br><span class="line">type Name = string;</span><br><span class="line">联合类型</span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wang();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line">type Pet = Dog | Cat;</span><br><span class="line">元祖类型</span><br><span class="line">type PetList = [Dog, Cat];</span><br><span class="line"></span><br><span class="line">2. interface能够声明合并</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface User &#123;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">=</span><br><span class="line">/**</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="ts中如何实现一个函数的重载"><a href="#ts中如何实现一个函数的重载" class="headerlink" title="ts中如何实现一个函数的重载"></a>ts中如何实现一个函数的重载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js是动态类型语言，所以是没有overload的，但js可以在运行的时候判断类型</span><br><span class="line">ts的重载只是重载函数声明，函数的实现还是只有一个</span><br></pre></td></tr></table></figure>

<h2 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Observable //被观察者</span><br><span class="line">Observer // 观察者</span><br><span class="line">Reaction //响应</span><br><span class="line"></span><br><span class="line">mobx底层对数据的观察是使用Object.defineProperty(mobx4)或Proxy(mobx5)</span><br><span class="line">observer这个装饰器，对react组件的render方法进行跟踪，将render方法加入到各个observable的依赖中，当observale发生变化的时候，就会调用forceUpdate更新组件</span><br><span class="line">（mobx4将Array用类数组对象来模拟的，通过包装类封装为一个对象）</span><br></pre></td></tr></table></figure>

<h2 id="webpack常用loader"><a href="#webpack常用loader" class="headerlink" title="webpack常用loader"></a>webpack常用loader</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">样式：style-loader、css-loader、less-loader、sass-loader</span><br><span class="line">文件：file-loader、url-loader</span><br><span class="line">编译：babel-loader、ts-loader</span><br><span class="line">校验：eslint-loader</span><br><span class="line"></span><br><span class="line">常用的plugin</span><br><span class="line">html-webpack-plugin</span><br><span class="line">webpack-bundle-analyzer 打包分析</span><br><span class="line">HotModuleReplacementPlugin 热更新</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自己写webpack插件：</span><br><span class="line">主要就是通过访问compliler和compilation拦截webpack的执行</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">垃圾收集器会定期（周期性）的找出那些不再继续使用的变量，释放其内存，因为开销比较大，所以会按照固定的时间间隔周期性的执行</span><br><span class="line"></span><br><span class="line">最常用的两种方法：标记清除（常用）和引用计数</span><br><span class="line"></span><br><span class="line">标记清除：变量进入作用域，进行标记，离开作用域进行清除回收</span><br><span class="line"></span><br><span class="line">引用计数：就是跟踪记录每个值被引用的次数，引用一次加1，删除减1，引用计数为0时，进行回收，（循环引用可能会导致内存泄漏）</span><br><span class="line"></span><br><span class="line">常见的内存泄漏原因：</span><br><span class="line">全局变量过多引起内存泄漏</span><br><span class="line">闭包</span><br><span class="line">dom事件未清除</span><br><span class="line">循环引用</span><br></pre></td></tr></table></figure>

<h2 id="谈谈你对webpack的理解？"><a href="#谈谈你对webpack的理解？" class="headerlink" title="谈谈你对webpack的理解？"></a>谈谈你对webpack的理解？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack是一个打包模块化js的工具，在webpack里一切文件皆模块</span><br><span class="line">，通过loader转换，通过plugin注入钩子，最后输出由多个</span><br><span class="line">模块组合成的文件，webpack专注构建模块化。WebPack可</span><br><span class="line">以看做是模块的打包机器：它做的事情是，分析你的项目</span><br><span class="line">结构，找到js模块及其它的一些浏览器不能直接运行的</span><br><span class="line">拓展语言，例如：Scss，TS等，并将其打包为合适的格式</span><br><span class="line">以供浏览器使用。</span><br></pre></td></tr></table></figure>

<h2 id="说说webpack与grunt、gulp的不同？"><a href="#说说webpack与grunt、gulp的不同？" class="headerlink" title="说说webpack与grunt、gulp的不同？"></a>说说webpack与grunt、gulp的不同？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三者都是前端构建工具，grunt和gulp在早期比较流行，</span><br><span class="line">现在webpack相对来说比较主，不过一些轻量化的任务</span><br><span class="line">还是会用gulp来处理，比如单独打包CSS文件等。</span><br><span class="line"></span><br><span class="line">grunt和gulp是基于任务和流（Task、Stream）的。</span><br><span class="line">类似jQuery，找到一个（或一类）文件，对其做一</span><br><span class="line">系列链式操作，更新流上的数据，整条链式操作</span><br><span class="line">构成了一个任务，多个任务就构成了web的构建流程。</span><br><span class="line"></span><br><span class="line">webpack是基于入口的。webpack会自动地递归解析</span><br><span class="line">入口所需要加载的所有资源文件，然后用不同的</span><br><span class="line">Loader来处理不同的文件，用Plugin来扩展webpack功能。</span><br><span class="line"></span><br><span class="line">所以，从构建来说，gulp和grunt需要开发者将整个</span><br><span class="line">前端构建过程拆分成多个`Task`，并合理控制所有`Task`的</span><br><span class="line">调用关系；webpack需要开发者找到入口，并需要清楚对</span><br><span class="line">于不同的资源应该使什么Loader做何种解析和加工对</span><br><span class="line">于知识背景来说，gulp更像后端开发者的思路，</span><br><span class="line">需要对于整个流程了如指掌webpack更倾向于前端开发者的思路</span><br></pre></td></tr></table></figure>

<h2 id="什么是bundle-什么是chunk，什么是module"><a href="#什么是bundle-什么是chunk，什么是module" class="headerlink" title="什么是bundle,什么是chunk，什么是module?"></a>什么是bundle,什么是chunk，什么是module?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bundle：是由webpack打包出来的文件</span><br><span class="line">chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割</span><br><span class="line">module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块</span><br></pre></td></tr></table></figure>

<h2 id="什么是Loader-什么是Plugin"><a href="#什么是Loader-什么是Plugin" class="headerlink" title="什么是Loader?什么是Plugin?"></a>什么是Loader?什么是Plugin?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Loaders是用来告诉webpack如何转化处理某一类型的文件，</span><br><span class="line">并且引入到打包出的文中</span><br><span class="line">2）Plugin是用来自定义webpack打包过程的方式，</span><br><span class="line">一个插件是含有apply方法的一个，通过这个方法可以参与</span><br><span class="line">到整个webpack打包的各个流程(生命周期)。</span><br></pre></td></tr></table></figure>

<h2 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file-loader：把文件输出到一个文件夹中，在代码中通过</span><br><span class="line">相对URL去引用输出的文件</span><br><span class="line">url-loader：和file-loader类似，但是能在文件很小的情况下</span><br><span class="line">以base64的方式把文件内容注入到代码中去</span><br><span class="line">source-map-loader：加载额外的Source Map文件，以方便断点调试</span><br><span class="line">image-loader：加载并且压缩图片文件</span><br><span class="line">babel-loader：把ES6转换成ES5</span><br><span class="line">css-loader：加载CSS，支持模块化、压缩、文件导入等特性</span><br><span class="line">style-loader：把CSS代码注入到JavaScript中，通过DOM操作去加载CSS。</span><br><span class="line">eslint-loader：通过ESLint检查JavaScript代码</span><br></pre></td></tr></table></figure>

<h2 id="有哪些常见的Plugin？他们是解决什么问题的？"><a href="#有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Plugin？他们是解决什么问题的？"></a>有哪些常见的Plugin？他们是解决什么问题的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define-plugin：定义环境变量</span><br><span class="line">commons-chunk-plugin：提取公共代码</span><br><span class="line">uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</span><br></pre></td></tr></table></figure>

<h2 id="Loader和Plugin的不同？"><a href="#Loader和Plugin的不同？" class="headerlink" title="Loader和Plugin的不同？"></a>Loader和Plugin的不同？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不同的作用</span><br><span class="line">Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，</span><br><span class="line">但是webpack原生是只能解析js文件，如果想将其他文件</span><br><span class="line">也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</span><br><span class="line"></span><br><span class="line">Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br><span class="line"></span><br><span class="line">不同的用法</span><br><span class="line">Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么</span><br><span class="line">类型的文件（test），使用什么加载(loader)和使用的参数（options）</span><br><span class="line"></span><br><span class="line">Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</span><br></pre></td></tr></table></figure>

<h2 id="webpack的构建流程是什么"><a href="#webpack的构建流程是什么" class="headerlink" title="webpack的构建流程是什么?"></a>webpack的构建流程是什么?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</span><br><span class="line">初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</span><br><span class="line">开始编译：用上一步得到的参数初始化Compiler对象，</span><br><span class="line">加载所有配置的插件，执行对象的 run 方法开始执行编译；</span><br><span class="line"></span><br><span class="line">确定入口：根据配置中的 entry 找出所有的入口文件；</span><br><span class="line"></span><br><span class="line">编译模块：从入口文件出发，调用所有配置的 Loader</span><br><span class="line">对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到</span><br><span class="line">所有入口依赖的文件都经过了本步骤的处理；</span><br><span class="line"></span><br><span class="line">完成模块编译：在经过第4步使用Loader翻译完所有模块后，</span><br><span class="line">得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</span><br><span class="line"></span><br><span class="line">输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk转换成一个单独的文件加入到输</span><br><span class="line">出列表，这步是可以修改输出内容的最后机会；</span><br><span class="line"></span><br><span class="line">输出完成：在确定好输出内容后，根据配置确定输出的</span><br><span class="line">路径和文件名，把文件内容写入到文件系统。</span><br><span class="line"></span><br><span class="line">在以上过程中，Webpack会在特定的时间点广播出特定</span><br><span class="line">的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，</span><br><span class="line">并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</span><br></pre></td></tr></table></figure>

<h2 id="描述一下编写loader或plugin的思路？"><a href="#描述一下编写loader或plugin的思路？" class="headerlink" title="描述一下编写loader或plugin的思路？"></a>描述一下编写loader或plugin的思路？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，</span><br><span class="line">并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。</span><br><span class="line">编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。</span><br><span class="line">相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br></pre></td></tr></table></figure>

<h2 id="如何利用webpack来优化前端性能？"><a href="#如何利用webpack来优化前端性能？" class="headerlink" title="如何利用webpack来优化前端性能？"></a>如何利用webpack来优化前端性能？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用webpack优化前端性能是指优化webpack的输出结果，</span><br><span class="line">让打包的最终结果在浏览器运行快速高效。</span><br><span class="line"></span><br><span class="line">压缩代码。删除多余的代码、注释、简化代码的写法等等方式。</span><br><span class="line">可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件</span><br><span class="line">，利用cssnano（css-loader?minimize）来压缩css</span><br><span class="line"></span><br><span class="line">利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对</span><br><span class="line">应的路径。可以利用webpack对于output参数和各loader的publicPath</span><br><span class="line">参数来修改资源路径</span><br><span class="line"></span><br><span class="line">删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。</span><br><span class="line"></span><br><span class="line">可以通过在启动webpack时追加参数--optimize-minimize来</span><br><span class="line">实现提取公共代码。</span><br></pre></td></tr></table></figure>

<h2 id="如何提高webpack的构建速度？"><a href="#如何提高webpack的构建速度？" class="headerlink" title="如何提高webpack的构建速度？"></a>如何提高webpack的构建速度？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多入口情况下，使用CommonsChunkPlugin来提取公共代码</span><br><span class="line">通过externals配置来提取常用库</span><br><span class="line">利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，</span><br><span class="line">再通过DllReferencePlugin将预编译的模块加载进来。</span><br><span class="line">使用Happypack 实现多线程加速编译</span><br><span class="line">使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</span><br><span class="line">使用Tree-shaking和Scope Hoisting来剔除多余代码</span><br></pre></td></tr></table></figure>

<h2 id="怎么配置单页应用？怎么配置多页应用？"><a href="#怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="怎么配置单页应用？怎么配置多页应用？"></a>怎么配置单页应用？怎么配置多页应用？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用webpack的AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。</span><br><span class="line">多页应用中要注意的是：每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表,随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</span><br></pre></td></tr></table></figure>

<h2 id="vue项目中实现按需加载？"><a href="#vue项目中实现按需加载？" class="headerlink" title="vue项目中实现按需加载？"></a>vue项目中实现按需加载？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。</span><br><span class="line">不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。</span><br><span class="line">	</span><br><span class="line">单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</span><br><span class="line"></span><br><span class="line">通过import(*)语句来控制加载时机，webpack内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个chunk。当代码执行到import(*)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill</span><br></pre></td></tr></table></figure>


<p>自主搭建、灵活定制、高效复用</p>
<p>1.单向链表的创建、插入和反转<br>2.二叉搜索树的查找、插入、删除思想，写伪代码<br>3.tcp链接和释放过程，http，https，tcp和udp比较<br>4.链表顺序翻转</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖（Debouncing）和节流（Throttling）实现</title>
    <url>/2019/06/11/%E9%98%B2%E6%8A%96%EF%BC%88Debouncing%EF%BC%89%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%88Throttling%EF%BC%89%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="手写防抖（Debouncing）和节流（Throttling）"><a href="#手写防抖（Debouncing）和节流（Throttling）" class="headerlink" title="手写防抖（Debouncing）和节流（Throttling）"></a>手写防抖（Debouncing）和节流（Throttling）</h2><h3 id="防抖（Debouncing）实现"><a href="#防抖（Debouncing）实现" class="headerlink" title="防抖（Debouncing）实现"></a>防抖（Debouncing）实现</h3><ul>
<li>典型例子：限制<code>鼠标连击</code>触发、<code>监听用户输入</code>。<blockquote>
<p><strong>解释</strong>：当一次事件发生后，事件处理器要等一定阀值的时间，如果这段时间过去后，<br>再也没有事件发生，就处理最后一次发生的事件。如果还差<code>0.01</code>秒到达指定事件，这是又有一次<br>事件触发，那么之前的等待作废，需要重新再次等待指定时间。</p>
</blockquote>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//防抖动函数</span><br><span class="line">function debounce(fn, wait = 50, immediate) &#123;</span><br><span class="line"></span><br><span class="line">	let timer;</span><br><span class="line">	</span><br><span class="line">	return function() &#123;</span><br><span class="line">	</span><br><span class="line">		if (immediate) &#123;</span><br><span class="line">		</span><br><span class="line">		fn.apply(this, arguments)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (timer) clearTimeout(timer)</span><br><span class="line">		</span><br><span class="line">		timer = setTimeout(() =&gt; &#123;</span><br><span class="line">		</span><br><span class="line">			fn.apply(this, arguments)</span><br><span class="line">			</span><br><span class="line">		&#125;,wait)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--more--></li>
</ul>
<h4 id="节流（Throttling）实现"><a href="#节流（Throttling）实现" class="headerlink" title="节流（Throttling）实现"></a>节流（Throttling）实现</h4><blockquote>
<p><strong>解释</strong>：可以理解为事件再一个管道中传输，加上这个节流阀之后，事件的流速就会减慢，<br>节流可以将一个函数的调用频率限制再一定阀值内，例如 1s ，那么 1s 内这个函数一定不会被调用两次。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//简单的节流函数</span><br><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">	let prev = new Date();</span><br><span class="line">	return function() &#123; 	</span><br><span class="line">	    const args = arguments;   </span><br><span class="line">		const now = new Date();</span><br><span class="line">		if (now - prev &gt; wait) &#123;</span><br><span class="line">			fn.apply(this, args);</span><br><span class="line">			prev = new Date();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://psytn65m0.bkt.clouddn.com/01.jpg"  height="270" width="180"></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题——封装函数驼峰命名</title>
    <url>/2019/06/22/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<h2 id="封装函数使字符串以驼峰式命名"><a href="#封装函数使字符串以驼峰式命名" class="headerlink" title="封装函数使字符串以驼峰式命名"></a>封装函数使字符串以驼峰式命名</h2><ul>
<li>已知字符串foo = ‘get-element-by-id’,写一个函数将其转换为驼峰式命名“getElementById”<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//详细过程分析：</span><br><span class="line">var foo = &#x27;get-element-by-id&#x27;;</span><br><span class="line"></span><br><span class="line">//根据某个字符进行分割</span><br><span class="line">var arr = foo.split(&#x27;-&#x27;);</span><br><span class="line"></span><br><span class="line">//分割成四个片段保存在数组内</span><br><span class="line">console.log(arr) // (4) [&quot;get&quot;, &quot;element&quot;, &quot;by&quot;, &quot;id&quot;]</span><br><span class="line"></span><br><span class="line">//将下标为1的数组元素第一个字符元素转为大写</span><br><span class="line">console.log(arr[1].charAt(0).toUpperCase()) //E</span><br><span class="line"></span><br><span class="line">//截取后面字符元素</span><br><span class="line">console.log(arr[1].substr(1, arr[1].length - 1)) //lement</span><br><span class="line"></span><br><span class="line">//遍历</span><br><span class="line">for(var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1)</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr) //(4) [&quot;get&quot;, &quot;Element&quot;, &quot;By&quot;, &quot;Id&quot;]</span><br><span class="line"></span><br><span class="line">//根据某一个字符将数组转换为字符串</span><br><span class="line">console.log(arr.join(&#x27;&#x27;));</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//封装</span><br><span class="line">function toString(foo) &#123;</span><br><span class="line">    var arr = foo.split(&#x27;-&#x27;);</span><br><span class="line">    </span><br><span class="line">    for(var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return arr.join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(toString(&#x27;get-element-by-id&#x27;))</span><br></pre></td></tr></table></figure>
<p>把the-first-name变成theFirstName</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reg = /-(\w)/g</span><br><span class="line">var str = &quot;the-first-name&quot;</span><br><span class="line">console.log(str.replace(reg, function($, $1)&#123;</span><br><span class="line">    return $1.toUpperCase()</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>把aabb换成bbaa</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reg = /(\w)\1(\w)\2/g;</span><br><span class="line">var str = &quot;aabb&quot;;</span><br><span class="line">// console.log(str.replace(reg,&quot;$2$2$1$1&quot;));//&quot;bbaa&quot;</span><br><span class="line">console.log(str.replace(reg,function($,$1,$2)&#123;</span><br><span class="line">  return $2+$2+$1+$1;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>正则简单的去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;aaaabbbbbccccc&quot;;</span><br><span class="line">var reg = /(\w)\1*/g;</span><br><span class="line">console.log.replace(reg,&quot;$1&quot;));//abc</span><br></pre></td></tr></table></figure>
<pre><code>       把&quot;1000000000&quot;变成&quot;100.000.000&quot;这种写法，把后面往前面查，三位加个点
       <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;100000000&quot;;</span><br><span class="line">var reg = /(?=(\B)(\d&#123;3&#125;)+$)/g;</span><br><span class="line">console.log(str.replace(reg,&quot;.&quot;))//&quot;100.000.000&quot;</span><br><span class="line">||</span><br><span class="line">string.replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, &quot;.&quot;) //先行断言?=,后行断言(?!\d)</span><br><span class="line">||</span><br><span class="line">(25435345.22).toLocaleString(str(&#x27;en-US&#x27;)</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
