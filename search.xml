<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>13个超实用的JavaScript数组操作技巧</title>
    <url>/2020/07/18/13%E4%B8%AA%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84JavaScript%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="13-个超实用的-JavaScript-数组操作技巧"><a href="#13-个超实用的-JavaScript-数组操作技巧" class="headerlink" title="13 个超实用的 JavaScript 数组操作技巧"></a>13 个超实用的 JavaScript 数组操作技巧</h2><span id="more"></span>

<h3 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fruits = [&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;&quot;watermelon&quot;,&quot;apple&quot;,&quot;orrage&quot;]</span><br><span class="line">//第一种方法</span><br><span class="line">let uniqueFruits = Array.from(new Set(fruits))</span><br><span class="line">//第二种方法</span><br><span class="line">let uniqueFruits2 = [...new Set(fruits)]</span><br></pre></td></tr></table></figure>

<h3 id="2-替换数组中的特定值"><a href="#2-替换数组中的特定值" class="headerlink" title="2.替换数组中的特定值"></a>2.替换数组中的特定值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用.splice(start,value to remove,valueToAdd),返回删除对象，并修改原数组</span><br><span class="line">let fruits = [&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;,&quot;watermelon&quot;,&quot;apple&quot;,&quot;orrage&quot;]</span><br><span class="line">fruits.splice(0,2,&quot;potato&quot;,&quot;tomato&quot;)</span><br><span class="line">console.log(fruits)</span><br></pre></td></tr></table></figure>

<h3 id="3-不使用-map-映射数组"><a href="#3-不使用-map-映射数组" class="headerlink" title="3.不使用.map()映射数组"></a>3.不使用.map()映射数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let friends = [</span><br><span class="line">    &#123; name: &#x27;John&#x27;, age: 22 &#125;,</span><br><span class="line">    &#123; name: &#x27;Peter&#x27;, age: 23 &#125;,</span><br><span class="line">    &#123; name: &#x27;Mark&#x27;, age: 24 &#125;,</span><br><span class="line">    &#123; name: &#x27;Maria&#x27;, age: 22 &#125;,</span><br><span class="line">    &#123; name: &#x27;Monica&#x27;, age: 21 &#125;,</span><br><span class="line">    &#123; name: &#x27;Martha&#x27;, age: 19 &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let friendsNames = Array.from(friends, (&#123;name&#125;) =&gt; name)</span><br><span class="line"></span><br><span class="line">console.log(friendsNames)//returns [&quot;John&quot;, &quot;Peter&quot;, &quot;Mark&quot;, &quot;Maria&quot;, &quot;Monica&quot;, &quot;Martha&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="4-清空数组"><a href="#4-清空数组" class="headerlink" title="4.清空数组"></a>4.清空数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fruits = [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;grape&quot;, &quot;apple&quot;];</span><br><span class="line">//要清空数组，仅需要将数组的长度设置为0</span><br><span class="line">fruits.length = 0;</span><br><span class="line">console.log(fruits); // returns []</span><br></pre></td></tr></table></figure>

<h3 id="5-数组转对象"><a href="#5-数组转对象" class="headerlink" title="5.数组转对象"></a>5.数组转对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fruits = [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;];</span><br><span class="line"></span><br><span class="line">let fruitsObj = &#123;...fruits&#125;;</span><br><span class="line"></span><br><span class="line">console.log(fruitsObj) // returns &#123;0: &quot;banana&quot;, 1: &quot;apple&quot;, 2: &quot;orange&quot;, 3: &quot;watermelon&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-用数据填充数组"><a href="#6-用数据填充数组" class="headerlink" title="6.用数据填充数组"></a>6.用数据填充数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let newArray = new Array(10).fill(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">console.log(newArray)</span><br></pre></td></tr></table></figure>

<h3 id="7-合并数组"><a href="#7-合并数组" class="headerlink" title="7.合并数组"></a>7.合并数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];</span><br><span class="line">var meat = [&quot;poultry&quot;, &quot;beef&quot;, &quot;fish&quot;];</span><br><span class="line">var vegetables = [&quot;potato&quot;, &quot;tomato&quot;, &quot;cucumber&quot;];</span><br><span class="line">//使用扩展运算符...</span><br><span class="line">var food = […fruits, …meat, …vegetables];</span><br><span class="line">console.log(food);</span><br></pre></td></tr></table></figure>

<h3 id="8-求数组的交集"><a href="#8-求数组的交集" class="headerlink" title="8.求数组的交集"></a>8.求数组的交集</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr1 = [0,2,3,5,6,8,6]</span><br><span class="line">var arr2 = [1,2,3,4,5,6,4]</span><br><span class="line">var duplicatedValues = [...new Set(arr1)].filter(item=&gt;arr2.includes(item))</span><br><span class="line">console.log(duplicatedValues)</span><br></pre></td></tr></table></figure>

<h3 id="9-从数组中删除虚值"><a href="#9-从数组中删除虚值" class="headerlink" title="9.从数组中删除虚值"></a>9.从数组中删除虚值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//虚值有：false、0、null、NaN、undefined、&quot;&quot;.</span><br><span class="line">var mixedArr = [0,&quot;blue&quot;,&quot;&quot;,NaN,9,true,undefined,&quot;white&quot;,false]</span><br><span class="line">var trueArr = mixedArr.filter(Boolean)</span><br><span class="line">console.log(trueArr)</span><br></pre></td></tr></table></figure>

<h3 id="10-从数组中获取随机值"><a href="#10-从数组中获取随机值" class="headerlink" title="10.从数组中获取随机值"></a>10.从数组中获取随机值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var colors = [&quot;blue&quot;, &quot;white&quot;, &quot;green&quot;, &quot;navy&quot;, &quot;pink&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;];</span><br><span class="line"></span><br><span class="line">var randomColor = colors[(Math.floor(Math.random() * (color.length)))]</span><br></pre></td></tr></table></figure>

<h3 id="11-反转数组"><a href="#11-反转数组" class="headerlink" title="11.反转数组"></a>11.反转数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var colors = [“blue”, “white”, “green”, “navy”, “pink”, “purple”, “orange”, “yellow”, “black”, “brown”];</span><br><span class="line">var reversedColors = colors.reverse();</span><br><span class="line">console.log(reversedColors);</span><br></pre></td></tr></table></figure>

<h3 id="12-lastIndexOf-方法"><a href="#12-lastIndexOf-方法" class="headerlink" title="12.lastIndexOf()方法"></a>12.lastIndexOf()方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查找给定元素的最后依次出现的索引</span><br><span class="line">var nums = [1, 5, 2, 6, 3, 5, 2, 3, 6, 5, 2, 7];</span><br><span class="line">var lastIndex = nums.lastIndexOf(5);</span><br><span class="line">console.log(lastIndex); // returns 9</span><br></pre></td></tr></table></figure>

<h3 id="13-对数组中所有值求和"><a href="#13-对数组中所有值求和" class="headerlink" title="13.对数组中所有值求和"></a>13.对数组中所有值求和</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var nums = [1,5,4,3]</span><br><span class="line">var sum = nums.reduce((x,y)=&gt;x+y)</span><br><span class="line">console.log(sum)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS垃圾回收机制</title>
    <url>/2019/10/19/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="谈谈-JS-垃圾回收机制？"><a href="#谈谈-JS-垃圾回收机制？" class="headerlink" title="谈谈 JS 垃圾回收机制？"></a>谈谈 JS 垃圾回收机制？</h2> <span id="more"></span>

<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><pre><code>Javascript中的内存管理是自动执行的，而且是不可见的。在我们创建基本类型、对象、函数
时，这些都需要内存，当不需要某样东西时，JavaScript引擎会利用垃圾回收机制清除它。

在局部作用域中，当函数执行完毕，局部变量也就没必要存在了，因此垃圾收集器很容易
做出判断回收。但是全局变量什么时候需要自动释放内存空间很难判断，因此在开发中，
需要尽量避免使用全局变量。
</code></pre>
<h4 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h4><p>JavaScript 中内存管理的主要概念是可达性。</p>
<p>当一些值以某种方式可访问或可用，它们会被存储在内存中，叫做可达值。</p>
<ul>
<li>一些固有可达值，由于显而易见的原因无法删除。例如：<ul>
<li>本地函数的局部变量或参数</li>
<li>当前嵌套调用链上的其他函数的变量和参数</li>
<li>全局变量等</li>
</ul>
</li>
</ul>
<p>这些值 称为 根</p>
<ul>
<li>如果引用或引用链 可以从根访问任何其他值，则认为该值是可访问的。<ul>
<li>一个对象引用另一个对象的属性，则该对象是为可达性。</li>
</ul>
</li>
</ul>
<p>JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除哪些不可访问的对象。</p>
<h4 id="内部算法"><a href="#内部算法" class="headerlink" title="内部算法"></a>内部算法</h4><p>v8 的垃圾回收策略基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同<br>的算法。</p>
<p>新生代采用 Scavenge 算法(赋值算法)</p>
<ul>
<li><p>Scavenge 为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分<br>为 from 和 to 两个空间。每次 gc,会将 from 空间的存活对象复制到 to 空间。然后两个空间角色<br>对换(又称反转)。</p>
</li>
<li><p>该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。</p>
</li>
</ul>
<p>老生代采用 Mark-Sweep(标记清除)和 Mark-Compact(标记整理)</p>
<ul>
<li>标记-清除算法，定期执行一下“垃圾回收”步骤：<ul>
<li>垃圾回收器获取根并“标记”它们</li>
<li>然后访问并标记所有来自它们的引用</li>
<li>然后访问标记的对象 并 标记它们的引用</li>
<li>以此类推，知道有为访问的引用为止</li>
<li>除了标记的对象外，所有对象都被删除。</li>
</ul>
</li>
</ul>
<p>Mark-Compact 算法(标记整理)</p>
<ul>
<li>标记清除存在一个问题，清除死亡对象后会造成内存空间不连续，这时候 v8 会使用<br>Mark-Compact 算法(标记整理)，它会在标记完成之后将活着的对象往一端移动，移动完成<br>后直接清理掉边界外的内存。</li>
</ul>
<p>Reference Counting(引用计数算法)</p>
<ul>
<li>引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时<br>更新计数器，如果计数器值为 0 则直接回收内存。 很明显，引用计数最大的优势是暂停时间短</li>
</ul>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li><p>增量回收：如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费<br>一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分，然后<br>各个部分分别执行，这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。</p>
</li>
<li><p>空闲时间收集：垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。</p>
</li>
</ul>
<h4 id="v8-的内存限制"><a href="#v8-的内存限制" class="headerlink" title="v8 的内存限制"></a>v8 的内存限制</h4><ul>
<li>64 位系统最大约为 1.4G</li>
<li>32 位系统最大约为 0.7G</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM基本操作</title>
    <url>/2019/08/11/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="DOM-基本操作"><a href="#DOM-基本操作" class="headerlink" title="DOM 基本操作"></a>DOM 基本操作</h2><span id="more"></span>

<ul>
<li><p>获取 Dom 节点</p>
<ul>
<li><p>document 代表整个文档</p>
</li>
<li><p>document.getElementById()</p>
</li>
<li><p>document.getElementByTagName()</p>
</li>
<li><p>document.getElementByName() //只有部分标签 name 可生效，表单之类的</p>
</li>
<li><p>document.getElementByClassName()</p>
</li>
<li><p>querySelector() //静态的，不是实时的，保存的是当时的状态，是一个副本</p>
</li>
<li><p>querySelectorAll() //即使以后元素发生了改变，该值也不会改变</p>
</li>
</ul>
</li>
<li><p>遍历节点树</p>
<ul>
<li><p>parentNode -&gt; 父节点（最顶端 parentNode 为#document）</p>
</li>
<li><p>childNodes -&gt; 子节点们</p>
</li>
<li><p>firstChild -&gt; 第一个子节点</p>
</li>
<li><p>lastChild -&gt; 最后一个子节点</p>
</li>
<li><p>nextSibling -&gt; 后一个兄弟节点</p>
</li>
<li><p>previousSibling -&gt;前一个兄弟节点</p>
</li>
</ul>
</li>
<li><p>遍历元素节点树</p>
<ul>
<li><p>parentElement -&gt; 返回当前元素的父元素节点（IE9 以下不兼容）</p>
</li>
<li><p>children -&gt; 返回当前元素的元素子节点</p>
</li>
<li><p>node.childElementCount === node.children.length 返回当前元素的子元素节点个数（IE9 以下不兼容）</p>
</li>
<li><p>firstElementChild -&gt; 返回第一个元素节点（IE9 以下不兼容）</p>
</li>
<li><p>lastElementChild -&gt; 返回最后一个元素节点（IE9 以下不兼容）</p>
</li>
<li><p>nextElementSibling -&gt; 返回后一个元素节点（IE9 以下不兼容）</p>
</li>
<li><p>previousElementSibling -&gt; 返回前一个元素节点（IE9 以下不兼容）</p>
</li>
</ul>
</li>
<li><p>节点的类型</p>
<ul>
<li><p>元素节点 —— 1</p>
</li>
<li><p>属性节点 —— 2</p>
</li>
<li><p>文本节点 —— 3</p>
</li>
<li><p>注释节点（Comment）—— 8</p>
</li>
<li><p>document —— 9</p>
</li>
<li><p>DocumentFragment —— 11</p>
</li>
<li><p>获取节点类型 nodeType</p>
</li>
</ul>
</li>
<li><p>节点的四个属性</p>
<ul>
<li><p>nodeName</p>
<ul>
<li>元素的标签名，以大写形式表示，只读</li>
</ul>
</li>
<li><p>nodeValue</p>
<ul>
<li>Text 节点或 Comment 节点的文本内容，可读写</li>
</ul>
</li>
<li><p>nodeType</p>
<ul>
<li>该节点的类型，只读</li>
</ul>
</li>
<li><p>attributes</p>
<ul>
<li>Element 节点的属性集合</li>
</ul>
</li>
</ul>
</li>
<li><p>节点的一个方法</p>
<ul>
<li>Node.hasChildNodes()<ul>
<li>所有节点都有 hasChildNodes()方法，判断有无子节点，有一个或多个返回 true</li>
</ul>
</li>
</ul>
</li>
<li><p>Dom 基本操作——增</p>
<ul>
<li>document.createElement()</li>
<li>document.createTextNode()</li>
<li>document.createComment()</li>
<li>document.createDocumentFragment()</li>
</ul>
</li>
<li><p>Dom 基本操作——插</p>
<ul>
<li>parentNode.appendChild()</li>
<li>parentNode.insertBefore(a, b)</li>
</ul>
</li>
<li><p>Dom 基本操作——删</p>
<ul>
<li>parent.removeChild()</li>
<li>child.remove()</li>
</ul>
</li>
<li><p>Dom 基本操作-替换</p>
<ul>
<li>parent.replaceChild(new, origin)</li>
</ul>
</li>
<li><p>Element 节点的一些属性</p>
<ul>
<li>innerHTML</li>
<li>innerText(火狐不兼容)/textContent(老版本 IE 不兼容)</li>
</ul>
</li>
<li><p>Element 节点的一些方法</p>
<ul>
<li>ele.setAttribute()</li>
<li>ele.getAttribute()</li>
</ul>
</li>
<li><p>查看元素的几何尺寸</p>
<ul>
<li><p>domEle.getBoundingClientRect()</p>
</li>
<li><p>兼容性很好</p>
</li>
<li><p>返回一个对象，里面有 left、top、right、bottom、width、height。</p>
</li>
</ul>
<p>left 和 top 代表元素左上角的 X 和 Y 坐标，right 和 bottom 代表元素右下角的 X 和 Y 坐标</p>
<ul>
<li><p>height 和 width 属性老版本 IE 未实现</p>
</li>
<li><p>返回的结果不是“实时的”</p>
</li>
</ul>
</li>
<li><p>查看元素的宽高尺寸<br>dom.offsetWidth</p>
<p>dom.offsetHeight</p>
</li>
<li><p>查看元素的位置<br>dom.offsetLeft</p>
<p>dom.offsetTop</p>
<p>对于无定位父级的元素，返回相对文档的坐标。</p>
<p>对于有定位的父级元素，返回相对最近的有定位的父级的坐标，无论距离是怎么产生的</p>
</li>
<li><p>dom.offsetParent<br>返回最近的有定位的父级，若无，返回 body，body.offsetParent 返回 nul</p>
</li>
<li><p>让滚动条滚动</p>
<ul>
<li>window 上的三个方法：scroll()==scrollTo()、scrollBy()</li>
<li>scroll()和 scrollTo()将 x、y 坐标传入，让滚动条滚动到当前位置</li>
<li>scrollBy() 会在之前的数据基础上累加，可以利用 scrollBy()实现快速阅读的功能</li>
</ul>
</li>
<li><p>查询计算样式</p>
<ul>
<li><p>window.getComputedStyle(ele, null)[style]</p>
</li>
<li><p>第二个参数 null，放的是伪元素，可以获取伪元素的属性</p>
</li>
<li><p>计算样式只读</p>
</li>
<li><p>返回的计算样式都是绝对值，没有相对单位</p>
</li>
</ul>
<p>-IE8 及以下不兼容（ele.currentStyle[style]）</p>
</li>
<li><p>封装函数，返回元素的第 n 层祖先元素节点</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function retParent(elem, n) &#123;</span><br><span class="line">    while(elem &amp;&amp; n) &#123;</span><br><span class="line">        elem = elem.parentElement</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">    return elem</span><br><span class="line">&#125;</span><br><span class="line">var i = document.getElementByTagName(&#x27;i&#x27;)[0]</span><br></pre></td></tr></table></figure>

<ul>
<li>原型上封装函数 myChildren 获取子元素，解决一千浏览器的兼容性问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.prototype.myChildren = function () &#123;</span><br><span class="line">    var child = this.childNodes</span><br><span class="line">    var len = child.length</span><br><span class="line">    for (var i = 0;i &lt; len; i++) &#123;</span><br><span class="line">        if(child[i].nodeType == 1) &#123;</span><br><span class="line">            arr.push(child[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var div = document.getElementByTagName(&#x27;div&#x27;)[0]</span><br></pre></td></tr></table></figure>

<ul>
<li>自己封装 hasChildren()方法，不可用 children 属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.prototype.hasChildren = function () &#123;</span><br><span class="line">    var child = this.childNodes</span><br><span class="line">    var len = child.length</span><br><span class="line">    for (var i = 0;i &lt; len; i++) &#123;</span><br><span class="line">        if(child[i].nodeType == 1) &#123;</span><br><span class="line">           return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var div = document.getElementByTagName(&#x27;div&#x27;)[0]</span><br></pre></td></tr></table></figure>

<ul>
<li>封装函数，返回元素 e 的第 n 个兄弟元素节点，n 为正，返回后面的兄弟元素节点，n 为负，返回前面的，n 为 0，返回自己</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function retSibling(e, n) &#123;</span><br><span class="line">    while(e &amp;&amp; n) &#123;</span><br><span class="line">        if(n &gt; 0) &#123;</span><br><span class="line">            if(e.nextElementSibling) &#123;</span><br><span class="line">                e.nextElementSibling</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for(e = e.nextSibling; e &amp;&amp; e.nodeType != 1; e = e.nextSibling)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if(e.previousElementSibling) &#123;</span><br><span class="line">                e = e.previousElementSibling</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for(e = e.previousSibling; e &amp;&amp; e.nodeType != 1; e = e.previousSibling)</span><br><span class="line">            &#125;</span><br><span class="line">            n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>封装 insertAfter(),功能类似与 insertBefore(new, origin),直接在 Element.prototype 上编程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.prototype.insertAfter = function(new, origin) &#123;</span><br><span class="line">    var beforeNode = origin.nextElementSibling</span><br><span class="line">    if (beforeNode == null) &#123;</span><br><span class="line">        this.appendChild(new)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.insertBefore(new, beforeNode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>封装滚动条的 x 轴、y 轴的距离函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getScrollOffset() &#123;</span><br><span class="line">    if (window.pageXOffset) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: window.pageXOffset,</span><br><span class="line">            y: window.pageYOffset</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: document.body.scrollLeft + document.documentElement.scrollLeft,</span><br><span class="line">            y: document.body.scrollTop + document.documentElement.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>封装可视区窗口大小的函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getViewportOffset() &#123;</span><br><span class="line">    if (window.innerWidth) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            w: window.innerWidth,</span><br><span class="line">            h: window.innerHeight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (document.compatMode === &#x27;BackCompat&#x27;) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                w: document.body.clientWidth,</span><br><span class="line">                h: document.body.clientHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                w: document.documentElement.clientWidth,</span><br><span class="line">                h: document.documentElement.clientHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>封装样式获取的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getStyle(elem, prop) &#123;</span><br><span class="line">    if(window.getComputedStyle) &#123;</span><br><span class="line">        return window.getComputedStyle(elem, null)[prop]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return elem.currentStyle[prop]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery学习</title>
    <url>/2020/09/05/Jquery%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="jQuery-学习"><a href="#jQuery-学习" class="headerlink" title="jQuery 学习"></a>jQuery 学习</h2><span id="more"></span>

<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><ul>
<li>jQuery 入口函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;)</span><br><span class="line">或者（简写）</span><br><span class="line">$(function()&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<!-- more -->

<ul>
<li>javascript 入口函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>jQuery 的入口函数是在 html 的所有标签 DOM 都加载之后，就会执行包裹的代码，可以执行多次，并且不会覆盖上次。</li>
<li>javascript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完成后，才会执行，只能执行一次，如果第二次会把第一次的执行覆盖。</li>
</ul>
<h3 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h3><ul>
<li>元素选择器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>id 选择器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#test&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>class 选择器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;.test&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>属性选择器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;[href]&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>:empty 选择器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;:empty&quot;)</span><br><span class="line">//选择空的元素，既不不含子元素也不包含文本的元素</span><br><span class="line">$(&quot;div:empty&quot;) //选择div中为空的div元素</span><br></pre></td></tr></table></figure>

<ul>
<li>:parent 选择器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;td:parent&quot;)</span><br><span class="line">//选取所有带有子元素或文本的&lt;td&gt;标签元素</span><br></pre></td></tr></table></figure>

<ul>
<li>:contains 选择器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;div:contains(&#x27;hello&#x27;)&quot;)</span><br><span class="line">//找到div中包含文本hello的指定元素</span><br></pre></td></tr></table></figure>

<ul>
<li>:has 选择器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;div:has(p)&quot;)</span><br><span class="line">//找到包含p标签元素的div</span><br></pre></td></tr></table></figure>

<ul>
<li>补充</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;:button&quot;) //获取所有type为button的&lt;input&gt;元素和&lt;button&gt;元素，去掉冒号，只能获取&lt;button&gt;元素。</span><br></pre></td></tr></table></figure>

<h3 id="常用-jQuery-事件方法"><a href="#常用-jQuery-事件方法" class="headerlink" title="常用 jQuery 事件方法"></a>常用 jQuery 事件方法</h3><ul>
<li>click() 点击事件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).click(function()&#123;</span><br><span class="line">    $(this).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>dblclick() 双击事件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).dblclick(function()&#123;</span><br><span class="line">    $(this).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>mouseenter() 鼠标指针穿过元素时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseenter(function()&#123;</span><br><span class="line">    alert(&quot;您的鼠标移到了p标签元素上！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>mouseleave() 鼠标指针离开元素时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseleave(function()&#123;</span><br><span class="line">    alert(&quot;您的鼠标离开了该p标签元素！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>mouseup() 当在元素上松开鼠标时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseup(()=&gt;&#123;</span><br><span class="line">    alert(&quot;鼠标在p标签上松开！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>hover() 模拟光标悬停事件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).hover(</span><br><span class="line">    function()&#123;</span><br><span class="line">        alert(&quot;你进入了p标签！&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function()&#123;</span><br><span class="line">        alert(&quot;你离开了p标签！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>focus() 当元素获得焦点时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;input&quot;).focus(function()&#123;</span><br><span class="line">    $(this).css(&quot;background-color&quot;,&quot;#ccc&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>blur() 当元素失去焦点时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;input&quot;).blur(function()&#123;</span><br><span class="line">    $(this).css(&quot;background-color&quot;,&quot;#fff&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>keypress,keydown,keyup</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取按键代码或ASCII码</span><br><span class="line">$(window).keydown(function(event)&#123;</span><br><span class="line">    //通过event.which可以拿到按键代码，如果是keypress事件中则拿到ASCII码。</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;)</span><br><span class="line">//获取事件对象</span><br><span class="line">$(window).keypress(function(event)&#123;</span><br><span class="line">    //获取事件对象，里面包含各种有用的信息。</span><br><span class="line">    console.log(event);</span><br><span class="line">    //console.log(event.which);</span><br><span class="line">&#125;);</span><br><span class="line">//keypress事件获取键入的字符</span><br><span class="line">$(window).keypress(function(event)&#123;</span><br><span class="line">    //event.which是获取ASCII码，前面的函数是将ASCII码转换成字符，空格键和Enter键输出均为空白。</span><br><span class="line">    console.log(String.fromCharCode(event.which));</span><br><span class="line">    //从event对象中key属性获取字符，但是Enter键的key值为&quot;Enter&quot;，空白键还是空白&quot; &quot;。</span><br><span class="line">    console.log(event.key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>off() 事件移除</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).off() //移除所有button元素身上绑定的事件</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).off(&quot;click&quot;) //移除所有的click事件，移除指定类型</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).off(&quot;click&quot;, test) //移除click事件中的test回调方法，移除指定类型的事件</span><br></pre></td></tr></table></figure>

<ul>
<li>阻止事件冒泡</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;.son&quot;).click(function(event)&#123;</span><br><span class="line">    alert(&quot;son&quot;)</span><br><span class="line">    //return false;</span><br><span class="line">    event.stopPropagation(); //阻止事件冒泡</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;.father&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;father&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>阻止默认行为</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//a标签跳转、submit提交按钮等</span><br><span class="line">$(&quot;a&quot;).click(function(event)&#123;</span><br><span class="line">    alert(&quot;弹出注册框！&quot;);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>trigger()、triggerHandler() 自动触发事件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//触发绑定到被选元素的所有事件</span><br><span class="line">$(&quot;.father&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;father&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.father&quot;).trigger(&quot;click&quot;);   //方法一:会触发事件冒泡</span><br><span class="line">$(&quot;.father&quot;).triggerHandler(&quot;click&quot;); //方法二:只触发事件，不会触发事件冒泡</span><br><span class="line">-------------------------------</span><br><span class="line">$(&quot;input[type=&#x27;submit&#x27;]&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;submit&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;input[type=&#x27;submit&#x27;]&quot;).trigger(&quot;click&quot;); //方法一：触发事件的同时，还会触发默认行为。</span><br><span class="line">$(&quot;input[type=&#x27;submit&#x27;]&quot;).triggerHandler(&quot;click&quot;) //方法二：只触发事件，不触发默认行为。</span><br><span class="line">//注意：这里&lt;a&gt;标签有点特殊，这两个方法都不会触发默认行为，如果想使用trigger()触发&lt;a&gt;标签的事件和默认行为的话，可以在&lt;a&gt;标签中添加一个&lt;span&gt;,例如&lt;a href =&quot;#&quot;&gt;&lt;span&gt;百度&lt;/span&gt;&lt;/a&gt; 这种写法。</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义事件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 想要自定义事件，必须满足两个条件</span><br><span class="line">* 1.事件必须是通过on绑定的</span><br><span class="line">* 2.事件必须通过trigger来触发</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).on(&quot;myClick&quot;,function()&#123;</span><br><span class="line">    alert(&quot;son&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).trigger(&quot;myClick&quot;);</span><br><span class="line">or</span><br><span class="line">$(&quot;.son&quot;).triggerHandler(&quot;myClick&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>事件命名空间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 想要事件的命名空间有效，必须满足两个条件</span><br><span class="line">* 1.事件通过on来绑定(自定义事件)</span><br><span class="line">* 2.通过trigger()或者triggerHandler()来触发</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).on(&quot;eventName.zs&quot;,function()&#123;</span><br><span class="line">    alert(&quot;click zhangsan&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.son&quot;).on(&quot;eventName.ls&quot;,function()&#123;</span><br><span class="line">    alert(&quot;click lisi&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.son&quot;).trigger(&quot;click.zs&quot;);</span><br><span class="line">or</span><br><span class="line">$(&quot;.son&quot;).triggerHandler(&quot;click.zs&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="隐藏和显示"><a href="#隐藏和显示" class="headerlink" title="隐藏和显示"></a>隐藏和显示</h3><ul>
<li>hide() 隐藏 html 元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#hide&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>show() 显示 html 元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#show&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).show();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(selector).hide(speed,callback);</span><br><span class="line"></span><br><span class="line">$(selector).show(speed,callback);</span><br><span class="line"></span><br><span class="line">//可选的speed参数表示规定显示/隐藏的速度(slow、fast、毫秒)</span><br><span class="line">//可选的callback参数是隐藏或显示完成后所执行的函数名称</span><br><span class="line"></span><br><span class="line">$(&quot;.hidebtn&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;div&quot;).hide(1000,&quot;linear&quot;,function()&#123;</span><br><span class="line">        alert(&quot;Hide() 方法已完成!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//第二个参数是一个字符串，表示过渡使用哪种缓动函数，jQuery自身提供(linear、swing)</span><br><span class="line">//补充：callback函数名后面加上括号，会立刻执行函数体，而不是等到显示/隐藏之后才执行,如add()作为callback参数会立即执行，而add作为参数则不会，callback函数可以是匿名函数，$(selector)选中的元素个数为n个，则callback函数会执行n次。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>toggle() 切换 hide()和 show()方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).toggle();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><ul>
<li>fadeIn() 用于淡入以隐藏的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeIn(3000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法： $(selector).fadeIn(speed, callback)</span><br><span class="line">// 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">// 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure>

<ul>
<li>fadeOut() 用于淡出可见元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeOut(&quot;slow&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//语法： $(selector).fadeOut(speed, callback)</span><br><span class="line">// 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">// 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure>

<ul>
<li>fadeToggle() 用于在 fadeIn()与 fadeOut()方法之间进行切换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeToggle();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//语法： $(selector).fadeToggle(speed, callback)</span><br><span class="line">// 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">// 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure>

<ul>
<li>fadeTo() 允许渐变为给定的不透明度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.3);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).fadeTo(speed, opacity, callback)</span><br><span class="line">//必须的speed参数规定效果时长(slow、fast、毫秒)</span><br><span class="line">//必须的opacity规定不透明度(介于0-1之间)</span><br></pre></td></tr></table></figure>

<h3 id="滑动方法"><a href="#滑动方法" class="headerlink" title="滑动方法"></a>滑动方法</h3><ul>
<li>slideDown() 用于元素向下滑动</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideDown();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).slideDown(speed,callback)</span><br><span class="line">//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">//可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure>

<ul>
<li>slideUp() 用于元素向上滑动</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideUp();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).slideUp(speed,callback)</span><br><span class="line">//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">//可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure>

<ul>
<li>slideToggle() 在 slideDown()与 slideUp()方法之间进行切换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideToggle();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).slideToggle(speed,callback)</span><br><span class="line">//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">//可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure>

<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul>
<li>animate()方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//默认情况下，所有html元素都有一个静态位置，且无法移动。</span><br><span class="line">//先将p标签元素设置为position:relative/absolute/fixed</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;p&quot;).animate(&#123;</span><br><span class="line">      left:&#x27;250px&#x27;,</span><br><span class="line">      opacity:&#x27;0.5&#x27;,</span><br><span class="line">      height:&#x27;400px&#x27;,</span><br><span class="line">      width: &#x27;400px&#x27;,</span><br><span class="line">      paddingLeft:&#x27;10px&#x27;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//语法： $(selector).animate(&#123;params&#125;,speed,callback)</span><br><span class="line">// params参数可以操作几乎所有的css属性，但名字要采用camel标记法</span><br></pre></td></tr></table></figure>

<ul>
<li>stop() 停止动画</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> $(&quot;#flip&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;#panel&quot;).slideDown(5000);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">$(&quot;#stop&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;#panel&quot;).stop();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">语法: $(selector).stop(stopAll,goToEnd)</span><br><span class="line">//可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停/止活动的动画，允许任何排入队列的动画向后执行。</span><br><span class="line">//可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。</span><br></pre></td></tr></table></figure>

<ul>
<li>jQuery 方法链接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;)</span><br><span class="line">  .slideUp(2000)</span><br><span class="line">  .slideDown(2000);</span><br></pre></td></tr></table></figure>

<h3 id="jQuery-获取内容和属性"><a href="#jQuery-获取内容和属性" class="headerlink" title="jQuery 获取内容和属性"></a>jQuery 获取内容和属性</h3><ul>
<li>获取内容 text()、html()、val()<ul>
<li>text() 设置或返回所选元素的文本内容</li>
<li>html() 设置或返回所选元素的内容(包括 html 标记)</li>
<li>val() 设置或返回表单字段的值</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).text());</span><br><span class="line">&#125;)</span><br><span class="line">//-----------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).html())</span><br><span class="line">&#125;)</span><br><span class="line">//------------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  alert($(&quot;input&quot;).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取属性 attr()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//项目QC刚用过</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    console.log($(&quot;p&quot;).attr(&quot;data-text&quot;));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>补充：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop()函数返回相应属性或空字符串。</span><br><span class="line">attr()函数返回相应属性或undefined</span><br><span class="line">1.对于HTML元素本身就带有的固有属性，在处理时使用prop方法</span><br><span class="line">2.对HTML元素我们自己定义的DOM属性，在处理时使用attr方法</span><br><span class="line">3.具有true和false两个属性的属性，如checked、selected或者disabled使用prop()</span><br></pre></td></tr></table></figure>

<h3 id="设置内容和属性"><a href="#设置内容和属性" class="headerlink" title="设置内容和属性"></a>设置内容和属性</h3><ul>
<li>设置内容 text()、html()、val()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).text(&quot;hello&quot;));</span><br><span class="line">&#125;)</span><br><span class="line">//-----------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).html(&quot;hello&quot;))</span><br><span class="line">&#125;)</span><br><span class="line">//------------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  alert($(&quot;input&quot;).val(&quot;hello&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>text()、html() 以及 val() 的回调函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).text(function(i,orignText)&#123;</span><br><span class="line">        //i 为被选元素列表中当前元素的下标</span><br><span class="line">        //orignText 为原来的值</span><br><span class="line">        //return 为返回的新值</span><br><span class="line"></span><br><span class="line">        return &quot;hello&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>设置属性 attr()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).attr(&quot;data-text&quot;,&quot;hello world&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 允许同时设置多个属性</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).attr(&#123;</span><br><span class="line">        &quot;data-text&quot;,&quot;hello world&quot;,</span><br><span class="line">        &quot;title&quot;,&quot;jQuery学习！&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>attr() 也存在回调函数(同上)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;#runoob&quot;).attr(&quot;href&quot;, function(i,origValue)&#123;</span><br><span class="line">    return origValue + &quot;/jquery&quot;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><ul>
<li>removeAttr()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;span&quot;).removeAttr(&quot;class name&quot;);</span><br><span class="line">//表示同时删除span标签的class和name属性</span><br></pre></td></tr></table></figure>

<ul>
<li>removeProp()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;span&quot;).removeProp(&quot;class&quot;);</span><br><span class="line">//表示删除所有span标签的class属性</span><br></pre></td></tr></table></figure>

<h3 id="jQuery-添加元素"><a href="#jQuery-添加元素" class="headerlink" title="jQuery 添加元素"></a>jQuery 添加元素</h3><ul>
<li><p>append/prepend 是在选择元素内容嵌入(文本或标签)</p>
</li>
<li><p>after/before 实在元素外部追加(文本或标签)</p>
</li>
<li><p>参数可以是多个，可以是一个 list</p>
</li>
</ul>
<h3 id="jQuery-删除元素"><a href="#jQuery-删除元素" class="headerlink" title="jQuery 删除元素"></a>jQuery 删除元素</h3><ul>
<li>remove() 方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).remove()</span><br><span class="line"></span><br><span class="line">//remove() 方法删除被选元素及其子元素</span><br></pre></td></tr></table></figure>

<ul>
<li>empty() 方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).empty()</span><br><span class="line"></span><br><span class="line">//empty() 方法删除被选元素的子元素而不删除自身</span><br></pre></td></tr></table></figure>

<ul>
<li>过滤被删除的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).remove(&quot;.italic&quot;)</span><br><span class="line"></span><br><span class="line">//表示删除所有&lt;p&gt;标签元素中class = &quot;italic&quot;的元素</span><br><span class="line">//过滤时，只能作用于同级元素之间</span><br></pre></td></tr></table></figure>

<h3 id="jQuery-获取并设置-CSS-类"><a href="#jQuery-获取并设置-CSS-类" class="headerlink" title="jQuery 获取并设置 CSS 类"></a>jQuery 获取并设置 CSS 类</h3><ul>
<li>addClass() 向不用的元素添加 class 属性，在添加类时可以选取多个元素,也可以设置多个类。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">	$(&quot;h1, h3, p&quot;).addClass(&quot;fontColor fontSize&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>removeClass() 在不同元素中删除指定的 class 属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">	$(&quot;h1, h3, p&quot;).removeClass(&quot;fontSize&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>toggleClass() 对被选元素进行添加/删除类的切换操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;.btn2&quot;).click(function()&#123;</span><br><span class="line">	$(&quot;h1, h3, p&quot;).toggleClass(&quot;fontColor2&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="css-方法"><a href="#css-方法" class="headerlink" title="css() 方法"></a>css() 方法</h3><ul>
<li>返回 css 属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).css(&quot;background-color&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 css 属性,可以同时设置多个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).css(&#123;&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><ul>
<li>width()、height()<ul>
<li>width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）</li>
<li>height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).width() //获取</span><br><span class="line">$(&quot;p&quot;).width(20) //设置</span><br></pre></td></tr></table></figure>

<ul>
<li><p>innerWidth()、innerHeight()</p>
<ul>
<li>innerWidth() 方法返回元素的宽度（包括内边距）。</li>
<li>innerHeight() 方法返回元素的高度（包括内边距）。</li>
</ul>
</li>
<li><p>outerWidth()、outerHeight()</p>
<ul>
<li>outerWidth() 方法返回元素的宽度（包括内边距和边框）。</li>
<li>outerHeight() 方法返回元素的高度（包括内边距和边框）。</li>
</ul>
</li>
<li><p>offset()</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;.son&quot;).offset().left //元素距离窗口的偏移距离</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).offset(&#123;</span><br><span class="line">    left: 20,</span><br><span class="line">&#125;) //设置元素距离窗口的偏移距离</span><br></pre></td></tr></table></figure>

<ul>
<li>position()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;.son&quot;).position().left //获取元素距离定位元素的偏移距离</span><br><span class="line"></span><br><span class="line">// 注意点：position() 方法只能获取不能设置</span><br></pre></td></tr></table></figure>

<ul>
<li>scrollTop()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;scroller&quot;).scrollTop() //获取元素相对滚动条顶部的偏移</span><br><span class="line"></span><br><span class="line">$(&quot;scroller&quot;).scrollTop(300) //设置元素相对滚动条顶部的偏移</span><br><span class="line"></span><br><span class="line">//获取网页滚动的偏移(考虑兼容)</span><br><span class="line">$(&quot;body&quot;).scrollTop() + $(&quot;html&quot;).scrollTop() //ie-&gt;body,chrome...-&gt;html</span><br><span class="line"></span><br><span class="line">//设置网页滚动的偏移(考虑兼容)</span><br><span class="line">$(&quot;html,body&quot;).scrollTop(300)</span><br></pre></td></tr></table></figure>

<ul>
<li>补充：设置了 box-sizing 后，width()=width - padding - border</li>
</ul>
<h3 id="jQuery-遍历"><a href="#jQuery-遍历" class="headerlink" title="jQuery 遍历"></a>jQuery 遍历</h3><h4 id="祖先"><a href="#祖先" class="headerlink" title="祖先"></a>祖先</h4><ul>
<li>parent() 返回元素的直接父元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>parents() 返回被选元素的所有祖先元素，直到文档根元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents();</span><br><span class="line">&#125;)</span><br><span class="line">//过滤所有祖先，并且是&lt;ul&gt;元素</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents(&quot;ul&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>parentsUntil() 返回给定的两个元素之间的所有祖先元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//返回&lt;span&gt;与&lt;div&gt;元素之间的所有祖先元素</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parentsUntil(&quot;div&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="后代"><a href="#后代" class="headerlink" title="后代"></a>后代</h4><ul>
<li>children() 返回被选元素的所有直接子元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;div&quot;).children();</span><br><span class="line"></span><br><span class="line">//可以使用可选参数来过滤子元素的搜索</span><br><span class="line">$(&quot;div&quot;).children(&quot;p.aaa&quot;); //返回类名为aaa的&lt;p&gt;元素，且是div的直接子元素。</span><br></pre></td></tr></table></figure>

<ul>
<li>find() 返回被选元素的后代元素，一路向下直到最后一个后代</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;div&quot;).find(&quot;span&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="同胞"><a href="#同胞" class="headerlink" title="同胞"></a>同胞</h4><ul>
<li><p>siblings() 返回被选元素的所有同胞元素，可以使用可选参数过滤搜索。</p>
</li>
<li><p>next() 返回被选元素的下一个同胞元素，只返回一个元素</p>
</li>
<li><p>nextAll() 返回被选元素的所有跟随的同胞元素</p>
</li>
<li><p>nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素</p>
</li>
<li><p>pre()、prevAll()、prevUntil() 同上，方向相反</p>
</li>
</ul>
<h4 id="过滤：缩小搜索元素的范围"><a href="#过滤：缩小搜索元素的范围" class="headerlink" title="过滤：缩小搜索元素的范围"></a>过滤：缩小搜索元素的范围</h4><ul>
<li>first() 返回被选元素的首个元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).first();</span><br></pre></td></tr></table></figure>

<ul>
<li>last() 返回被选元素的最后一个元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).last();</span><br></pre></td></tr></table></figure>

<ul>
<li>eq() 返回被选元素中带有指定索引号的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).eq(1);</span><br><span class="line"></span><br><span class="line">//索引号从0开始，eq(1)选择的是第二个&lt;p&gt;元素</span><br></pre></td></tr></table></figure>

<ul>
<li>filter() 允许规定一个标准，返回匹配的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).filter(&quot;.className&quot;);</span><br><span class="line"></span><br><span class="line">//返回带有类名className的所有&lt;p&gt;元素</span><br></pre></td></tr></table></figure>

<ul>
<li>not() 返回所有不匹配的元素，与 filter()相反</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).not(&quot;.className&quot;);</span><br><span class="line"></span><br><span class="line">//返回所有不带有类名className的&lt;p&gt;元素</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS每日一题</title>
    <url>/2022/04/15/JS%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h2 id="设计-LazyMan-类"><a href="#设计-LazyMan-类" class="headerlink" title="设计 LazyMan 类"></a>设计 LazyMan 类</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目</span></span><br><span class="line"><span class="title class_">LazyMan</span>(<span class="string">&quot;Tony&quot;</span>)</span><br><span class="line">  .<span class="title function_">eat</span>(<span class="string">&quot;lunch&quot;</span>)</span><br><span class="line">  .<span class="title function_">eat</span>(<span class="string">&quot;dinner&quot;</span>)</span><br><span class="line">  .<span class="title function_">sleepFirst</span>(<span class="number">5</span>)</span><br><span class="line">  .<span class="title function_">sleep</span>(<span class="number">10</span>)</span><br><span class="line">  .<span class="title function_">eat</span>(<span class="string">&quot;junk food&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了5秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// I am eating dinner</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating junk food</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazyManClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi I am <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taskList</span> = [];</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">next</span>();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params">food</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> fn = (<span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I am eating <span class="subst">$&#123;f&#125;</span>`</span>);</span><br><span class="line">        that.<span class="title function_">next</span>();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(food);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taskList</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sleep</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> fn = (<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`等待了<span class="subst">$&#123;t&#125;</span>秒...`</span>);</span><br><span class="line">          that.<span class="title function_">next</span>();</span><br><span class="line">        &#125;, t * <span class="number">1000</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(time);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taskList</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sleepFirst</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> fn = (<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`等待了<span class="subst">$&#123;t&#125;</span>秒...`</span>);</span><br><span class="line">          that.<span class="title function_">next</span>();</span><br><span class="line">        &#125;, t * <span class="number">1000</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(time);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taskList</span>.<span class="title function_">unshift</span>(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 负责执行任务队列</span></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="variable language_">this</span>.<span class="property">taskList</span>.<span class="title function_">shift</span>();</span><br><span class="line">    fn &amp;&amp; <span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">LazyMan</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LazyManClass</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="按照规则解析字符串"><a href="#按照规则解析字符串" class="headerlink" title="按照规则解析字符串"></a>按照规则解析字符串</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入一串数字字符串，经过解析</span></span><br><span class="line"><span class="comment">// 如果连续数字的话，就取连续的第一个数和最后一个数，中间用 ～ 隔开</span></span><br><span class="line"><span class="comment">// 如果不连续就用 ， 隔开</span></span><br><span class="line"><span class="comment">// 输入 &#x27;1， 2， 3， 5， 7， 8， 10&#x27;，输出&#x27;1~3, 5, 7~8, 10&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getValue</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = str.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> +i);</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> tmp = arr[<span class="number">0</span>];</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item + <span class="number">1</span> !== self[index + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tmp !== item) &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;tmp&#125;</span>~<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(item);</span><br><span class="line">      &#125;</span><br><span class="line">      tmp = self[index + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;1,2,3,5,7,8,9&quot;</span>;</span><br><span class="line"><span class="title function_">getValue</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getValue2</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = str.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> +i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> target = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur - <span class="number">1</span> === self[index - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span>~<span class="subst">$&#123;cur&#125;</span>`</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span>,<span class="subst">$&#123;cur&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">    .<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 1~2~3~4~5 =&gt; 1~5</span></span><br><span class="line">      <span class="keyword">const</span> reg = <span class="regexp">/(\d&#123;1,&#125;)(~\d&#123;1,&#125;)*(~\d&#123;1,&#125;)/</span>;</span><br><span class="line">      <span class="keyword">return</span> item.<span class="title function_">replace</span>(reg, <span class="string">&quot;$1$3&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;1,2,3,5,7,8,9&quot;</span>;</span><br><span class="line"><span class="title function_">getValue2</span>(str);</span><br></pre></td></tr></table></figure>

<h2 id="this-全面考察"><a href="#this-全面考察" class="headerlink" title="this 全面考察"></a>this 全面考察</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;person1&quot;</span>,</span><br><span class="line">  <span class="attr">show1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">show2</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">show3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">show4</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&quot;person2&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">show1</span>(); <span class="comment">// person1</span></span><br><span class="line">person1.<span class="property">show1</span>.<span class="title function_">call</span>(person2); <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">show2</span>(); <span class="comment">// window</span></span><br><span class="line">person1.<span class="property">show2</span>.<span class="title function_">call</span>(person2); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">show3</span>()(); <span class="comment">// window &#123;&#125;</span></span><br><span class="line">person1.<span class="title function_">show3</span>().<span class="title function_">call</span>(person2); <span class="comment">// person2 &#123;&#125;</span></span><br><span class="line">person1.<span class="property">show3</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// window &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">show4</span>()(); <span class="comment">// &#x27;person1&#x27;</span></span><br><span class="line">person1.<span class="title function_">show4</span>().<span class="title function_">call</span>(person2); <span class="comment">// &#x27;person1&#x27;</span></span><br><span class="line">person1.<span class="property">show4</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// &#x27;person2&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6453234253452432 + 7326362323251323</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumberSum</span>(<span class="params">str1, str2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr1 = str1.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>();</span><br><span class="line">  <span class="keyword">const</span> arr2 = str2.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> length = <span class="title class_">Math</span>.<span class="title function_">max</span>(arr1.<span class="property">length</span>, arr2.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> num1 = <span class="title class_">Number</span>(arr1[i]) || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> num2 = <span class="title class_">Number</span>(arr2[i]) || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> sum = num1 + num2 + flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      sum = sum % <span class="number">10</span>;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="title function_">push</span>(sum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(flag);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bigNumberSum</span>(<span class="string">&quot;6453234253452432&quot;</span>, <span class="string">&quot;7326362323251323&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="多个异步函数如何同步执行？"><a href="#多个异步函数如何同步执行？" class="headerlink" title="多个异步函数如何同步执行？"></a>多个异步函数如何同步执行？</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步函数之间有关联关系</span></span><br><span class="line"><span class="comment">// 前一个异步函数的输出作为后一个异步函数的输入</span></span><br><span class="line"><span class="comment">// 同步方法的处理</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">pipeFunctions</span> = (<span class="params">...fns</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">preFn, curFn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title function_">preFn</span>(...args);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">curFn</span>(res);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x</span>) =&gt; x + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">x</span>) =&gt; x * <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subtraction</span> = (<span class="params">x</span>) =&gt; x - <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">division</span> = (<span class="params">x</span>) =&gt; x / <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> targetFn = <span class="title function_">pipeFunctions</span>(</span><br><span class="line">  add, <span class="comment">// 10</span></span><br><span class="line">  multiply, <span class="comment">// 50</span></span><br><span class="line">  subtraction, <span class="comment">// 45</span></span><br><span class="line">  division <span class="comment">// 9</span></span><br><span class="line">);</span><br><span class="line"><span class="title function_">targetFn</span>(<span class="number">5</span>); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 异步方法的处理</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">pipeFunctions2</span> = (<span class="params">...fns</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">preFn, curFn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (...args) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">preFn</span>(...args);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">curFn</span>(res);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">asyncFn</span> = (<span class="params">v</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(v);</span><br><span class="line">    &#125;, <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = <span class="keyword">async</span> (<span class="params">x</span>) =&gt; <span class="keyword">await</span> <span class="title function_">asyncFn</span>(x + <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = <span class="keyword">async</span> (<span class="params">x</span>) =&gt; <span class="keyword">await</span> <span class="title function_">asyncFn</span>(x * <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subtraction</span> = <span class="keyword">async</span> (<span class="params">x</span>) =&gt; <span class="keyword">await</span> <span class="title function_">asyncFn</span>(x - <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">division</span> = <span class="keyword">async</span> (<span class="params">x</span>) =&gt; <span class="keyword">await</span> <span class="title function_">asyncFn</span>(x / <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> targetFn2 = <span class="title function_">pipeFunctions2</span>(</span><br><span class="line">  add, <span class="comment">// 10</span></span><br><span class="line">  multiply, <span class="comment">// 50</span></span><br><span class="line">  subtraction, <span class="comment">// 45</span></span><br><span class="line">  division <span class="comment">// 9</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">targetFn2</span>(<span class="number">5</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<h2 id="找出数组中唯一落单的数（只出现一次的数）"><a href="#找出数组中唯一落单的数（只出现一次的数）" class="headerlink" title="找出数组中唯一落单的数（只出现一次的数）"></a>找出数组中唯一落单的数（只出现一次的数）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [1, 4, 3, 3, 2, 4, 1] =&gt; 2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法1:</span></span><br><span class="line"><span class="comment"> *  利用object的key-value特性存储数据，</span></span><br><span class="line"><span class="comment"> *  找出value值为1对应的key值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUnique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[item]) &#123;</span><br><span class="line">      obj[item] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[item]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[key] === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> +key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">getUnique</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法2:</span></span><br><span class="line"><span class="comment"> *  如果第一个值第一次出现的位置和最后一次出现的位置相同</span></span><br><span class="line"><span class="comment"> *  那么这个值就只出现了一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUnique2</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> arr.<span class="title function_">indexOf</span>(item) === arr.<span class="title function_">lastIndexOf</span>(item))[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">getUnique2</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法3:数字的异或运算</span></span><br><span class="line"><span class="comment"> *  两个相同的数字进行异或运算得到 0</span></span><br><span class="line"><span class="comment"> *  0 与任何 a 异或运算都将得到 a 本身</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUnique3</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    result ^= arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">getUnique3</span>(arr);</span><br></pre></td></tr></table></figure>

<h2 id="a-1-amp-amp-a-2-amp-amp-a-3"><a href="#a-1-amp-amp-a-2-amp-amp-a-3" class="headerlink" title="a==1 &amp;&amp; a==2 &amp;&amp; a==3"></a>a==1 &amp;&amp; a==2 &amp;&amp; a==3</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.with 语句</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> i++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; (a == <span class="number">2</span>) &amp; (a == <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Are you kidding me?&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.隐式转换</span></span><br><span class="line"><span class="comment">// 核心：对象类型转换为原始类型，处理逻辑：</span></span><br><span class="line"><span class="comment">// 1. 调用[Symbol.toPrimitive]，转换成功则结束，否则执行2</span></span><br><span class="line"><span class="comment">// 2. 调用valueOf，转换成功则结束，否则执行3</span></span><br><span class="line"><span class="comment">// 3. 调用toString，转换成功则结束，否则执行4</span></span><br><span class="line"><span class="comment">// 4. 如果都没有转换成原始类型，则抛出异常</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; (a == <span class="number">2</span>) &amp; (a == <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Are you kidding me?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.数组类型的隐式转换</span></span><br><span class="line"><span class="comment">// 数组类型转换为基本类型时，会调用toString方法</span></span><br><span class="line"><span class="comment">// toString会调用join方法</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="property">join</span> = a.<span class="property">shift</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; (a == <span class="number">2</span>) &amp; (a == <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Are you kidding me?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.Object.defineProperty进行数据劫持</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">window</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; (a == <span class="number">2</span>) &amp; (a == <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Are you kidding me?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.方法劫持-Proxy</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> target.<span class="property">x</span>++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; (a == <span class="number">2</span>) &amp; (a == <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Are you kidding me?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏字符 半形朝鲜文填充符 (U+FFA0)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">if</span>ﾠ = <span class="function">() =&gt;</span> !<span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>ﾠ(a == <span class="number">1</span> &amp;&amp; (a == <span class="number">2</span>) &amp; (a == <span class="number">3</span>));</span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Are you kidding me?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并多个对象"><a href="#合并多个对象" class="headerlink" title="合并多个对象"></a>合并多个对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="comment">// 1. Object.assign()</span></span><br><span class="line"><span class="comment">// 同名属性会覆盖</span></span><br><span class="line"><span class="comment">// 第一个参数如果不为对象，需要转换为对象，转换失败会报错</span></span><br><span class="line"><span class="comment">// 非第一个参数，剩余参数不为对象也要转换为对象，转换失败直接忽略</span></span><br><span class="line"><span class="keyword">const</span> result1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj1, obj2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 扩展运算符</span></span><br><span class="line"><span class="comment">// 同名属性覆盖</span></span><br><span class="line"><span class="comment">// 如果第一个参数不为对象，直接忽略</span></span><br><span class="line"><span class="keyword">const</span> result2 = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br></pre></td></tr></table></figure>

<h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象互转</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> entries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries); <span class="comment">//[[&quot;a&quot;,&quot;1&quot;],[&quot;b&quot;,&quot;2&quot;]]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries); <span class="comment">//&#123;a: &#x27;1&#x27;, b: &#x27;2&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map -&gt; 对象</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">//&#123;&#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2&#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map); <span class="comment">//&#123;a: 1, b: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤对象</span></span><br><span class="line"><span class="keyword">const</span> course = &#123;</span><br><span class="line">  <span class="attr">math</span>: <span class="number">79</span>,</span><br><span class="line">  <span class="attr">english</span>: <span class="number">85</span>,</span><br><span class="line">  <span class="attr">chinese</span>: <span class="number">90</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Object</span>.<span class="title function_">entries</span>(course).<span class="title function_">filter</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> value &gt; <span class="number">80</span>);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(result); <span class="comment">// &#123;english: 85, chinese: 90&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="去掉空格"><a href="#去掉空格" class="headerlink" title="去掉空格"></a>去掉空格</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;   foo   &quot;</span>;</span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/^\s+/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// 去掉前面空格</span></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/\s+$/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">//去掉后面空格</span></span><br><span class="line"><span class="comment">// 去掉前面空格</span></span><br><span class="line">str.<span class="title function_">trimStart</span>();</span><br><span class="line">str.<span class="title function_">trimLeft</span>();</span><br><span class="line"><span class="comment">// 去掉后面空格</span></span><br><span class="line">str.<span class="title function_">trimEnd</span>();</span><br><span class="line">str.<span class="title function_">trimRight</span>();</span><br><span class="line"><span class="comment">// 去掉前后空格</span></span><br><span class="line">str.<span class="title function_">trim</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>100道前端优质面试题</title>
    <url>/2022/03/11/100%E9%81%93%E5%89%8D%E7%AB%AF%E4%BC%98%E8%B4%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><span id="more"></span>

<ul>
<li>程序执行时需要的计算量和内存空间</li>
<li>复杂度是数量级，不是具体的数字</li>
<li>一般是针对一个具体的算法，而非一个完整的系统</li>
</ul>
<h2 id="将一个数组旋转-K-步"><a href="#将一个数组旋转-K-步" class="headerlink" title="将一个数组旋转 K 步"></a>将一个数组旋转 K 步</h2><ul>
<li>输入一个数组[1, 2, 3, 4, 5, 6, 7]</li>
<li>k=3,即旋转 3 步</li>
<li>输出[5, 6, 7, 1, 2, 3, 4]</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 原数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 步数</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n^2),空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rotate1</span>(<span class="params">arr: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (!k || length === <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> step = <span class="title class_">Math</span>.<span class="title function_">abs</span>(k % length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; step; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = arr.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// unshift内置api时间复杂度位O(n),开销比较大</span></span><br><span class="line">      arr.<span class="title function_">unshift</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 原数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 步数</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(1)，空间复杂度O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rotate2</span>(<span class="params">arr: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (!k || length === <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> step = <span class="title class_">Math</span>.<span class="title function_">abs</span>(k % length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> part1 = arr.<span class="title function_">slice</span>(-step);</span><br><span class="line">  <span class="keyword">const</span> part2 = arr.<span class="title function_">slice</span>(<span class="number">0</span>, length - step);</span><br><span class="line">  <span class="keyword">const</span> part3 = part1.<span class="title function_">concat</span>(part2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 性能测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> * <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;rotate1&quot;</span>);</span><br><span class="line"><span class="title function_">rotate1</span>(arr, <span class="number">9</span> * <span class="number">10000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;rotate1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;rotate2&quot;</span>);</span><br><span class="line"><span class="title function_">rotate2</span>(arr, <span class="number">9</span> * <span class="number">10000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;rotate2&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="判断字符串是否括号匹配"><a href="#判断字符串是否括号匹配" class="headerlink" title="判断字符串是否括号匹配"></a>判断字符串是否括号匹配</h2><ul>
<li>一个字符串 s 可能包含{}()[]三种括号</li>
<li>判断 s 是否是括号匹配的</li>
<li>如（a{b}c）匹配，而{a(b 或者{a(b}c)就是不匹配的</li>
</ul>
<p>栈 vs 数组<br>栈：逻辑结构，理论模型，不管如何实现，不受任何语言的限制。<br>数组：物理结构，真实的功能实现，受限于编程语言。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isMatch</span>(<span class="params">left: <span class="built_in">string</span>, right: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (left === <span class="string">&quot;&#123;&quot;</span> &amp;&amp; right === <span class="string">&quot;&#125;&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (left === <span class="string">&quot;(&quot;</span> &amp;&amp; right === <span class="string">&quot;)&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (left === <span class="string">&quot;[&quot;</span> &amp;&amp; right === <span class="string">&quot;]&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">matchBracket</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> length = str.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> leftSymbols = <span class="string">&quot;&#123;[(&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> rightSymbols = <span class="string">&quot;)]&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 时间复杂度O(n),空间复杂度O(n)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> s = str[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftSymbols.<span class="title function_">includes</span>(s)) &#123;</span><br><span class="line">      <span class="comment">// 左括号，压栈</span></span><br><span class="line">      stack.<span class="title function_">push</span>(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightSymbols.<span class="title function_">includes</span>(s)) &#123;</span><br><span class="line">      <span class="keyword">const</span> top = stack[stack.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断右括号是否匹配</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isMatch</span>(top, s)) &#123;</span><br><span class="line">        stack.<span class="title function_">pop</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个栈实现一个队列"><a href="#两个栈实现一个队列" class="headerlink" title="两个栈实现一个队列"></a>两个栈实现一个队列</h2><ul>
<li>请用两个栈实现一个队列</li>
<li>API：add delete length</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">stack1</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">stack2</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">n: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="title function_">push</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">delete</span>(): <span class="built_in">number</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack1.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> n = stack1.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack2.<span class="title function_">push</span>(n);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = stack2.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack2.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> n = stack2.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack1.<span class="title function_">push</span>(n);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res || <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">length</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义一个-js-函数，反转单向链表"><a href="#定义一个-js-函数，反转单向链表" class="headerlink" title="定义一个 js 函数，反转单向链表"></a>定义一个 js 函数，反转单向链表</h2><p>链表是一种物理结构(非逻辑结构),类似数组<br>数组需要一段连续的内存空间，而链表是零散的<br>链表节点的数据结构{ value, next?, prev? }</p>
<p>链表 vs 数组<br>都是有序结构<br>链表：查询慢 O(n),新增和删除快 O(1)<br>数组：查询快 O(1),新增和删除慢 O(n)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILinkListNode</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">  next?: <span class="title class_">ILinkListNode</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLinkList</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="title class_">ILinkListNode</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;arr is empty&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">curNode</span>: <span class="title class_">ILinkListNode</span> = &#123;</span><br><span class="line">    <span class="attr">value</span>: arr[length - <span class="number">1</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">1</span>) <span class="keyword">return</span> curNode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    curNode = &#123;</span><br><span class="line">      <span class="attr">value</span>: arr[i],</span><br><span class="line">      <span class="attr">next</span>: curNode,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> curNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"><span class="keyword">const</span> list = <span class="title function_">createLinkList</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转单向链表，返回反转后的head node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listNode 需要操作的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseLinkList</span>(<span class="params">listNode: ILinkListNode</span>): <span class="title class_">ILinkListNode</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">prevNode</span>: <span class="title class_">ILinkListNode</span> | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">curNode</span>: <span class="title class_">ILinkListNode</span> | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">nextNode</span>: <span class="title class_">ILinkListNode</span> | <span class="literal">undefined</span> = listNode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (nextNode) &#123;</span><br><span class="line">    <span class="comment">// 第一个元素，删除next指针，防止循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (curNode &amp;&amp; !prevNode) &#123;</span><br><span class="line">      <span class="keyword">delete</span> curNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转指针</span></span><br><span class="line">    <span class="keyword">if</span> (curNode &amp;&amp; prevNode) &#123;</span><br><span class="line">      curNode.<span class="property">next</span> = prevNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevNode = curNode;</span><br><span class="line">    curNode = nextNode;</span><br><span class="line">    nextNode = nextNode?.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理链表最后一个元素</span></span><br><span class="line">  curNode!.<span class="property">next</span> = prevNode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> curNode!;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseList = <span class="title function_">reverseLinkList</span>(list);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;reverseList&quot;</span>, reverseList);</span><br></pre></td></tr></table></figure>

<h2 id="用链表实现队列"><a href="#用链表实现队列" class="headerlink" title="用链表实现队列"></a>用链表实现队列</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILinkListNode</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">ILinkListNode</span> | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">head</span>: <span class="title class_">ILinkListNode</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">tail</span>: <span class="title class_">ILinkListNode</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队，在tail位置</span></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">n: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">newNode</span>: <span class="title class_">ILinkListNode</span> = &#123;</span><br><span class="line">      <span class="attr">value</span>: n,</span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">tail</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">len</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队，在head位置</span></span><br><span class="line">  <span class="title function_">delete</span>(): <span class="built_in">number</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> === <span class="literal">null</span> || <span class="variable language_">this</span>.<span class="property">len</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">len</span>--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">length</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">len</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">queue.<span class="title function_">add</span>(<span class="number">100</span>);</span><br><span class="line">queue.<span class="title function_">add</span>(<span class="number">200</span>);</span><br><span class="line">queue.<span class="title function_">add</span>(<span class="number">300</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;length&quot;</span>, queue.<span class="property">length</span>); <span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">delete</span>()); <span class="comment">//100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;length2&quot;</span>, queue.<span class="property">length</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="链表和数组，哪个实现队列更快？"><a href="#链表和数组，哪个实现队列更快？" class="headerlink" title="链表和数组，哪个实现队列更快？"></a>链表和数组，哪个实现队列更快？</h2><ul>
<li>空间复杂度都是 O(n)</li>
<li>add 时间复杂度：链表 O(1)，数组 O(1);</li>
<li>delete 时间复杂度：链表 O(1)，数组 O(n);</li>
</ul>
<h2 id="实现二分查找"><a href="#实现二分查找" class="headerlink" title="实现二分查找"></a>实现二分查找</h2><ul>
<li>凡有序，必二分</li>
<li>凡二分，时间复杂度必包含 O(logn)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 循环的方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 查找的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment"> * 返回目标索引下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch1</span>(<span class="params">arr: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> startIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> endIndex = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (startIndex &lt;= endIndex) &#123;</span><br><span class="line">    <span class="keyword">const</span> midIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((startIndex + endIndex) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> midValue = arr[midIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target &lt; midValue) &#123;</span><br><span class="line">      endIndex = midIndex - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; midValue) &#123;</span><br><span class="line">      startIndex = midIndex + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> midIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找-递归的方式</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> arr 查找的数组</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> <span class="variable">startIndex</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> <span class="variable">endIndex</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch2</span>(<span class="params"></span></span><br><span class="line"><span class="params">  arr: <span class="built_in">number</span>[],</span></span><br><span class="line"><span class="params">  target: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  startIndex?: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  endIndex?: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!startIndex) startIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!endIndex) endIndex = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (startIndex &gt; endIndex) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> midIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((startIndex + endIndex) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> midValue = arr[midIndex];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (target &lt; midValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">binarySearch2</span>(arr, target, startIndex, midIndex - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; midValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">binarySearch2</span>(arr, target, midIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> midIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能测试</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch1</span>(arr, target));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch2</span>(arr, target));</span><br></pre></td></tr></table></figure>

<h2 id="给定一个递增的数组，找出其中和为-n-的两个元素"><a href="#给定一个递增的数组，找出其中和为-n-的两个元素" class="headerlink" title="给定一个递增的数组，找出其中和为 n 的两个元素"></a>给定一个递增的数组，找出其中和为 n 的两个元素</h2><ul>
<li>有一个递增的数组[1, 2, 4, 7, 11, 15]和一个 n = 15</li>
<li>数组中有两个数和为 n，即 4+11=15</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 嵌套循环 时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 操作数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findTwoNumbers1</span>(<span class="params">arr: <span class="built_in">number</span>[], n: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 时间复杂度：O(n^2)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = arr[i];</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> n2 = arr[j];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (n1 + n2 === n) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(n1, n2);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双指针，时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 操作数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  思路：</span></span><br><span class="line"><span class="comment">  定义i指向头，j指向尾，求arr[i] + arr[j]</span></span><br><span class="line"><span class="comment">  如果大于n，则j需要向前移动</span></span><br><span class="line"><span class="comment">  如果小于n，则j需要向后移动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findTwoNumbers2</span>(<span class="params">arr: <span class="built_in">number</span>[], n: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = arr[i];</span><br><span class="line">    <span class="keyword">const</span> n2 = arr[j];</span><br><span class="line">    <span class="keyword">const</span> sum = n1 + n2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; n) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(n1, n2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求一个二叉搜索树（BST）的第-k-小值"><a href="#求一个二叉搜索树（BST）的第-k-小值" class="headerlink" title="求一个二叉搜索树（BST）的第 k 小值"></a>求一个二叉搜索树（BST）的第 k 小值</h2><ul>
<li>前序(根左右)，中序(左根右)，后序(左右根)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ItreeNode</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">ItreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">ItreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bstTree</span>: <span class="title class_">ItreeNode</span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">left</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">left</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">left</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="attr">left</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">right</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">left</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="attr">left</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="attr">left</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node tree node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">preOrderTraverse</span>(<span class="params">node: ItreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">preOrderTraverse</span>(node.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">preOrderTraverse</span>(node.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树中序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node tree node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inOrderTraverse</span>(<span class="params">node: ItreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inOrderTraverse</span>(node.<span class="property">left</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">  <span class="title function_">inOrderTraverse</span>(node.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树后序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node tree node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">postOrderTraverse</span>(<span class="params">node: ItreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">postOrderTraverse</span>(node.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">postOrderTraverse</span>(node.<span class="property">right</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求二叉搜索树第k值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node bst tree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 第k个值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getKthValue</span>(<span class="params">node: ItreeNode | <span class="literal">null</span>, k: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">arr</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inOrderTraverse</span>(<span class="params">node: ItreeNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">inOrderTraverse</span>(node.<span class="property">left</span>);</span><br><span class="line">    arr.<span class="title function_">push</span>(node.<span class="property">value</span>);</span><br><span class="line">    <span class="title function_">inOrderTraverse</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inOrderTraverse</span>(node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契数列（递归）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * 时间复杂度O(2^n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契数列（循环）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> n1 = <span class="number">1</span>; <span class="comment">// 记录n-1的结果</span></span><br><span class="line">  <span class="keyword">let</span> n2 = <span class="number">0</span>; <span class="comment">// 记录n-2的结果</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res = n1 + n2;</span><br><span class="line">    n2 = n1;</span><br><span class="line">    n1 = res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="青蛙跳台阶（动态规划思想解决问题）"><a href="#青蛙跳台阶（动态规划思想解决问题）" class="headerlink" title="青蛙跳台阶（动态规划思想解决问题）"></a>青蛙跳台阶（动态规划思想解决问题）</h2><ul>
<li>一只青蛙，一次可以跳 1 级，也可以跳 2 级</li>
<li>问：青蛙跳到 n 级台阶，总共有多少种方式？</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 答案同上一题</span></span><br></pre></td></tr></table></figure>

<h2 id="将数组中的-0-移动到末尾"><a href="#将数组中的-0-移动到末尾" class="headerlink" title="将数组中的 0 移动到末尾"></a>将数组中的 0 移动到末尾</h2><ul>
<li>如输入[1, 0, 3, 0, 11, 0],输出[1, 3, 11, 0, 0, 0]</li>
<li>只移动 0 ，其他顺序不变</li>
<li>必须在原数组进行操作</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * (嵌套循环)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr number arr</span></span><br><span class="line"><span class="comment"> * 时间复杂度 O(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">moveZero1</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> zeroCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - zeroCount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      arr.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">      arr.<span class="title function_">splice</span>(i, <span class="number">1</span>); <span class="comment">// O(n)</span></span><br><span class="line">      i--;</span><br><span class="line">      zeroCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * (双指针)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr number arr</span></span><br><span class="line"><span class="comment"> * 时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">moveZero2</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">let</span> j = -<span class="number">1</span>; <span class="comment">// 指向第一个 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        j = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> n = arr[i];</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      arr[j] = n;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// moveZero1(arr);</span></span><br><span class="line"><span class="title function_">moveZero2</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<h2 id="计算字符串中连续最多的字符以及次数"><a href="#计算字符串中连续最多的字符以及次数" class="headerlink" title="计算字符串中连续最多的字符以及次数"></a>计算字符串中连续最多的字符以及次数</h2><ul>
<li>输入’abbbcccccccddeee1234412’</li>
<li>计算得到连续最多的字符是’c’,7 次</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">str</span></span></span><br><span class="line"><span class="comment"> * 时间复杂度： O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRes</span> &#123;</span><br><span class="line">  <span class="attr">char</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findContinuousChar1</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="title class_">IRes</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>: <span class="title class_">IRes</span> = &#123;</span><br><span class="line">    <span class="attr">char</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> length = str.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tempLength = <span class="number">0</span>; <span class="comment">// 临时记录当前连续字符的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    tempLength = <span class="number">0</span>; <span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str[i] === str[j]) &#123;</span><br><span class="line">        tempLength++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (str[i] !== str[j] || j === length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempLength &gt; res.<span class="property">length</span>) &#123;</span><br><span class="line">          res.<span class="property">char</span> = str[i];</span><br><span class="line">          res.<span class="property">length</span> = tempLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; length - <span class="number">1</span>) &#123;</span><br><span class="line">          i = j - <span class="number">1</span>; <span class="comment">// 跳步</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">str</span></span></span><br><span class="line"><span class="comment"> * 时间复杂度： O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRes</span> &#123;</span><br><span class="line">  <span class="attr">char</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findContinuousChar2</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="title class_">IRes</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>: <span class="title class_">IRes</span> = &#123;</span><br><span class="line">    <span class="attr">char</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> length = str.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tempLength = <span class="number">0</span>; <span class="comment">// 临时记录当前连续字符的长度</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[i] === str[j]) &#123;</span><br><span class="line">      tempLength++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[i] !== str[j] || i === length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果不相等或者 i 循环到了末尾</span></span><br><span class="line">      <span class="keyword">if</span> (tempLength &gt; res.<span class="property">length</span>) &#123;</span><br><span class="line">        res.<span class="property">char</span> = str[j];</span><br><span class="line">        res.<span class="property">length</span> = tempLength;</span><br><span class="line">      &#125;</span><br><span class="line">      tempLength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; length - <span class="number">1</span>) &#123;</span><br><span class="line">        j = i; <span class="comment">// 让 j 追上 i</span></span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;abbbcccccccddeee1234412&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findContinuousChar1</span>(str));</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">arr</span></span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort1</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> midIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> midValue = arr.<span class="title function_">splice</span>(midIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">left</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">right</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意： splice会改变原数组，不能直接使用length</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = arr[i];</span><br><span class="line">    <span class="keyword">if</span> (n &lt; midValue) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickSort1</span>(left).<span class="title function_">concat</span>(midValue, <span class="title function_">quickSort1</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">quickSort1</span>(arr));</span><br></pre></td></tr></table></figure>

<h2 id="对称数"><a href="#对称数" class="headerlink" title="对称数"></a>对称数</h2><ul>
<li>求 1 - 10000 之间的所有对称数（回文）</li>
<li>例如：0， 1， 2， 11， 22， 101， 232，1221</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findPalindromeNumbers1</span>(<span class="params">max: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">if</span> (max &lt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">    <span class="comment">// 转换为字符转 -&gt; 转换为数组 -&gt; 再反转 -&gt; 比较</span></span><br><span class="line">    <span class="keyword">const</span> s = i.<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">if</span> (s === s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findPalindromeNumbers1</span>(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findPalindromeNumbers2</span>(<span class="params">max: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">if</span> (max &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = i;</span><br><span class="line">    <span class="keyword">let</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// n: 123</span></span><br><span class="line">    <span class="comment">// rev: 321</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      rev = rev * <span class="number">10</span> + (n % <span class="number">10</span>);</span><br><span class="line">      n = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i === rev) res.<span class="title function_">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findPalindromeNumbers2</span>(<span class="number">200</span>));</span><br></pre></td></tr></table></figure>

<h2 id="高效的字符串前缀匹配"><a href="#高效的字符串前缀匹配" class="headerlink" title="高效的字符串前缀匹配"></a>高效的字符串前缀匹配</h2><ul>
<li>有一个英文单词库（数组），里面有几十万个英文单词</li>
<li>输入一个字符串，快速判断是不是某一个单词的前缀</li>
<li>（说明思路，不用写代码）</li>
</ul>
<p>思路一：</p>
<ol>
<li><p>遍历单词库数组</p>
</li>
<li><p>indexOf 判断前缀</p>
</li>
<li><p>实际时间复杂度超过 O(n),因为 indexOf 的计算量</p>
</li>
</ol>
<p>思路二（对象取 key 时间复杂度为 O(1)）：</p>
<ol>
<li><p>英文字母一共就 26 个，可以提前把单词库数组拆分为 26 个</p>
</li>
<li><p>第一层 26 个，第二层、第三层，继续拆分…</p>
</li>
<li><p>最后把单词库拆分为一颗树</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 树结构</span><br><span class="line">const wordsTree = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    a: &#123;...&#125;</span><br><span class="line">    b: &#123;...&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    a: &#123;...&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    a: &#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数字千分位格式化"><a href="#数字千分位格式化" class="headerlink" title="数字千分位格式化"></a>数字千分位格式化</h2><ul>
<li>将数字千分位格式化，输出字符串</li>
<li>如输入数字 12050100，输出字符串 12,050,100</li>
<li>(注意：逆序判断)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * 使用数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format1</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  n = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n); <span class="comment">// 只考虑整数</span></span><br><span class="line">  <span class="keyword">const</span> reverseArr = n.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reverseArr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">        <span class="keyword">return</span> curr + <span class="string">&quot;,&quot;</span> + prev;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> curr + prev;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * 使用字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format2</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  n = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> str = n.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="keyword">const</span> length = str.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> j = length - i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">        res = str[i] + res;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = <span class="string">&quot;,&quot;</span> + str[i] + res;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res = str[i] + res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切换字母大小写"><a href="#切换字母大小写" class="headerlink" title="切换字母大小写"></a>切换字母大小写</h2><ul>
<li>输入一个字符串，切换其中字母的大小写</li>
<li>如：输入字符串 12aBc34，输出字符串 12AbC34</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">switchLetterCase1</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> length = s.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reg1 = <span class="regexp">/[a-z]/</span>;</span><br><span class="line">  <span class="keyword">const</span> reg2 = <span class="regexp">/[A-Z]/</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = s[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reg1.<span class="title function_">test</span>(c)) &#123;</span><br><span class="line">      res += c.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reg2.<span class="title function_">test</span>(c)) &#123;</span><br><span class="line">      res += c.<span class="title function_">toLowerCase</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res += c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ASCII 编码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">switchLetterCase2</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> length = s.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reg1 = <span class="regexp">/[a-z]/</span>;</span><br><span class="line">  <span class="keyword">const</span> reg2 = <span class="regexp">/[A-Z]/</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = s[i];</span><br><span class="line">    <span class="keyword">const</span> code = c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (code &gt;= <span class="number">65</span> &amp;&amp; code &lt;= <span class="number">90</span>) &#123;</span><br><span class="line">      res += c.<span class="title function_">toLowerCase</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code &gt;= <span class="number">97</span> &amp;&amp; code &lt;= <span class="number">122</span>) &#123;</span><br><span class="line">      res += c.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res += c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为何-0-1-0-2-0-3"><a href="#为何-0-1-0-2-0-3" class="headerlink" title="为何 0.1+0.2 !==0.3?"></a>为何 0.1+0.2 !==0.3?</h2><ul>
<li><p>计算机使用二进制存储数据</p>
</li>
<li><p>整数转二进制没有误差</p>
</li>
<li><p>小数可能无法用二进制准确表达</p>
</li>
</ul>
<h2 id="请说明-ajax、fetch、axios-三者的区别？"><a href="#请说明-ajax、fetch、axios-三者的区别？" class="headerlink" title="请说明 ajax、fetch、axios 三者的区别？"></a>请说明 ajax、fetch、axios 三者的区别？</h2><ul>
<li><p>ajax(asynchronous javascript xml),一种技术统称</p>
</li>
<li><p>fetch，一个具体的 API</p>
</li>
<li><p>axios，第三方库 <a href="https://axios-http.com/">https://axios-http.com/</a></p>
</li>
</ul>
<h2 id="节流和防抖：两者有什么区别？分别用于什么场景？"><a href="#节流和防抖：两者有什么区别？分别用于什么场景？" class="headerlink" title="节流和防抖：两者有什么区别？分别用于什么场景？"></a>节流和防抖：两者有什么区别？分别用于什么场景？</h2><ul>
<li><p>防抖</p>
<ol>
<li>例如：一个搜索输入框，等输入停止后，再出发搜索</li>
</ol>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">200</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>节流<ol>
<li>drag 或 scroll 期间出发某个回调，要设置一个时间间隔</li>
</ol>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      timer = <span class="number">0</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="px-em-rem-vw-vh有什么区别？"><a href="#px-em-rem-vw-vh有什么区别？" class="headerlink" title="px % em rem vw/vh有什么区别？"></a><em>px % em rem vw/vh</em>有什么区别？</h2><ul>
<li><p>px 基本单位，是绝对单位（其他的都是相对单位）</p>
</li>
<li><p>% 是相对于父元素的宽度比例</p>
</li>
<li><p>em 相对于当前元素的 font-size</p>
</li>
<li><p>rem 相对于跟元素的 font-size</p>
</li>
<li><p>vw 屏幕宽度的 1%</p>
</li>
<li><p>vh 屏幕高度的 1%</p>
</li>
<li><p>vmin 取 vw、vh 两者中的最小值</p>
</li>
<li><p>vmax 取 vw、vh 两者中的最大值</p>
</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li><p>箭头函数的特点</p>
<ol>
<li>没有 arguments</li>
<li>无法通过 apply、call、bind 改变 this</li>
<li>某些肩头函数代码难以阅读</li>
</ol>
</li>
</ul>
<h2 id="for…in-和-for…of-有什么区别"><a href="#for…in-和-for…of-有什么区别" class="headerlink" title="for…in 和 for…of 有什么区别"></a>for…in 和 for…of 有什么区别</h2><ul>
<li><p>key 和 value</p>
<ol>
<li>for…in 遍历得到 key</li>
<li>for…of 遍历得到 value</li>
</ol>
</li>
<li><p>适用于不同的数据类型</p>
<ol>
<li>遍历对象： for…in 可以，for…of 不可以</li>
<li>遍历 Map、Set：for…of 可以，for…in 不可以</li>
<li>遍历 generator：for…of 可以，for…in 不可以</li>
</ol>
</li>
<li><p>可枚举 vs 可迭代</p>
<ol>
<li>for…in 用于可枚举（Object.getOwnPropertyDescriptors(obj)）数据，如对象、数组、字符串</li>
<li>for…of 用于可迭代(arr[Symbol.iterator])数据，如数组、字符串、Map、Set</li>
</ol>
</li>
</ul>
<h2 id="for-await…of-有什么作用？"><a href="#for-await…of-有什么作用？" class="headerlink" title="for await…of 有什么作用？"></a>for await…of 有什么作用？</h2><ul>
<li>for await…of 用于遍历多个 Promise</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPromise</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="title function_">createPromise</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> p2 = <span class="title function_">createPromise</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="keyword">const</span> p3 = <span class="title function_">createPromise</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> list = [p1, p2, p3];</span><br><span class="line">  <span class="keyword">const</span> list2 = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ---------------同时调用----------------</span></span><br><span class="line">  <span class="comment">// 方式一</span></span><br><span class="line">  <span class="comment">// const res1 = await p1;</span></span><br><span class="line">  <span class="comment">// console.log(res1);</span></span><br><span class="line">  <span class="comment">// const res2 = await p2;</span></span><br><span class="line">  <span class="comment">// console.log(res2);</span></span><br><span class="line">  <span class="comment">// const res3 = await p3;</span></span><br><span class="line">  <span class="comment">// console.log(res3);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方式二</span></span><br><span class="line">  <span class="comment">// Promise.all(list).then((res) =&gt; console.log(res));</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方式三</span></span><br><span class="line">  <span class="comment">// for await (let res of list) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(res);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// -----------------逐步调用---------------</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> list2) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">createPromise</span>(value);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="offsetHeight、scrollHeight、clientHeight-区别？"><a href="#offsetHeight、scrollHeight、clientHeight-区别？" class="headerlink" title="offsetHeight、scrollHeight、clientHeight 区别？"></a>offsetHeight、scrollHeight、clientHeight 区别？</h2><ul>
<li><p>offsetHeight、offsetWidth: border + padding + content</p>
</li>
<li><p>clientHeight、clientWidth: padding + content</p>
</li>
<li><p>scrollHeight、scrollWidth: padding + 实际内容尺寸</p>
</li>
</ul>
<h2 id="HTMLCollection-和-NodeList-区别？"><a href="#HTMLCollection-和-NodeList-区别？" class="headerlink" title="HTMLCollection 和 NodeList 区别？"></a>HTMLCollection 和 NodeList 区别？</h2><ul>
<li><p>Node 和 Element</p>
<ol>
<li>DOM 是一棵树，所有节点都是 Node</li>
<li>Node 是 Element 的基类</li>
<li>Element 是其他 HTML 元素的基类，如 HTMLDivElement</li>
</ol>
</li>
<li><p>HTMLCollection 和 NodeList</p>
<ol>
<li>HTMLCollection 是 Element 的集合（elem.children）</li>
<li>NodeList 是 Node 集合（elem.childNodes）</li>
<li>HTMLCollection 不会包含 Text 和 Comment 节点，NodeList 则会包含</li>
</ol>
</li>
<li><p>HTMLCollection 和 NodeList 都不是数组，而是“累数组”</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换</span></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(list);</span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(list);</span><br><span class="line"><span class="keyword">const</span> arr3 = [...list];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Vue-中-computed-和-watch-的区别？"><a href="#Vue-中-computed-和-watch-的区别？" class="headerlink" title="Vue 中 computed 和 watch 的区别？"></a>Vue 中 computed 和 watch 的区别？</h2><ul>
<li><p>用途不同</p>
<ol>
<li>computed 用于计算产生新的数据，有缓存</li>
<li>watch 用于监听现有数据</li>
</ol>
</li>
<li><p>扩展知识</p>
<ol>
<li>computed 有缓存</li>
<li>methods 没有缓存</li>
</ol>
</li>
</ul>
<h2 id="Vue-组件通讯的方式"><a href="#Vue-组件通讯的方式" class="headerlink" title="Vue 组件通讯的方式"></a>Vue 组件通讯的方式</h2><ul>
<li>props 和 $emit</li>
<li>自定义事件</li>
<li>$attrs</li>
<li>$parent</li>
<li>$refs</li>
<li>provide/inject</li>
<li>vuex</li>
</ul>
<h2 id="vuex-mutation-和-action-的区别？"><a href="#vuex-mutation-和-action-的区别？" class="headerlink" title="vuex mutation 和 action 的区别？"></a>vuex mutation 和 action 的区别？</h2><ul>
<li>mutation: 同步代码</li>
<li>action: 可包含异步代码</li>
</ul>
<h2 id="JS-严格模式有什么特点？"><a href="#JS-严格模式有什么特点？" class="headerlink" title="JS 严格模式有什么特点？"></a>JS 严格模式有什么特点？</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>; <span class="comment">//全局开启</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>; <span class="comment">// 局部开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点<ol>
<li>全局变量必须先声明</li>
<li>禁止使用 with</li>
<li>this 指向 undefined 而不是 window</li>
<li>函数参数不能重名</li>
<li>eval 有单独作用域，不推荐使用</li>
</ol>
</li>
</ul>
<h2 id="HTTP-跨域请求事为什么发送-options-请求？"><a href="#HTTP-跨域请求事为什么发送-options-请求？" class="headerlink" title="HTTP 跨域请求事为什么发送 options 请求？"></a>HTTP 跨域请求事为什么发送 options 请求？</h2><ul>
<li>跨域请求<ol>
<li>浏览器同源策略</li>
<li>同源策略一般限制 ajax 网络请求，不能跨域请求 server</li>
<li>不会限制<code>&lt;link&gt; &lt;img&gt; &lt;script&gt; &lt;iframe&gt;</code> 加载第三方资源</li>
</ol>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSONP</span></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">onSuccess</span> = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.aaa.com/api/getData&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="comment">// https://www.aaa.com/api/getData 返回一段字符串，交给前端执行达到传递数据的目的</span></span><br><span class="line"><span class="string">&#x27;onSuccess(&#123;data: &#123;/* 数据内容 */&#125;&#125;)&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CORS 配置允许跨域（服务端）</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://localhost:8080&quot;</span>); <span class="comment">// 或者 *</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Requested-With&quot;</span>);</span><br><span class="line">response.<span class="title function_">setHeader</span>(</span><br><span class="line">  <span class="string">&quot;Access-Control-Allow-Methods&quot;</span>,</span><br><span class="line">  <span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span></span><br><span class="line">);</span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 允许跨域接受cookie</span></span><br></pre></td></tr></table></figure>

<ul>
<li>答案<ol>
<li>options 请求，是跨域请求之前的预检查</li>
<li>浏览器自行发起的</li>
<li>不会影响实际的功能</li>
</ol>
</li>
</ul>
<h2 id="JS-内存泄漏如何检测？场景有哪些？"><a href="#JS-内存泄漏如何检测？场景有哪些？" class="headerlink" title="JS 内存泄漏如何检测？场景有哪些？"></a>JS 内存泄漏如何检测？场景有哪些？</h2><ul>
<li><p>垃圾回收 GC</p>
<ol>
<li>引用计数</li>
<li>标记清除</li>
</ol>
</li>
<li><p>场景</p>
<ol>
<li>意外的全局变量</li>
<li>遗忘的定时器</li>
<li>使用不当的闭包</li>
<li>遗漏的 DOM 元素</li>
<li>网络回调</li>
</ol>
</li>
<li><p>内存泄漏属于非预期的，闭包是主动行为，闭包非内存泄漏</p>
</li>
<li><p>可以使用 chrome devtools 的 performance 和 memory 工具类检测 js 内存</p>
</li>
<li><p><a href="https://www.cnblogs.com/dasusu/p/12200176.html">参考</a></p>
</li>
</ul>
<h2 id="vdom-真的很快吗？"><a href="#vdom-真的很快吗？" class="headerlink" title="vdom 真的很快吗？"></a>vdom 真的很快吗？</h2><ul>
<li><p>js 直接操作 dom 才是最快的，vdom 并不快</p>
</li>
<li><p>但是 vdom 是最合适“数据驱动视图”的技术方案</p>
</li>
</ul>
<h2 id="遍历数组，for-和-forEach-哪个快？"><a href="#遍历数组，for-和-forEach-哪个快？" class="headerlink" title="遍历数组，for 和 forEach 哪个快？"></a>遍历数组，for 和 forEach 哪个快？</h2><ul>
<li><p>时间复杂度都是 O(n)</p>
</li>
<li><p>结论：</p>
<ol>
<li>for 更快</li>
<li>forEach 每次都要创建一个函数来调用，而 for 不会创建函数</li>
<li>函数需要独立的作用域，会有额外的开销</li>
</ol>
</li>
</ul>
<h2 id="nodejs-如何开启进程，进程如何通讯？"><a href="#nodejs-如何开启进程，进程如何通讯？" class="headerlink" title="nodejs 如何开启进程，进程如何通讯？"></a>nodejs 如何开启进程，进程如何通讯？</h2><ul>
<li><p>进程 process VS 线程 thread</p>
<ol>
<li>进程： 进行资源分配和调度的最小单元，有独立内存空间</li>
<li>线程： 进行运算调度的最小单元，共享进程内存空间</li>
<li>js 是单线程的，但可以多进行执行，如 、WebWorker</li>
</ol>
</li>
<li><p>为何需要多进程？</p>
<ul>
<li>多核 CPU，更适合处理多进程</li>
<li>内存较大，多个进程才能更好的利用（单进程有内存上线）</li>
</ul>
</li>
<li><p>开启进程两种方法 child_process.fork， cluster.fork</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>).<span class="property">fork</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">url</span> === <span class="string">&quot;/xxx&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 开启子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> computeProcess = <span class="title function_">fork</span>(<span class="string">&quot;./compute.js&quot;</span>);</span><br><span class="line">    computeProcess.<span class="title function_">send</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">    computeProcess.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&quot;sum is&quot;</span> + data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    computeProcess.<span class="title function_">on</span>(<span class="string">&quot;close&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子进程因报错而退出&quot;</span>);</span><br><span class="line">      computeProcess.<span class="title function_">kill</span>();</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;localhost: 3000 starting...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compute.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子进程id&quot;</span>, process.<span class="property">pid</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子进程接收到的数据&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> sum = <span class="title function_">getSum</span>();</span><br><span class="line"></span><br><span class="line">  process.<span class="title function_">send</span>(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cpuCoreLength = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).<span class="title function_">cpus</span>().<span class="property">length</span>;</span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&quot;cluster&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.<span class="property">isMaster</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpuCoreLength; i++) &#123;</span><br><span class="line">    cluster.<span class="title function_">fork</span>(); <span class="comment">// 开启子进程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.<span class="title function_">on</span>(<span class="string">&quot;exit&quot;</span>, <span class="function">(<span class="params">worker</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子进程退出&quot;</span>);</span><br><span class="line">    cluster.<span class="title function_">fork</span>(); <span class="comment">// 进程守护</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  server.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请描述-JS-Bridge-的原理"><a href="#请描述-JS-Bridge-的原理" class="headerlink" title="请描述 JS Bridge 的原理"></a>请描述 JS Bridge 的原理</h2><ul>
<li><p>什么是 JS Bridge？</p>
<ul>
<li>js 无法直接调用 native API</li>
<li>需要通过一些特定的“格式”来调用</li>
<li>这些“格式”就统称 JS-Bridge，例如微信 JSSDK</li>
</ul>
</li>
<li><p>JS Bridge 的常见实现方式</p>
<ul>
<li>注册全局 API</li>
<li>URL Scheme</li>
</ul>
</li>
</ul>
<h2 id="requestIdleCallback-和-requestAnimationFrame-有什么区别？"><a href="#requestIdleCallback-和-requestAnimationFrame-有什么区别？" class="headerlink" title="requestIdleCallback 和 requestAnimationFrame 有什么区别？"></a>requestIdleCallback 和 requestAnimationFrame 有什么区别？</h2><ul>
<li><p>区别</p>
<ul>
<li>requestAnimationFrame 每次渲染完都会执行，高优先级</li>
<li>requestIdleCallback 空闲时候才执行，低优先级</li>
<li>requestAnimationFrame 比 requestIdleCallback 先执行，因为优先级高</li>
</ul>
</li>
<li><p>补充</p>
<ul>
<li>两者都是宏任务</li>
</ul>
</li>
</ul>
<h2 id="vue-生命周期？"><a href="#vue-生命周期？" class="headerlink" title="vue 生命周期？"></a>vue 生命周期？</h2><ul>
<li><p>befroeCreate</p>
<ul>
<li>创建一个空白的 Vue 实例</li>
<li>data、method 尚未被初始化，不可使用</li>
</ul>
</li>
<li><p>created</p>
<ul>
<li>vue 实例初始化完成，完成相应式绑定</li>
<li>data、method 都已经初始化完成，可以调用</li>
<li>尚未开始渲染模板</li>
</ul>
</li>
<li><p>beforeMount</p>
<ul>
<li>编译模板，调用 render 生成 vdom</li>
<li>还没有开始渲染 DOM</li>
</ul>
</li>
<li><p>mounted</p>
<ul>
<li>完成 DOM 渲染</li>
<li>组件创建完成</li>
<li>开始由“创建阶段”进入“运行阶段”</li>
</ul>
</li>
<li><p>beforeUpdate</p>
<ul>
<li>data 发生变化之后</li>
<li>准备更新 DOM （尚未更新 DOM）</li>
</ul>
</li>
<li><p>updated</p>
<ul>
<li>data 发生变化，且 DOM 更新完成</li>
<li>不要在 updated 中修改 data，可能会导致死循环</li>
</ul>
</li>
<li><p>beforeUnmount</p>
<ul>
<li>组件进入销毁阶段（尚未销毁，可以正常使用）</li>
<li>可移除、解绑一些全局事件、自定义事件</li>
</ul>
</li>
<li><p>unmounted</p>
<ul>
<li>组件被销毁了</li>
<li>所有子组件也被销毁了</li>
</ul>
</li>
<li><p>连环问：vue 什么时候操作 dom 比较合适？</p>
<ul>
<li>mounted 和 updated 都不能保证子组件全部挂载完成</li>
<li>使用 $nextTick 操作 dom</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 仅在整个视图都被渲染之后才会运行的代码</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>连环问：Ajax 应该放在那个生命周期？</p>
<ul>
<li>两个选择：created 和 mounted</li>
<li>推荐：mounted</li>
</ul>
</li>
<li><p>vue3 composition API 生命周期有什么区别？</p>
<ul>
<li>setup 代替了 beforeCreate 和 created</li>
<li>使用 hooks 函数的形式，如 mounted 改为 onMounted()</li>
</ul>
</li>
</ul>
<h2 id="Vue2、Vue3、React-三者-diff-算法有什么区别？"><a href="#Vue2、Vue3、React-三者-diff-算法有什么区别？" class="headerlink" title="Vue2、Vue3、React 三者 diff 算法有什么区别？"></a>Vue2、Vue3、React 三者 diff 算法有什么区别？</h2><ul>
<li>严格的 Tree diff 算法的时间复杂度是 O(n*3)</li>
<li>vue、react 框架对 tree diff 进行了优化 O(n)<ul>
<li>只比较同一层级，不跨级比较</li>
<li>tag 不同则删除重建</li>
<li>子节点通过 key 区分<ul>
<li>vdom diff 算法会根据 key 判断元素是否需要删除</li>
<li>匹配了 key，则只移动元素 - 性能较好</li>
<li>未匹配 key，则删除重建 - 性能较差</li>
</ul>
</li>
</ul>
</li>
<li>区别<ul>
<li>react 仅右移</li>
<li>vue2 双端比较</li>
<li>vue3 最长递增子序列</li>
</ul>
</li>
</ul>
<h2 id="Vue-router-三种模式（React-router-也一样）"><a href="#Vue-router-三种模式（React-router-也一样）" class="headerlink" title="Vue-router 三种模式（React-router 也一样）"></a>Vue-router 三种模式（React-router 也一样）</h2><ul>
<li>Hash</li>
<li>WebHistory</li>
<li>MemoryHistory（v4 之前叫做 abstract history）</li>
</ul>
<h2 id="移动端-H5-click-有-300ms-延迟，如何解决？"><a href="#移动端-H5-click-有-300ms-延迟，如何解决？" class="headerlink" title="移动端 H5 click 有 300ms 延迟，如何解决？"></a>移动端 H5 click 有 300ms 延迟，如何解决？</h2><ul>
<li><p>背景：double tap to zoom</p>
</li>
<li><p>初期解决方案 FastClick</p>
<ul>
<li>监听 touchend 事件(touchstart touchend 会先于 click 触发)</li>
<li>使用自定义 DOM 事件模拟一个 click 事件</li>
<li>把默认的 click 事件(300ms 之后触发)禁止掉</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;load&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">FastClick</span>.<span class="title function_">attach</span>(<span class="variable language_">document</span>.<span class="property">body</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>现代浏览器的改进（width=device-width）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;id=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="网络请求中，token-和-cookie-有什么区别？"><a href="#网络请求中，token-和-cookie-有什么区别？" class="headerlink" title="网络请求中，token 和 cookie 有什么区别？"></a>网络请求中，token 和 cookie 有什么区别？</h2><ul>
<li><p>cookie</p>
<ul>
<li>http 无状态，每次请求都要带 cookie，以帮助识别身份</li>
<li>服务端也可以向客户端 set-cookie，cookie 大小限制 4kb</li>
<li>默认有跨域限制：不可跨域共享、传递 cookie</li>
</ul>
</li>
<li><p>token vs cookie</p>
<ul>
<li>cookie 是 http 规范，而 token 是自定义传递</li>
<li>cookie 会默认被浏览器存储，而 token 需自己存储</li>
<li>token 默认没有跨域限制</li>
</ul>
</li>
<li><p>JWT(JSON Web Token)</p>
<ul>
<li>前端发起登录，后端验证成功之后，返回一个加密的 token</li>
<li>前端自行存储这个 token（其中包含了用户信息，加密了）</li>
<li>以后访问服务端的接口，都带着这个 token，作为用户信息</li>
</ul>
</li>
</ul>
<h2 id="Session-和-JWT-哪个更好？"><a href="#Session-和-JWT-哪个更好？" class="headerlink" title="Session 和 JWT 哪个更好？"></a>Session 和 JWT 哪个更好？</h2><ul>
<li><p>session</p>
<ul>
<li>优点<ul>
<li>原理简单，易于学习</li>
<li>用户信息存储在服务端，可以快速封禁某个用户</li>
</ul>
</li>
<li>缺点<ul>
<li>占用服务端内存，硬件成本高</li>
<li>多进程，多服务器时，不好同步-需要使用第三方缓存，如 redis</li>
<li>默认有跨域限制</li>
</ul>
</li>
</ul>
</li>
<li><p>JWT</p>
<ul>
<li>优点<ul>
<li>不占用服务器内存</li>
<li>多进程、多服务器不受影响</li>
<li>没有跨域限制</li>
</ul>
</li>
<li>缺点<ul>
<li>用户信息存储在客户端，无法快速封禁某用户</li>
<li>万一服务器密钥被泄漏，则用户信息全部丢失</li>
<li>token 体积一般大于 cookie，会增加请求的数据量</li>
</ul>
</li>
</ul>
</li>
<li><p>答案</p>
<ul>
<li>如有严格管理用户信息的需求（保密、快速封禁），推荐 session</li>
<li>如没有特殊要求，则使用 JWT</li>
</ul>
</li>
</ul>
<h2 id="如何实现-SSO-单点登录？"><a href="#如何实现-SSO-单点登录？" class="headerlink" title="如何实现 SSO 单点登录？"></a>如何实现 SSO 单点登录？</h2><ul>
<li><p>基于 cookie（主域名相同）</p>
<ul>
<li>cookie 默认不可跨域共享，但有些情况下可设置共享</li>
<li>主域名相同，如<a href="http://www.baidu.com,image.baidu.com/">www.baidu.com,image.baidu.com</a></li>
<li>设置 cookie domain 为主域名，即可共享 cookie</li>
</ul>
</li>
<li><p>SSO（主域名不相同，cookie 无法共享）</p>
<ul>
<li><img src="/images/md_img/sso.jpg" alt="sso"></li>
</ul>
</li>
</ul>
<h2 id="HTTP-协议和-UDP-协议有什么区别？"><a href="#HTTP-协议和-UDP-协议有什么区别？" class="headerlink" title="HTTP 协议和 UDP 协议有什么区别？"></a>HTTP 协议和 UDP 协议有什么区别？</h2><ul>
<li>网络协议<ul>
<li>HTTP 协议在应用层</li>
<li>TCP、UDP 协议在传输层<ul>
<li>TCP 协议<ul>
<li>有连接，有断开</li>
<li>稳定传输</li>
</ul>
</li>
<li>UDP 协议<ul>
<li>无连接，无断开</li>
<li>不稳定传输，但效率高</li>
<li>如视频会议、语音通话</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HTTP-协议-1-0、1-1、2-0-有什么区别？"><a href="#HTTP-协议-1-0、1-1、2-0-有什么区别？" class="headerlink" title="HTTP 协议 1.0、1.1、2.0 有什么区别？"></a>HTTP 协议 1.0、1.1、2.0 有什么区别？</h2><ul>
<li><p>HTTP 1.0</p>
<ul>
<li>最基础的 HTTP 协议</li>
<li>支持基本的 GET、POST 方法</li>
</ul>
</li>
<li><p>HTTP 1.1</p>
<ul>
<li>缓存策略 cache-control、E-tag 等</li>
<li>支持长连接 Connection: keep-alive,一次 TCP 连接多次请求</li>
<li>支持断点续传，状态码 206</li>
<li>支持新的方法 PUT、DELETE 等，可用于 Restful API</li>
</ul>
</li>
<li><p>HTTP 2.0</p>
<ul>
<li>可压缩 header，减少体积</li>
<li>多路复用，一次 TCP 连接中可以多个 HTTP 并行请求</li>
<li>服务端推送</li>
</ul>
</li>
</ul>
<h2 id="什么是-HTTPS-中间人攻击？如何预防？"><a href="#什么是-HTTPS-中间人攻击？如何预防？" class="headerlink" title="什么是 HTTPS 中间人攻击？如何预防？"></a>什么是 HTTPS 中间人攻击？如何预防？</h2><ul>
<li><p>HTTPS 加密传输</p>
<ul>
<li>HTTP 明文传输</li>
<li>HTTPS 加密传输 HTTP + TLS/SSL</li>
<li><img src="/images/md_img/https.jpg" alt="https加密"></li>
</ul>
</li>
<li><p>答案</p>
<ul>
<li>使用正规厂商的加密证书可以防止中间人攻击</li>
</ul>
</li>
</ul>
<h2 id="defer-和-async-有什么区别？"><a href="#defer-和-async-有什么区别？" class="headerlink" title="defer 和 async 有什么区别？"></a>defer 和 async 有什么区别？</h2><ul>
<li>区别 <img src="/images/md_img/defer_async.jpg" alt="区别"></li>
</ul>
<h2 id="prefetch-和-dns-prefetch-有什么区别？"><a href="#prefetch-和-dns-prefetch-有什么区别？" class="headerlink" title="prefetch 和 dns-prefetch 有什么区别？"></a>prefetch 和 dns-prefetch 有什么区别？</h2><ul>
<li>preload 资源在当前页面使用，会优先加载</li>
<li>prefetch 资源在未来页面使用，空闲时加载</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;other.js&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>dns-prefetch 即 DNS 预查询</li>
<li>preconnect 即 DNS 预连接</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.xxx.com/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.xxx.com&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="你知道哪些前端攻击？该如何预防？"><a href="#你知道哪些前端攻击？该如何预防？" class="headerlink" title="你知道哪些前端攻击？该如何预防？"></a>你知道哪些前端攻击？该如何预防？</h2><ul>
<li><p>xss</p>
<ul>
<li>Cross Site Script 跨站脚本攻击</li>
<li>手段：将 js 代码插入到网页内容中，渲染时执行 js 代码</li>
<li>预防：特殊字符替换（前端或后端）</li>
</ul>
</li>
<li><p>csrf</p>
<ul>
<li><p>Cross Site Request Forgery 跨站请求伪造</p>
</li>
<li><p>手段：诱导用户去访问另一个网站的接口，伪造请求</p>
</li>
<li><p>预防：严格的跨域限制 + 验证码机制</p>
</li>
<li><p>csrf 详细过程</p>
<ul>
<li>用户登录 A 网站，有了 A 网站的 cookie</li>
<li>诱导用户到 B 网站，并发起 A 网站的请求</li>
<li>A 网站的 API 发现有 cookie，认为是用户自己操作的</li>
</ul>
</li>
<li><p>csrf 预防手段</p>
<ul>
<li>严格的跨域请求限制，如判断 referer（请求来源）</li>
<li>为 cookie 设置 SameSite，禁止跨域传递 cookie</li>
<li>关键接口使用短信验证码</li>
</ul>
</li>
</ul>
</li>
<li><p>点击劫持</p>
<ul>
<li>click jacing</li>
<li>手段：诱导界面上蒙一个透明 iframe，诱导用户点击</li>
<li>预防：让 iframe 不能跨域加载</li>
</ul>
</li>
<li><p>DDos</p>
<ul>
<li>Distribute denial-of-service 分布式拒绝服务</li>
<li>手段：分布式的、大规模的流量访问，使服务器瘫痪</li>
<li>预防：软件层不好做，需硬件预防（如阿里云 WAF）</li>
</ul>
</li>
<li><p>SQL 注入</p>
<ul>
<li>手段：提交内容时写入 SQL 语句，破环数据库</li>
<li>预防：处理输入的内容，替换特殊字符</li>
</ul>
</li>
</ul>
<h2 id="WebSocket-和-HTTP-有什么区别？"><a href="#WebSocket-和-HTTP-有什么区别？" class="headerlink" title="WebSocket 和 HTTP 有什么区别？"></a>WebSocket 和 HTTP 有什么区别？</h2><ul>
<li><p>WebSocket</p>
<ul>
<li><p>支持端对端通讯</p>
</li>
<li><p>可以由 client 发起，也可以由 server 发起</p>
</li>
<li><p>用于：消息通知，直播间讨论区，聊天室，协同编辑</p>
</li>
<li><p>client</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">WebSocketServer</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;ws&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> wsServer = <span class="keyword">new</span> <span class="title class_">WebSocketServer</span>(&#123; <span class="attr">port</span>: <span class="number">3000</span> &#125;);</span><br><span class="line"></span><br><span class="line">wsServer.<span class="title function_">on</span>(<span class="string">&quot;connection&quot;</span>, <span class="function">(<span class="params">ws</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;connection&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ws.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到了信息&quot;</span>, msg.<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ws.<span class="title function_">send</span>(<span class="string">&quot;服务端已经收到了信息&quot;</span> + msg.<span class="title function_">toString</span>());</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>server</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://127.0.0.1:3000&quot;</span>);</span><br><span class="line">ws.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;opened&quot;</span>);</span><br><span class="line">  ws.<span class="title function_">send</span>(<span class="string">&quot;client opened&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到了信息&quot;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;clicked&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ws.<span class="title function_">send</span>(<span class="string">&quot;当前时间&quot;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>WebSocket 连接过程</p>
<ul>
<li>先发起一个 http 请求</li>
<li>成功之后再升级到 WebSocket 协议，再通讯</li>
</ul>
</li>
<li><p>WebSocket 和 HTTP 区别？</p>
<ul>
<li>WebSocket 协议名是 ws://,可双端发起请求</li>
<li>WebSocket 没有跨域限制</li>
<li>通过 send 和 onmessage 通讯（HTTP 通过 req 和 res）</li>
</ul>
</li>
<li><p>ws 可升级为 wss（like https）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">&quot;https&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">WebSocketServer</span> &#125; <span class="keyword">from</span> <span class="string">&quot;ws&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="title function_">createServer</span>(&#123;</span><br><span class="line">  <span class="attr">cert</span>: <span class="title function_">readFileSync</span>(<span class="string">&quot;/path/to/cert.pem&quot;</span>),</span><br><span class="line">  <span class="attr">key</span>: <span class="title function_">readFileSync</span>(<span class="string">&quot;/path/to/key.pem&quot;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocketServer</span>(&#123; server &#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>实际项目推荐 socket.io,API 更简洁</p>
</li>
</ul>
<h2 id="WebSocket-和-HTTP-长轮询的区别？"><a href="#WebSocket-和-HTTP-长轮询的区别？" class="headerlink" title="WebSocket 和 HTTP 长轮询的区别？"></a>WebSocket 和 HTTP 长轮询的区别？</h2><ul>
<li><p>区别</p>
<ul>
<li>HTTP 长轮询：客户端发起请求，服务端阻塞，不会立即返回</li>
<li>WebSocket：客户端可发起请求，服务端也可发起请求</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>HTTP 长轮询，需处理 timeout，即 timeout 之后重新发请求</li>
</ul>
</li>
</ul>
<h2 id="描述从输入-url-到页面展示的完整过程"><a href="#描述从输入-url-到页面展示的完整过程" class="headerlink" title="描述从输入 url 到页面展示的完整过程"></a>描述从输入 url 到页面展示的完整过程</h2><ul>
<li>网络请求<ul>
<li>DNS 查询（得到 IP），建立 TCP 连接（三次握手）</li>
<li>浏览器发起 HTTP 请求</li>
<li>收到请求响应，得到 HTML 源代码</li>
</ul>
</li>
<li>解析（字符串 -&gt; 结构化数据）<ul>
<li>HTML 构建 DOM 树</li>
<li>CSS 构建 CSSOM 树（style tree）</li>
<li>两者结合，形成 render tree</li>
</ul>
</li>
<li>渲染（render tree 绘制到页面）<ul>
<li>计算各个 DOM 的尺寸、定位，最后绘制到页面</li>
<li>遇到 js 可能会执行（参考 defer、async）</li>
<li>异步 CSS、图片加载，可能会触发重新渲染</li>
</ul>
</li>
</ul>
<h2 id="重绘-repaint-重排-reflow-有什么区别？"><a href="#重绘-repaint-重排-reflow-有什么区别？" class="headerlink" title="重绘 repaint 重排 reflow 有什么区别？"></a>重绘 repaint 重排 reflow 有什么区别？</h2><ul>
<li><p>重绘 repaint</p>
<ul>
<li>元素外观改变，如颜色、背景色</li>
<li>但元素的尺寸、定位不变，不会影响到其他元素的位置</li>
</ul>
</li>
<li><p>重排 relfow</p>
<ul>
<li>重新计算尺寸和布局，可能会影响其他元素的位置</li>
<li>如元素高度增加，可能会使相邻元素位置下移</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li>重排比重绘影响更大，消耗更大</li>
<li>所以，要尽量避免无意义的重排</li>
</ul>
</li>
<li><p>减少重排的方法</p>
<ul>
<li>集中修改样式，或直接切换 css、class</li>
<li>修改之前先设置 display: none,脱离文档流</li>
<li>使用 BFC 特性，不影响其他元素位置</li>
<li>频发触发（resize、scroll）使用节流和防抖</li>
<li>使用 createDocumentFragment 批量操作 DOM</li>
<li>优化动画，使用 CSS3 和 requestAnimationFrame</li>
</ul>
</li>
</ul>
<h2 id="如何实现网页多标签通讯？"><a href="#如何实现网页多标签通讯？" class="headerlink" title="如何实现网页多标签通讯？"></a>如何实现网页多标签通讯？</h2><ul>
<li><p>使用 WebSocket</p>
<ul>
<li>无跨域限制</li>
<li>需要服务端支持，成本高</li>
</ul>
</li>
<li><p>localStorage（跨域不共享）</p>
<ul>
<li>同域的 A 和 B 两个页面</li>
<li>A 页面设置 localStorage</li>
<li>B 页面可监听到 localStorage 值的修改</li>
</ul>
</li>
<li><p>SharedWorker(必须同域)</p>
<ul>
<li>SharedWorker 是 WebWorker 的一种</li>
<li>WebWorker 可开启子进程执行 JS，但不能操作 DOM</li>
<li>SharedWorker 可单独开启一个进程，用于同域页面通讯</li>
</ul>
</li>
</ul>
<h2 id="网页和-iframe-如何通讯？"><a href="#网页和-iframe-如何通讯？" class="headerlink" title="网页和 iframe 如何通讯？"></a>网页和 iframe 如何通讯？</h2><ul>
<li>使用 postMessage 通讯</li>
<li>注意跨域的限制和判断</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父传子</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">iframe1</span>.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="comment">// 子传父</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="comment">// 接收</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">origin</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="请描述-koa2-洋葱圈模型？"><a href="#请描述-koa2-洋葱圈模型？" class="headerlink" title="请描述 koa2 洋葱圈模型？"></a>请描述 koa2 洋葱圈模型？</h2><ul>
<li><p>koa2</p>
<ul>
<li>一个简约、流行的 nodejs 框架</li>
<li>通过中间件组织代码</li>
<li>多个中间件以“洋葱圈模型”执行</li>
</ul>
</li>
<li><p>代码执行过程</p>
<ul>
<li><img src="/images/md_img/koa1.jpg" alt="koa1"></li>
</ul>
</li>
<li><p>洋葱圈模型(类似捕获冒泡)</p>
<ul>
<li><img src="/images/md_img/koa2.jpg" alt="koa2"></li>
</ul>
</li>
</ul>
<h2 id="H5-页面如何进行首屏优化？"><a href="#H5-页面如何进行首屏优化？" class="headerlink" title="H5 页面如何进行首屏优化？"></a>H5 页面如何进行首屏优化？</h2><ul>
<li><p>路由懒加载</p>
<ul>
<li>适用于 SPA</li>
<li>路由拆分，优先保证首页加载</li>
</ul>
</li>
<li><p>服务端渲染 SSR</p>
<ul>
<li>传统前后端分离（SPA）渲染页面的过程复杂</li>
<li>SSR 渲染页面过程简单，所有性能好</li>
<li>如果是纯 H5 页面，SSR 是性能优化的终极方案</li>
</ul>
</li>
<li><p>App 预取</p>
<ul>
<li>如果 H5 在 App WebView 中展示，可使用 App 预取</li>
<li>用户访问列表页面时，App 预加载文章首屏内容</li>
<li>用户进入 H5 页面，直接从 App 中获取内容，瞬间展示首屏</li>
</ul>
</li>
<li><p>分页</p>
<ul>
<li>针对列表页</li>
<li>默认只展示第一页内容</li>
<li>上滑加载更多</li>
</ul>
</li>
<li><p>图片懒加载 lazyload</p>
<ul>
<li>针对详情页</li>
<li>默认只展示文本内容，然后出发图片懒加载</li>
<li>注意：提前设置图片尺寸，尽量只重绘不重排</li>
</ul>
</li>
<li><p>Hybrid</p>
<ul>
<li>提前将 HTML、JS、CSS 下载到 App 内部</li>
<li>在 App webview 中使用 file：// 协议加载页面文件</li>
<li>再用 Ajax 获取内容并展示（也结合 App 预取）</li>
</ul>
</li>
</ul>
<h2 id="后端一次性返回-10w-条数据，你该如何渲染？"><a href="#后端一次性返回-10w-条数据，你该如何渲染？" class="headerlink" title="后端一次性返回 10w 条数据，你该如何渲染？"></a>后端一次性返回 10w 条数据，你该如何渲染？</h2><ul>
<li><p>设计不合理，去砍了后端</p>
</li>
<li><p>自定义中间层</p>
<ul>
<li>自定义 nodejs 中间层，获取并拆分这 10w 条数据</li>
<li>前端对接 nodejs 中间层，而不是服务端</li>
<li>成本比较高</li>
</ul>
</li>
<li><p>虚拟列表</p>
<ul>
<li>只渲染可视区域</li>
</ul>
</li>
</ul>
<h2 id="React-都有哪些注意点（坑）？"><a href="#React-都有哪些注意点（坑）？" class="headerlink" title="React 都有哪些注意点（坑）？"></a>React 都有哪些注意点（坑）？</h2><ul>
<li><p>自定义组件首字母大写</p>
</li>
<li><p>js 关键字的冲突（htmlFor、className）</p>
</li>
<li><p>JSX 的数据类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> value=&#123;<span class="number">1</span>&#125; /&gt; <span class="comment">// number</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span> <span class="comment">// string</span></span><br></pre></td></tr></table></figure></li>
<li><p>setState 是异步更新的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span> + <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span>); <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如何统一监听-Vue-组件报错？"><a href="#如何统一监听-Vue-组件报错？" class="headerlink" title="如何统一监听 Vue 组件报错？"></a>如何统一监听 Vue 组件报错？</h2><ul>
<li><p>window.onerror</p>
<ul>
<li>全局监听所有 js 错误</li>
<li>try…catch 中的错误无法被监听到</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">msg, source, line, column, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg, source, line, column, error);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>errorCaptured 生命周期</p>
<ul>
<li>监听所有下级组件的错误</li>
<li>返回 false 会阻止向上传播</li>
</ul>
</li>
<li><p>errorHandler 配置</p>
<ul>
<li>Vue 全局错误监听，所有组件错误都会汇总到这里</li>
<li>但 errorCaptured 返回 false，不会传播到这里</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">app.<span class="property">config</span>.<span class="property">errorHandler</span> = <span class="function">(<span class="params">err, vm, info</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error, vm, info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>异步错误</p>
<ul>
<li>异步回调里面的错误，errorHandler 监听不到</li>
<li>需要使用 window.onerror</li>
</ul>
</li>
</ul>
<h2 id="如何统一监听-React-报错？"><a href="#如何统一监听-React-报错？" class="headerlink" title="如何统一监听 React 报错？"></a>如何统一监听 React 报错？</h2><ul>
<li><p>ErrorBoundary 组件</p>
<ul>
<li>监听所有下级组件报错，可降级展示 UI</li>
<li>只监听组件渲染时报错，不监听 DOM 事件、异步错误<ul>
<li>不监听 DOM 事件报错，可用 try…catch,window.onerror</li>
</ul>
</li>
<li>只在 production 环境生效，dev 会直接抛出错误</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">error</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新state，显示降级UI</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; error &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, errorInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 统计上报错误信息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">error</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>报错了<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如果一个-H5-很慢，你该如何排查性能问题？"><a href="#如果一个-H5-很慢，你该如何排查性能问题？" class="headerlink" title="如果一个 H5 很慢，你该如何排查性能问题？"></a>如果一个 H5 很慢，你该如何排查性能问题？</h2><ul>
<li><p>前端性能指标</p>
<ul>
<li>First Paint（FP）</li>
<li>First ContentFul Paint（FCP）</li>
<li>DomContentLoaded（DCL）</li>
<li>Largest Contentful Paint（LCP）</li>
<li>Load（L）</li>
</ul>
</li>
<li><p>Chrome devtools</p>
<ul>
<li>Performance 可查看上述性能指标，并有网页快照</li>
<li>Network 可以查看各个资源的加载时间</li>
</ul>
</li>
<li><p>lighthouse（第三方性能评测工具）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// terminal</span></span><br><span class="line">lighthouse <span class="attr">https</span>:<span class="comment">//www.imooc.com/ --view --preset=desktop</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过以上工具来判读是加载慢还是渲染慢</p>
<ul>
<li>加载慢<ul>
<li>优化服务端硬件配置，使用 CDN</li>
<li>路由懒加载，大组件异步加载-减少主包的体积</li>
<li>优化 http 缓存策略</li>
</ul>
</li>
<li>渲染慢<ul>
<li>优化服务端接口（如 ajax 获取数据慢）</li>
<li>优化全段组件内部逻辑</li>
<li>服务端渲染 SSR</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="如何理解-HTML-语义化？"><a href="#如何理解-HTML-语义化？" class="headerlink" title="如何理解 HTML 语义化？"></a>如何理解 HTML 语义化？</h2><ul>
<li>让人更容易读懂（增加代码可读性）</li>
<li>让搜索引擎更容易读懂（SEO）</li>
</ul>
<h2 id="块状元素-amp-内联元素？"><a href="#块状元素-amp-内联元素？" class="headerlink" title="块状元素 &amp; 内联元素？"></a>块状元素 &amp; 内联元素？</h2><ul>
<li>块级元素<ul>
<li>display: block/table;</li>
<li>div、h1、h2、table、ul、ol、p 等</li>
</ul>
</li>
<li>内联元素<ul>
<li>display: inline/inline-block;</li>
<li>span、img、input、button 等；</li>
</ul>
</li>
</ul>
<h2 id="如下代码，请问-div-的-offsetWidth-是多大？"><a href="#如下代码，请问-div-的-offsetWidth-是多大？" class="headerlink" title="如下代码，请问 div 的 offsetWidth 是多大？"></a>如下代码，请问 div 的 offsetWidth 是多大？</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>offsetWidth = (内容宽度 + 内边距 + 边框)，无外边距</li>
<li>答案： 100 + 10 + 1 * 2 = 122px</li>
<li>可以通过：box-sizing: border-box; 使得 offsetWidth=100</li>
</ul>
<h2 id="margin-纵向重叠问题"><a href="#margin-纵向重叠问题" class="headerlink" title="margin 纵向重叠问题"></a>margin 纵向重叠问题</h2><ul>
<li>如下代码，A 和 B 之间的距离是多少？</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>相邻元素的 margin-top 和 margin-bottom 会发生重叠</li>
<li>空白内容 p 标签也会重叠</li>
<li>答案：15px</li>
</ul>
<h2 id="margin-负值问题"><a href="#margin-负值问题" class="headerlink" title="margin 负值问题"></a>margin 负值问题</h2><ul>
<li>margin-top 和 margin-left 负值，元素向上、向左移动</li>
<li>margin-right 负值，右侧元素左移，自身不受影响</li>
<li>margin-bottom 负值，下方元素上移，自身不受影响</li>
</ul>
<h2 id="BFC-理解与应用"><a href="#BFC-理解与应用" class="headerlink" title="BFC 理解与应用"></a>BFC 理解与应用</h2><ul>
<li>Block format context，块级格式化上下文</li>
<li>一块独立渲染区域，内部元素的渲染不会影响边界以外的元素</li>
<li>形成 BFC 的常见条件<ul>
<li>float 不是 none</li>
<li>position 是 absolute 或 fixed</li>
<li>overflow 不是 visible</li>
<li>display 是 flex、inline-block 等</li>
</ul>
</li>
<li>常见应用：<ul>
<li>清除浮动</li>
</ul>
</li>
</ul>
<h2 id="float-布局"><a href="#float-布局" class="headerlink" title="float 布局"></a>float 布局</h2><ul>
<li>实现圣杯布局和双飞翼布局<ul>
<li>目的<ul>
<li>三栏布局，中间一栏最先加载和渲染</li>
<li>两侧内容固定，中间内容随着宽度自适应</li>
<li>一般用于 PC 网页</li>
</ul>
</li>
<li>实现<ul>
<li>使用 float 布局</li>
<li>两侧使用 margin 负值，以便和中间内容横向重叠</li>
<li>防止中间内容被两侧覆盖，一个用 padding，一个用 margin</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="css-定位"><a href="#css-定位" class="headerlink" title="css 定位"></a>css 定位</h2><ul>
<li><p>absolute 和 relative 定位</p>
<ul>
<li>relative 依据自身定位</li>
<li>absolute 依据最近一层的定位元素定位<ul>
<li>定位元素：absolute、relative、fied、body</li>
</ul>
</li>
</ul>
</li>
<li><p>居中对齐</p>
<ul>
<li><p>水平居中</p>
<ul>
<li>inline 元素：text-align: center</li>
<li>block 元素：margin: auto</li>
<li>absolute 元素：left:50% + margin-left 负值</li>
</ul>
</li>
<li><p>垂直居中</p>
<ul>
<li>inline 元素：line-height 的值等于 height 的值</li>
<li>absolute 元素：top: 50% + margin-top 负值</li>
<li>absolute 元素：transform(-50%, -50%)</li>
<li>absolute 元素：top,left,bottom,right=0 + margin: auto</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="css-图文样式"><a href="#css-图文样式" class="headerlink" title="css-图文样式"></a>css-图文样式</h2><ul>
<li><p>line-height 如何继承</p>
<ul>
<li>如下代码，p 标签的行高是多少？</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">200%</span>; <span class="comment">/* 40px */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">1.5</span>; <span class="comment">/* 16 * 1.5 = 24 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">30px</span>; <span class="comment">/* 30px */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>答案： 40px</li>
</ul>
</li>
<li><p>具体数值，如 30px，则继承该值</p>
</li>
<li><p>写比例，如 2/1.5，则继承当前元素 font-size 的比例</p>
</li>
<li><p>写百分比，如 200%，则继承计算出来的值</p>
</li>
</ul>
<h2 id="css-响应式"><a href="#css-响应式" class="headerlink" title="css-响应式"></a>css-响应式</h2><ul>
<li><p>常见长度单位</p>
<ul>
<li>px，绝对长度单位</li>
<li>em，相对长度单位，相对于父元素</li>
<li>rem，相对长度单位，相对于根元素，常用与响应式布局</li>
</ul>
</li>
<li><p>响应式布局常用方案</p>
<ul>
<li>media-query，根据不同屏幕宽度设置根元素 font-size</li>
<li>rem，基于根元素的相对单位</li>
<li>rem 的弊端：“阶梯”性</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">374px</span>) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">86px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="keyword">@media</span> <span class="keyword">only</span> scrren <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">413px</span>) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="keyword">@media</span> <span class="keyword">only</span> scrren <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">414px</span>) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">110px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">0.16rem</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">1rem</span>; <span class="comment">/* 100px */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span>div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>网页视口尺寸</p>
<ul>
<li>window.screen.height // 屏幕高度</li>
<li>window.innerHeight // 网页视口高度<ul>
<li>vh 网页视口高度的 1/100</li>
<li>vw 网页视口宽度的 1/100</li>
<li>vmax 取两者最大值；vmin 取两者最小值</li>
</ul>
</li>
<li>document.body.clientHeight // body 高度</li>
</ul>
</li>
</ul>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><ul>
<li>识别所有值类型<ul>
<li>undefined</li>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>Symbol</li>
</ul>
</li>
<li>识别函数、<ul>
<li>function</li>
</ul>
</li>
<li>判断是否是引用类型<ul>
<li>object</li>
</ul>
</li>
</ul>
<h2 id="手写-call"><a href="#手写-call" class="headerlink" title="手写 call"></a>手写 call</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">  ctx[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = ctx[fn](...args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> ctx[fn];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写-apply"><a href="#手写-apply" class="headerlink" title="手写 apply"></a>手写 apply</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span> (<span class="params">context, args = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">  ctx[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = ctx[fn](...args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> ctx[fn];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">newFn</span>(<span class="params">...newFnArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> newFn) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">fn</span>(...args, ...newFnArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, [...args, ...newFnArgs]);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写-instanceof"><a href="#手写-instanceof" class="headerlink" title="手写 instanceof"></a>手写 instanceof</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.通过left.__proto__.__proto__这种方式从下往上获取原型对象</span></span><br><span class="line"><span class="comment">* 2.通过Object.create(null)的实例是没有原型链</span></span><br><span class="line"><span class="comment">* 3.有原型链的实例的尽头都是Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">instanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!left.<span class="property">__proto__</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (right === <span class="title class_">Object</span> || left.<span class="property">__proto__</span> === right.<span class="property">protorype</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">instanceof</span>(left.<span class="property">__proto__</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步和单线程"><a href="#异步和单线程" class="headerlink" title="异步和单线程"></a>异步和单线程</h2><ul>
<li><p>js 是单线程语言，同时只能做一件事</p>
</li>
<li><p>浏览器和 nodejs 已支持启动进程，如 web worker</p>
</li>
<li><p>js 和 dom 渲染共用同一个线程，因为 js 可以修改 dom 结构，所以遇到等待（网络请求，定时任务）就会卡住</p>
<ul>
<li>网络请求，如 ajax 图片加载</li>
<li>定时任务，如 setTimeout</li>
</ul>
</li>
<li><p>所以需要异步（callback）</p>
</li>
<li><p>异步和同步的区别？</p>
<ul>
<li>基于 js 是单线程语言</li>
<li>异步不会阻塞代码执行</li>
<li>同步会阻塞代码执行</li>
</ul>
</li>
</ul>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><ul>
<li><p>for…in（以及 forEach、for）都是常规的同步遍历</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">muti</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(num * num);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现象：1s后，同时打印 1，4，9</span></span><br><span class="line">nums.<span class="title function_">forEach</span>(<span class="keyword">async</span> (item) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">muti</span>(item);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现象：异步等待打印</span></span><br><span class="line">!(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">muti</span>(i);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><p>for…of 常用于异步的遍历</p>
</li>
</ul>
<h2 id="从-event-loop-解释，为什么微任务执行更早？"><a href="#从-event-loop-解释，为什么微任务执行更早？" class="headerlink" title="从 event loop 解释，为什么微任务执行更早？"></a>从 event loop 解释，为什么微任务执行更早？</h2><ul>
<li><p>宏任务：</p>
</li>
<li><p>setTimeout、setInterval、ajax、DOM 事件</p>
</li>
<li><p>微任务：</p>
</li>
<li><p>promise、async/await</p>
</li>
<li><p>微任务的执行时机要比宏任务要早</p>
</li>
<li><p>每次 call stack 清空，即每次轮询结束，即同步任务执行完成</p>
</li>
<li><p>如果 DOM 结构有改变，则会重新进行 DOM 渲染</p>
</li>
<li><p>宏任务：DOM 渲染后触发，如 setTimeout</p>
</li>
<li><p>微任务：DOM 渲染前触发，如 promise</p>
</li>
<li><p>所以：微任务先于宏任务先执行</p>
</li>
<li><p>补充：</p>
<ul>
<li>微任务都是 ES6 语法规定的</li>
<li>宏任务都是由浏览器规定的</li>
</ul>
</li>
</ul>
<h2 id="BOM-API"><a href="#BOM-API" class="headerlink" title="BOM API"></a>BOM API</h2><ul>
<li>navigator</li>
<li>screen</li>
<li>location</li>
<li>history</li>
</ul>
<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ul>
<li><p>xhr.readyState</p>
<ul>
<li>0 (未初始化)还没有调用 send()方法</li>
<li>1 (载入)已调用 send()方法，正在发送请求</li>
<li>2 (载入完成) send()方法执行完成，已经接收到全部响应内容</li>
<li>3 (交互) 正在解析响应内容</li>
<li>4 (完成) 响应内容解析完成，可以在客户端调用</li>
</ul>
</li>
<li><p>xhr.status</p>
<ul>
<li>2xx 表示成功处理请求，如 200</li>
<li>3xx 需要重定向，浏览器直接跳转，如 301、302、304</li>
<li>4xx 客户端请求错误，如 404、403</li>
<li>5xx 服务端错误</li>
</ul>
</li>
</ul>
<h2 id="常见状态码？"><a href="#常见状态码？" class="headerlink" title="常见状态码？"></a>常见状态码？</h2><p>信息响应</p>
<ul>
<li>101 协议切换</li>
</ul>
<p>成功响应</p>
<ul>
<li>200 成功</li>
<li>204 请求成功，不反悔任何内容</li>
<li>206 分块请求成功</li>
</ul>
<p>重定向</p>
<ul>
<li>301 永久重定向（配合 location，浏览器自动处理）</li>
<li>302 临时重定向（配合 location，浏览器自动处理）</li>
<li>304 资源未被修改（协商缓存 ）</li>
</ul>
<p>客户端响应</p>
<ul>
<li>400 无法被服务器理解</li>
<li>401 未授权</li>
<li>403 禁止访问</li>
<li>404 资源未找到</li>
<li>405 没有权限,请求方法(get/post 等)错误</li>
</ul>
<p>服务端响应</p>
<ul>
<li><p>500 服务器错误</p>
</li>
<li><p>503 服务不可达</p>
</li>
<li><p>504 网关超时</p>
</li>
<li><p>本身状态码就是一种约定，一种协议和规范，不要尝试违反规范，例如 IE 浏览器</p>
</li>
</ul>
<h2 id="http-常见-methods？"><a href="#http-常见-methods？" class="headerlink" title="http 常见 methods？"></a>http 常见 methods？</h2><ul>
<li><p>传统 methods</p>
<ul>
<li>get 获取服务器的数据</li>
<li>post 向服务器提交数据</li>
</ul>
</li>
<li><p>新的 methods</p>
<ul>
<li>get 获取数据</li>
<li>post 新建数据</li>
<li>patch/put 更新数据</li>
<li>delete 删除数据</li>
</ul>
</li>
</ul>
<h2 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h2><ul>
<li><p>一种新的 API 设计方法</p>
</li>
<li><p>传统 API 设计：把每个 url 当作一个功能</p>
</li>
<li><p>Restful API 设计：把每个 url 当作一个唯一的资源</p>
</li>
<li><p>原则</p>
<ul>
<li>不使用 url 参数<ul>
<li>传统 API 设计：/api/list?pageIndex=2</li>
<li>Restful API 设计：/api/list/2</li>
</ul>
</li>
<li>用 method 表示操作类型<ul>
<li>传统 API 设计<ul>
<li>post 请求 /api/create-blog</li>
<li>post 请求 /api/update-blog?id=100</li>
<li>get 请求 /api/get-blog?id=100</li>
</ul>
</li>
<li>Restful API 请求<ul>
<li>post 请求 /api/blog</li>
<li>patch 请求 /api/blog/100</li>
<li>get 请求 /api/blog/100</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常见-http-headers？"><a href="#常见-http-headers？" class="headerlink" title="常见 http headers？"></a>常见 http headers？</h2><ul>
<li><p>Request Headers</p>
<ul>
<li>Accept 浏览器可接收的数据格式</li>
<li>Accept-Encoding 浏览器可接收的压缩算法，如 gzip</li>
<li>Accept-Languange 浏览器可接收的语言，如 zh-CN</li>
<li>Connection: keep-alive 一次 TCP 连接重复使用</li>
<li>cookie</li>
<li>Host 如：<a href="http://www.baidu.com/">www.baidu.com</a></li>
<li>Cache-Control</li>
<li>User-Agent （简称 UA）浏览器信息</li>
<li>Content-type 发送数据的格式，如 application/json</li>
</ul>
</li>
<li><p>Response Headers</p>
<ul>
<li>Content-type 返回数据的格式，如 application/json</li>
<li>Content-length 返回数据的大小，多少字节</li>
<li>Content-Encoding 返回数据的压缩算法，如 gzip</li>
<li>Set-Cookie</li>
<li>Expires</li>
<li>Etag</li>
<li>date</li>
</ul>
</li>
<li><p>自定义 header</p>
</li>
<li><p>缓存相关的 headers</p>
<ul>
<li>Cache-Control Expires</li>
<li>Last-Modified If-Modified-Since</li>
<li>Etag If-None-Match</li>
</ul>
</li>
</ul>
<h2 id="http-缓存？"><a href="#http-缓存？" class="headerlink" title="http 缓存？"></a>http 缓存？</h2><ul>
<li><p>强制缓存</p>
<ul>
<li><img src="/images/md_img/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98.png" alt="强制缓存"></li>
<li>强制缓存过期后会去服务端重新请求</li>
</ul>
</li>
<li><p>协商缓存</p>
<ul>
<li>服务端缓存策略</li>
<li>服务端判断客户端资源，是否和服务端资源一样</li>
<li>一致则返回 304，否则返回 200 和最新的资源</li>
<li>在 Response Headers 中，有两种：<ul>
<li>Last-Modified 资源的最后修改时间<ul>
<li><img src="/images/md_img/last_modified.png" alt="last_modified"></li>
</ul>
</li>
<li>Etag 资源的唯一标识<ul>
<li><img src="/images/md_img/etag.png" alt="etag"></li>
</ul>
</li>
</ul>
</li>
<li><img src="/images/md_img/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png" alt="协商缓存"></li>
<li>Last-Modified 和 Etag<ul>
<li>会优先使用 Etag</li>
<li>Last-Modified 只能精确到秒级</li>
<li>如果资源被重复生成，而内容不变，则 Etag 更精确</li>
</ul>
</li>
</ul>
</li>
<li><p>综述</p>
<ul>
<li><img src="/images/md_img/http%E7%BC%93%E5%AD%98.png" alt="http缓存"></li>
</ul>
</li>
</ul>
<h2 id="刷新操作对缓存的影响？"><a href="#刷新操作对缓存的影响？" class="headerlink" title="刷新操作对缓存的影响？"></a>刷新操作对缓存的影响？</h2><ul>
<li>正常操作：地址输入 url，跳转链接，前进后退等<ul>
<li>强制缓存有效，协商缓存有效</li>
</ul>
</li>
<li>手动刷新：F5，点击刷新按钮，右击菜单刷新<ul>
<li>强制缓存失效，协商缓存有效</li>
</ul>
</li>
<li>强制刷新：ctrl + F5<ul>
<li>强制缓存失效，协商缓存失效</li>
</ul>
</li>
</ul>
<h2 id="访问浏览器网页过程？"><a href="#访问浏览器网页过程？" class="headerlink" title="访问浏览器网页过程？"></a>访问浏览器网页过程？</h2><ul>
<li><p>加载过程</p>
<ul>
<li>DNS 解析：域名-&gt;IP 地址</li>
<li>浏览器根据 IP 地址 axing 服务器发起 http 请求</li>
<li>服务器处理 http 请求，并返回给浏览器</li>
</ul>
</li>
<li><p>渲染过程</p>
<ul>
<li>根据 HTML 代码生成 DOM Tree</li>
<li>根据 CSS 代码生成 CSSOM 树</li>
<li>将 DOM Tree 和 CSSOM 整合成 Render Tree</li>
<li>根据 Render Tree 渲染页面</li>
<li>遇到 script 标签则停止渲染，优先加载并执行 js 代码，完成再继续</li>
<li>直至把 Render Tree 渲染完成</li>
</ul>
</li>
</ul>
<h2 id="为何要将-css-文件放在-head-标签中呢？"><a href="#为何要将-css-文件放在-head-标签中呢？" class="headerlink" title="为何要将 css 文件放在 head 标签中呢？"></a>为何要将 css 文件放在 head 标签中呢？</h2><ul>
<li>css 放在 body 标签尾部时，DOMTree 构建完成之后便开始构建 RenderTree，并计算布局渲染网页，等加载解析完 css 之后，开始构建 CSSOMTree，并和 DOMTree 重新构建 RenderTree，重新计算布局渲染网页</li>
<li>css 放在 head 中，先加载 css，之后解析 css 构建 CSSOMTree，同时构建 DOMTree，CSSOMTree 和 DOMTree 都构建完成之后开始构建 Render Tree，计算布局网页</li>
<li>两者对比，css 放在 head 中比放在 body 标签尾部少了一次构建 RenderTree，一次计算布局和一次渲染网页，因此性能会更好，并且 css 放在 body 标签尾部会在网页中短暂出现裸奔的 html，不利于用户体验</li>
</ul>
<h2 id="为什么建议把-script-标签放在-body-最后？"><a href="#为什么建议把-script-标签放在-body-最后？" class="headerlink" title="为什么建议把 script 标签放在 body 最后？"></a>为什么建议把 script 标签放在 body 最后？</h2><ul>
<li>js 的下载和执行会阻塞 DOMTree 的构建，即会中断 DOMTree 的更新，所以如果把 script 标签放在首屏范围内的 HTML 代码中会截断首屏的内容。</li>
<li>普通 script 标签放在 body 底部，做与不做 async 或者 defer 处理都不会影响首屏时间，但是会影响 DomContentLoad 和 load 的时间，进而影响依赖他们的代码的执行的开始时间</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 页面的全部资源加载完成后才会执行，包括图片、视频等</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// DOM 渲染完成后即可执行，此时图片、视频可能还没有加载完</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li>性能优化原则<ul>
<li>多使用内存、缓存</li>
<li>减少 CUP 计算，减少网络加载耗时</li>
<li>适用于所有变成的性能优化-空间换时间</li>
</ul>
</li>
<li>从何入手<ul>
<li>让加载更快<ul>
<li>减少资源体积：压缩代码</li>
<li>减少访问次数：合并代码，SSR 服务器渲染，缓存，精灵图<ul>
<li>缓存（webpack contenthash）<ul>
<li>静态资源加 hash 后缀，根据文件内容计算 hash</li>
<li>文件内容不变，则 hash 不变则 url 不变</li>
<li>url 和文件不变，则会自动触发 http 的缓存机制，返回 304</li>
</ul>
</li>
<li>SSR<ul>
<li>服务器端渲染：将网页和数据一起加载，一起渲染</li>
<li>非 SSR（前后端分离）：先加载网页，后加载数据，再渲染数据</li>
</ul>
</li>
</ul>
</li>
<li>使用更快的网络：CDN</li>
</ul>
</li>
<li>让渲染更快<ul>
<li>css 放在 head，js 放在 body 最下面</li>
<li>尽早开始执行 js，用 DOMContentLoaded 触发</li>
<li>懒加载（图片懒加载，下滑更多等）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img id=<span class="string">&quot;img&quot;</span> src=<span class="string">&quot;preview.png&quot;</span> data-realsrc=<span class="string">&quot;abc.png&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;img&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  img.<span class="property">src</span>=img.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-realsrc&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>对 DOM 查询进行缓存</li>
<li>合并频繁的 DOM 操作,document.createDocumentFragment()</li>
<li>节流 throttle、防抖 debounce</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>XSS 跨站请求攻击<ul>
<li>攻击方式<ul>
<li>一个博客网站，我发表一篇博客，其中嵌入 script 脚本</li>
<li>脚本内容：获取 cookie，发送到我的服务器</li>
<li>发布这篇博客，有人查看，就可以回去到访问者的 cookie</li>
</ul>
</li>
<li>预防方式<ul>
<li>替换特殊字符</li>
</ul>
</li>
</ul>
</li>
<li>XSRF 跨站请求伪造<ul>
<li>预防<ul>
<li>增加验证，例如密码、短信验证、指纹等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ES6-新增的声明方式"><a href="#ES6-新增的声明方式" class="headerlink" title="ES6 新增的声明方式"></a>ES6 新增的声明方式</h2><ul>
<li>let、const<ul>
<li>不属于顶层对象 window</li>
<li>不允许重复声明</li>
<li>不存在变量提升</li>
<li>暂时性死区（不能在变量声明之前去使用）</li>
<li>块级作用域</li>
</ul>
</li>
</ul>
<h2 id="定制化输出特定数组"><a href="#定制化输出特定数组" class="headerlink" title="定制化输出特定数组"></a>定制化输出特定数组</h2><ul>
<li>随机生成一个长度为 10 的整数类型的数据</li>
<li>例如 [2, 10, 3, 35, 5, 11, 10, 11, 20]</li>
<li>将其排列成一个新数组，要求新数组形式如下：</li>
<li>[[2, 3, 5], [10, 11],[20],[35]]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获取随机数 0-99</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRandomNumber</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">  min = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(min);</span><br><span class="line">  max = <span class="title class_">Math</span>.<span class="title function_">floor</span>(max);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">() =&gt;</span> <span class="title function_">getRandomNumber</span>(<span class="number">0</span>, <span class="number">99</span>));</span><br><span class="line"><span class="comment">// 2. 去重(没必要)</span></span><br><span class="line">arr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"><span class="comment">// 3. 排序</span></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="comment">// 4. 存储 0-9 10-19 20-29</span></span><br><span class="line"><span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> key = <span class="title class_">Math</span>.<span class="title function_">floor</span>(item / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!map[key]) &#123;</span><br><span class="line">    map[key] = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map[key].<span class="title function_">push</span>(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> map) &#123;</span><br><span class="line">  result.<span class="title function_">push</span>(map[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure>

<h2 id="将树状结构转换为属性平铺的结构"><a href="#将树状结构转换为属性平铺的结构" class="headerlink" title="将树状结构转换为属性平铺的结构"></a>将树状结构转换为属性平铺的结构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目</span></span><br><span class="line"><span class="keyword">const</span> entry = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">      <span class="attr">c</span>: &#123;</span><br><span class="line">        <span class="attr">dd</span>: <span class="string">&quot;abcdd&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">d</span>: &#123;</span><br><span class="line">      <span class="attr">ee</span>: <span class="string">&quot;adee&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">f</span>: <span class="string">&quot;af&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = &#123;</span><br><span class="line">  <span class="string">&quot;a.b.c.dd&quot;</span>: <span class="string">&quot;abcdd&quot;</span>,</span><br><span class="line">  <span class="string">&quot;a.d.ee&quot;</span>: <span class="string">&quot;adee&quot;</span>,</span><br><span class="line">  <span class="string">&quot;a.f&quot;</span>: <span class="string">&quot;af&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解答</span></span><br><span class="line"><span class="comment">// 方法1: 递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatObj</span>(<span class="params">obj, preKey = <span class="string">&quot;&quot;</span>, result = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> newKey = <span class="string">`<span class="subst">$&#123;preKey&#125;</span><span class="subst">$&#123;key&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">flatObj</span>(obj[key], <span class="string">`<span class="subst">$&#123;newKey&#125;</span>.`</span>, result);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[newKey] = obj[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2: while循环-队列</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatObj2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj);</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [key, value] = queue.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [k, v] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>([<span class="string">`<span class="subst">$&#123;key&#125;</span>.<span class="subst">$&#123;k&#125;</span>`</span>, v]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[<span class="string">`<span class="subst">$&#123;key&#125;</span>.<span class="subst">$&#123;k&#125;</span>`</span>] = v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="title function_">flatObj</span>(entry);</span><br><span class="line"><span class="title function_">flatObj2</span>(entry);</span><br></pre></td></tr></table></figure>

<h2 id="将平铺属性的数据结构转换为树状数据结构"><a href="#将平铺属性的数据结构转换为树状数据结构" class="headerlink" title="将平铺属性的数据结构转换为树状数据结构"></a>将平铺属性的数据结构转换为树状数据结构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目</span></span><br><span class="line"><span class="keyword">const</span> entry = &#123;</span><br><span class="line">  <span class="string">&quot;a.b.c.dd&quot;</span>: <span class="string">&quot;abcdd&quot;</span>,</span><br><span class="line">  <span class="string">&quot;a.d.ee&quot;</span>: <span class="string">&quot;adee&quot;</span>,</span><br><span class="line">  <span class="string">&quot;a.f&quot;</span>: <span class="string">&quot;af&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">      <span class="attr">c</span>: &#123;</span><br><span class="line">        <span class="attr">dd</span>: <span class="string">&quot;abcdd&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">d</span>: &#123;</span><br><span class="line">      <span class="attr">ee</span>: <span class="string">&quot;adee&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">f</span>: <span class="string">&quot;af&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 答案</span></span><br><span class="line"><span class="comment">// 方法1: 双重循环</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> entry) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = entry[key];</span><br><span class="line">    <span class="keyword">const</span> keyMap = key.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result[keyMap[<span class="number">0</span>]]) &#123;</span><br><span class="line">      result[keyMap[<span class="number">0</span>]] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tmp = result[keyMap[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">let</span> length = keyMap.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!tmp[keyMap[i]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === length - <span class="number">1</span>) &#123;</span><br><span class="line">          tmp[keyMap[i]] = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          tmp[keyMap[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      tmp = tmp[keyMap[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2: 递归</span></span><br><span class="line"><span class="comment">// &#123;&quot;a.b.c.dd&quot;: &quot;abcdd&quot;&#125;</span></span><br><span class="line"><span class="comment">// =&gt; &#123;&quot;a.b.c&quot;: &#123;&quot;dd&quot;:&quot;abcdd&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment">// =&gt;...</span></span><br><span class="line"><span class="comment">// =&gt; &#123;&quot;a&quot;: &#123;&quot;b&quot;: &#123;&quot;c&quot;: &#123;&quot;dd&quot;: &quot;abcdd&quot;&#125;&#125;&#125;&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">map2</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getNest</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> lastIndex = key.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> value = entry[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastIndex !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> entry[key];</span><br><span class="line">      <span class="keyword">const</span> preKey = key.<span class="title function_">substring</span>(<span class="number">0</span>, lastIndex);</span><br><span class="line">      <span class="keyword">const</span> restKey = key.<span class="title function_">substring</span>(lastIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!entry[preKey]) &#123;</span><br><span class="line">        entry[preKey] = &#123; [restKey]: value &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry[preKey][restKey] = value;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/./</span>.<span class="title function_">test</span>(preKey)) &#123;</span><br><span class="line">        <span class="title function_">getNest</span>(preKey);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> entry) &#123;</span><br><span class="line">    <span class="title function_">getNest</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">map</span>(entry);</span><br><span class="line"><span class="title function_">map2</span>(entry);</span><br></pre></td></tr></table></figure>

<h2 id="react-自定义封装不会反复创建的定时器（setInterval）"><a href="#react-自定义封装不会反复创建的定时器（setInterval）" class="headerlink" title="react 自定义封装不会反复创建的定时器（setInterval）"></a>react 自定义封装不会反复创建的定时器（setInterval）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useTimer</span> = (<span class="params">step = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> timeout = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setNum</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num + <span class="number">1</span>);</span><br><span class="line">    &#125;, step * <span class="number">1000</span>);</span><br><span class="line">    timer.<span class="property">current</span> = timeout;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">clear</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setNum</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer.<span class="property">current</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    num,</span><br><span class="line">    start,</span><br><span class="line">    clear,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="修改下面代码，顺序输出-0-99"><a href="#修改下面代码，顺序输出-0-99" class="headerlink" title="修改下面代码，顺序输出 0-99"></a>修改下面代码，顺序输出 0-99</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求：</span></span><br><span class="line"><span class="comment">// 1. 只能修改 setTimeout</span></span><br><span class="line"><span class="comment">// 2. 不能修改Math.floor(Math.random() * 1000)</span></span><br><span class="line"><span class="comment">// 3. 不能使用全局变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">  &#125;, <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">print</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 答案</span></span><br><span class="line"><span class="comment">// 方法1: 立即执行函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">    &#125;)(),</span><br><span class="line">    <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">print</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法1: setTimeout第三个参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">10</span>,</span><br><span class="line">    <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">print</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-循环和-splice-的坑"><a href="#for-循环和-splice-的坑" class="headerlink" title="for 循环和 splice 的坑"></a>for 循环和 splice 的坑</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for循环和splice的坑</span></span><br><span class="line"><span class="comment">// 具体描述：在对一个数组执行for循环时，</span></span><br><span class="line"><span class="comment">// 删除数组元素，会存在什么问题</span></span><br><span class="line"><span class="comment">// 方法1: i--</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] === <span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">    arr.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">    i--; <span class="comment">// 需要处理下 i--</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2: 倒序</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] === <span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">    arr.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for...in</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[index] === <span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">    arr.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    index--; <span class="comment">// 仍然会有问题</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<h2 id="持续更新中…"><a href="#持续更新中…" class="headerlink" title="持续更新中…"></a>持续更新中…</h2>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之特性</title>
    <url>/2019/08/29/Node.js%E4%B9%8B%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="Node-js-是什么"><a href="#Node-js-是什么" class="headerlink" title="Node.js 是什么?"></a>Node.js 是什么?</h3><span id="more"></span>

<ul>
<li>Node.js 是一个 JavaScript 运行时环境，可以解析和执行 js 代码。</li>
<li>构建于 Chrome 的 V8 引擎之上</li>
<li>没有 BOM、DOM，有 EcmaScript 语法。</li>
<li>node 中有很多具名的核心模块<ul>
<li>fs 文件操作模块</li>
<li>http 服务器构建模块</li>
<li>path 路径模块</li>
<li>os 操作系统信息模块</li>
</ul>
</li>
<li>在核心模块中提供了一些服务器级别的操作 API - 文件读写 - 网络服务的构建 - 网络通信 - http 服务器<!--more--></li>
</ul>
<h3 id="node-都有哪些特性？"><a href="#node-都有哪些特性？" class="headerlink" title="node 都有哪些特性？"></a>node 都有哪些特性？</h3><ul>
<li><p>单线程</p>
<ul>
<li>不会为每个用户连接创建一个新的线程，仅仅使用一个线程，减少了操作系统的线程创建<br>和销毁的时间开销。缺点就是一个用户造成线程的崩溃会导致整个服务的崩溃。</li>
<li>减少内存的开销</li>
</ul>
</li>
<li><p>事件驱动 event-driven</p>
<ul>
<li>node 中一个时刻只能执行一个事件回调函数，但是执行过程中，可以转而处理<br>其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。</li>
</ul>
</li>
<li><p>非阻塞 I/O</p>
<ul>
<li>I/O 数据传输操作会阻塞代码的执行，极大降低了程序的执行效率,因为一个线程只能处理<br>一项任务，要想提高吞吐量必须通过多线程。非阻塞 I/O 机制，可以将异步操作的处理<br>代码放在回调函数中，从而提高了程序的执行效率。</li>
</ul>
</li>
</ul>
<h3 id="浏览器的进程和线程"><a href="#浏览器的进程和线程" class="headerlink" title="浏览器的进程和线程"></a>浏览器的进程和线程</h3><ul>
<li>一个程序可以有多个进程</li>
<li>一个进程可以有多个线程</li>
<li>进程在执行 u 欧城中拥有独立的内存单元，而多个线程共享内存。</li>
<li>多个线程之间可以相互通信</li>
<li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口</li>
<li>线程不能独立执行，必须依存在应用程序中</li>
</ul>
<h3 id="Node-js-适合开发什么？"><a href="#Node-js-适合开发什么？" class="headerlink" title="Node.js 适合开发什么？"></a>Node.js 适合开发什么？</h3><ul>
<li>善于 I/O,不善于计算，因为 Node.js 最擅长的就是任务调度，不适合于利用 CPU 进行过多的运算的程序。</li>
<li>当应用程序需要处理大量并发的 I/O,而在向客户端发出响应之前，应用程序内部不需要<br>进行非常复杂处理的时候，Node.js 非常合适。</li>
<li>Node.js 也非常适合与 web socket 配合，开发长连接的实时交互应用程序。<ul>
<li>用户表单</li>
<li>考试系统</li>
<li>聊天室</li>
<li>图文直播</li>
</ul>
</li>
</ul>
<h3 id="nodejs-能做什么？"><a href="#nodejs-能做什么？" class="headerlink" title="nodejs 能做什么？"></a>nodejs 能做什么？</h3><ul>
<li>Node.js 可以生成动态页面内容</li>
<li>Node.js 可以创建，打开，读取，写入，删除和关闭服务器上的文件</li>
<li>Node.js 可以收集表单数据</li>
<li>Node.js 可以添加，删除，修改数据库中的数据</li>
</ul>
<h3 id="服务端渲染和客户端渲染的区别"><a href="#服务端渲染和客户端渲染的区别" class="headerlink" title="服务端渲染和客户端渲染的区别"></a>服务端渲染和客户端渲染的区别</h3><ul>
<li>客户端渲染不利于 SEO 搜索引擎优化</li>
<li>服务器渲染可以被爬虫抓取</li>
<li>例如：京东商品列表是服务端渲染，用户评论是客户端渲染（提高用户体验）</li>
</ul>
<h4 id="小补充：使用-cnpm"><a href="#小补充：使用-cnpm" class="headerlink" title="小补充：使用 cnpm"></a>小补充：使用 cnpm</h4><ul>
<li><p>方法一 安装 cnpm</p>
<ul>
<li><code>npm install --global cnpm</code></li>
</ul>
</li>
<li><p>方法二 改变 registry</p>
<ul>
<li><code>npm install jquery --registry=https://registry.npm.taobao.org</code></li>
</ul>
</li>
<li><p>方法三 加入配置选项</p>
<ul>
<li><code>npm config set registry https://registry.npm.taobao.org</code></li>
<li><code>npm config list</code></li>
</ul>
</li>
</ul>
<h2 id="用-nodejs-实现读取文件操作"><a href="#用-nodejs-实现读取文件操作" class="headerlink" title="用 nodejs 实现读取文件操作"></a>用 nodejs 实现读取文件操作</h2><!--more-->

<pre><code> const fs = require(&quot;fs&quot;)

//fs 核心模块提供了一个fs.readFile方法，用来读取指定目录下的文件

//fs.readFile有三个参数
// 1. 读取文件的路径
// 2. 读取文件的编码格式
// 3. 当文件读取完成，调用这个callback回调函数来读取文件的结果

fs.readFile(&#39;./data/hello.txt&#39;,&#39;utf-8&#39;,function(err,data)&#123;
    if(err)&#123;
        console.log(err)    //第一个参数是err对象
        return
    &#125; else &#123;
        console.log(data)   //第二个参数才是data数据
    &#125;
&#125;)
</code></pre>
<h2 id="用-nodejs-实现写入文件操作"><a href="#用-nodejs-实现写入文件操作" class="headerlink" title="用 nodejs 实现写入文件操作"></a>用 nodejs 实现写入文件操作</h2><pre><code>const fs = require(&#39;fs&#39;)

let msg = &#39;hello world&#39;

//fs.writeFile有三个参数
// 1. 第一个参数为写入的文件路径
// 2. 第二个参数为写入的内容
// 3. 第三个参数为可选参数，表示写文件的编码格式
// 4. 第四个参数为回调函数，回调函数只有一个参数err，判断是否写入成功。

fs.writeFile(&#39;./data/hello.txt&#39;,msg,&#39;utf-8&#39;,function(err)&#123;
    if(err)&#123;
        console.log(&#39;写入错误&#39; + err)
    &#125; else &#123;
        console.log(&#39;ok&#39;)
    &#125;
&#125;)
</code></pre>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex &amp; Redux工作流程</title>
    <url>/2019/09/18/Vuex-Redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Vue-核心原理"><a href="#Vue-核心原理" class="headerlink" title="Vue 核心原理"></a>Vue 核心原理</h2><span id="more"></span>

<img src="https://raw.githubusercontent.com/foolishmax/static/master/images/vuex.png" width="450" />

<ul>
<li><p>Store : 统一的状态管理容器对象</p>
</li>
<li><p>Vue Components : Vue 组件</p>
</li>
<li><p>dispatch : 操作行为触发方法，是唯一能执行 action 的方法</p>
</li>
<li><p>actions : 操作行为处理模块。 负责处理 Vue Components 接收的所有交互行为，</p>
</li>
<li><p>commit : 状态改变提交操作方法，对 mutation 进行提交，是唯一能执行 mutation<br>的方法</p>
</li>
<li><p>mutation : 状态改变操作方法，Vuex 中修改 state 的唯一推荐方法，该方法只能<br>进行同步操作</p>
</li>
<li><p>getter : state 对象读取方法，类似 computed 计算属性。</p>
</li>
</ul>
<blockquote>
<p>过程：Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要<br>改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，<br>重新渲染 Vue Components，界面随之更新。</p>
</blockquote>
<h2 id="Redux-核心原理"><a href="#Redux-核心原理" class="headerlink" title="Redux 核心原理"></a>Redux 核心原理</h2><img src="https://raw.githubusercontent.com/foolishmax/static/master/images/redux.png" width="450" />

<ul>
<li><p>只使用 redux，流程是这样的：</p>
<blockquote>
<p>component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component</p>
</blockquote>
</li>
<li><p>使用 react-redux 之后，流程是这样的：</p>
<blockquote>
<p>component –&gt; actionCreator(data) –&gt; reducer –&gt; component</p>
</blockquote>
</li>
</ul>
<p>store 的三大功能：dispatch,subscribe,getState 都不需要手动来写了，react-redux 帮我们<br>做了这些，同时提供了 Provider 和 connect</p>
<ul>
<li><p>注意点:</p>
<ul>
<li>store 是唯一的</li>
<li>只有 store 能够改变自己的内容</li>
<li>reducer 必须是一个纯函数（给定固定的输入，一定会有固定的输出，不会产生副作用）</li>
</ul>
</li>
<li><p>核心 API</p>
<ul>
<li>createStore(reducer)<ul>
<li>创建 store，并将 reducer 传递给 store</li>
</ul>
</li>
<li>store.dispatch(action)<ul>
<li>创建 action 之后，负责将 action 传给 store</li>
<li>action 是一个对象形式，会包含 Type(告诉 store 要做的事情)、Value(参数结果)</li>
</ul>
</li>
<li>store.getState()<ul>
<li>获取 store 内容</li>
</ul>
</li>
<li>store.subscribe()<ul>
<li>订阅 store 改变，只要 store 发生改变，其中的回调函数就会被执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Vuex-和-Redux-的区别？"><a href="#Vuex-和-Redux-的区别？" class="headerlink" title="Vuex 和 Redux 的区别？"></a>Vuex 和 Redux 的区别？</h2><ul>
<li><p>都是状态管理系统，除了具备床柜的状态管理的功能之外，也针对自身框架进行一些优化特性。</p>
</li>
<li><p>状态注入组件：</p>
<ul>
<li>React-Redux: 通过<code>&lt;Provider/&gt;</code>组件拿到 store 之后，还需要显示指定容器组件，<br>即用 connect 包装一下该组件。</li>
<li>Vue 通过 Vue.use(Vuex)将 vuex 应用为全局的插件，将 store 传入跟实例，就可以<br>使得 store 对象运行在任何 vue 组件中。</li>
</ul>
</li>
<li><p>vuex 借鉴 redux，通过弱化概念（action、reducer），弱化了 dispatch 的存在感，<br>任何东西都没做实质性消减，但同时使得整套框架更加易于理解了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>vue基础知识</title>
    <url>/2019/07/29/Vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="vue-的特点（优点）"><a href="#vue-的特点（优点）" class="headerlink" title="vue 的特点（优点）"></a>vue 的特点（优点）</h4><span id="more"></span>

<ul>
<li>vue 关注视图层，用数据操作的方式代替了 dom 操作</li>
<li>vue 通过响应式的数据绑定实现了数据和视图之间的更新交互</li>
<li>vue 通过组件化开发让工程结构更加明确，更易于维护</li>
<li>vue 通过虚拟 DOM，优化了 DOM 操作，实现了性能提高</li>
<li>vue 拥有自己的 vue-cli 脚手架工具，对良好的工程化性能</li>
</ul>
<h4 id="Vue-的双向数据绑定原理是什么？"><a href="#Vue-的双向数据绑定原理是什么？" class="headerlink" title="Vue 的双向数据绑定原理是什么？"></a>Vue 的双向数据绑定原理是什么？</h4><pre><code>vue.js 是采用 数据劫持 结合 发布-订阅者 模式的方式，通过Object.defineProperty()
来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：
1.当把一个普通JavaScript对象传给Vue实例当作它的data选项的时候，Vue会遍历它的属性，
用Object.defineProperty劫持各个属性的setter、getter，给这个对象的某一个值赋值，
就会触发setter，就能监听到数据的变化
2. compile解析模板指令，将模板中的变量替换成数据，然后渲染页面视图，并将每个指令对应的
节点添加监听数据的订阅者Watcher，一旦数据由变动，收到通知更新视图
3. 通过Observer来监听model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭
起Observer和Compile之间的桥梁，达到数据变化-&gt;视图更新，视图变化-&gt;数据更新。
</code></pre>
<!--more-->

<h4 id="Proxy-与-Object-defineProperty-优劣对比？"><a href="#Proxy-与-Object-defineProperty-优劣对比？" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比？"></a>Proxy 与 Object.defineProperty 优劣对比？</h4><ul>
<li>Proxy 的优势如下：<ul>
<li>Proxy 可以监听对象，而 Object.defineProperty 只能监听属性。</li>
<li>Proxy 还可以直接监听数组的变化。</li>
<li>Proxy 有多大 13 种的拦截方法，不限于 apply、ownKeys、deletePreperty 等，这些<br>都是 Object.defineProperty 不具备的。</li>
<li></li>
</ul>
</li>
<li>Object.defineProperty 的优势：<ul>
<li>兼容性好，支持 IE9，而 Proxy 存在浏览器兼容问题。</li>
</ul>
</li>
</ul>
<h4 id="解释单向数据流和双向数据绑定"><a href="#解释单向数据流和双向数据绑定" class="headerlink" title="解释单向数据流和双向数据绑定"></a>解释单向数据流和双向数据绑定</h4><pre><code>单向数据流： 数据流是单向的，数据流动方向可以追踪，流动单一，追查问题可以更加方便快捷，
缺点就是写起来不太方便，要是UI发生变更就必须创建各种action来维护对应的state

双向数据绑定： 数据之间是相同的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的
场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，添加了出错debug的难度
</code></pre>
<h4 id="请详细说下你对-Vue-生命周期的理解？"><a href="#请详细说下你对-Vue-生命周期的理解？" class="headerlink" title="请详细说下你对 Vue 生命周期的理解？"></a>请详细说下你对 Vue 生命周期的理解？</h4><pre><code>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后

    beforeCreate 创建前执行（vue实例的挂载元素$el和数据对象data都为undefined，还未初始化）

    created 完成创建 （完成了data数据初始化，el还未初始化）

    beforeMount 载入前（vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。）

    mounted 载入后html已经渲染(vue实例挂载完成，data.message成功渲染。)

    beforeUpdate 更新前状态（view层的数据变化前，不是data中的数据改变前）

    updated 更新状态后

    beforeDestroy 销毁前

    destroyed 销毁后 （在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在）


说一下每一个阶段可以做的事情

    beforeCreate:可以在这里加一个loading事件，在加载实例时触发。

    created: 初始化完成时的事件写这里，如果这里结束了loading事件，异步请求也在这里调用。

    mounted: 挂载元素，获取到DOM节点

    updated: 对数据进行处理的函数写这里。

    beforeDestroy: 可以写一个确认停止事件的确认框。
</code></pre>
<h4 id="vue-router-有哪几种导航钩子？"><a href="#vue-router-有哪几种导航钩子？" class="headerlink" title="vue-router 有哪几种导航钩子？"></a>vue-router 有哪几种导航钩子？</h4><pre><code>三种

1. 全局导航钩子（跳转前进行判断拦截）

    + to: Route:即将要进入的目标 路由对象
    + from: Route:当前导航正要离开的路由
    + next: Function: 一定要调用该方法来resolve这个钩子，执行结果依赖于next方法的调用参数
        - next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。

        - next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。

        - next(&#39;/&#39;) 或者 next(&#123; path: &#39;/&#39; &#125;): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。

        - next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。


    router.beforeEach(to, from, next),  //全局前置守卫

    router.beforeResolve(to, from, next),   //全局解析守卫，在 2.5.0+
    你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach
    类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，
    解析守卫就被调用。

    router.afterEach(to, from )    //全局后置守卫，钩子不会接受 next 函数也不会改变导航本身

2. 组件内钩子

    beforeRouteEnter(to, from, next)    //跳转到这个组件时

    beforeRouteUpdate(to, from, next)   //当前路由改变，但是该组件被复用时调用

    beforeRouteLeave(to, from, next)    //离开这个组件时

3. 单独路由独享组件
    用法同全局守卫，只是将其写进其中一个路由对象中，只在这个路由下起作用。

    beforeEnter(to, from, next)


完整的导航解析流程：

    1. 导航被触发。
    2. 在失活的组件里调用离开守卫。
    3. 调用全局的 beforeEach 守卫。
    4. 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
    5. 在路由配置里调用 beforeEnter。
    6. 解析异步路由组件。
    7. 在被激活的组件里调用 beforeRouteEnter。
    8. 调用全局的 beforeResolve 守卫 (2.5+)。
    9. 导航被确认。
    10. 调用全局的 afterEach 钩子。
    11. 触发 DOM 更新。
    12. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
</code></pre>
<h4 id="动态路由定义和获取？"><a href="#动态路由定义和获取？" class="headerlink" title="动态路由定义和获取？"></a>动态路由定义和获取？</h4><pre><code>在 router 目录下的 index.js 文件中，对 path 属性加上 /:id。

使用 router 对象的 params.id 获取
</code></pre>
<h4 id="key-值的作用？"><a href="#key-值的作用？" class="headerlink" title="key 值的作用？"></a>key 值的作用？</h4><pre><code>key是为了高效的实现DOM渲染。
</code></pre>
<h4 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h4><pre><code>1.v-bind绑定一个value属性，监听message
2.v-on指令给当前元素绑定input事件
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--等价于下面--&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot;</span><br><span class="line">    v-bind:value=&quot;message&quot;</span><br><span class="line">    v-on:input=&quot;message=$event.target.value&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-model-修饰符"><a href="#v-model-修饰符" class="headerlink" title="v-model 修饰符"></a>v-model 修饰符</h4><ul>
<li><p>1.lazy 修饰符</p>
<ul>
<li>1.1 默认情况下，v-model 默认是在 input 事件中同步输入框的数据的</li>
<li>1.2 一旦有数据发生改变对应的 data 中的数据就会自动发生改变</li>
<li>1.3 lazy 是修饰符可以让数据在失去焦点或者回车时才会更新</li>
</ul>
</li>
<li><p>2.number 修饰符</p>
<ul>
<li>2.1 默认情况下，在输入框中我们输入数字还是字母，都会被当作字符串类型进行处理</li>
<li>2.2 但是如果我们希望处理的是是数字类型，那么最好直接将内容当作数字处理</li>
<li>2.3 number 修饰符可以让输入框中输入的内容自动转成数字类型</li>
</ul>
</li>
<li><p>3.trim 修饰符（移除的字符包括空格、行终止符、制表符、换行符、回车符、换页符等）</p>
<ul>
<li>如果输入的内容首尾有很多空格，通常我们希望将其去除</li>
<li>trim 修饰符可以过滤内容左右两边的空格</li>
<li>补充：str.replace(/\s/g, “”); //去除字符串所有空格</li>
</ul>
</li>
</ul>
<h4 id="v-on-修饰符"><a href="#v-on-修饰符" class="headerlink" title="v-on 修饰符"></a>v-on 修饰符</h4><ul>
<li><p>.stop 调用 event.stopPropagation()</p>
</li>
<li><p>.prevent 调用 event.preventDefault()</p>
</li>
<li><p>.{keyCode|keyAlias} 只当事件是从特定键触发时才触发回调</p>
</li>
<li><p>.native 监听组件根元素的原生事件</p>
</li>
<li><p>.once 只能触发一次回调</p>
</li>
</ul>
<h4 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set"></a>Vue.set</h4><pre><code>//Vue中不允许动态添加根级别的响应式属性，Vue.set方法可以向嵌套对象添加
响应式属性。
//参数一：要修改的对象
//参数二：索引值
//参数三：修改后的值

Vue.set(vm.obj, 2, &#39;b&#39;)
vm.$set(vm.obj, 2, &#39;b&#39;)
</code></pre>
<h4 id="vue-router-使用-params-与-query-传参有什么区别？"><a href="#vue-router-使用-params-与-query-传参有什么区别？" class="headerlink" title="vue-router 使用 params 与 query 传参有什么区别？"></a>vue-router 使用 params 与 query 传参有什么区别？</h4><pre><code>vue-router可以通过params与query进行传参
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//传递</span><br><span class="line">this.$router.push(&#123;path: &#x27;./xxx&#x27;, params: &#123;xx:xxx&#125;&#125;)</span><br><span class="line">this.$router.push(&#123;path: &#x27;./xxx&#x27;, query: &#123;xx:xxx&#125;&#125;)</span><br><span class="line"></span><br><span class="line">//接受</span><br><span class="line">this.$route.params</span><br><span class="line">this.$route.query</span><br></pre></td></tr></table></figure>

<ul>
<li><p>params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系</p>
</li>
<li><p>params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题</p>
</li>
</ul>
<h4 id="Vue-如何取出-URL-中的"><a href="#Vue-如何取出-URL-中的" class="headerlink" title="Vue 如何取出 URL 中的 #"></a>Vue 如何取出 URL 中的 <code>#</code></h4><pre><code>vue-router 默认使用hash模式，所以路由加载时候，项目中的url会自带#，如果不想使用#，可以使用
vue-router 的另一种模式history

new Router (&#123;
    mode: &#39;history&#39;,
    routes: []
&#125;)
</code></pre>
<h4 id="对-MVC、MVVM-的理解？"><a href="#对-MVC、MVVM-的理解？" class="headerlink" title="对 MVC、MVVM 的理解？"></a>对 MVC、MVVM 的理解？</h4><pre><code>1. MVC：所有的通信都是单向的

    View传送指令到Controller
    Controller 完成业务逻辑后，要求Model改变状态
    Model将新的数据发送到View，用户得到反馈

2.MVVM（类似MVP——Model View Presenter）

    View层：视图层
    Model层：数据层
    ViewModel层：视图模型层
        视图模型层时view和model沟通的桥梁
        一方面实现了Data Binding，数据绑定，将model的改变实时反应到view中
        另一方面实现了DOM Listener，也就是DOM监听，发生事件改变，改变对应的data

    一种前端架构模式，model为数据模型，view为视图UI层,view和model之间
    并没有直接的联系，通过viewmodel实现双向数据的绑定。各部分通信都是双向的
    因此开发者只需关注业务层，无需手动操作DOM，无需关心数据状态的同步问题，复杂
    的数据状态维护完全由MVVM来统一管理。
    采用双向数据绑定，View的变动自动反应在ViewModel，反之亦然
</code></pre>
<h4 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h4><pre><code>为什么需要虚拟DOM？

    浏览器加载一个HTML文件需要做那些事？
    创建DOM tree ——&gt; 创建CSS tree ——&gt; 构建Render tree ——&gt; 布局Layout ——&gt; 绘制Painting
    如果用传统的原生api或jQuery操作DOM时，浏览器会从构建DOM树开始从头到尾
    执行一边流程，就会浪费掉很多性能。

1. state数据

2.（JSX）模板

3. 数据 + 模板生成虚拟DOM（虚拟DOM就是一个JS对象，用来描述真实的DOM）

4. 用虚拟DOM的结构生成真实的DOM来显示

5. state数据发生改变

6. 数据 + 模板生成新的虚拟DOM

7. 比较原始虚拟DOM和新的虚拟DOM的区别，找到不同点
    通过diff算法，将不同的比较内容结果保存到本地的一个js对象中，最终一次性
    的将这个js对象attach应用到DOM树上，通知浏览器执行绘制工作，避免了大量的
    无畏计算。

8. 直接操作DOM，改变内容。
</code></pre>
<h4 id="nextTick-的应用场景"><a href="#nextTick-的应用场景" class="headerlink" title="nextTick 的应用场景"></a>nextTick 的应用场景</h4><pre><code>Vue.nextTick 用于延迟执行一段代码，它的回调函数会在DOM更新完成后调用。

在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调
函数中

在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于
徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。

原理：
        nextTick实际上就是创建一个新的宏任务，vue中双向绑定的数据赋值时需要调用
    watcher的update方法(比如某个div绑定了一个数据，那么该div就会生成一个
    watcher，而update的方法就是更新自身的innerHTML，当然中间还有一层虚拟DOM)，
    而watcher的update就是通过nextTick来执行的。
</code></pre>
<h4 id="Vue-组件中-data-为什么必须是函数？"><a href="#Vue-组件中-data-为什么必须是函数？" class="headerlink" title="Vue 组件中 data 为什么必须是函数？"></a>Vue 组件中 data 为什么必须是函数？</h4><pre><code>如果data是一个对象，那么 由于对象本身属于引用类型，当我们修改其中一个属性值的之后，
会影响到所有Vue实例的数据。如果将data作为一个函数返回一个对象，那么每一个实例的data
属性都是独立的，相互不会影响。例如：在同一个组件复用的时候，就类似给每个组件实例
创建了一个私有的数据空间，让各自的组件实例维护各自的数据。
</code></pre>
<h4 id="计算属性-computed、watch-和事件-methods-有什么区别？"><a href="#计算属性-computed、watch-和事件-methods-有什么区别？" class="headerlink" title="计算属性 computed、watch 和事件 methods 有什么区别？"></a>计算属性 computed、watch 和事件 methods 有什么区别？</h4><pre><code>computed： 计算属性是会基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时
才会重新求值。

computed属性有两个方法：set、get
`fullName: &#123;
    //赋值
    set: function(newValue)&#123;const names = newValue.split(&#39; &#39;);
    this.firstName = names[0];this.lastName = names[1];&#125;,//一般用不着,使用的时候有参数
    //取值
    get: function()&#123;return this.firstName + &#39; &#39; + this.lastName&#125;
&#125;
`

watch：更多的的是观察作用，类似于某些数据的监听回调，每当监听的数据变化时都
会执行相应的回调进行后续的操作。

method：不管数据是否改变，只要发生重新渲染，methods都会调用执行。
</code></pre>
<ul>
<li>运用场景：<ul>
<li>当需要进行数值计算，并且依赖于其他数据时，应该使用 computed，利用 computed 的<br>缓存特性，避免每次获取值时，都需要重新计算。</li>
<li>当需要在数据变化时执行异步或者开销较大的操作时，使用 watch。</li>
</ul>
</li>
</ul>
<h4 id="Vue-父子组件之间如何传值？"><a href="#Vue-父子组件之间如何传值？" class="headerlink" title="Vue 父子组件之间如何传值？"></a>Vue 父子组件之间如何传值？</h4><pre><code>父组件从后端获取数据，vue官方推荐使用axios来进行前后端交互，使用
axios.get(),返回一个Promise，然后用.then()在里面写个接收函数来接受返回值ret，
ret的返回值就可以对应的赋值给data里面定义的key-value值。

父传子： 在父组件中使用的子组件标签上通过 v-bind:xxx=&quot;&quot;,然后再回到子组件中，
通过props&#123;list: Array&#125;来接收从父组件传过来的值，接收的值就可以在子组件中使用，
这样就完成了将数据传输到子组件的全过程。

子传父： 子组件向父组件传值一般都是通过事件决定，例如click，当子组件上绑定
被点击事件触发时，可以在这个触发事件的函数中，使用vue自带的
this.$emit(&#39;父组件接收的事件名&#39;， 要传输的参数)，然后再父组件中使用的子组件
标签上通过 @事件名 = &#39;func&#39;，然后再父组件的method中补全这个func，然后func
中将从子组件中传递过来的值赋给父组件的data中，这样就完成了子组件向父组件传值了。

props 数据验证：

`不支持驼峰标识，驼峰需要改成 **-** 连接 的形式`

1.都支持哪数据类型?
    String、Number、Boolean、Array、Object、Date、Function、Symbol
2.props也支持自定义类型：
Vue.component(&#39;my-component&#39;, &#123;
    props: &#123;
        //基础类型检查（&#39;null&#39;匹配任何类型）
        propA: Number,
        //多个可能的值类型
        propB: [String, Number],
        //是否是必填的字符串
        propC: &#123;
            type: String,
            required: true
        &#125;,
        //带有默认值的数字
        propD: &#123;
            type: Number,
            default: 100
        &#125;,
        //对象或数组默认值必须从一个工厂函数获取
        propE: &#123;
            type: Object,
            default: function()&#123;
                return &#123;&#125;
            &#125;
            ========
            type: Array,
            default: function()&#123;
                return []
            &#125;
        &#125;,
        //自定义验证函数
        propF: &#123;
            validate: function(value)&#123;
                return [&#39;success&#39;,&#39;warning&#39;,&#39;danger&#39;].indexOf(value)!== -1
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<h4 id="为什么需要浅拷贝？"><a href="#为什么需要浅拷贝？" class="headerlink" title="为什么需要浅拷贝？"></a>为什么需要浅拷贝？</h4><pre><code>js变量的引用类型在进行复制操作的时候会复制地址，导致两个变量指向同一份数据。

在对一个对象进行操作并且不希望影响原对象的时候，应该先进行拷贝操作。
</code></pre>
<h4 id="父子组件的访问方式"><a href="#父子组件的访问方式" class="headerlink" title="父子组件的访问方式"></a>父子组件的访问方式</h4><ul>
<li><p>父组件访问子组件：</p>
<ul>
<li>$children ——用的比较少</li>
<li>$refs ——用的较多</li>
</ul>
</li>
<li><p>子组件访问父组件：</p>
<ul>
<li>$parent ——用的较少</li>
</ul>
</li>
<li><p>子组件访问根组件：</p>
<ul>
<li>$root ——用的较多</li>
</ul>
</li>
</ul>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><ul>
<li>插槽</li>
<li>具名插槽</li>
<li>作用域插槽：父组件替换插槽的标签，但是内容有子组件来提供。</li>
</ul>
<h4 id="keep-alive-遇见-vue-router"><a href="#keep-alive-遇见-vue-router" class="headerlink" title="keep-alive 遇见 vue-router"></a>keep-alive 遇见 vue-router</h4><ul>
<li><p>keep-alive 是 vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染</p>
<ul>
<li>两个重要的属性：</li>
<li>include - 字符串或正则表达，只有匹配的组件会被缓存</li>
<li>exclude - 字符串或正则表达，任何匹配的组件不会被缓存</li>
</ul>
</li>
<li><p>router-view 也是一个组件，如果直接被包在 keep-aive 里面，所有路径匹配的视图组件<br>都会被缓存。</p>
</li>
<li><p>对应两个钩子函数 activated 和 deactivated，当组件被激活时，触发 activated，组件<br>被移除时，触发 deactivated。</p>
</li>
</ul>
<h4 id="为什么选择-axios？"><a href="#为什么选择-axios？" class="headerlink" title="为什么选择 axios？"></a>为什么选择 axios？</h4><ul>
<li><p>axios：ajax i/o system(个人理解)</p>
</li>
<li><p>尤大 在 2016-11-3，公告以后 vue-resource 不再维护，官方推荐新的 ajax 库用 axios。</p>
</li>
<li><p>功能特点</p>
<ul>
<li>在浏览器中发送 XMLHttpRequest 请求</li>
<li>在 node.js 中发送 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="谈谈对-Vue-SSR-的理解"><a href="#谈谈对-Vue-SSR-的理解" class="headerlink" title="谈谈对 Vue SSR 的理解"></a>谈谈对 Vue SSR 的理解</h4><ul>
<li><p>SSR 大致的意思就是 vue 在客户端将标签渲染成的整个 html 片段的工作在服务端<br>完成，服务端形成 html 片段直接返回给客户端这个过程就交租服务端渲染。</p>
</li>
<li><p>服务端渲染 SSR 的优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具<br>并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面<br>通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面<br>（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</p>
</li>
<li><p>首屏加载更快：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开<br>始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；<br>SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，<br>所以 SSR 有更快的内容到达时间；</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个<br>钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中<br>运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA<br>不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</p>
</li>
<li><p>更多的服务器负载：更多的服务器负载：在 Node.js 中渲染完整的应用程序，<br>显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源<br>(CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic )<br>下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="你有对-Vue-项目进行哪些优化？"><a href="#你有对-Vue-项目进行哪些优化？" class="headerlink" title="你有对 Vue 项目进行哪些优化？"></a><a href="https://juejin.im/post/5d548b83f265da03ab42471d">你有对 Vue 项目进行哪些优化？</a></h4><ul>
<li><p>代码层面的优化：</p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>合理使用 computed 和 watch</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化(通过 Object.freeze 冻结一个对象，之后就不能修改了，避免了 Object<br>.defineProperty 对数据的劫持)</li>
<li>事件的销毁(在 js 中使用 addEventListener 等方式创建的事件不会自动销毁，需要手动<br>移除对这些事件的监听，避免造成内存泄漏)</li>
<li>图片资源懒加载(vue-lazyload 插件)</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
</li>
<li><p>Webpack 层面的优化</p>
<ul>
<li>webpack 对图片进行压缩</li>
<li>多个页面的公共代码抽离成单独的文件</li>
</ul>
</li>
<li><p>基础的 Web 技术优化</p>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB前端性能优化</title>
    <url>/2019/07/17/WEB%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="WEB-前端性能优化常见方法"><a href="#WEB-前端性能优化常见方法" class="headerlink" title="WEB 前端性能优化常见方法"></a>WEB 前端性能优化常见方法</h1><p>前端性能优化针对不用资源有不同的性能优化方式</p>
<span id="more"></span>

<ul>
<li><p>内容优化</p>
<pre><code>+ (1)减少HTTP请求数：因为一个完整的请求要经过    DNS寻址，与服务器建立连接，发送数据，
</code></pre>
<p>等待服务器响应，接受数据等消耗时间成本和资源成本的复杂过程。 - 常见解决方法： + 资源和并和压缩：合并多个 CSS 文件和 js 文件并使用相应的工具对 js、css、图片等进行压缩处理 + 雪碧图（精灵图）：减少请求数 + 合理设置 http 缓存：原则就是能缓存的越多越好，越久越好，通过 http header 中<br>设置 Expires 过期时间，或者 Last-Modifed 进行请求验证 + 减少 http 请求头、配置多个域名和 CDN 加速、使用缓存<br>（HTTP 缓存、浏览器缓存、应用缓存）、优化 cookie + （2）避免重定向：减少不必要的 http 跳转 + （3）延迟加载组件，预加载组件，图片懒加载 + （4）减少 DOM 元素数量：页面中存在大量 DOM 元素，会导致 JavaScript 遍历 DOM 的效率变慢。</p>
</li>
<li><p>服务器优化</p>
<ul>
<li>（1）使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度</li>
<li>（2）Gzip 压缩</li>
<li>（3）设置 ETag：ETags（Entity tags，实体标签）是 web 服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。</li>
<li>（4）提前刷新缓冲区</li>
<li>（5）避免空的图像 src</li>
</ul>
</li>
<li><p>Cookie 优化</p>
<ul>
<li>（1）减少 Cookie 的大小</li>
<li>（2）针对 Web 组件使用域名无关的 Cookie</li>
</ul>
</li>
<li><p>CSS 优化</p>
<ul>
<li>将 CSS 代码放在 HTML 页面的顶部</li>
<li>避免使用 CSS 表达式</li>
<li>使用<link>来代替@import</li>
<li>避免使用 Filters</li>
</ul>
</li>
<li><p>JavaScript 优化</p>
<ul>
<li>(1) 将 JavaScript 脚本放在页面的底部。</li>
<li>(2) 将 JavaScript 和 CSS 作为外部文件来引用：在实际应用中使用外部文件可以提高页面速度，因为 JavaScript 和 CSS 文件都能在浏览器中产生缓存。</li>
<li>(3) 最小化 DOM 的访问：使用 JavaScript 访问 DOM 元素比较慢。</li>
<li>(4) document.getElement…将获取到的元素长度提取出来</li>
<li>(5) 尽量减少会产生 reflow 和 repaint 的操作，因为它们都是需要消耗资源的</li>
<li>(6) 慎用 with，with 他会修改编译时的词法作用域，修改了执行环境，访问非局部属性的<br>时候，会从指定 obj 作用域上开始查找，相当于增长了作用域长度，而过长的作用域链会造成<br>查找性能下降。</li>
<li>(7) 慎用 eval 和 Function,需要 js 引擎将源代码转换成可执行代码，这是很消耗资源的操作，<br>同时，也不利于压缩工具进行压缩。</li>
<li>(8) 减少作用域链的查找，访问非本作用域下的变量，在循环遍历的时候使用局部变量缓存该变量，<br>遍历结束后再重写那个变量，尤其是全局变量处于作用域的最顶端，访问时查找次数最多</li>
</ul>
</li>
<li><p>图像优化</p>
<ul>
<li>(1)优化图片大小</li>
<li>（2）通过 CSS Sprites 优化图片</li>
<li>（3）不要在 HTML 中使用压缩图片</li>
<li>（4）favicon.ico 要小而且可缓存</li>
</ul>
</li>
<li><p>robots.txt<br>搜索引擎蜘蛛访问网站时会第一个访问 robots.txt 文件，robots.txt 用于指导搜索引擎<br>蜘蛛禁止抓取网站的某些内容和只允许抓取哪些内容，放在站点根目录。</p>
</li>
<li><p>dns-prefetch</p>
<ul>
<li><p><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.bootcss.com&quot;&gt;</code></p>
</li>
<li><p>使用 dns-prefetch 对项目中使用的域名进行 DNS 预解析，减少 DNS 查询。</p>
</li>
</ul>
</li>
<li><p>URL 优化<br>越短越好<br>避免太多参数<br>目录层次尽量少<br>文件及目录名具有描述性<br>字母全部小写<br>连词符使用-而不是_<br>URL 中包括关键字</p>
</li>
<li><p>TDK 优化<br>TDK 为 title，description，keywords 三个的统称。<br>title：分隔符一般有 ， - <em>,其中</em>对百度比较友好，-对谷歌比较友好，title 长度 pc 端一般<br>30 个中文，移动端 20 个，超过会截断为省略号。</p>
</li>
<li><p>其他<br>标签语义化<br>img 设置 alt 属性<br>不需要跟踪爬行的链接，设置 rel = “nofollow”</p>
</li>
</ul>
<p>[参考]：（<a href="https://segmentfault.com/a/1190000008829958%EF%BC%89">https://segmentfault.com/a/1190000008829958）</a></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>TS进阶题目</title>
    <url>/2022/01/17/TS%E8%BF%9B%E9%98%B6%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<ul>
<li>在线 TS 地址 <a href="https://www.typescriptlang.org/">typescript</a></li>
</ul>
<span id="more"></span>

<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><ul>
<li>以下代码为什么会提示错误，应该如何解决上述问题？</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">kind</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createCustomer&lt;T <span class="keyword">extends</span> <span class="title class_">User</span>&gt;(<span class="attr">u</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: u.<span class="property">id</span>,</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&#x27;customer&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一种解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">kind</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createCustomer&lt;T <span class="keyword">extends</span> <span class="title class_">User</span>&gt;(<span class="attr">u</span>: T): <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: u.<span class="property">id</span>,</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&#x27;customer&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">kind</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createCustomer&lt;t <span class="keyword">extends</span> <span class="title class_">User</span>&gt;(<span class="attr">u</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...u,</span><br><span class="line">    <span class="attr">id</span>: u.<span class="property">id</span>,</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&#x27;customer&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><ul>
<li>以下函数我们希望参数<em>a</em>和<em>b</em>的类型都是一致的，即<em>a</em>和<em>b</em>同时为<em>number</em>或<em>string</em>类型，当它们的类型不一致时，ts 类型检查器能自动提示对应的错误信息。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a: <span class="built_in">string</span> | <span class="built_in">number</span>,b: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">&#x27;:&#x27;</span> + b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<p><strong>第一种解决方案</strong></p>
<ul>
<li>函数重载</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a: <span class="built_in">string</span> | <span class="built_in">number</span>, b: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">&#x27;:&#x27;</span> + b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a <span class="keyword">as</span> <span class="built_in">number</span>) + (b <span class="keyword">as</span> <span class="built_in">number</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p><strong>第二种解决方案</strong></p>
<ul>
<li>自定义路由守卫</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isStringArray = (<span class="attr">params</span>: <span class="built_in">string</span>[] | <span class="built_in">number</span>[]): params is <span class="built_in">string</span>[] =&gt; <span class="keyword">typeof</span> params[<span class="number">0</span>] === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args: <span class="built_in">string</span>[] | <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isStringArray</span>(args)) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>] + <span class="string">&#x27;:&#x27;</span> + args[<span class="number">1</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>] + args[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p><strong>第三种解决方案</strong></p>
<ul>
<li>范型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> f&lt;T <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: T) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">&#x27;:&#x27;</span> + b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a <span class="keyword">as</span> <span class="built_in">number</span>) + (b <span class="keyword">as</span> <span class="built_in">number</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><ul>
<li>实现 SetOptional 工具类型，支持把给定的 keys 对应的属性变为可选，参考<em>Partial<T></em></li>
<li>实现 SetRequired 工具类型，支持把给定的 keys 对应的属性变成必填，参考 <em>Require<T></em></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetOptional 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  b?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SomeOptional</span> = <span class="title class_">SetOptional</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SomeOptional</span> = &#123;</span><br><span class="line">  a?: <span class="built_in">number</span>; <span class="comment">//该属性变为可选的</span></span><br><span class="line">  b?: <span class="built_in">string</span>; <span class="comment">//保持不变</span></span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetRequired 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  b?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SomeRequired</span> = <span class="title class_">SetRequired</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SomeRequired</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>; <span class="comment">//保持不变</span></span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span>; <span class="comment">//该属性变为必选的</span></span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<ul>
<li>SetOptional</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  b?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对交叉类型进行扁平化处理</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Simplify</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetOptional</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Simplify</span>&lt;<span class="title class_">Partial</span>&lt;<span class="title class_">Pick</span>&lt;T, K&gt;&gt; &amp; <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SomeOptional</span> = <span class="title class_">SetOptional</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>SetRequired</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  b?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Simplify</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetRequired</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Simplify</span>&lt;<span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt; &amp; <span class="title class_">Required</span>&lt;<span class="title class_">Pick</span>&lt;T, K&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SomeRequired</span> = <span class="title class_">SetRequired</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  b?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Simplely</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetOptional</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Simplely</span>&lt;&#123; [X <span class="keyword">in</span> keyof <span class="title class_">Omit</span>&lt;T, K&gt;]: T[X]; &#125; &amp; &#123; [P <span class="keyword">in</span> K]?: T[P] &#125;&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetRequired</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Simplely</span>&lt;&#123; [X <span class="keyword">in</span> keyof <span class="title class_">Omit</span>&lt;T, K&gt;]: T[X]; &#125; &amp; &#123; [P <span class="keyword">in</span> K]-?: T[P] &#125;&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SomeOptional</span> = <span class="title class_">SetOptional</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SomeRequired</span> = <span class="title class_">SetRequired</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 3</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Simplify</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetOptional</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Simplify</span>&lt;<span class="title class_">Partial</span>&lt;<span class="title class_">Pick</span>&lt;T, K&gt;&gt; &amp; <span class="title class_">Omit</span>&lt;T, K&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetRequired</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Simplify</span>&lt;<span class="title class_">Required</span>&lt;<span class="title class_">Pick</span>&lt;T, K&gt;&gt; &amp; <span class="title class_">Omit</span>&lt;T, K&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><ul>
<li><em>Pick&lt;T, K extends keyof T&gt;</em> 的作用是将某个类型中的字属性挑出来，得到包含这个类型部分属性的字类型。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">completed</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TodoPreview</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Todo</span>, <span class="string">&quot;title&quot;</span> | <span class="string">&quot;completed&quot;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">TodoPreview</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;clean room&quot;</span>,</span><br><span class="line">  <span class="attr">completed</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题：如何定义一个<em>ConditionalPick</em>工具类型，支持根据指定的<em>Condition</em>条件来生成新的类型，对应的使用示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">c</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">d</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringKeyOnly</span> = <span class="title class_">ConditionalPick</span>&lt;<span class="title class_">Example</span>, <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="comment">// =&gt; &#123;a: string&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types">神奇的 as</a></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">c</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">d</span>: &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ConditionalPick</span>&lt;T, K&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (T[P] <span class="keyword">extends</span> K ? P : <span class="built_in">never</span>)]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringKeysOnly</span> = <span class="title class_">ConditionalPick</span>&lt;<span class="title class_">Example</span>, <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="comment">// =&gt; &#123;a: string&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><ul>
<li>定义一个工具类型<em>AppendArgument</em>,为已有函数累心增加指定类型的参数，新增的参数名是<em>x</em>，将作为新函数类型的第一个参数，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AppendArgument</span>&lt;F, A&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FinalFn</span> = <span class="title class_">AppendArgument</span>&lt;<span class="title class_">Fn</span>, <span class="built_in">boolean</span>&gt;</span><br><span class="line"><span class="comment">// (x: boolean, a: number, b: string) =&gt; number;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<ul>
<li>延伸阅读 <a href="https://mp.weixin.qq.com/s/mkvnJh3fBmL86Vnrv9xAyQ">掌握 TS 这些工具类型，让你开发事半功倍</a></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AppendArgument</span>&lt;F <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>, A&gt; = <span class="function">(<span class="params">x: A, ...args: Parameters&lt;F&gt;</span>) =&gt;</span> <span class="title class_">ReturnType</span>&lt;F&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FinalFn</span> = <span class="title class_">AppendArgument</span>&lt;<span class="title class_">Fn</span>, <span class="built_in">boolean</span>&gt;;</span><br><span class="line"><span class="comment">// (x: boolean, a: number, b: string) =&gt; number;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<ul>
<li>延伸阅读 <a href="https://mp.weixin.qq.com/s/JT2N2K5hvQAXN45B2DEbQw">用上这几招，轻松实现 TS 类型提取</a></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AppendArgument</span>&lt;F, T&gt; = F <span class="keyword">extends</span> (...<span class="attr">args</span>: infer <span class="title class_">Args</span>) =&gt; infer <span class="title class_">Return</span> ? <span class="function">(<span class="params">x: T, ...args: Args</span>) =&gt;</span> <span class="title class_">Return</span> : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FinalFn</span> = <span class="title class_">AppendArgument</span>&lt;<span class="title class_">Fn</span>, <span class="built_in">boolean</span>&gt;;</span><br><span class="line"><span class="comment">// (x: boolean, a: number, b: string) =&gt; number</span></span><br></pre></td></tr></table></figure>

<h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><ul>
<li>定义一个 NativeFlat 工具类型，支持把数组类型拍平(扁平化),示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NativeFlat</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = <span class="comment">// 实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NativeResult</span> = <span class="title class_">NativeFlat</span>&lt;[[<span class="string">&#x27;a&#x27;</span>],[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],[<span class="string">&#x27;d&#x27;</span>]]&gt;;</span><br><span class="line"><span class="comment">// =&gt; &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在完成<em>NativeFlat</em>工具类型之后，继续实现<em>DeepFlat</em>工具类型，以支持多维数组类型：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DeepFlat</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = <span class="built_in">unknown</span> <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Deep</span> = [[<span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [[<span class="string">&#x27;d&#x27;</span>]], [[[[<span class="string">&#x27;e&#x27;</span>]]]]];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DeepTestResult</span> = <span class="title class_">DeepFlat</span>&lt;<span class="title class_">Deep</span>&gt;</span><br><span class="line"><span class="comment">// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<ul>
<li>NativeFlat</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NaiveFlat</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P] <span class="keyword">extends</span> <span class="built_in">any</span>[] ? T[P][<span class="built_in">number</span>] : T[P]</span><br><span class="line">&#125;[<span class="built_in">number</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NaiveResult</span> = <span class="title class_">NaiveFlat</span>&lt;[[<span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;d&#x27;</span>]]&gt;</span><br><span class="line"><span class="comment">// NaiveResult的结果： &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>DeepFlat</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Deep</span> = [[<span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [[<span class="string">&#x27;d&#x27;</span>]], [[[[<span class="string">&#x27;e&#x27;</span>]]]]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DeepFlat</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> <span class="built_in">any</span>[] ? <span class="title class_">DeepFlat</span>&lt;T[K]&gt; : T[K]</span><br><span class="line">&#125;[<span class="built_in">number</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DeepTestResult</span> = <span class="title class_">DeepFlat</span>&lt;<span class="title class_">Deep</span>&gt;</span><br><span class="line"><span class="comment">// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><ul>
<li>使用类型别名定义一个<em>EmptyObject</em>类型，是的该类型只允许空对象赋值：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EmptyObject</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">shouldPass</span>: <span class="title class_">EmptyObject</span> = &#123;&#125;; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">shouldFail</span>: <span class="title class_">EmptyObject</span> = &#123; <span class="comment">// Error</span></span><br><span class="line">  <span class="attr">prop</span>: <span class="string">&quot;TS&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更改以下<em>takeSomeTypeOnly</em>函数类型定义，让参数只允许严格 SomeType 类型的值，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SomeType</span> = &#123;</span><br><span class="line">  <span class="attr">prop</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">takeSomeTypeOnly</span>(<span class="params">x: SomeType</span>) &#123;<span class="keyword">return</span> x&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> x = &#123;<span class="attr">prop</span>: <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">takeSomeTypeOnly</span>(x); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = &#123;<span class="attr">prop</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">additionalProp</span>: <span class="string">&#x27;x&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">takeSomeTypeOnly</span>(y); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<ul>
<li>EmptyObject</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type PropertyKey = string | number | symbol;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmptyObject</span> = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> <span class="title class_">PropertyKey</span>]: <span class="built_in">never</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">shouldPass</span>: <span class="title class_">EmptyObject</span> = &#123;&#125;; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">shouldFail</span>: <span class="title class_">EmptyObject</span> = &#123; <span class="comment">// Error</span></span><br><span class="line">  <span class="attr">prop</span>: <span class="string">&quot;TS&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>takeSomeTypeOnly</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SomeType</span> = &#123;</span><br><span class="line">  <span class="attr">prop</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Exclusive</span>&lt;<span class="variable constant_">T1</span>, <span class="variable constant_">T2</span> <span class="keyword">extends</span> <span class="variable constant_">T1</span>&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof <span class="variable constant_">T2</span>]: K <span class="keyword">extends</span> keyof <span class="variable constant_">T1</span> ? <span class="variable constant_">T2</span>[K] : <span class="built_in">never</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> takeSomeTypeOnly&lt;T <span class="keyword">extends</span> <span class="title class_">SomeType</span>&gt;(<span class="attr">x</span>: <span class="title class_">Exclusive</span>&lt;<span class="title class_">SomeType</span>, T&gt;) &#123;<span class="keyword">return</span> x&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> x = &#123;<span class="attr">prop</span>: <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">takeSomeTypeOnly</span>(x); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = &#123;<span class="attr">prop</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">additionalProp</span>: <span class="string">&#x27;x&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">takeSomeTypeOnly</span>(y); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><ul>
<li>定义一个<em>NonEmptyArray</em>工具类型，用于确保数据为非空数组</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonEmptyArray</span>&lt;T&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">err</span>: <span class="title class_">NonEmptyArray</span>&lt;<span class="built_in">string</span>&gt; = []; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">succ</span>: <span class="title class_">NonEmptyArray</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;Hello Ts&#x27;</span>]; <span class="comment">//Ok</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonEmptyArray</span>&lt;T&gt; = [T, ...T[]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">err</span>: <span class="title class_">NonEmptyArray</span>&lt;<span class="built_in">string</span>&gt; = []; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">succ</span>: <span class="title class_">NonEmptyArray</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;Hello Ts&#x27;</span>]; <span class="comment">//Ok</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonEmptyArray</span>&lt;T&gt; = T[] &amp; &#123;<span class="number">0</span>: T&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">err</span>: <span class="title class_">NonEmptyArray</span>&lt;<span class="built_in">string</span>&gt; = []; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">succ</span>: <span class="title class_">NonEmptyArray</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;Hello Ts&#x27;</span>]; <span class="comment">//Ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 3</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonEmptyArray</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> <span class="built_in">number</span>]: T;</span><br><span class="line">&#125; &amp; &#123;</span><br><span class="line">  <span class="number">0</span>: T</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">err</span>: <span class="title class_">NonEmptyArray</span>&lt;<span class="built_in">string</span>&gt; = []; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">succ</span>: <span class="title class_">NonEmptyArray</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;Hello Ts&#x27;</span>]; <span class="comment">//Ok</span></span><br></pre></td></tr></table></figure>

<h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><ul>
<li>定义一个<em>JoinStrArray</em>工具类型，用于根据指定的<code>Separator</code>分隔符，对字符串数据类型进行拼接，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">JoinStrArray</span>&lt;<span class="title class_">Arr</span> <span class="keyword">extends</span> <span class="built_in">string</span>[], <span class="title class_">Separator</span> <span class="keyword">extends</span> <span class="built_in">string</span>, <span class="title class_">Result</span> <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = [<span class="string">&quot;Sem&quot;</span>, <span class="string">&quot;Lolo&quot;</span>, <span class="string">&quot;Kaquko&quot;</span>]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NamesComma</span> = <span class="title class_">JoinStrArray</span>&lt;<span class="title class_">Names</span>, <span class="string">&quot;,&quot;</span>&gt; <span class="comment">// &quot;Sem,Lolo,Kaquko&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NamesSpace</span> = <span class="title class_">JoinStrArray</span>&lt;<span class="title class_">Names</span>, <span class="string">&quot; &quot;</span>&gt; <span class="comment">// &quot;Sem Lolo Kaquko&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NamesStars</span> = <span class="title class_">JoinStrArray</span>&lt;<span class="title class_">Names</span>, <span class="string">&quot;⭐️&quot;</span>&gt; <span class="comment">// &quot;Sem⭐️Lolo⭐️Kaquko&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">JoinStrArray</span>&lt;</span><br><span class="line">  <span class="title class_">Arr</span> <span class="keyword">extends</span> <span class="built_in">string</span>[],</span><br><span class="line">  <span class="title class_">Separator</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">Result</span> <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">&gt; =</span><br><span class="line"><span class="title class_">Arr</span> <span class="keyword">extends</span> [infer <span class="title class_">El</span>,...infer <span class="title class_">Rest</span>]</span><br><span class="line">? <span class="title class_">Rest</span> <span class="keyword">extends</span> <span class="built_in">string</span>[]</span><br><span class="line">? <span class="title class_">El</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">? <span class="title class_">Result</span> <span class="keyword">extends</span> <span class="string">&quot;&quot;</span></span><br><span class="line">? <span class="title class_">JoinStrArray</span>&lt;<span class="title class_">Rest</span>, <span class="title class_">Separator</span>,<span class="string">`<span class="subst">$&#123;El&#125;</span>`</span>&gt;</span><br><span class="line">: <span class="title class_">JoinStrArray</span>&lt;<span class="title class_">Rest</span>, <span class="title class_">Separator</span>,<span class="string">`<span class="subst">$&#123;Result&#125;</span><span class="subst">$&#123;Separator&#125;</span><span class="subst">$&#123;El&#125;</span>`</span>&gt;</span><br><span class="line">: <span class="string">`<span class="subst">$&#123;Result&#125;</span>`</span></span><br><span class="line">: <span class="string">`<span class="subst">$&#123;Result&#125;</span>`</span></span><br><span class="line">: <span class="string">`<span class="subst">$&#123;Result&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = [<span class="string">&quot;Sem&quot;</span>, <span class="string">&quot;Lolo&quot;</span>, <span class="string">&quot;Kaquko&quot;</span>]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NamesComma</span> = <span class="title class_">JoinStrArray</span>&lt;<span class="title class_">Names</span>, <span class="string">&quot;,&quot;</span>&gt; <span class="comment">// &quot;Sem,Lolo,Kaquko&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NamesSpace</span> = <span class="title class_">JoinStrArray</span>&lt;<span class="title class_">Names</span>, <span class="string">&quot; &quot;</span>&gt; <span class="comment">// &quot;Sem Lolo Kaquko&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NamesStars</span> = <span class="title class_">JoinStrArray</span>&lt;<span class="title class_">Names</span>, <span class="string">&quot;⭐️&quot;</span>&gt; <span class="comment">// &quot;Sem⭐️Lolo⭐️Kaquko&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><ul>
<li>实现一个<em>Trim</em>工具类型，用于对字符串字面量类型进行去空格处理，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Trim</span>&lt;V <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Trim</span>&lt;<span class="string">&#x27;  foolishmax  &#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TrimLeft</span>&lt;V <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = V <span class="keyword">extends</span> <span class="string">` <span class="subst">$&#123;infer R&#125;</span>`</span> ? <span class="title class_">TrimLeft</span>&lt;R&gt; : V;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TrimRight</span>&lt;V <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = V <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer R&#125;</span> `</span>? <span class="title class_">TrimRight</span>&lt;R&gt; : V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Trim</span>&lt;V <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="title class_">TrimLeft</span>&lt;<span class="title class_">TrimRight</span>&lt;V&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Trim</span>&lt;<span class="string">&#x27;  foolishmax  &#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h2><ul>
<li>实现一个*IsEqual&lt;A, B&gt;*工具类型，用于比较两个类型是否相等，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsEqual</span>&lt;A, B&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E0</span> = <span class="title class_">IsEqual</span>&lt;<span class="number">1</span>, <span class="number">2</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E1</span> = <span class="title class_">IsEqual</span>&lt;&#123;a : <span class="number">1</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;&#125;&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E2</span> = <span class="title class_">IsEqual</span>&lt;[<span class="number">1</span>], []&gt;; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案（原始方案） 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsEqual</span>&lt;A, B&gt; = A <span class="keyword">extends</span> B ? (B <span class="keyword">extends</span> A ? <span class="literal">true</span> : <span class="literal">false</span>) : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E0</span> = <span class="title class_">IsEqual</span>&lt;<span class="number">1</span>, <span class="number">2</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E1</span> = <span class="title class_">IsEqual</span>&lt;&#123;a : <span class="number">1</span>&#125;, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E2</span> = <span class="title class_">IsEqual</span>&lt;[<span class="number">1</span>], []&gt;; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E3</span> = <span class="title class_">IsEqual</span>&lt;<span class="literal">true</span>, <span class="built_in">boolean</span>&gt; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E4</span> = <span class="title class_">IsEqual</span>&lt;<span class="number">1</span> | <span class="number">2</span>, <span class="number">1</span>&gt; <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line">这是因为泛型和*<span class="keyword">extends</span>*两者结合所产生的*distributive conditionial types*效应导致的</span><br></pre></td></tr></table></figure>

<p><strong>解决方案（稍微优化）2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsEqual</span>&lt;A, B&gt; = [A] <span class="keyword">extends</span> [B] ? [B] <span class="keyword">extends</span> [A] ? <span class="literal">true</span> : <span class="literal">false</span> : <span class="literal">false</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IsEqual</span>&lt;A, B&gt; = [A, B] <span class="keyword">extends</span> [B, A] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E0</span> = <span class="title class_">IsEqual</span>&lt;<span class="number">1</span>, <span class="number">2</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E1</span> = <span class="title class_">IsEqual</span>&lt;&#123;a : <span class="number">1</span>&#125;, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E2</span> = <span class="title class_">IsEqual</span>&lt;[<span class="number">1</span>], []&gt;; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E3</span> = <span class="title class_">IsEqual</span>&lt;<span class="built_in">any</span>, <span class="built_in">string</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E4</span> = <span class="title class_">IsEqual</span>&lt; &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;, &#123; <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span> &#125;&gt; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">这是因为<span class="title class_">Ts</span>中<span class="built_in">any</span>可以赋值为任何类型，任何类型也可以赋值给<span class="built_in">any</span>，这就意味着<span class="built_in">any</span>和任意类型之间都是assignable的，对于<span class="keyword">extends</span>而言就是都可以相互<span class="keyword">extends</span>的，所以<span class="variable constant_">E3</span>是<span class="literal">true</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">readonly</span>不会改变assignable。</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 4</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsEqual</span>&lt;A, B&gt; =</span><br><span class="line">(&lt;G&gt;<span class="function">() =&gt;</span> G <span class="keyword">extends</span> A ? <span class="number">1</span> : <span class="number">2</span>) <span class="keyword">extends</span></span><br><span class="line">(&lt;G&gt;<span class="function">() =&gt;</span> G <span class="keyword">extends</span> B ? <span class="number">1</span> : <span class="number">2</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E0</span> = <span class="title class_">IsEqual</span>&lt;<span class="number">1</span>, <span class="number">2</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E1</span> = <span class="title class_">IsEqual</span>&lt;&#123;a : <span class="number">1</span>&#125;, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E2</span> = <span class="title class_">IsEqual</span>&lt;[<span class="number">1</span>], []&gt;; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h2><ul>
<li>实现一个<em>Head</em>工具类型，用于获取数组类型的第一个类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Head</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt;&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H0</span> = <span class="title class_">Head</span>&lt;[]&gt; <span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H1</span> = <span class="title class_">Head</span>&lt;[<span class="number">1</span>]&gt; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H2</span> = <span class="title class_">Head</span>&lt;[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&gt; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Head</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt;&gt; = T <span class="keyword">extends</span> [] ? <span class="built_in">never</span> : T[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H0</span> = <span class="title class_">Head</span>&lt;[]&gt; <span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H1</span> = <span class="title class_">Head</span>&lt;[<span class="number">1</span>]&gt; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H2</span> = <span class="title class_">Head</span>&lt;[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&gt; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Head</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt;&gt; = T <span class="keyword">extends</span> [<span class="attr">head</span>: infer H, ...<span class="attr">rest</span>: <span class="built_in">any</span>[]] ? H : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H0</span> = <span class="title class_">Head</span>&lt;[]&gt; <span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H1</span> = <span class="title class_">Head</span>&lt;[<span class="number">1</span>]&gt; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H2</span> = <span class="title class_">Head</span>&lt;[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&gt; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h2><ul>
<li>实现一个<em>Tail</em>工具类型，用于获取数组类型除了第一个类型外，剩余的类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tail</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt;&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Tail</span>&lt;[]&gt; <span class="comment">//[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Tail</span>&lt;[<span class="number">1</span>, <span class="number">2</span>]&gt; <span class="comment">// [2]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Tail</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&gt; <span class="comment">//[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tail</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt;&gt; = T <span class="keyword">extends</span> [infer A, ...infer B] ? B : [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Tail</span>&lt;[]&gt; <span class="comment">//[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Tail</span>&lt;[<span class="number">1</span>, <span class="number">2</span>]&gt; <span class="comment">// [2]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Tail</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&gt; <span class="comment">//[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h2 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h2><ul>
<li>实现一个<em>Unshift</em>工具类型，用于把指定类型 E 作为第一个元素添加到<em>T</em>数组类型中，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Unshift</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U0</span> = <span class="title class_">Unshift</span>&lt;[], <span class="number">1</span>&gt;; <span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U1</span> = <span class="title class_">Unshift</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>&gt;; <span class="comment">//[0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Unshift</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = [E, ...T];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U0</span> = <span class="title class_">Unshift</span>&lt;[], <span class="number">1</span>&gt;; <span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U1</span> = <span class="title class_">Unshift</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>&gt;; <span class="comment">//[0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h2 id="第十五题"><a href="#第十五题" class="headerlink" title="第十五题"></a>第十五题</h2><ul>
<li>实现一个<em>Shift</em>工具类型，用于移除<em>T</em>数组类型中的第一个类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shift</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S0</span> = <span class="title class_">Shift</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">Shift</span>&lt;[<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">boolean</span>]&gt;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shift</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer A, ...infer B] ? B : [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S0</span> = <span class="title class_">Shift</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt;; <span class="comment">// [2, 3]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">Shift</span>&lt;[<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">boolean</span>]&gt;; <span class="comment">// [number, boolean]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S2</span> = <span class="title class_">Shift</span>&lt;[]&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S3</span> = <span class="title class_">Shift</span>&lt;[<span class="built_in">string</span>]&gt;; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h2 id="第十六题"><a href="#第十六题" class="headerlink" title="第十六题"></a>第十六题</h2><ul>
<li>实现一个<em>Push</em>工具类型，用于把指定类型<em>E</em>作为最后一个元素添加到<em>T</em>数组类型中，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Push</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P0</span> = <span class="title class_">Push</span>&lt;[], <span class="number">1</span>&gt;; <span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P1</span> = <span class="title class_">Push</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>&gt;; <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Push</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = T <span class="keyword">extends</span> [...infer U] ? [...U, E] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P0</span> = <span class="title class_">Push</span>&lt;[], <span class="number">1</span>&gt;; <span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P1</span> = <span class="title class_">Push</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>&gt;; <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Push</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = [...T, E];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P0</span> = <span class="title class_">Push</span>&lt;[], <span class="number">1</span>&gt;; <span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P1</span> = <span class="title class_">Push</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>&gt;; <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="第十七题"><a href="#第十七题" class="headerlink" title="第十七题"></a>第十七题</h2><ul>
<li>实现一个<em>Includes</em>工具类型，用于判断指定的类型<em>E</em>，是否包含在<em>T</em>数组类型中，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">Includes</span>&lt;[], <span class="number">1</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Includes</span>&lt;[<span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>&gt;; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = E <span class="keyword">extends</span> T[<span class="built_in">number</span>] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">Includes</span>&lt;[], <span class="number">1</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Includes</span>&lt;[<span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>&gt;; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = T <span class="keyword">extends</span> [infer A, ...infer R] ? E <span class="keyword">extends</span> A ? <span class="literal">true</span> : <span class="title class_">Includes</span>&lt;R, E&gt; : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">Includes</span>&lt;[], <span class="number">1</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Includes</span>&lt;[<span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>&gt;; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="第十八题"><a href="#第十八题" class="headerlink" title="第十八题"></a>第十八题</h2><ul>
<li>实现一个<em>UnionToIntersection</em>工具类型，用于把联合类型转换为交叉类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionToIntersection</span>&lt;U&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U0</span> = <span class="title class_">UnionToIntersection</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;; <span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U1</span> = <span class="title class_">UnionToIntersection</span>&lt;&#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125; | &#123;<span class="attr">age</span>: <span class="built_in">number</span>&#125;&gt;; <span class="comment">// &#123;name: string&#125; &amp; &#123;age: number&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<ul>
<li><p><a href="https://www.jianshu.com/p/071b948209f3">逆变协变</a></p>
</li>
<li><p>注释</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fun</span>&lt;X&gt; = <span class="function">(<span class="params">...args: X[]</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f</span>: <span class="title class_">Fun</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">g</span>: <span class="title class_">Fun</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;</span><br><span class="line"></span><br><span class="line">g = f <span class="comment">// this cannot be assigned</span></span><br><span class="line"></span><br><span class="line">当f赋值给g时，新的g不能使用<span class="built_in">number</span>类型的参数，我们丢失了g的一部分类型，这就属于 逆变(contra-variance),这个和交集的工作机制类似。</span><br><span class="line"></span><br><span class="line">当我们把逆变位置放在条件类型时：<span class="title class_">Typescript</span>会创建一个交集，我们从函数参数中infer了一个类型，<span class="title class_">TypeScript</span>知道我们必须符合逆变的条件，然后<span class="title class_">TypeScript</span>会自动创建并集中所有的成分的交集。</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UnionToIntersection</span>&lt;U&gt; = (U <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="function">(<span class="params">k: U</span>) =&gt;</span> <span class="built_in">void</span> : <span class="built_in">never</span>) <span class="keyword">extends</span> (<span class="attr">k</span>: infer I) =&gt; <span class="built_in">void</span> ? I : <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U0</span> = <span class="title class_">UnionToIntersection</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt; <span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">U1</span> = <span class="title class_">UnionToIntersection</span>&lt;&#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; | &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;&gt; <span class="comment">// &#123; name: string; &#125; &amp; &#123; age: number; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第十九题"><a href="#第十九题" class="headerlink" title="第十九题"></a>第十九题</h2><ul>
<li>实现一个 <em>OptionalKeys</em> 工具类型，用来获取对象类型中声明的可选属性，示例如下:</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">from</span>?: <span class="built_in">string</span>;</span><br><span class="line">  speak?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OptionalKeys</span>&lt;T&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonOptionsKeys</span> = <span class="title class_">OptionalKeys</span>&lt;<span class="title class_">Person</span>&gt; <span class="comment">// &quot;from&quot; | &quot;speak&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">from</span>?: <span class="built_in">string</span>;</span><br><span class="line">  speak?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OptionalKeys</span>&lt;T&gt; = <span class="title class_">NonNullable</span>&lt;&#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: <span class="literal">undefined</span> <span class="keyword">extends</span> T[P] ? P : <span class="built_in">never</span></span><br><span class="line">&#125;[keyof T]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonOptionsKeys</span> = <span class="title class_">OptionalKeys</span>&lt;<span class="title class_">Person</span>&gt; <span class="comment">// &quot;from&quot; | &quot;speak&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">from</span>?: <span class="built_in">string</span>;</span><br><span class="line">  speak?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OptionalKeys</span>&lt;T&gt; = keyof &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="literal">undefined</span> <span class="keyword">extends</span> T[P] ? P : <span class="built_in">never</span>]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonOptionsKeys</span> = <span class="title class_">OptionalKeys</span>&lt;<span class="title class_">Person</span>&gt; <span class="comment">// &quot;from&quot; | &quot;speak&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 3</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">from</span>?: <span class="built_in">string</span>;</span><br><span class="line">  speak?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OptionalKeys</span>&lt;T&gt; = <span class="title class_">Exclude</span>&lt;&#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]: T <span class="keyword">extends</span> T[P] ? <span class="built_in">never</span> : T[P]</span><br><span class="line">&#125;[keyof T], <span class="literal">undefined</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonOptionalKeys</span> = <span class="title class_">OptionalKeys</span>&lt;<span class="title class_">Person</span>&gt;; <span class="comment">// &quot;from&quot; | &quot;speak</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 4</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">from</span>?: <span class="built_in">string</span>;</span><br><span class="line">  speak?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OptionalKeys</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: (<span class="literal">undefined</span> <span class="keyword">extends</span> T[P] ? P : <span class="built_in">never</span>)</span><br><span class="line">&#125;[keyof T] &amp; keyof T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonOptionalKeys</span> = <span class="title class_">OptionalKeys</span>&lt;<span class="title class_">Person</span>&gt;; <span class="comment">// &quot;from&quot; | &quot;speak</span></span><br></pre></td></tr></table></figure>

<h2 id="第二十题"><a href="#第二十题" class="headerlink" title="第二十题"></a>第二十题</h2><ul>
<li>实现一个<em>Curry</em>工具类型，用来实现函数类型的柯里化处理，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Curry</span>&lt;</span><br><span class="line">  F <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">any</span>[] = <span class="title class_">Parameters</span>&lt;F&gt;,</span><br><span class="line">  R = <span class="title class_">ReturnType</span>&lt;F&gt;</span><br><span class="line">&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C0</span> = <span class="title class_">Curry</span>&lt;<span class="function">() =&gt;</span> <span class="title class_">Date</span>&gt;; <span class="comment">// () =&gt; Date</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C1</span> = <span class="title class_">Curry</span>&lt;<span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> <span class="title class_">Date</span>&gt;; <span class="comment">// (arg: number) =&gt; Date</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C2</span> = <span class="title class_">Curry</span>&lt;<span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="title class_">Date</span>&gt;; <span class="comment">// (arg: number)=&gt;(arg: string) =&gt; Date</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Curry</span>&lt;</span><br><span class="line">  F <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>,</span><br><span class="line">  P <span class="keyword">extends</span> <span class="built_in">any</span>[] = <span class="title class_">Parameters</span>&lt;F&gt;,</span><br><span class="line">  R = <span class="title class_">ReturnType</span>&lt;F&gt;,</span><br><span class="line">&gt; = P <span class="keyword">extends</span> [infer A, ...infer B]</span><br><span class="line">  ? B <span class="keyword">extends</span> []</span><br><span class="line">  ? <span class="function">(<span class="params">arg: A</span>) =&gt;</span> R</span><br><span class="line">  : <span class="function">(<span class="params">arg: A</span>) =&gt;</span> <span class="title class_">Curry</span>&lt;<span class="function">(<span class="params">...arg: B</span>) =&gt;</span> R&gt;</span><br><span class="line">  : F;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C0</span> = <span class="title class_">Curry</span>&lt;<span class="function">() =&gt;</span> <span class="title class_">Date</span>&gt;; <span class="comment">// () =&gt; Date</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C1</span> = <span class="title class_">Curry</span>&lt;<span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> <span class="title class_">Date</span>&gt;; <span class="comment">// (arg: number) =&gt; Date</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C2</span> = <span class="title class_">Curry</span>&lt;<span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="title class_">Date</span>&gt;; <span class="comment">// (arg: number)=&gt;(arg: string) =&gt; Date</span></span><br></pre></td></tr></table></figure>

<h2 id="第二十一题"><a href="#第二十一题" class="headerlink" title="第二十一题"></a>第二十一题</h2><ul>
<li>实现一个<em>Merge</em>工具类型，用于把两个类型合成一个新的类型，第二类型（SecondType）的<em>Keys</em>将会覆盖第一种类型（FirstType）的<em>Keys</em>，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Merge</span>&lt;<span class="title class_">FirstType</span>, <span class="title class_">SecondType</span>&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> M = <span class="title class_">Merge</span>&lt;<span class="title class_">Foo</span>, <span class="title class_">Bar</span>&gt;; <span class="comment">// &#123;a: number, b: number&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<ul>
<li>将 FirstType 和 SecondType 做交叉类型，并遍历每一个属性；</li>
<li>如果当前属性名在 SecondType 类型中，则使用 SecondType 类型中的当前属性值；</li>
<li>如果当前属性名在 FirstType 类型中，则使用 FirstType 类型中的当前属性值；</li>
<li>否则为 never；</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Merge</span>&lt;<span class="title class_">FirstType</span>, <span class="title class_">SecondType</span>&gt; =&#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof (<span class="title class_">FirstType</span> &amp; <span class="title class_">SecondType</span>)]</span><br><span class="line">  : K <span class="keyword">extends</span> keyof <span class="title class_">SecondType</span></span><br><span class="line">  ? <span class="title class_">SecondType</span>[K]</span><br><span class="line">  : K <span class="keyword">extends</span> keyof <span class="title class_">FirstType</span></span><br><span class="line">  ? <span class="title class_">FirstType</span>[K]</span><br><span class="line">  : <span class="built_in">never</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> M = <span class="title class_">Merge</span>&lt;<span class="title class_">Foo</span>, <span class="title class_">Bar</span>&gt;; <span class="comment">// &#123;a: number, b: number&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<ul>
<li>先将 FirstType 类型中已经有的，和 SecondType 类型中相同的属性删除；</li>
<li>将前面结果和 SecondType 做交叉类型，获得合并后结果。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Merge</span>&lt;F, S&gt; = <span class="title class_">Omit</span>&lt;F, keyof S&gt; &amp; S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> M = <span class="title class_">Merge</span>&lt;<span class="title class_">Foo</span>, <span class="title class_">Bar</span>&gt;; <span class="comment">// &#123;a: number, b: number&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="第二十二题"><a href="#第二十二题" class="headerlink" title="第二十二题"></a>第二十二题</h2><ul>
<li>实现一个<em>RequireAtLeastOne</em>工具类型，它将创建一个至少含有一个给定<em>keys</em>的类型，其余<em>keys</em>类型保持原样，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Responder</span> = &#123;</span><br><span class="line">  text?: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  json?: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  secure?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequireAtLeastOne</span>&lt;</span><br><span class="line">  <span class="title class_">ObjectType</span>,</span><br><span class="line">  <span class="title class_">KeysType</span> <span class="keyword">extends</span> keyof <span class="title class_">ObjectType</span> = keyof <span class="title class_">ObjectType</span>,</span><br><span class="line">&gt; = 代码实现</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">responder</span>: <span class="title class_">RequireAtLeastOne</span>&lt;<span class="title class_">Responder</span>, <span class="string">&#x27;text&#x27;</span>|<span class="string">&#x27;json&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">json</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;&#123;&quot;message&quot;: &quot;ok&quot;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">secure</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Responder</span> = &#123;</span><br><span class="line">  text?: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  json?: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  secure?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequireAtLeastOne</span>&lt;</span><br><span class="line">  <span class="title class_">ObjectType</span>,</span><br><span class="line">  <span class="title class_">KeysType</span> <span class="keyword">extends</span> keyof <span class="title class_">ObjectType</span> = keyof <span class="title class_">ObjectType</span>,</span><br><span class="line">&gt; = <span class="title class_">KeysType</span> <span class="keyword">extends</span> <span class="built_in">unknown</span> ? <span class="title class_">ObjectType</span> &amp; &#123;</span><br><span class="line">  [K <span class="keyword">in</span> <span class="title class_">KeysType</span>]-?: <span class="title class_">ObjectType</span>[K]</span><br><span class="line">&#125; : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示当前类型至少包含 &#x27;text&#x27; 或 &#x27;json&#x27; 键</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">responder</span>: <span class="title class_">RequireAtLeastOne</span>&lt;<span class="title class_">Responder</span>, <span class="string">&#x27;text&#x27;</span> | <span class="string">&#x27;json&#x27;</span>&gt; = &#123;</span><br><span class="line">    <span class="attr">json</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;&#123;&quot;message&quot;: &quot;ok&quot;&#125;&#x27;</span>,</span><br><span class="line">    <span class="attr">secure</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-expect-error 因为没有&#x27;text&#x27;和&#x27;json&#x27;中的任何一个，报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">responder2</span>: <span class="title class_">RequireAtLeastOne</span>&lt;<span class="title class_">Responder</span>, <span class="string">&#x27;text&#x27;</span> | <span class="string">&#x27;json&#x27;</span>&gt; = &#123;</span><br><span class="line">    <span class="attr">secure</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Responder</span> = &#123;</span><br><span class="line">  text?: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  json?: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  secure?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequireAtLeastOne</span>&lt;<span class="title class_">ObjectType</span>, <span class="title class_">KeysType</span> <span class="keyword">extends</span> keyof <span class="title class_">ObjectType</span> = keyof <span class="title class_">ObjectType</span>&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof <span class="title class_">ObjectType</span>]: K <span class="keyword">extends</span> <span class="title class_">KeysType</span> ? <span class="title class_">ObjectType</span> &amp; <span class="title class_">Required</span>&lt;<span class="title class_">Pick</span>&lt;<span class="title class_">ObjectType</span>, K&gt;&gt; : <span class="built_in">never</span>;</span><br><span class="line">&#125;[keyof <span class="title class_">ObjectType</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示当前类型至少包含 &#x27;text&#x27; 或 &#x27;json&#x27; 键</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">responder</span>: <span class="title class_">RequireAtLeastOne</span>&lt;<span class="title class_">Responder</span>, <span class="string">&quot;text&quot;</span> | <span class="string">&quot;json&quot;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">json</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;&#123;&quot;message&quot;: &quot;ok&quot;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">secure</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 3</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Responder</span> = &#123;</span><br><span class="line">  text?: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  json?: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  secure?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequireAtLeastOne</span>&lt;<span class="title class_">ObjectType</span>, <span class="title class_">KeysType</span> <span class="keyword">extends</span> keyof <span class="title class_">ObjectType</span> = <span class="title class_">KeysType</span> <span class="keyword">extends</span> <span class="built_in">unknown</span></span><br><span class="line">? <span class="title class_">Omit</span>&lt;<span class="title class_">ObjectType</span>, <span class="title class_">KeysType</span>&gt; &amp; <span class="title class_">Require</span>&lt;<span class="title class_">Pick</span>&lt;<span class="title class_">ObjectType</span>, <span class="title class_">KeysType</span>&gt;&gt;</span><br><span class="line">: <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示当前类型至少包含 &#x27;text&#x27; 或 &#x27;json&#x27; 键</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">responder</span>: <span class="title class_">RequireAtLeastOne</span>&lt;<span class="title class_">Responder</span>, <span class="string">&quot;text&quot;</span> | <span class="string">&quot;json&quot;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">json</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;&#123;&quot;message&quot;: &quot;ok&quot;&#125;&#x27;</span>,</span><br><span class="line">  <span class="attr">secure</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第二十三题"><a href="#第二十三题" class="headerlink" title="第二十三题"></a>第二十三题</h2><ul>
<li>实现一个<em>RemoveIndexSignature</em>工具类型，用于移除已有类型中的索引签名，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">symbol</span>]: <span class="built_in">any</span>;</span><br><span class="line">  <span class="title function_">bar</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RemoveIndexSignature</span>&lt;T&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> R = <span class="title class_">RemoveIndexSignature</span>&lt;<span class="title class_">Foo</span>&gt;; <span class="comment">// &#123;bar: ()=&gt;void;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">symbol</span>]: <span class="built_in">any</span>;</span><br><span class="line">  <span class="title function_">bar</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RemoveIndexSignature</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="built_in">string</span> <span class="keyword">extends</span> K ? <span class="built_in">never</span> : <span class="built_in">number</span> <span class="keyword">extends</span> K ? <span class="built_in">never</span> : <span class="built_in">symbol</span> <span class="keyword">extends</span> K ? <span class="built_in">never</span> : K]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> R = <span class="title class_">RemoveIndexSignature</span>&lt;<span class="title class_">Foo</span>&gt;; <span class="comment">// &#123;bar: () =&gt; void;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="第二十四题"><a href="#第二十四题" class="headerlink" title="第二十四题"></a>第二十四题</h2><ul>
<li>实现一个 <code>Mutable</code> 工具类型，用于移除对象类型上所有属性或者部分属性的 <code>readonly</code> 修饰符，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Mutable</span>&lt;T, <span class="title class_">Keys</span> <span class="keyword">extends</span> keyof T = keyof T&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">mutableFoo</span>: <span class="title class_">Mutable</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;a&#x27;</span>&gt; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">c</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">mutableFoo.<span class="property">a</span> = <span class="number">3</span>; <span class="comment">// ok</span></span><br><span class="line">mutableFoo.<span class="property">b</span> = <span class="string">&#x27;6&#x27;</span>; <span class="comment">// Cannot assign to &#x27;b&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Mutable</span>&lt;T, <span class="title class_">Keys</span> <span class="keyword">extends</span> keyof T = keyof T&gt; =</span><br><span class="line">&#123;-<span class="keyword">readonly</span> [K <span class="keyword">in</span> <span class="title class_">Keys</span>]: T[K] &#125; &amp; <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, <span class="title class_">Keys</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">mutableFoo</span>: <span class="title class_">Mutable</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;a&#x27;</span>&gt; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">c</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">mutableFoo.<span class="property">a</span> = <span class="number">3</span>; <span class="comment">// ok</span></span><br><span class="line">mutableFoo.<span class="property">b</span> = <span class="string">&#x27;6&#x27;</span>; <span class="comment">// Cannot assign to &#x27;b&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Mutable</span>&lt;T, <span class="title class_">Keys</span> <span class="keyword">extends</span> keyof T = keyof T&gt; =</span><br><span class="line">&#123;-<span class="keyword">readonly</span> [K <span class="keyword">in</span> <span class="title class_">Keys</span>]: T[K] : T[K]&#125; &amp; <span class="title class_">Omit</span>&lt;T, <span class="title class_">Keys</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">mutableFoo</span>: <span class="title class_">Mutable</span>&lt;<span class="title class_">Foo</span>, <span class="string">&#x27;a&#x27;</span>&gt; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">c</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">mutableFoo.<span class="property">a</span> = <span class="number">3</span>; <span class="comment">// ok</span></span><br><span class="line">mutableFoo.<span class="property">b</span> = <span class="string">&#x27;6&#x27;</span>; <span class="comment">// Cannot assign to &#x27;b&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure>

<h2 id="第二十五题"><a href="#第二十五题" class="headerlink" title="第二十五题"></a>第二十五题</h2><ul>
<li>实现一个 <code>IsUnion</code> 工具类型，判断指定的类型是否为联合类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsUnion</span>&lt;T, U = T&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">IsUnion</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">IsUnion</span>&lt;<span class="built_in">string</span>|<span class="built_in">never</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">IsUnion</span>&lt;<span class="built_in">string</span>|<span class="built_in">unknown</span>&gt; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsUnion</span>&lt;T, U = T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span> ? [U] <span class="keyword">extends</span> [T] ? <span class="literal">false</span> : <span class="literal">true</span> : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">IsUnion</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">IsUnion</span>&lt;<span class="built_in">string</span>|<span class="built_in">never</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">IsUnion</span>&lt;<span class="built_in">string</span>|<span class="built_in">unknown</span>&gt; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>知识点： 1.联合类型作为泛型的时候 extends 会触发分发执行 2.联合类型 T 写成[T]就变成了普通类型，extends 的时候不会分发执行</p>
<p>这里第一步<code>T extends any</code>肯定为真，一个其实就是利用其分发的特性，后面的[T]就是一个联合类型拆开后的某一个，因此如果是联合类型的话<code>[U] extends [T]</code>一定为否</p>
<h2 id="第二十六题"><a href="#第二十六题" class="headerlink" title="第二十六题"></a>第二十六题</h2><ul>
<li>实现一个<code>IsNever</code>工具类型，判断指定的类型是否为<code>never</code>类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsNever</span>&lt;T&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">IsNever</span>&lt;<span class="built_in">never</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">IsNever</span>&lt;<span class="built_in">never</span> | <span class="built_in">string</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">IsNever</span>&lt;<span class="literal">null</span>&gt; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<ul>
<li>用<code>[]</code>包裹 T，否则泛型参数会被当作一个裸类型处理，走<code>条件式分布类型</code>的判断逻辑，当泛型参数是 any 这种特殊值时，会得到分布后的类型。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsNever</span>&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">never</span>] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">IsNever</span>&lt;<span class="built_in">never</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">IsNever</span>&lt;<span class="built_in">never</span> | <span class="built_in">string</span>&gt; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">IsNever</span>&lt;<span class="literal">null</span>&gt; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="第二十七题"><a href="#第二十七题" class="headerlink" title="第二十七题"></a>第二十七题</h2><ul>
<li>实现一个<code>Reverse</code>工具类型，用于对元祖类型中元素的位置颠倒，并返回该数组，元祖的第一个元素就会变成最后一个，最后一个元素变成第一个。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Reverse</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R0</span> = <span class="title class_">Reverse</span>&lt;[]&gt; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">Reverse</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt; <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Reverse</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[],</span><br><span class="line">  R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer A, ...infer B] ? <span class="title class_">Reverse</span>&lt;B, [A, ...R]&gt; : R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R0</span> = <span class="title class_">Reverse</span>&lt;[]&gt; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">Reverse</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt; <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Reverse</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">&gt; = T <span class="keyword">extends</span> [infer A, ...infer B] ? [...<span class="title class_">Reverse</span>&lt;B&gt;, A] : [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R0</span> = <span class="title class_">Reverse</span>&lt;[]&gt; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">Reverse</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&gt; <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<h2 id="第二十八题"><a href="#第二十八题" class="headerlink" title="第二十八题"></a>第二十八题</h2><ul>
<li>实现一个<code>Split</code>工具类型，根据给定的分割符(Delimiter)对包含分割符的字符串进行切割，可用于定义<code>String.prototype.split</code>方法的返回值类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Item</span> = <span class="string">`zs, ls, ww`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Split</span>&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">Delimiter</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ElementType</span> = <span class="title class_">Split</span>&lt;<span class="title class_">Item</span>, <span class="string">&#x27;,&#x27;</span>&gt;; <span class="comment">// [&quot;zs&quot;, &quot;ls&quot;,&quot;ww&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Item</span> = <span class="string">`zs, ls, ww`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Split</span>&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">Delimiter</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Key&#125;</span><span class="subst">$&#123;Delimiter&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">? [<span class="title class_">Key</span>, ...<span class="title class_">Split</span>&lt;<span class="title class_">Rest</span>, <span class="title class_">Delimiter</span>&gt;]</span><br><span class="line">: S <span class="keyword">extends</span> <span class="string">&#x27;&#x27;</span> <span class="comment">/* 处理空字符串 */</span></span><br><span class="line">? []</span><br><span class="line">: [S]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ElementType</span> = <span class="title class_">Split</span>&lt;<span class="title class_">Item</span>, <span class="string">&#x27;,&#x27;</span>&gt;; <span class="comment">// [&quot;zs&quot;, &quot;ls&quot;,&quot;ww&quot;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ElementType2</span> = <span class="title class_">Split</span>&lt;<span class="string">&#x27;a|b|c||d&#x27;</span>, <span class="string">&#x27;|&#x27;</span>&gt;; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ElementType3</span> = <span class="title class_">Split</span>&lt;<span class="string">&#x27;abcdef&#x27;</span>, <span class="string">&#x27;&#x27;</span>&gt;; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="第二十九题"><a href="#第二十九题" class="headerlink" title="第二十九题"></a>第二十九题</h2><ul>
<li>实现一个<code>ToPath</code>工具类型，用于把属性访问<code>(.或[])</code>路径转换为元祖的形式，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToPath</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ToPath</span>&lt;<span class="string">&#x27;foo.bar.baz&#x27;</span>&gt; <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"><span class="title class_">ToPath</span>&lt;<span class="string">&#x27;foo[0].bar.baz&#x27;</span>&gt; <span class="comment">// [&#x27;foo&#x27;, &#x27;0&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToPath</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;<span class="string">`[<span class="subst">$&#123;infer D&#125;</span>]`</span>&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">? [...<span class="title class_">ToPath</span>&lt;F&gt;, ...([D] <span class="keyword">extends</span> [<span class="built_in">never</span>] ? [] : [D]), ...<span class="title class_">ToPath</span>&lt;R&gt;]</span><br><span class="line">: S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span>.<span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">? [...<span class="title class_">ToPath</span>&lt;F&gt;, ...<span class="title class_">ToPath</span>&lt;R&gt;]</span><br><span class="line">: S <span class="keyword">extends</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">? []</span><br><span class="line">: [S]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">ToPath</span>&lt;<span class="string">&#x27;foo.bar.baz&#x27;</span>&gt; <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ToPath</span>&lt;<span class="string">&#x27;foo[0].bar.baz&#x27;</span>&gt; <span class="comment">// [&#x27;foo&#x27;, &#x27;0&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="第三十题"><a href="#第三十题" class="headerlink" title="第三十题"></a>第三十题</h2><ul>
<li>完善<code>Chainable</code>类型的定义，是的 TS 能成功推断出<code>result</code>变量的类型，调用<code>option</code>方法之后会不断扩展当前对象的类型，使得调用<code>get</code>方法后能获取正确的类型。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">config</span>: <span class="title class_">Chainable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Chainable</span> = &#123;</span><br><span class="line">  <span class="title function_">option</span>(<span class="attr">key</span>: <span class="built_in">string</span>, <span class="attr">value</span>: <span class="built_in">any</span>): <span class="built_in">any</span></span><br><span class="line">  <span class="title function_">get</span>(): <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = config</span><br><span class="line">  .<span class="title function_">option</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">7</span>)</span><br><span class="line">  .<span class="title function_">option</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;lolo&#x27;</span>)</span><br><span class="line">  .<span class="title function_">option</span>(<span class="string">&#x27;address&#x27;</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;XiaMen&#x27;</span> &#125;)</span><br><span class="line">  .<span class="title function_">get</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ResultType</span> = <span class="keyword">typeof</span> result</span><br><span class="line"><span class="comment">// 期望 ResultType 的类型是：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   age: number</span></span><br><span class="line"><span class="comment">//   name: string</span></span><br><span class="line"><span class="comment">//   address: &#123;</span></span><br><span class="line"><span class="comment">//     value: string</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">config</span>: <span class="title class_">Chainable</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Chainable</span>&lt;T = &#123;&#125;&gt; = &#123;</span><br><span class="line">  option&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, V <span class="keyword">extends</span> <span class="built_in">any</span>&gt;(<span class="attr">key</span>: K, <span class="attr">value</span>: V): <span class="title class_">Chainable</span>&lt;&#123; [P <span class="keyword">in</span> K]: V &#125; &amp; T&gt;;</span><br><span class="line">  <span class="title function_">get</span>(): T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = config.<span class="title function_">option</span>(<span class="string">&quot;age&quot;</span>, <span class="number">7</span>).<span class="title function_">option</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lolo&quot;</span>).<span class="title function_">option</span>(<span class="string">&quot;address&quot;</span>, &#123; <span class="attr">value</span>: <span class="string">&quot;XiaMen&quot;</span> &#125;).<span class="title function_">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ResultType</span> = <span class="keyword">typeof</span> result;</span><br></pre></td></tr></table></figure>

<h2 id="第三十一题"><a href="#第三十一题" class="headerlink" title="第三十一题"></a>第三十一题</h2><ul>
<li>实现一个<code>Repeat</code>工具类型，用于根据类型变量<code>C</code>的值，重复<code>T</code>类型并以元祖的形式返回新的类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Repeat</span>&lt;T, C <span class="keyword">extends</span> <span class="built_in">number</span>&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R0</span> = <span class="title class_">Repeat</span>&lt;<span class="number">0</span>, <span class="number">0</span>&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">Repeat</span>&lt;<span class="number">1</span>, <span class="number">3</span>&gt;; <span class="comment">// [1, 1, 1]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R2</span> = <span class="title class_">Repeat</span>&lt;<span class="built_in">number</span>, <span class="number">2</span>&gt;; <span class="comment">// [number, number]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Repeat</span>&lt;T, C <span class="keyword">extends</span> <span class="built_in">number</span>, A <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = A[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> C ? A : <span class="title class_">Repeat</span>&lt;T, C, [...A, T]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R0</span> = <span class="title class_">Repeat</span>&lt;<span class="number">0</span>, <span class="number">0</span>&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">Repeat</span>&lt;<span class="number">1</span>, <span class="number">3</span>&gt;; <span class="comment">// [1, 1, 1]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R2</span> = <span class="title class_">Repeat</span>&lt;<span class="built_in">number</span>, <span class="number">2</span>&gt;; <span class="comment">// [number, number]</span></span><br></pre></td></tr></table></figure>

<h2 id="第三十二题"><a href="#第三十二题" class="headerlink" title="第三十二题"></a>第三十二题</h2><ul>
<li>实现一个<code>RepeatString</code>工具类型，用于根据类型变量<code>C</code>的值，重复 T 类型并以<code>字符串</code>的形式返回新的类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RepeatString</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S0</span> = <span class="title class_">RepeatString</span>&lt;<span class="string">&quot;a&quot;</span>, <span class="number">0</span>&gt;; <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">RepeatString</span>&lt;<span class="string">&quot;ab&quot;</span>, <span class="number">2</span>&gt;; <span class="comment">// &#x27;abab&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RepeatString</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  C <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  A <span class="keyword">extends</span> <span class="built_in">any</span>[] = []</span><br><span class="line">&gt; = A[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> C</span><br><span class="line">? S</span><br><span class="line">: <span class="title class_">RepeatString</span>&lt;T, C, <span class="string">`<span class="subst">$&#123;S&#125;</span><span class="subst">$&#123;T&#125;</span>`</span>, [...A, T]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S0</span> = <span class="title class_">RepeatString</span>&lt;<span class="string">&quot;a&quot;</span>, <span class="number">0</span>&gt;; <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">RepeatString</span>&lt;<span class="string">&quot;ab&quot;</span>, <span class="number">2</span>&gt;; <span class="comment">// &#x27;abab&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="第三十三题"><a href="#第三十三题" class="headerlink" title="第三十三题"></a>第三十三题</h2><ul>
<li>实现一个<code>ToNumber</code>工具类型，用于实现把数值字符串转换为数值类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToNumber</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">ToNumber</span>&lt;<span class="string">&quot;0&quot;</span>&gt;; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ToNumber</span>&lt;<span class="string">&quot;10&quot;</span>&gt;; <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ToNumber</span>&lt;<span class="string">&quot;20&quot;</span>&gt;; <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToNumber</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>, S <span class="keyword">extends</span> <span class="built_in">any</span>[] = [], L <span class="keyword">extends</span> <span class="built_in">number</span> = S[<span class="string">&quot;length&quot;</span>]&gt; =</span><br><span class="line"><span class="string">`<span class="subst">$&#123;L&#125;</span>`</span> <span class="keyword">extends</span> T ? L : <span class="title class_">ToNumber</span>&lt;T, [...S, <span class="number">1</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">ToNumber</span>&lt;<span class="string">&quot;0&quot;</span>&gt;; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ToNumber</span>&lt;<span class="string">&quot;10&quot;</span>&gt;; <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ToNumber</span>&lt;<span class="string">&quot;20&quot;</span>&gt;; <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h2 id="第三十四题"><a href="#第三十四题" class="headerlink" title="第三十四题"></a>第三十四题</h2><ul>
<li>实现一个<code>SmallerThan</code>工具类型，用于比较数值类型的大小，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SmallerThan</span>&lt;</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  M <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">&gt; = <span class="comment">//代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S0</span> = <span class="title class_">SmallerThan</span>&lt;<span class="number">0</span>, <span class="number">1</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">SmallerThan</span>&lt;<span class="number">2</span>, <span class="number">0</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S2</span> = <span class="title class_">SmallerThan</span>&lt;<span class="number">8</span>, <span class="number">10</span>&gt;; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SmallerThan</span>&lt;</span><br><span class="line">  N <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  M <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">any</span>[] = [],</span><br><span class="line">  L <span class="keyword">extends</span> <span class="built_in">number</span> = S[<span class="string">&quot;length&quot;</span>]</span><br><span class="line">&gt; = L <span class="keyword">extends</span> N</span><br><span class="line">? L <span class="keyword">extends</span> M ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line">: L <span class="keyword">extends</span> M ? <span class="literal">false</span> : <span class="title class_">SmallerThan</span>&lt;N, M, [...S, <span class="number">1</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S0</span> = <span class="title class_">SmallerThan</span>&lt;<span class="number">0</span>, <span class="number">1</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">SmallerThan</span>&lt;<span class="number">2</span>, <span class="number">0</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S2</span> = <span class="title class_">SmallerThan</span>&lt;<span class="number">8</span>, <span class="number">10</span>&gt;; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="第三十五题"><a href="#第三十五题" class="headerlink" title="第三十五题"></a>第三十五题</h2><ul>
<li>实现一个<code>Add</code>工具类型，用于实现对数组对应的数值进行加法运算，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Add</span>&lt;T, R&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A0</span> = <span class="title class_">Add</span>&lt;<span class="number">5</span>, <span class="number">5</span>&gt;; <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A1</span> = <span class="title class_">Add</span>&lt;<span class="number">8</span>, <span class="number">20</span>&gt;; <span class="comment">// 28</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A2</span> = <span class="title class_">Add</span>&lt;<span class="number">10</span>, <span class="number">20</span>&gt;; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Push</span>&lt;T <span class="keyword">extends</span> <span class="built_in">number</span>[], V&gt; = [...T, V];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CreateTuple</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  A <span class="keyword">extends</span> <span class="built_in">number</span>[] = []</span><br><span class="line">&gt; = A[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> T ? A : <span class="title class_">CreateTuple</span>&lt;T, <span class="title class_">Push</span>&lt;A, <span class="number">1</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Add</span>&lt;T <span class="keyword">extends</span> <span class="built_in">number</span>, R <span class="keyword">extends</span> <span class="built_in">number</span>&gt; = [...<span class="title class_">CreateTuple</span>&lt;T&gt;, ...<span class="title class_">CreateTuple</span>&lt;R&gt;][<span class="string">&quot;length&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A0</span> = <span class="title class_">Add</span>&lt;<span class="number">5</span>, <span class="number">5</span>&gt;; <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A1</span> = <span class="title class_">Add</span>&lt;<span class="number">8</span>, <span class="number">20</span>&gt;; <span class="comment">// 28</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A2</span> = <span class="title class_">Add</span>&lt;<span class="number">10</span>, <span class="number">20</span>&gt;; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<h2 id="第三十六题"><a href="#第三十六题" class="headerlink" title="第三十六题"></a>第三十六题</h2><ul>
<li>实现一个<code>Filter</code>工具类型，用于根据类型变量<code>F</code>的值进行类型过滤，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Filter</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], F&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F0</span> = <span class="title class_">Filter</span>&lt;[<span class="number">6</span>, <span class="string">&quot;lolo&quot;</span>, <span class="number">7</span>, <span class="string">&quot;semlinker&quot;</span>, <span class="literal">false</span>], <span class="built_in">number</span>&gt;; <span class="comment">// [6, 7]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="title class_">Filter</span>&lt;[<span class="string">&quot;kakuqo&quot;</span>, <span class="number">2</span>, [<span class="string">&quot;ts&quot;</span>], <span class="string">&quot;lolo&quot;</span>], <span class="built_in">string</span>&gt;; <span class="comment">// [&quot;kakuqo&quot;, &quot;lolo&quot;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="title class_">Filter</span>&lt;[<span class="number">0</span>, <span class="literal">true</span>, <span class="built_in">any</span>, <span class="string">&quot;abao&quot;</span>], <span class="built_in">string</span>&gt;; <span class="comment">// [any, &quot;abao&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本题关键点就是对`any`类型的处理：</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A0</span> = <span class="built_in">any</span> &amp; <span class="number">1</span>; <span class="comment">// any</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A1</span> = <span class="built_in">any</span> &amp; <span class="built_in">boolean</span>; <span class="comment">// any</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A2</span> = <span class="built_in">any</span> &amp; <span class="built_in">never</span>; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsAny</span>&lt;T&gt; = <span class="number">0</span> <span class="keyword">extends</span> (<span class="number">1</span> &amp; T) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Filter</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], F&gt; = T <span class="keyword">extends</span> [infer <span class="variable constant_">R1</span>, ...infer <span class="variable constant_">R2</span>]</span><br><span class="line">? <span class="title class_">IsAny</span>&lt;<span class="variable constant_">R1</span>&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">? [<span class="variable constant_">R1</span>, ...<span class="title class_">Filter</span>&lt;<span class="variable constant_">R2</span>, F&gt;]</span><br><span class="line">: [...<span class="variable constant_">R1</span> <span class="keyword">extends</span> F ? [<span class="variable constant_">R1</span>] : [], ...<span class="title class_">Filter</span>&lt;<span class="variable constant_">R2</span>, F&gt;]</span><br><span class="line">:[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F0</span> = <span class="title class_">Filter</span>&lt;[<span class="number">6</span>, <span class="string">&quot;lolo&quot;</span>, <span class="number">7</span>, <span class="string">&quot;semlinker&quot;</span>, <span class="literal">false</span>], <span class="built_in">number</span>&gt;; <span class="comment">// [6, 7]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="title class_">Filter</span>&lt;[<span class="string">&quot;kakuqo&quot;</span>, <span class="number">2</span>, [<span class="string">&quot;ts&quot;</span>], <span class="string">&quot;lolo&quot;</span>], <span class="built_in">string</span>&gt;; <span class="comment">// [&quot;kakuqo&quot;, &quot;lolo&quot;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="title class_">Filter</span>&lt;[<span class="number">0</span>, <span class="literal">true</span>, <span class="built_in">any</span>, <span class="string">&quot;abao&quot;</span>], <span class="built_in">string</span>&gt;; <span class="comment">// [any, &quot;abao&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="第三十七题"><a href="#第三十七题" class="headerlink" title="第三十七题"></a>第三十七题</h2><ul>
<li>实现一个<code>Flat</code>工具类型，支持把数组类型拍平（扁平化）,示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flat</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F0</span> = <span class="title class_">Flat</span>&lt;[]&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="title class_">Flat</span>&lt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]&gt;; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="title class_">Flat</span>&lt;[<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;d&#x27;</span>, [<span class="string">&#x27;e&#x27;</span>, [<span class="string">&#x27;f&#x27;</span>]]]]&gt;; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flat</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer <span class="title class_">First</span>, ...infer <span class="title class_">Rest</span>]</span><br><span class="line">? <span class="title class_">First</span> <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">? [...<span class="title class_">Flat</span>&lt;<span class="title class_">First</span>&gt;, ...<span class="title class_">Flat</span>&lt;<span class="title class_">Rest</span>&gt;]</span><br><span class="line">: [<span class="title class_">First</span>, ...<span class="title class_">Flat</span>&lt;<span class="title class_">Rest</span>&gt;]</span><br><span class="line">: [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F0</span> = <span class="title class_">Flat</span>&lt;[]&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="title class_">Flat</span>&lt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]&gt;; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="title class_">Flat</span>&lt;[<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;d&#x27;</span>, [<span class="string">&#x27;e&#x27;</span>, [<span class="string">&#x27;f&#x27;</span>]]]]&gt;; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flat</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], S <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = T <span class="keyword">extends</span> [infer R, ...infer <span class="title class_">Rest</span>]</span><br><span class="line">? R <span class="keyword">extends</span> <span class="built_in">any</span>[]</span><br><span class="line">? <span class="title class_">Flat</span>&lt;<span class="title class_">Rest</span>, <span class="title class_">Flat</span>&lt;R, S&gt;&gt;</span><br><span class="line">: <span class="title class_">Flat</span>&lt;<span class="title class_">Rest</span>, [...S, R]&gt;</span><br><span class="line">: S</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F0</span> = <span class="title class_">Flat</span>&lt;[]&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="title class_">Flat</span>&lt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]&gt;; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="title class_">Flat</span>&lt;[<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;d&#x27;</span>, [<span class="string">&#x27;e&#x27;</span>, [<span class="string">&#x27;f&#x27;</span>]]]]&gt;; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="第三十八题"><a href="#第三十八题" class="headerlink" title="第三十八题"></a>第三十八题</h2><ul>
<li>实现<code>StartsWith</code>工具类型，判断字符串字面量类型<code>T</code>是否以给定的字符串字面量类型<code>U</code>开头，并根据判断结果返回布尔值，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StartsWith</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>, U <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S0</span> = <span class="title class_">StartsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;12&#x27;</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">StartsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;13&#x27;</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S2</span> = <span class="title class_">StartsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;1234&#x27;</span>&gt;; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>之后，继续实现<code>EndsWith</code>工具类型，判断字符串字面量类型<code>T</code>是否以给定的字符串字面量类型<code>U</code>结尾，并根据判断结果返回布尔值，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EndsWith</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>, U <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E0</span> = <span class="title class_">EndsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;23&#x27;</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E1</span> = <span class="title class_">EndsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;13&#x27;</span>&gt;; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E2</span> = <span class="title class_">EndsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;123&#x27;</span>&gt;; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StartWith</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StartsWith</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>, U <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;U&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S0</span> = <span class="title class_">StartsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;12&#x27;</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">StartsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;13&#x27;</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S2</span> = <span class="title class_">StartsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;1234&#x27;</span>&gt;; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EndsWith</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EndsWith</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>, U <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Head&#125;</span><span class="subst">$&#123;U&#125;</span>`</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E0</span> = <span class="title class_">EndsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;23&#x27;</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E1</span> = <span class="title class_">EndsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;13&#x27;</span>&gt;; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E2</span> = <span class="title class_">EndsWith</span>&lt;<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;123&#x27;</span>&gt;; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="第三十九题"><a href="#第三十九题" class="headerlink" title="第三十九题"></a>第三十九题</h2><ul>
<li>实现<code>IsAny</code>工具类型，用于判断类型<code>T</code>是否为<code>any</code>类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsAny</span>&lt;T&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">IsAny</span>&lt;<span class="built_in">never</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">IsAny</span>&lt;<span class="built_in">unknown</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">IsAny</span>&lt;<span class="built_in">any</span>&gt;; <span class="comment">// tue</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路： 利用任何类型和any交叉都等于any来实现</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IsAny</span>&lt;T&gt; = <span class="number">0</span> <span class="keyword">extends</span> <span class="number">1</span> &amp; T ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">IsAny</span>&lt;<span class="built_in">never</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">IsAny</span>&lt;<span class="built_in">unknown</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">IsAny</span>&lt;<span class="built_in">any</span>&gt;; <span class="comment">// tue</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unknown 只能赋给 unknown 或者 any</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IsAny</span>&lt;T&gt; = [<span class="built_in">unknown</span>] <span class="keyword">extends</span> [T] ? ([T] <span class="keyword">extends</span> [<span class="built_in">string</span>] ? <span class="literal">true</span> : <span class="literal">false</span>) : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">IsAny</span>&lt;<span class="built_in">never</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">IsAny</span>&lt;<span class="built_in">unknown</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">IsAny</span>&lt;<span class="built_in">any</span>&gt;; <span class="comment">// tue</span></span><br></pre></td></tr></table></figure>

<h2 id="第四十题"><a href="#第四十题" class="headerlink" title="第四十题"></a>第四十题</h2><ul>
<li>实现<code>AnyOf</code>工具类型，只要数组中任意元素的类型非<code>Falsy</code>类型、<code>&#123;&#125;</code>类型或<code>[]</code>类型，则返回<code>true</code>，否则返回<code>false</code>,如果数组为空的话，则返回<code>false</code>，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AnyOf</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A0</span> = <span class="title class_">AnyOf</span>&lt;[]&gt;; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A1</span> = <span class="title class_">AnyOf</span>&lt;[<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>,<span class="literal">false</span>,[],&#123;&#125;]&gt;; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A2</span> = <span class="title class_">AnyOf</span>&lt;[<span class="number">1</span>, <span class="string">&quot;&quot;</span>,<span class="literal">false</span>,[],&#123;&#125;]&gt;; <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Falsy</span> = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> <span class="title class_">PropertyKey</span>]: <span class="built_in">never</span></span><br><span class="line">&#125; | [] | <span class="string">&#x27;&#x27;</span> | <span class="string">&quot;&quot;</span> | <span class="literal">false</span> | <span class="number">0</span> | <span class="literal">undefined</span> | <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnyOf</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer A, ...infer <span class="title class_">Rest</span>]</span><br><span class="line">? (A <span class="keyword">extends</span> <span class="title class_">Falsy</span> ? <span class="title class_">AnyOf</span>&lt;<span class="title class_">Rest</span>&gt; : <span class="literal">true</span>)</span><br><span class="line">: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="第四十一题"><a href="#第四十一题" class="headerlink" title="第四十一题"></a>第四十一题</h2><ul>
<li>实现<code>Replace</code>工具类型，用于实现字符串类型的替换操作，具体的使用示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Replace</span>&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">From</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">To</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R0</span> = <span class="title class_">Replace</span>&lt;<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>&gt;; <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">Replace</span>&lt;<span class="string">&#x27;foobar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>&gt;; <span class="comment">// &#x27;foofoo&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R2</span> = <span class="title class_">Replace</span>&lt;<span class="string">&#x27;foobarbar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>&gt;; <span class="comment">// &#x27;foofoobar&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此外，继续实现<code>ReplaceAll</code>工具类型，用于实现替换所有满足条件的字串，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReplaceAll</span>&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">From</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">To</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R0</span> = <span class="title class_">ReplaceAll</span>&lt;<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>&gt;; <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">ReplaceAll</span>&lt;<span class="string">&#x27;barfoo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>&gt;; <span class="comment">// &#x27;foofoo&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R2</span> = <span class="title class_">ReplaceAll</span>&lt;<span class="string">&#x27;foobarbar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>&gt;; <span class="comment">// &#x27;foofoofoo&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R3</span> = <span class="title class_">ReplaceAll</span>&lt;<span class="string">&#x27;foobarfoobar&#x27;</span>, <span class="string">&#x27;ob&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&gt;; <span class="comment">// &#x27;fobarfobar&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Replace</span>&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">From</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">To</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer H&#125;</span><span class="subst">$&#123;From&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">? <span class="string">`<span class="subst">$&#123;H&#125;</span><span class="subst">$&#123;To&#125;</span><span class="subst">$&#123;R&#125;</span>`</span></span><br><span class="line">: S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R0</span> = <span class="title class_">Replace</span>&lt;<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>&gt;; <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">Replace</span>&lt;<span class="string">&#x27;foobar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>&gt;; <span class="comment">// &#x27;foofoo&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R2</span> = <span class="title class_">Replace</span>&lt;<span class="string">&#x27;foobarbar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>&gt;; <span class="comment">// &#x27;foofoobar&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReplaceAll</span>&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">From</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">To</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer H&#125;</span><span class="subst">$&#123;From&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">? <span class="string">`<span class="subst">$&#123;H&#125;</span><span class="subst">$&#123;To&#125;</span><span class="subst">$&#123;ReplaceAll&lt;R, From, To&gt;&#125;</span>`</span></span><br><span class="line">: S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R0</span> = <span class="title class_">ReplaceAll</span>&lt;<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>&gt;; <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">ReplaceAll</span>&lt;<span class="string">&#x27;barfoo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>&gt;; <span class="comment">// &#x27;foofoo&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R2</span> = <span class="title class_">ReplaceAll</span>&lt;<span class="string">&#x27;foobarbar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>&gt;; <span class="comment">// &#x27;foofoofoo&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R3</span> = <span class="title class_">ReplaceAll</span>&lt;<span class="string">&#x27;foobarfoobar&#x27;</span>, <span class="string">&#x27;ob&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&gt;; <span class="comment">// &#x27;fobarfobar&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="第四十二题"><a href="#第四十二题" class="headerlink" title="第四十二题"></a>第四十二题</h2><ul>
<li>实现<code>IndexOf</code>工具类型，用于获取数组类型中指定项的索引值，若不存在的话，则返回<code>-1</code>字面量类型，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IndexOf</span>&lt;A <span class="keyword">extends</span> <span class="built_in">any</span>[], <span class="title class_">Item</span>&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">IndexOf</span>&lt;<span class="title class_">Arr</span>, <span class="number">0</span>&gt;; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">IndexOf</span>&lt;<span class="title class_">Arr</span>, <span class="number">1</span>&gt;; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">IndexOf</span>&lt;<span class="title class_">Arr</span>, <span class="number">3</span>&gt;; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IndexOf</span>&lt;A <span class="keyword">extends</span> <span class="built_in">any</span>[], <span class="title class_">Item</span>, R <span class="keyword">extends</span> <span class="built_in">any</span>[] = []&gt; = A <span class="keyword">extends</span> [infer H, ...infer <span class="title class_">Rest</span>]</span><br><span class="line">? <span class="title class_">Item</span> <span class="keyword">extends</span> H</span><br><span class="line">? R[<span class="string">&quot;length&quot;</span>]</span><br><span class="line">: <span class="title class_">IndexOf</span>&lt;<span class="title class_">Rest</span>, <span class="title class_">Item</span>, [...R, H]&gt;</span><br><span class="line">: -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I0</span> = <span class="title class_">IndexOf</span>&lt;<span class="title class_">Arr</span>, <span class="number">0</span>&gt;; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">IndexOf</span>&lt;<span class="title class_">Arr</span>, <span class="number">1</span>&gt;; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">IndexOf</span>&lt;<span class="title class_">Arr</span>, <span class="number">3</span>&gt;; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="第四十三题"><a href="#第四十三题" class="headerlink" title="第四十三题"></a>第四十三题</h2><ul>
<li>实现一个<code>Permutation</code>工具类型，当输入一个联合类型时，返回一个包含该联合类型的全排列类型数组。示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Permutation</span>&lt;T, K = T&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P0</span> = <span class="title class_">Permutation</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>&gt;; <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;] | [&#x27;b&#x27; , &#x27;a&#x27;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P1</span> = <span class="title class_">Permutation</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>&gt;; <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] | [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;] | [&quot;b&quot;, &quot;a&quot;, &quot;c&quot;] | [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] | [&quot;c&quot;, &quot;a&quot;, &quot;b&quot;] | [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Permutation</span>&lt;T, K = T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">never</span>]</span><br><span class="line">? []</span><br><span class="line">: K <span class="keyword">extends</span> K</span><br><span class="line">? [K, ...<span class="title class_">Permutation</span>&lt;<span class="title class_">Exclude</span>&lt;T, K&gt;&gt;]</span><br><span class="line">: <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P0</span> = <span class="title class_">Permutation</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>&gt;; <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;] | [&#x27;b&#x27; , &#x27;a&#x27;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">P1</span> = <span class="title class_">Permutation</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>&gt;; <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] | [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;] | [&quot;b&quot;, &quot;a&quot;, &quot;c&quot;] | [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] | [&quot;c&quot;, &quot;a&quot;, &quot;b&quot;] | [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="第四十四题"><a href="#第四十四题" class="headerlink" title="第四十四题"></a>第四十四题</h2><ul>
<li>实现<code>Unpacked</code>工具类型，用于对类型执行“拆箱”操作，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Unpacked</span>&lt;T&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T00</span> = <span class="title class_">Unpacked</span>&lt;<span class="built_in">string</span>&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T01</span> = <span class="title class_">Unpacked</span>&lt;<span class="built_in">string</span>[]&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T02</span> = <span class="title class_">Unpacked</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T03</span> = <span class="title class_">Unpacked</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T04</span> = <span class="title class_">Unpacked</span>&lt;<span class="title class_">Unpacked</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;[]&gt;&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T05</span> = <span class="title class_">Unpacked</span>&lt;<span class="built_in">any</span>&gt;;  <span class="comment">// any</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T06</span> = <span class="title class_">Unpacked</span>&lt;<span class="built_in">never</span>&gt;;  <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Unpacked</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; infer A</span><br><span class="line">? A</span><br><span class="line">: T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;infer B&gt;</span><br><span class="line">? B</span><br><span class="line">: T <span class="keyword">extends</span> (infer A)[]</span><br><span class="line">? A</span><br><span class="line">: T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T00</span> = <span class="title class_">Unpacked</span>&lt;<span class="built_in">string</span>&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T01</span> = <span class="title class_">Unpacked</span>&lt;<span class="built_in">string</span>[]&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T02</span> = <span class="title class_">Unpacked</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T03</span> = <span class="title class_">Unpacked</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T04</span> = <span class="title class_">Unpacked</span>&lt;<span class="title class_">Unpacked</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;[]&gt;&gt;;  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T05</span> = <span class="title class_">Unpacked</span>&lt;<span class="built_in">any</span>&gt;;  <span class="comment">// any</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T06</span> = <span class="title class_">Unpacked</span>&lt;<span class="built_in">never</span>&gt;;  <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<h2 id="第四十五题"><a href="#第四十五题" class="headerlink" title="第四十五题"></a>第四十五题</h2><ul>
<li>实现<code>JsonifiedObject</code>工具类型，用于对<code>Object</code>对象类型进行序列话操作，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">toJSON</span>(): <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Jsonified</span>&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObject</span> = &#123;</span><br><span class="line">  <span class="attr">str</span>: <span class="string">&quot;literalstring&quot;</span>;</span><br><span class="line">  <span class="attr">fn</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">date</span>: <span class="title class_">Date</span>;</span><br><span class="line">  <span class="attr">customClass</span>: <span class="title class_">MyClass</span>;</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&quot;property&quot;</span>;</span><br><span class="line">    <span class="attr">clz</span>: <span class="title class_">MyClass</span>;</span><br><span class="line">    <span class="attr">nested</span>: &#123; <span class="attr">attr</span>: <span class="title class_">Date</span> &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">JsonifiedMyObject</span> = <span class="title class_">Jsonified</span>&lt;<span class="title class_">MyObject</span>&gt;;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">ex</span>: <span class="title class_">JsonifiedMyObject</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">z1</span>: <span class="string">&quot;MyClass&quot;</span> = ex.<span class="property">customClass</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">z2</span>: <span class="built_in">string</span> = ex.<span class="property">obj</span>.<span class="property">nested</span>.<span class="property">attr</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">toJSON</span>(): <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Jsonified</span>&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> &#123; <span class="title function_">toJSON</span>(): infer <span class="title class_">Return</span> &#125;</span><br><span class="line">    ? <span class="title class_">ReturnType</span>&lt;T[K][<span class="string">&quot;toJSON&quot;</span>]&gt;</span><br><span class="line">    : T[K] <span class="keyword">extends</span> (...<span class="attr">arg</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">    ? <span class="built_in">never</span></span><br><span class="line">    : T[K] <span class="keyword">extends</span> <span class="built_in">object</span></span><br><span class="line">    ? <span class="title class_">Jsonified</span>&lt;T[K]&gt;</span><br><span class="line">    : T[K];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObject</span> = &#123;</span><br><span class="line">  <span class="attr">str</span>: <span class="string">&quot;literalstring&quot;</span>;</span><br><span class="line">  <span class="attr">fn</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">date</span>: <span class="title class_">Date</span>;</span><br><span class="line">  <span class="attr">customClass</span>: <span class="title class_">MyClass</span>;</span><br><span class="line">  <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&quot;property&quot;</span>;</span><br><span class="line">    <span class="attr">clz</span>: <span class="title class_">MyClass</span>;</span><br><span class="line">    <span class="attr">nested</span>: &#123; <span class="attr">attr</span>: <span class="title class_">Date</span> &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">JsonifiedMyObject</span> = <span class="title class_">Jsonified</span>&lt;<span class="title class_">MyObject</span>&gt;;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">ex</span>: <span class="title class_">JsonifiedMyObject</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">z1</span>: <span class="string">&quot;MyClass&quot;</span> = ex.<span class="property">customClass</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">z2</span>: <span class="built_in">string</span> = ex.<span class="property">obj</span>.<span class="property">nested</span>.<span class="property">attr</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第四十六题"><a href="#第四十六题" class="headerlink" title="第四十六题"></a>第四十六题</h2><ul>
<li>实现<code>RequireAllOrNone</code>工具类型，用于满足以下功能，当设置<code>age</code>属性时，<code>gender</code>属性也会变成必填，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequireAllOrNone</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">RequireAllOrNone</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">RequireAllOrNone</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">7</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequireAllOrNone</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Omit</span>&lt;T, K&gt; &amp; (</span><br><span class="line">  &#123;[P <span class="keyword">in</span> K]-?: T[P]&#125; | &#123;[P <span class="keyword">in</span> K]?: <span class="built_in">never</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">RequireAllOrNone</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">RequireAllOrNone</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">7</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p3</span>: <span class="title class_">RequireAllOrNone</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123; <span class="comment">// error</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">7</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第四十七题"><a href="#第四十七题" class="headerlink" title="第四十七题"></a>第四十七题</h2><ul>
<li>实现<code>RequireExactlyOne</code>工具类型，用于满足以下功能，即只能包含<code>age</code>或<code>gender</code>属性，不能包含着两个属性，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能包含Keys中唯一的一个Key</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequireExactlyOne</span>&lt;T, <span class="title class_">Keys</span> <span class="keyword">extends</span> keyof T&gt; = <span class="comment">// 你的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">RequireExactlyOne</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">7</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">RequireExactlyOne</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p3</span>: <span class="title class_">RequireExactlyOne</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">7</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能包含Keys中唯一的一个Key</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RequireExactlyOne</span>&lt;T, <span class="title class_">Keys</span> <span class="keyword">extends</span> keyof T, K <span class="keyword">extends</span> keyof T = <span class="title class_">Keys</span>&gt; =</span><br><span class="line"><span class="title class_">Keys</span> <span class="keyword">extends</span> <span class="built_in">any</span></span><br><span class="line">? <span class="title class_">Omit</span>&lt;T, K&gt; &amp; <span class="title class_">Required</span>&lt;<span class="title class_">Pick</span>&lt;T, <span class="title class_">Keys</span>&gt;&gt; &amp; <span class="title class_">Partial</span>&lt;<span class="title class_">Record</span>&lt;<span class="title class_">Exclude</span>&lt;K, <span class="title class_">Keys</span>&gt;, <span class="built_in">never</span>&gt;&gt;</span><br><span class="line">: <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">RequireExactlyOne</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">7</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">RequireExactlyOne</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p3</span>: <span class="title class_">RequireExactlyOne</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">7</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第四十八题"><a href="#第四十八题" class="headerlink" title="第四十八题"></a>第四十八题</h2><ul>
<li>实现<code>ConsistsOnlyOf</code>工具类型，用于判断<code>LongString</code>字符串类型是否由 0 个或多个<code>Substring</code>字符串类型组成，示例如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ConsistsOnlyOf</span>&lt;<span class="title class_">LongString</span> <span class="keyword">extends</span> <span class="built_in">string</span>, <span class="title class_">SubString</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="comment">// 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C0</span> = <span class="title class_">ConsistsOnlyOf</span>&lt;<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C1</span> = <span class="title class_">ConsistsOnlyOf</span>&lt;<span class="string">&#x27;ababab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C2</span> = <span class="title class_">ConsistsOnlyOf</span>&lt;<span class="string">&#x27;aBa&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C3</span> = <span class="title class_">ConsistsOnlyOf</span>&lt;<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ConsistsOnlyOf</span>&lt;<span class="title class_">LongString</span> <span class="keyword">extends</span> <span class="built_in">string</span>, <span class="title class_">SubString</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt; =</span><br><span class="line"><span class="title class_">LongString</span> <span class="keyword">extends</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">? <span class="literal">true</span></span><br><span class="line">: <span class="title class_">LongString</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;SubString&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">? <span class="title class_">ConsistsOnlyOf</span>&lt;R, <span class="title class_">SubString</span>&gt;</span><br><span class="line">: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C0</span> = <span class="title class_">ConsistsOnlyOf</span>&lt;<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C1</span> = <span class="title class_">ConsistsOnlyOf</span>&lt;<span class="string">&#x27;ababab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C2</span> = <span class="title class_">ConsistsOnlyOf</span>&lt;<span class="string">&#x27;aBa&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">C3</span> = <span class="title class_">ConsistsOnlyOf</span>&lt;<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="第四十九题"><a href="#第四十九题" class="headerlink" title="第四十九题"></a>第四十九题</h2><ul>
<li>项目中定义了接口返回的数据的类型，每层都能灵活扩展一些属性，怎么做呢？</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口返回数据结构</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Data</span> = &#123;</span><br><span class="line">  aaa?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">bbb</span>: &#123;</span><br><span class="line">    <span class="attr">ccc</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DeepRecord</span>&lt;<span class="title class_">Obj</span> <span class="keyword">extends</span> <span class="title class_">Record</span>&lt;keyof <span class="built_in">any</span>, <span class="built_in">unknown</span>&gt;&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]: <span class="title class_">Obj</span>[key] <span class="keyword">extends</span> <span class="title class_">Record</span>&lt;keyof <span class="built_in">any</span>, <span class="built_in">unknown</span>&gt;</span><br><span class="line">    ? <span class="title class_">DeepRecord</span>&lt;<span class="title class_">Obj</span>[key]&gt; &amp; <span class="title class_">Record</span>&lt;keyof <span class="built_in">any</span>, <span class="built_in">unknown</span>&gt;</span><br><span class="line">    : <span class="title class_">Obj</span>[key];</span><br><span class="line">&#125; &amp; <span class="title class_">Record</span>&lt;keyof <span class="built_in">any</span>, <span class="built_in">unknown</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IData</span> = <span class="title class_">DeepRecord</span>&lt;<span class="title class_">Data</span>&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="第五十题"><a href="#第五十题" class="headerlink" title="第五十题"></a>第五十题</h2><ul>
<li>当一个索引为 ‘desc’ | ‘asc’ 的时候，其他索引都是 false</li>
</ul>
<p><strong>解决方案</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GenerateType</span>&lt;keys <span class="keyword">extends</span> keyof <span class="built_in">any</span>, <span class="variable constant_">V1</span>, <span class="variable constant_">V2</span>&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keys]: &#123;</span><br><span class="line">    [key1 <span class="keyword">in</span> key]: <span class="variable constant_">V1</span>;</span><br><span class="line">  &#125; &amp; &#123;</span><br><span class="line">    [key2 <span class="keyword">in</span> <span class="title class_">Exclude</span>&lt;keys, key&gt;]: <span class="variable constant_">V2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;[keys];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> R = <span class="title class_">GenerateType</span>&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span> | <span class="string">&quot;d&quot;</span>, <span class="string">&quot;desc&quot;</span> | <span class="string">&quot;asc&quot;</span>, <span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="第五十一题"><a href="#第五十一题" class="headerlink" title="第五十一题"></a>第五十一题</h2><ul>
<li>取出<strong>interface</strong>中<strong>userInfo</strong>的类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  data?: &#123;</span><br><span class="line">    userInfo?: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 1</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单版 Required</span></span><br><span class="line"><span class="comment">// 缺点 层级深了需要写多个Required</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = <span class="title class_">Required</span>&lt;<span class="title class_">Required</span>&lt;<span class="title class_">Result</span>&gt;[<span class="string">&quot;data&quot;</span>]&gt;[<span class="string">&quot;userInfo&quot;</span>];</span><br></pre></td></tr></table></figure>

<p><strong>解决方案 2</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归Required</span></span><br><span class="line"><span class="comment">// 缺点数据类型都会变成Required</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IsOptional</span>&lt;<span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Obj</span>, <span class="title class_">Obj</span>&gt; = &#123;&#125; <span class="keyword">extends</span> <span class="title class_">Pick</span>&lt;<span class="title class_">Obj</span>, <span class="title class_">Key</span>&gt;</span><br><span class="line">  ? <span class="title class_">Key</span></span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DeepRequired</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]-?: <span class="title class_">IsOptional</span>&lt;K, T&gt; <span class="keyword">extends</span> <span class="built_in">never</span> ? T[K] : <span class="title class_">DeepRequired</span>&lt;T[K]&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = <span class="title class_">DeepRequired</span>&lt;<span class="title class_">Result</span>&gt;[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;userInfo&quot;</span>];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>aliyun服务器实践</title>
    <url>/2022/08/02/aliyun%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="创建新的账号"><a href="#创建新的账号" class="headerlink" title="创建新的账号"></a>创建新的账号</h2><p>默认使用 root 登录，由于 root 权限太高，出于安全考虑，创建 foolishmax（自定义）账号</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增账号foolishmax</span></span><br><span class="line">adduser foolishmax</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改foolishmax的密码</span></span><br><span class="line">passwd foolishmax</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为foolishmax账号添加sudo权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到文件位置 /etc/sudoers</span></span><br><span class="line">whereis sudoers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">u 标识所有者、w 表示写权限 + 表示添加</span></span><br><span class="line">chmod u+w /etc/sudoers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 /etc/sudoers</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到 `root ALL=(ALL) ALL`</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再加一行 `work ALL=(ALL) ALL`</span></span><br><span class="line">vim /etc/sudoers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还原权限</span></span><br><span class="line">chmod u-w /etc/sudoers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换foolishmax用户</span></span><br><span class="line">su foolishmax</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换回root</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换成功</span></span><br></pre></td></tr></table></figure>

<h2 id="下载常用工具"><a href="#下载常用工具" class="headerlink" title="下载常用工具"></a>下载常用工具</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// git</span><br><span class="line">yum -y install git</span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line">// 安装docker</span><br><span class="line">yum -y install docker</span><br><span class="line">docker --version</span><br><span class="line"></span><br><span class="line">// 安装docker-compose</span><br><span class="line">// 1. 下载二进制文件</span><br><span class="line">wget https://github.com/docker/compose/releases/download/1.24.0/docker-compose-Linux-x86_64</span><br><span class="line">// 2.移动文件</span><br><span class="line">mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line">// 3.赋予可执行权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line">// 4.创建软链</span><br><span class="line">ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line">// 5.测试是否安装成功</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><p><a href="https://ecs.console.aliyun.com/securityGroupDetail/region/cn-shanghai/groupId/sg-uf6ecwnj4s2zj738k4a8/detail/intranetIngress">aliyun 控制台服务</a></p>
<h2 id="发布测试机"><a href="#发布测试机" class="headerlink" title="发布测试机"></a>发布测试机</h2><p>思路：</p>
<ol>
<li>使用 github actions 监听 dev 分支 push</li>
<li>登录测试机，获取最新 dev 分支代码</li>
<li>重建构建镜像 <strong>docker-compose build project-name</strong></li>
<li>重启所有容器 <strong>docker-compose up -d</strong></li>
</ol>
<p>github actions<br>代码在项目 <strong>.github/workflows</strong> 目录下面的 <strong>.yml</strong> 格式文件<br><strong>deplop-dev.yml</strong>示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This workflow will <span class="keyword">do</span> a clean install of node dependencies, build the <span class="built_in">source</span> code and run tests across different versions of node</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">github actions 中文文档 https://docs.github.com/cn/actions/getting-started-with-github-actions</span></span><br><span class="line"></span><br><span class="line">name: deploy for dev</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">    push:</span><br><span class="line">        branches:</span><br><span class="line">            - &#x27;dev&#x27; # 只针对 dev 分支</span><br><span class="line">        paths:</span><br><span class="line">            - &#x27;.github/workflows/*&#x27;</span><br><span class="line">            # - &#x27;__test__/**&#x27; # dev 不需要立即测试</span><br><span class="line">            - &#x27;src/**&#x27;</span><br><span class="line">            - &#x27;Dockerfile&#x27;</span><br><span class="line">            - &#x27;docker-compose.yml&#x27;</span><br><span class="line">            - &#x27;bin/*&#x27;</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">    deploy-dev:</span><br><span class="line">        runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">        steps:</span><br><span class="line">            - uses: actions/checkout@v2</span><br><span class="line">            - name: set ssh key # 临时设置 ssh key</span><br><span class="line">              run: |</span><br><span class="line">                  mkdir -p ~/.ssh/</span><br><span class="line">                  echo &quot;$&#123;&#123;secrets.WFP_ID_RSA&#125;&#125;&quot; &gt; ~/.ssh/id_rsa # secret 在这里配置 https://github.com/imooc-lego/biz-editor-server/settings/secrets</span><br><span class="line">                  chmod 600 ~/.ssh/id_rsa</span><br><span class="line">                  ssh-keyscan &quot;182.92.xxx.xxx&quot; &gt;&gt; ~/.ssh/known_hosts</span><br><span class="line">            - name: deploy # 部署</span><br><span class="line">              run: |</span><br><span class="line">                  ssh work@182.92.xxx.xxx &quot;</span><br><span class="line">                    # 【注意】用 work 账号登录，手动创建 /home/work/imooc-lego 目录</span><br><span class="line">                    # 然后 git clone https://username:password@github.com/imooc-lego/biz-editor-server.git -b dev （私有仓库，使用 github 用户名和密码）</span><br><span class="line">                    # 记得删除 origin ，否则会暴露 github 密码</span><br><span class="line"></span><br><span class="line">                    cd /home/work/imooc-lego/biz-editor-server;</span><br><span class="line">                    git remote add origin https://wangfupeng1988:$&#123;&#123;secrets.WFP_PASSWORD&#125;&#125;@github.com/imooc-lego/biz-editor-server.git;</span><br><span class="line">                    git checkout dev;</span><br><span class="line">                    git pull origin dev; # 重新下载最新代码</span><br><span class="line">                    git remote remove origin; # 删除 origin ，否则会暴露 github 密码</span><br><span class="line">                    # 启动 docker</span><br><span class="line">                    docker-compose build editor-server; # 和 docker-compose.yml service 名字一致</span><br><span class="line">                    docker-compose up -d;</span><br><span class="line">                  &quot;</span><br><span class="line">            - name: delete ssh key # 删除 ssh key</span><br><span class="line">              run: rm -rf ~/.ssh/id_rsa</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>aliyun</tag>
      </tags>
  </entry>
  <entry>
    <title>30-seconds-of-code-study</title>
    <url>/2022/02/07/30-seconds-of-code-study/</url>
    <content><![CDATA[<ul>
<li>已经迁移至<a href="https://foolishmax.github.io/mixin/zh-CN/api/30-seconds-of-code/to-safe-integer">mixin</a></li>
</ul>
]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之express</title>
    <url>/2019/09/08/express%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/</url>
    <content><![CDATA[<h2 id="Node-js-之-express"><a href="#Node-js-之-express" class="headerlink" title="Node.js 之 express"></a>Node.js 之 express</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引包</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于原来的http.createServer</span></span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//公开指定目录</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&quot;/puclic/&quot;</span>, express.<span class="title function_">static</span>(<span class="string">&quot;./public/&quot;</span>));</span><br><span class="line"><span class="comment">//当省略第一个参数的时候，可以通过省略/public的方式访问</span></span><br><span class="line"><span class="comment">//app.use(express.static(&#x27;./public/&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当服务器收到get请求 / 的时候，执行回调函数</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&quot;hello exporess&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/about&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于server.listen</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;app is running at port 3000&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Express-使用-art-template"><a href="#Express-使用-art-template" class="headerlink" title="Express 使用 art-template"></a>Express 使用 art-template</h2><ul>
<li><a href="http://aui.github.io/art-template/express/">Express&amp;art-template 官网</a></li>
<li>Install</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save art-templates</span><br><span class="line">npm install --save express-art-template</span><br></pre></td></tr></table></figure>

<ul>
<li>Example</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">// view engine setup</span><br><span class="line">app.engine(&#x27;art&#x27;, require(&#x27;express-art-template&#x27;));</span><br><span class="line">app.set(&#x27;view&#x27;, &#123;</span><br><span class="line">    debug: process.env.NODE_ENV !== &#x27;production&#x27;</span><br><span class="line">&#125;);</span><br><span class="line">app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));</span><br><span class="line">app.set(&#x27;view engine&#x27;, &#x27;art&#x27;);</span><br><span class="line"></span><br><span class="line">// routes</span><br><span class="line">app.get(&#x27;/&#x27;, function (req, res) &#123;</span><br><span class="line">    res.render(&#x27;index.art&#x27;, &#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">            name: &#x27;aui&#x27;,</span><br><span class="line">            tags: [&#x27;art&#x27;, &#x27;template&#x27;, &#x27;nodejs&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h2><ul>
<li><p>在 Express 中没有内置获取表单 POST 请求体的 API，需要引入一个第三方包：body-parser</p>
</li>
<li><p>Install</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save body-parser</span><br></pre></td></tr></table></figure>

<ul>
<li>config</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;)</span><br><span class="line">var bodyParser = require(&#x27;body-parser&#x27;)</span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">//配置 body-parser,req对象上就会多出来一个 body 属性</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended: false&#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br></pre></td></tr></table></figure>

<ul>
<li>use</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.use(function(req, res)&#123;</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;)</span><br><span class="line">    res.write(&#x27;hello&#x27;)</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/2019/08/23/TypeScript/</url>
    <content><![CDATA[<h3 id="什么是-TypeScript？"><a href="#什么是-TypeScript？" class="headerlink" title="什么是 TypeScript？"></a>什么是 TypeScript？</h3><span id="more"></span>

<ul>
<li><p>TypeScript 是 JavaScript 的超集，任何合法的 js 程序都是合法的 TypeScript 程序</p>
</li>
<li><p>TypeScript 通过向 JavaScript 增加可选的静态类型声明把 JavaScript 变成强类型程序<br>语言</p>
</li>
<li><p>提供静态类型声明可约束函数、变量、属性等程序实体</p>
</li>
</ul>
<h3 id="为什么要使用-TypeScript？"><a href="#为什么要使用-TypeScript？" class="headerlink" title="为什么要使用 TypeScript？"></a>为什么要使用 TypeScript？</h3><ol>
<li><p>提供了静态类型系统，大大增强了代码的可读性以及可维护性</p>
</li>
<li><p>提供最新和不断发展的 javascript 特性，能让我们建立 更健壮的组件</p>
</li>
<li><p>TS 具有防患于未然的静态检查，以及干净利落的只能提示</p>
</li>
</ol>
<h3 id="TypeScript-中的数据类型"><a href="#TypeScript-中的数据类型" class="headerlink" title="TypeScript 中的数据类型"></a>TypeScript 中的数据类型</h3><blockquote>
<p>typescript 中为了使编写的代码更规范，更利于维护，增加了类型校验，在 typescript 中<br>主要提供了以下数据类型：</p>
</blockquote>
<ul>
<li>布尔类型 bolean</li>
<li>数字类型 number</li>
<li>字符串类型 string</li>
<li>数组类型 array</li>
<li>元组类型 tuple</li>
<li>枚举类型 enum</li>
<li>任意类型 any</li>
<li>null 和 undefined</li>
<li>void 类型</li>
<li>never 类型</li>
</ul>
<blockquote>
<p>typescript 中为了使编写的代码更规范，更有利于维护，增加了类型校验，写 ts 代码必须指定类型</p>
</blockquote>
<h3 id="未声明类型的变量-如果变量在声明的时候，未指定其类型，那么他会被识别为任意类"><a href="#未声明类型的变量-如果变量在声明的时候，未指定其类型，那么他会被识别为任意类" class="headerlink" title="未声明类型的变量: 如果变量在声明的时候，未指定其类型，那么他会被识别为任意类"></a>未声明类型的变量: 如果变量在声明的时候，未指定其类型，那么他会被识别为任意类</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> something;</span><br><span class="line"></span><br><span class="line">something = <span class="string">&quot;seven&quot;</span>;</span><br><span class="line"></span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"><span class="comment">//不会报错</span></span><br></pre></td></tr></table></figure>

<h3 id="如果没有明确的指定类型，那么-typescript-会依照类型推论的规则推导出一个规则"><a href="#如果没有明确的指定类型，那么-typescript-会依照类型推论的规则推导出一个规则" class="headerlink" title="如果没有明确的指定类型，那么 typescript 会依照类型推论的规则推导出一个规则"></a>如果没有明确的指定类型，那么 typescript 会依照类型推论的规则推导出一个规则</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="string">&quot;seven&quot;</span>;</span><br><span class="line">num = <span class="number">7</span>;</span><br><span class="line"><span class="comment">//会报错</span></span><br><span class="line"><span class="comment">//上面代码等价于：</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">string</span> = <span class="string">&quot;seven&quot;</span>;</span><br><span class="line">num = <span class="number">7</span>;</span><br><span class="line"><span class="comment">//typescript自动推测出num属于string类型</span></span><br></pre></td></tr></table></figure>

<h3 id="联合类型：表示取值可以为多种类型中的一种"><a href="#联合类型：表示取值可以为多种类型中的一种" class="headerlink" title="联合类型：表示取值可以为多种类型中的一种"></a>联合类型：表示取值可以为多种类型中的一种</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>:<span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">flag = <span class="string">&#x27;seven&#x27;</span></span><br><span class="line">flag = <span class="number">7</span></span><br><span class="line"><span class="comment">//联合类型使用 | 分隔每个类型，表示允许flag为string类型或者number类型</span></span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="comment">//访问联合类型的属性或者方法</span></span><br><span class="line"><span class="comment">//当typescript不确定一个联合类型的变量到底是哪个类型的时候，</span></span><br><span class="line">我们只能访问联合类型的所有类型中共有的属性和方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">something:<span class="built_in">string</span>|<span class="built_in">number</span></span>):<span class="built_in">number</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面代码会报错，因为length不是string和number共有的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以访问共有属性toString()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getString</span>(<span class="params">something:<span class="built_in">string</span>|<span class="built_in">number</span></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> something.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="comment">//联合属性在赋值的时候，会根据类型推论的规则推断出一个类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">string</span>|<span class="built_in">number</span></span><br><span class="line">a = <span class="string">&#x27;seven&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">length</span>) <span class="comment">//5，a被推断为string，有length属性</span></span><br><span class="line">a = <span class="number">7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">length</span>) <span class="comment">//编译时报错，被推断为number，无length属性</span></span><br></pre></td></tr></table></figure>

<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组类型定义(不允许出现其他类型，数组方法参数也有限制，</span></span><br><span class="line">如<span class="title function_">push</span>(<span class="string">&#x27;7&#x27;</span>)会报错，不能为字符串)</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:(<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">2</span>]</span><br><span class="line">---------------------------------</span><br><span class="line"><span class="comment">//数组泛型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//用接口表示数组</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NumberArray</span> &#123;</span><br><span class="line">    [<span class="attr">index</span>:<span class="built_in">number</span>]:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">NumberArray</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//NumberArray表示，只要index的类型时number，那么值的类型也必须时number</span></span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="comment">//any在数组中的应用</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">any</span>[] = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">24</span>, &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明（不允许输入多余或者少于要求的参数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x:<span class="built_in">number</span>, y: <span class="built_in">number</span></span>):<span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//right</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//false</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>) <span class="comment">//false</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">sum</span>:<span class="function">(<span class="params">x:<span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="keyword">function</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>):<span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="comment">//可选参数（使用 ? 表示可选的参数，只能放在参数的最后，后面不允许出现必须参数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName:<span class="built_in">string</span>, lastName?:<span class="built_in">string</span></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = <span class="title function_">buildName</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> tom = <span class="title function_">buildName</span>(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">//参数默认值（typescript会将添加了默认值的参数识别为可选参数）</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName:<span class="built_in">string</span>, lastName:<span class="built_in">string</span> = <span class="string">&#x27;cat&#x27;</span></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">            <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> firstName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tomcat = <span class="title function_">buildName</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> tom = <span class="title function_">buildName</span>(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment">//剩余参数，可以使用...rest的方式获取函数中的剩余参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items:<span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        array.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = []</span><br><span class="line"><span class="title function_">push</span>(a, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="comment">//重载：允许一个函数接受不同数量或者类型的参数时，做出不同的处理</span></span><br><span class="line"><span class="comment">//例如，数字或者字符串的反转输出</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="built_in">number</span> | <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Number</span>(x.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型（注意点）"><a href="#泛型（注意点）" class="headerlink" title="泛型（注意点）"></a>泛型（注意点）</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">A1</span> = <span class="string">&quot;x&quot;</span> <span class="keyword">extends</span> <span class="string">&quot;x&quot;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A2</span> = <span class="string">&quot;x&quot;</span> | <span class="string">&quot;y&quot;</span> <span class="keyword">extends</span> <span class="string">&quot;x&quot;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">&quot;x&quot;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A3</span> = P&lt;<span class="string">&quot;x&quot;</span> | <span class="string">&quot;y&quot;</span>&gt;; <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>这里的<em>extends</em>是指<strong>类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集</strong>。<br>P 是带参数 T 的泛型类型，A1 和 A2 的形式一样，结果也很好理解，A3 是泛型类型 P 传入参数<br>**’x’ | ‘y’**得到的类型，如果将 <strong>‘x’ | ‘Y’</strong> 代入泛型类的表达式，那应该会得到和 A2 类型的形式完全一样的结果，这里直接给结论了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type P&lt;T&gt; = T extends &#x27;x&#x27; ? string : number;</span><br><span class="line">type A3 = P&lt;&#x27;x&#x27; | &#x27;y&#x27;&gt; // A3的类型是 string ｜ number</span><br></pre></td></tr></table></figure>

<p>结果是不是出人意料？原因就是<strong>分配条件类型</strong>,在 TS 中对于 extends 关键字的条件类型（即上面的三元表达式类型），如果<em>extends</em>前面的参数是一个(裸类型)泛型类型，当传入该参数的是联合类型，则使用分配律计算最终结果。</p>
<p><em>分配律</em>是指，将联合型类的联合项拆分成单项，分别代入条件类型，然后将每个单项代入，再将得到的结果联合起来，得到最终的结果。</p>
<ul>
<li>特殊的 never</li>
</ul>
<p>那么，我们在看一个例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">A1</span> = <span class="built_in">never</span> <span class="keyword">extends</span> <span class="string">&quot;x&quot;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">&quot;x&quot;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A2</span> = P&lt;<span class="built_in">never</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，A2 和 A1 的结果竟然不一样，看起来<em>never</em>并不是一个联合类型啊，所以直接代入条件类型获取的结果应该和 A1 相同才对啊？</p>
<p>实际上，<strong>never 被认为是空的联合类型</strong>，never 是一个没有联合项的联合类型，所以还是满足上面的分配律，又因为没有联合项可以分配，所以*P<T>*的表达式根本就没有执行，所以 A2 的定义就类似于永远没有返回的函数一样，是 never 类型。</p>
<ul>
<li>如何防止条件判断中的分配</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> P&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="string">&quot;x&quot;</span>] ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A1</span> = P&lt;<span class="string">&quot;x&quot;</span> | <span class="string">&quot;y&quot;</span>&gt;; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A2</span> = P&lt;<span class="built_in">never</span>&gt;; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>在条件判断类型的定义中，将泛型参数使用 <strong>[]</strong> 括起来，即可阻断条件判断类型的分配，此时，传入的 T 的类型就会被当作一个整体，不再分配。</p>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>http深入浅出</title>
    <url>/2019/09/06/http%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/</url>
    <content><![CDATA[<h2 id="HTTP-简介"><a href="#HTTP-简介" class="headerlink" title="HTTP 简介"></a>HTTP 简介</h2><span id="more"></span>

<p>HTTP(HyperText Transfer Protocol)超文本传输协议，是万维网(World Wide Web)的基础协议</p>
<p>HTTP/0.9 (1991)</p>
<ul>
<li>仅仅支持 GET 请求</li>
<li>不包含 HTTP 头，只能传输 HTML 文件</li>
<li>没有状态码和错误代码</li>
</ul>
<p>HTTP/1.0 (1996)</p>
<ul>
<li>发送时添加 协议版本信息 (/HTTP/1.1)</li>
<li>添加响应状态码，如 200，404 等</li>
<li>引入 HTTP 头，多了传递信息的手段，更加灵活和方便拓展</li>
<li>HTTP 头引入 content-type 属性，具备了传输除纯文本 HTML 文件以外其他类型文档的能力</li>
</ul>
<p>HTTP/1.1 (1997)</p>
<ul>
<li>连接复用，长链接。多个请求复用同一个 tcp 连接，1.0 每次请求都需要重新建立连接(Connection: keep-alive Keep-Alive:timeout=5)</li>
<li>管道化技术：多个连续的请求不用等待返回就可以被发送，减少网络延迟的耗时</li>
<li>响应分块：单个请求返回部分内容(状态码 206)</li>
<li>新的缓存控制机制，引入 cache-control,eTag</li>
<li>新增 host 请求头，能够使不同域名配置在同一个 IP 地址服务器上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul>
<li><p>https(Hypertext Transfer Protocal Secure):超文本传输安全协议，在 http 基础上加了 secure 安全</p>
</li>
<li><p>https 是 http 协议的一种扩展，使用传输层安全性<strong>TLS</strong>或安全套接字层<strong>SSL</strong>对通信协议进行加密</p>
</li>
</ul>
<h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><ul>
<li><p>二进制帧</p>
</li>
<li><p>多路复用</p>
</li>
<li><p>头部压缩</p>
</li>
<li><p>服务端推送</p>
</li>
</ul>
<h2 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h2><ul>
<li>基于 UDP 的传输层下协议，特点快</li>
</ul>
<h2 id="创建一个简单的-http-服务"><a href="#创建一个简单的-http-服务" class="headerlink" title="创建一个简单的 http 服务"></a>创建一个简单的 http 服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加载http核心模块</span><br><span class="line">var http = require(&#x27;http&#x27;)</span><br><span class="line"></span><br><span class="line">var server = http.createServer()</span><br><span class="line"></span><br><span class="line">//服务器要做的处理事情</span><br><span class="line">server.on(&#x27;request&#x27;, function() &#123;</span><br><span class="line">    console.log(&#x27;收到客户端的请求了&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//绑定端口号，启动服务器</span><br><span class="line">server.listen(3000, function()&#123;</span><br><span class="line">    console.log(&#x27;server start.....&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;)</span><br><span class="line"></span><br><span class="line">var server = http.createServer()</span><br><span class="line"></span><br><span class="line">//request 请求处理函数，需要接受两个参数</span><br><span class="line">server.on(&#x27;request&#x27;, function(request, response) &#123;</span><br><span class="line">//  request 请求对象</span><br><span class="line">//  请求对象可以获取客户端的一些请求信息，如请求路径</span><br><span class="line">    console.log(&#x27;收到客户端的请求了,路径是：&#x27;+ request.url)</span><br><span class="line"></span><br><span class="line">//  response 响应对象</span><br><span class="line">//  响应数据只能是二进制数据或者字符串</span><br><span class="line">//  响应对象可以用开给客户端发送响应消息</span><br><span class="line">//  response对象中：write给客户端发送响应数据，最后使用end结束</span><br><span class="line">    response.write(&#x27;hello&#x27;)</span><br><span class="line">    response.write(&#x27; nodejs &#x27;)</span><br><span class="line">    response.end(request.url)</span><br><span class="line"></span><br><span class="line">//  或者直接end的同时发送响应数据：</span><br><span class="line">//  response.end(&#x27;hello nodejs&#x27;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(3000, function()&#123;</span><br><span class="line">    console.log(&#x27;server start.....&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Content-Type-设置编码"><a href="#Content-Type-设置编码" class="headerlink" title="Content-Type 设置编码"></a>Content-Type 设置编码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;)</span><br><span class="line">var server = http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(&#x27;request&#x27;,function (req,res) &#123;</span><br><span class="line">    //设置服务器响应内容的编码</span><br><span class="line">    res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/plain;charset=utf-8&#x27;)</span><br><span class="line">    res.end(&#x27;hello 世界&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000, function () &#123;</span><br><span class="line">    console.log(&#x27;server is running...&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>js引擎的预编译和执行</title>
    <url>/2019/08/13/js%E5%BC%95%E6%93%8E%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="var-的变量提升底层原理"><a href="#var-的变量提升底层原理" class="headerlink" title="var 的变量提升底层原理"></a>var 的变量提升底层原理</h2><span id="more"></span>

<pre><code>JavaScript引擎，不是逐条解释执行javascript代码，而是按照代码块一段段解释执行，
所谓代码块就是script标签分割的代码块。
js引擎的工作方式分为：预编译和执行代码两个阶段。

1）常见的编译型语言编译阶段：词法分析（生成词法单元）——&gt;语法分析（抽象语法树）——&gt;(语义检查，代码优化)——&gt;代码生成

2）对于解释型语言来说，通过词法分析和语法分析得到抽象语法树之后就开始执行了，在JavaScript
解释器在构造语法树的时候，如果无法构造，就会报语法错误，并结束整个代码块的执行。
而在整个编译阶段，会把“一等公民”function和var创建的变量进行提升。（其中函数提升在变量
提成之前）

3）JavaScript语法采用的是词法作用域，也就是javascript的变量和函数作用域是在定义时
决定的，函数调用时决定的是执行期上下文和作用域链，所以js解释器只需要静态分析就能确定每个
变量、函数的作用域，这种作用域也称为静态作用域。
</code></pre>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ul>
<li><p>全局执行上下文：默认的上下文，任何不再函数内部的代码都在全局上下文中。它会执行两<br>件事：创建一个全局的 window 对象(浏览器的情况下)，并且设置 this 的值等于这个全局对象。<br>一个程序只会有一个全局执行上下文。</p>
</li>
<li><p>函数执行上下文：每当函数被调用时，都会为该函数创建一个新的上下文。</p>
</li>
<li><p>Eval 函数执行上下文：执行在 eval 函数内部的代码也会有属于它自己的执行上下文。</p>
<p>执行栈：JavaScript 引擎会以栈的方式来处理多个执行期上下文其他语言叫“调用栈”，<br>类似于数据结构的栈 LIFO(后进先出)，用来存储代码运行时创建的所有执行上下文。<br>栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。</p>
<p>当 JavaScript 引擎第一次遇见脚本时，它会创建一个全局的执行上下文并且压入当前<br>执行栈，每当引擎遇到一个函数调用，会为该函数创建一个新的执行上下文并压入栈的顶部。</p>
<p>引擎会执行那些执行上下文位于栈顶的函数，当函数执行结束时，执行上下文从栈顶<br>弹出，控制流程到达当前栈中的下一个上下文。</p>
<p>当函数执行时，会创建一个成为 执行期上下文的内部对象。</p>
<p>执行期上下文就是 js 代码被解析和执行时的运行环境，函数每次执行都会创建一个独一无二的执行上下文，所以多次调用会产生<br>多个执行上下文，当函数执行完毕，所产生的执行上下文被销毁。</p>
<p>执行上下文的生命周期包括三个阶段：<br>创建阶段-&gt;执行阶段-&gt;挥手阶段</p>
<p>创建阶段会创建变量对象(Variable Object)，建立作用域链，确定 this 指向 1. 创建 Scope chain 2. 创建 AO 3. 设置 this 的值<br>创建 AO 主要做了以下事情： 1. 创建 AO 对象 2. 形参和变量声明存储到 AO 对象 //赋值为 undefined 3. 将形参和实参相统一 4. 函数声明的函数名作为 AO 对象的 key，函数体作为 value</p>
<p>执行阶段会完成变量赋值，函数引用，以及执行其他代码。</p>
</li>
<li><p>AO(Active Object) &amp; VO(Variable Object)的区别？</p>
<ul>
<li>VO：未进入执行上下文执行阶段之前，变量对象中的属性都不能访问。</li>
<li>AO：进入执行阶段之后，变量对象转变为活动对象，里面的属性都能访问了。</li>
<li>它们都是同一个对象，只是处于执行上下文的不同生命周期，而且只有处于<br>函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。</li>
</ul>
<p>如果函数引用了外部变量的值，则 JavaScript 引擎会为改函数创建一个闭包体（closure），<br>闭包体是一个完全封闭和独立的作用域，他不会在函数调用完毕后就被 js 引擎当作垃圾<br>进行回收，闭包体可以长期存在。</p>
</li>
</ul>
<ul>
<li>执行上下文总结：<ul>
<li>单线程</li>
<li>同步执行，只有栈顶的上下文处于执行中，而其他上下文需要等待</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈，而且其他所有上下文环境<br>都可以直接访问全局上下文的属性</li>
<li>函数的执行上下文的个数没有限制</li>
<li>每次某个函数被调用，就会有新的执行上下文为其创建，即使是调用的自身函数，也是如此。</li>
</ul>
</li>
</ul>
<h2 id="JS-执行机制"><a href="#JS-执行机制" class="headerlink" title="JS 执行机制"></a>JS 执行机制</h2><pre><code>同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入Event Table
并注册函数。

当指定的事情完成时（例如定时器执行完毕，获取数据结束等），Event Table会将这个函数移入Event Queue

主线程内的任务执行完毕为空，会去Event Queue（事件队列）读取对应的函数，进入主线程执行。

上述过程不断重复，称为Event Loop（事件轮询）
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>docker实践指南</title>
    <url>/2022/07/31/docker%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><span id="more"></span>

<h3 id="获取镜像-docker-pull"><a href="#获取镜像-docker-pull" class="headerlink" title="获取镜像 docker pull"></a>获取镜像 docker pull</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker pull 从镜像仓库中拉取或者更新指定镜像</span></span><br><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure>

<h3 id="列出已经下载的镜像-docker-images"><a href="#列出已经下载的镜像-docker-images" class="headerlink" title="列出已经下载的镜像 docker images"></a>列出已经下载的镜像 docker images</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出某一个镜像</span></span><br><span class="line">docker images ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="删除镜像-docker-rmi"><a href="#删除镜像-docker-rmi" class="headerlink" title="删除镜像 docker rmi"></a>删除镜像 docker rmi</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi 501</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or</span></span><br><span class="line">docker rmi centos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker prune命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有未被tag标记或者未被容器使用的镜像</span></span><br><span class="line">docker image prune</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有未被容器使用的镜像</span></span><br><span class="line">docker image prune -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有停止运行的容器</span></span><br><span class="line">docker container prune</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有未被挂载的卷</span></span><br><span class="line">docker volume prune</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有网络</span></span><br><span class="line">docker network prune</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除docker所有资源</span></span><br><span class="line">docker system prune</span><br></pre></td></tr></table></figure>

<h3 id="上传镜像-docker-push"><a href="#上传镜像-docker-push" class="headerlink" title="上传镜像 docker push"></a>上传镜像 docker push</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker push:将本地的镜像上传到镜像仓库，先登录镜像仓库</span></span><br><span class="line">docker push mynode:v1</span><br></pre></td></tr></table></figure>

<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="列出容器-docker-ps"><a href="#列出容器-docker-ps" class="headerlink" title="列出容器 docker ps"></a>列出容器 docker ps</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a :显示所有的容器，包括未运行的</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<h3 id="停止容器-docker-stop"><a href="#停止容器-docker-stop" class="headerlink" title="停止容器 docker stop"></a>停止容器 docker stop</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止运行中的容器myrunoob</span></span><br><span class="line">docker stop myrunoob</span><br></pre></td></tr></table></figure>

<h3 id="启动容器-docker-start"><a href="#启动容器-docker-start" class="headerlink" title="启动容器 docker start"></a>启动容器 docker start</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动已被停止的容器myrunoob</span></span><br><span class="line">docker start myrunoob</span><br></pre></td></tr></table></figure>

<h3 id="重启容器-docker-restart"><a href="#重启容器-docker-restart" class="headerlink" title="重启容器 docker restart"></a>重启容器 docker restart</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器myrunoob</span></span><br><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure>

<h3 id="删除容器-docker-rm"><a href="#删除容器-docker-rm" class="headerlink" title="删除容器 docker rm"></a>删除容器 docker rm</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制删除容器 db01、db02</span></span><br><span class="line">docker rm -f db01 db02</span><br></pre></td></tr></table></figure>

<h3 id="查看容器信息-docker-inspect"><a href="#查看容器信息-docker-inspect" class="headerlink" title="查看容器信息 docker inspect"></a>查看容器信息 docker inspect</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取容器/镜像的元数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取镜像mysql:5.6的元信息</span></span><br><span class="line">docker inspect mysql:5.6</span><br></pre></td></tr></table></figure>

<h3 id="查看容器日志-docker-logs"><a href="#查看容器日志-docker-logs" class="headerlink" title="查看容器日志 docker logs"></a>查看容器日志 docker logs</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">跟踪查看容器mynginx的日志输出</span></span><br><span class="line">docker logs -f mynginx</span><br></pre></td></tr></table></figure>

<h3 id="进入容器控制台-docker-exec"><a href="#进入容器控制台-docker-exec" class="headerlink" title="进入容器控制台 docker exec"></a>进入容器控制台 docker exec</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 在运行的容器中执行命令</span><br><span class="line">// -d:分离模式，在后台运行</span><br><span class="line">// -i: 即使没有附加也保持STDIN打开</span><br><span class="line">// -t: 分配一个伪终端</span><br><span class="line">// docker exec -it &lt;container-id&gt; /bin/sh</span><br><span class="line"></span><br><span class="line">// 执行 exit 退出</span><br></pre></td></tr></table></figure>

<h2 id="启动-docker"><a href="#启动-docker" class="headerlink" title="启动 docker"></a>启动 docker</h2><!--more-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open /Applications/Docker.app</span><br></pre></td></tr></table></figure>

<h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><p>eg1:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run ubuntu:15.10 /bin/echo &#x27;hello world&#x27;</span><br></pre></td></tr></table></figure>

<p>各个参数解析：</p>
<ul>
<li><p>docker：Docker 的二进制执行文件</p>
</li>
<li><p>run：与 docker 组合来运行一个容器</p>
</li>
<li><p>ubuntu:15.10 指定要运行的景象，docker 先从本地主机查找景象是否存在，如不存在，docker 就会从 <a href="https://hub.docker.com/">Docker hub</a>镜像仓库下载公共镜像</p>
</li>
<li><p>/bin/echo ‘hello world’：在启动的容器中执行的命令</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li><p>不存在时会出现错误信息： <em>Unable to find image ‘ubuntu:15.10’ locally</em></p>
</li>
<li><p>之后便会从镜像仓库下载公共镜像</p>
</li>
<li><p>打印 hello world</p>
</li>
<li><p>M1-Mac 可能会出现如下警告：<em>WARNING: The requested image’s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested</em></p>
<ul>
<li>解决方法：<strong>docker run –platform linux/amd64 ubuntu:15.10 /bin/echo ‘hello world’</strong></li>
</ul>
</li>
</ul>
<p>eg2:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 启动容器 docker run -p xxx:xxx -v=hostPath:containerPath -d --name &lt;container-name&gt; &lt;image-name&gt;</span><br><span class="line">// -p 端口映射</span><br><span class="line">// -v 数据卷，文件映射</span><br><span class="line">// -d 后台运行</span><br><span class="line">// --name 定义容器名称</span><br><span class="line">docker run -p 81:80 -d --name nginx1 nginx</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文件内容包含一条条构建镜像所需的指令和说明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Dockerfile</span></span><br><span class="line">FROM node:latest</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line">RUN npm set registry https://registry.npm.taobao.org</span><br><span class="line">RUN npm install</span><br><span class="line">RUN npm install pm2 -g</span><br><span class="line"></span><br><span class="line">CMD echo $SERVER_NAME &amp;&amp; echo $AUTHOR_NAME &amp;&amp; npm run start &amp;&amp; npx npm2 log</span><br><span class="line"></span><br><span class="line">ENV SERVER_NAME = &#x27;react-demo&#x27;</span><br><span class="line">ENV AUTHOR_NAME = &#x27;foolishmax&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure>

<h2 id="始构建镜像"><a href="#始构建镜像" class="headerlink" title="始构建镜像"></a>始构建镜像</h2><p>在 Dockerfile 文件的存放目录下，执行构建动作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker bild -t react-demo-image .</span><br></pre></td></tr></table></figure>

<h2 id="docker-images-查看"><a href="#docker-images-查看" class="headerlink" title="docker images 查看"></a>docker images 查看</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPOSITORY         TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">react-demo-image   latest    35c499bddac6   3 minutes ago   1.22GB</span><br><span class="line">node-test          latest    028a51c6e54d   8 months ago    945MB</span><br><span class="line">nginx              latest    f1325989da19   8 months ago    134MB</span><br></pre></td></tr></table></figure>

<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 8081:3000 -d --name react-demo-server react-demo-image</span><br></pre></td></tr></table></figure>

<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONTAINER ID   IMAGE              COMMAND                  CREATED         STATUS         PORTS                    NAMES</span><br><span class="line">f71ef1480035   react-demo-image   &quot;docker-entrypoint.s…&quot;   4 seconds ago   Up 3 seconds   0.0.0.0:8081-&gt;3000/tcp   react-demo-server</span><br></pre></td></tr></table></figure>

<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>docker logs f71ef1480035</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这两行对应Dockerfile中的CMD变量打印</span><br><span class="line">= react-demo</span><br><span class="line">= foolishmax</span><br><span class="line"></span><br><span class="line">&gt; react-demo@0.1.0 start</span><br><span class="line">&gt; react-scripts start</span><br><span class="line"></span><br><span class="line">(node:27) [DEP_WEBPACK_DEV_SERVER_ON_AFTER_SETUP_MIDDLEWARE] DeprecationWarning: &#x27;onAfterSetupMiddleware&#x27; option is deprecated. Please use the &#x27;setupMiddlewares&#x27; option.</span><br><span class="line">(Use `node --trace-deprecation ...` to show where the warning was created)</span><br><span class="line">(node:27) [DEP_WEBPACK_DEV_SERVER_ON_BEFORE_SETUP_MIDDLEWARE] DeprecationWarning: &#x27;onBeforeSetupMiddleware&#x27; option is deprecated. Please use the &#x27;setupMiddlewares&#x27; option.</span><br><span class="line">Starting the development server...</span><br><span class="line"></span><br><span class="line">Compiled successfully!</span><br><span class="line"></span><br><span class="line">You can now view react-demo in the browser.</span><br><span class="line"></span><br><span class="line">  Local:            http://localhost:3000</span><br><span class="line">  On Your Network:  http://172.17.0.2:3000</span><br><span class="line"></span><br><span class="line">Note that the development build is not optimized.</span><br><span class="line">To create a production build, use npm run build.</span><br><span class="line"></span><br><span class="line">webpack compiled successfully</span><br><span class="line">Compiling...</span><br><span class="line">Compiled successfully!</span><br><span class="line">webpack compiled successfully</span><br></pre></td></tr></table></figure>

<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p>docker stop f71ef1480035</p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>docker rm f71ef1480035</p>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>docker rmi 35c499bddac6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Untagged: react-demo-image:latest</span><br><span class="line">Deleted: sha256:35c499bddac6675ff20a7d951fc1c1f6770a10430278fec6f2b8d1c866037624</span><br></pre></td></tr></table></figure>

<h2 id="docker-compose-yml-文件"><a href="#docker-compose-yml-文件" class="headerlink" title="docker-compose.yml 文件"></a>docker-compose.yml 文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">edditor-server:</span> <span class="comment"># service name</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span> <span class="comment">#当前目录</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span> <span class="comment">#  基于Dockerfile构建</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">editor-server</span> <span class="comment">#依赖当前dockerfile创建出来的镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">editor-server</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:3000</span> <span class="comment">#宿主机通过8081访问</span></span><br><span class="line">  <span class="attr">editor-redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span> <span class="comment">#引用官方redis镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">editor-redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6378</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span> <span class="comment"># 设置时区</span></span><br><span class="line">  <span class="attr">editor-mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span> <span class="comment"># 引用官网 mysql 镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">editor-mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> <span class="comment"># 出错则重启</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span> <span class="comment"># 高权限，执行下面的 mysql/init</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authentication-plugin=mysql_native_password</span> <span class="comment"># 远程访问</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3305</span><span class="string">:3306</span> <span class="comment"># 宿主机可以用 127.0.0.1:3305 即可连接容器中的数据库，和 redis 一样</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.docker-volumes/mysql/log:/var/log/mysql</span> <span class="comment"># 记录日志</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.docker-volumes/mysql/data:/var/lib/mysql</span> <span class="comment"># 数据持久化</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/init:/docker-entrypoint-initdb.d/</span> <span class="comment"># 初始化 sql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=imooc_lego_course</span> <span class="comment"># 初始化容器时创建数据库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=Mysql_2019</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span> <span class="comment"># 设置时区</span></span><br><span class="line">  <span class="attr">editor-mongo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span> <span class="comment"># 引用官网 mongo 镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">editor-mongo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;.docker-volumes/mongo/data:/data/db&quot;</span> <span class="comment"># 数据持久化,映射本地文件</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MONGO_INITDB_DATABASE=imooc_lego_course</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span> <span class="comment"># 设置时区</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;27016:27017&quot;</span> <span class="comment"># 宿主机可以用 127.0.0.1:27016 即可连接容器中的数据库</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构建容器 docker-compose build <service-name></li>
<li>启动所有服务器 docker-compose up -d,后台启动</li>
<li>查看服务 docker-compose ps (相比较 docker ps 等于多了层作用域)</li>
<li>停止所有服务 docker-compose down</li>
</ul>
<p>注意：<br>经过以上操作之后需修改.gitignore 文件，增加一行 <em>.docker-volumes/</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript常用api合集</title>
    <url>/2020/07/17/javascript%E5%B8%B8%E7%94%A8api%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="一、节点"><a href="#一、节点" class="headerlink" title="一、节点"></a>一、节点</h2><h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node.nodeName //返回节点名称，只读</span><br><span class="line">Node.nodeType //返回节点类型的常数值，只读</span><br><span class="line">Node.nodeValue //返回Text或Comment节点的文本值，只读</span><br><span class="line">Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写</span><br><span class="line">Node.baseURI //返回当前网页的绝对路径</span><br><span class="line"></span><br><span class="line">Node.ownerDocument //返回当前节点所在的顶层文档对象，即document</span><br><span class="line">Node.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点</span><br><span class="line">Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点</span><br><span class="line">Node.parentNode //返回当前节点的父节点</span><br><span class="line">Node.parentElement //返回当前节点的父Element节点</span><br><span class="line">Node.childNodes //返回当前节点的所有子节点</span><br><span class="line">Node.firstChild //返回当前节点的第一个子节点</span><br><span class="line">Node.lastChild //返回当前节点的最后一个子节点</span><br><span class="line"></span><br><span class="line">Node.children //返回当前节点的所有Element子节点</span><br><span class="line">Node.firstElementChild //返回当前节点的第一个Element子节点</span><br><span class="line">Node.lastElementChild //返回当前节点的最后一个Element子节点</span><br><span class="line">Node.childElementCount //返回当前节点所有Element子节点的数目</span><br></pre></td></tr></table></figure>

<!--more-->

<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node.appendChild(node) //向节点添加最后的子节点</span><br><span class="line">Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点</span><br><span class="line">Node.cloneNode(true) //默认为false(克隆节点),true(克隆节点及其属性，以及后代)</span><br><span class="line">Node.insertBefore(newNode,oldNode) //在指定子节点前插入新的子节点</span><br><span class="line">Node.removeChild(node) //删除节点，在要删除节点的父节点上操作</span><br><span class="line">Node.replaceChild(newChild,oldChild) //替换节点</span><br><span class="line">Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点</span><br><span class="line">Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系</span><br><span class="line">Node.isEqualNode(node) //返回布尔值，用于检查两个节点是否想等，所谓的相等节点，指的的两个节点的类型、属性、子节点都相同</span><br><span class="line">Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个</span><br><span class="line"></span><br><span class="line">ChildNode.remove()  //用于删除当前节点</span><br><span class="line">ChildNode.before()  //在ChildNode前插入元素节点或者文本节点</span><br><span class="line">ChildNode.after()  //在ChildNode后插入元素或文本节点</span><br><span class="line">ChildNode.replaceWith()  //替换该节点的父节点下的子节点，可以为文本或元素对象</span><br></pre></td></tr></table></figure>

<h3 id="Document-节点"><a href="#Document-节点" class="headerlink" title="Document 节点"></a>Document 节点</h3><h4 id="Document-节点的属性"><a href="#Document-节点的属性" class="headerlink" title="Document 节点的属性"></a>Document 节点的属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.doctype //返回当前文档关联的文档类型定义(DTD)</span><br><span class="line">document.documentElement //返回当前文档的根节点(html)</span><br><span class="line">document.defaultView //返回document对象所在的window对象</span><br><span class="line">document.body //返回当前文档的&lt;body&gt;节点</span><br><span class="line">document.head //返回当前文档的&lt;head&gt;节点</span><br><span class="line">document.activeElement //返回当前文档中获得焦点的那个元素</span><br><span class="line"></span><br><span class="line">document.links //返回当前文档的所有a元素</span><br><span class="line">document.forms //返回页面中所有表单元素</span><br><span class="line">document.images //返回页面中所有图片元素</span><br><span class="line">document.embeds //返回网页中所有嵌入对象</span><br><span class="line">document.scripts //返回当前文档的所有脚本</span><br><span class="line">document.styleSheets //返回当前网页的所有样式表</span><br><span class="line"></span><br><span class="line">document.documentURI //表示当前文档的网址</span><br><span class="line">document.URI //返回当前文档的网址</span><br><span class="line">document.domain //返回当前文档的域名</span><br><span class="line">document.lastModified //返回当前文档最后修改的时间戳</span><br><span class="line">document.location //返回location对象，提供当前文档的URL信息</span><br><span class="line">document.referrer //返回当前文档的访问来源</span><br><span class="line">document.title //返回当前文档的标题</span><br><span class="line">document.characterSet //属性返回渲染当前文档的字符集，比如UTF-8</span><br><span class="line">document.readyState //返回当前文档的状态</span><br><span class="line">document.designMode //控制当前文档是否可编辑，可读写</span><br><span class="line">document.compatMode //返回浏览器处理文档的模式</span><br><span class="line">document.cookie //用来操作Cookie</span><br></pre></td></tr></table></figure>

<h3 id="Document-节点的方法"><a href="#Document-节点的方法" class="headerlink" title="Document 节点的方法"></a>Document 节点的方法</h3><h4 id="读写方法"><a href="#读写方法" class="headerlink" title="读写方法"></a>读写方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.open() //用于新建并打开一个文档</span><br><span class="line">document.close() //关闭open方法所新建的文档</span><br><span class="line">document.write() //用于向当前文档写入内容</span><br><span class="line">document.writeIn() //用于向当前文档写入内容，尾部添加换行符</span><br></pre></td></tr></table></figure>

<h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.querySelector(selectors) //接收一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点</span><br><span class="line">document.querySelectorAll(selectors) //接收一个CSS选择器作为参数，返回所有匹配该选择器的元素节点</span><br><span class="line">document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素</span><br><span class="line">document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素</span><br><span class="line">document.getElementsByName(name) //用于选择拥有name属性的HTML元素(比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;object&gt;等)</span><br><span class="line">document.getElementById(id) //返回匹配指定id属性的元素节点</span><br><span class="line">document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点</span><br></pre></td></tr></table></figure>

<h4 id="生成节点"><a href="#生成节点" class="headerlink" title="生成节点"></a>生成节点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.createElement(tagName) //用来生成HTML元素节点</span><br><span class="line">document.createTextNode(text) //用来生成文本节点</span><br><span class="line">document.createAttribute(name) //生成一个新的属性对象节点，并返回</span><br><span class="line">document.createDocumentFragment() //生成一个DocumentFragment对象</span><br></pre></td></tr></table></figure>

<h4 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用</span><br><span class="line">document.addEventListener(type,listener,capture) //注册事件</span><br><span class="line">document.removeEventListener(type,listener,capture) //注销事件</span><br><span class="line">document.dispatchEvent(event) //触发事件</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点</span><br><span class="line">document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点</span><br><span class="line">document.importNode(externalNode,deep) //从外部文档拷贝指定节点，插入当前文档</span><br></pre></td></tr></table></figure>

<h3 id="Element-节点"><a href="#Element-节点" class="headerlink" title="Element 节点"></a>Element 节点</h3><h4 id="Element-节点的属性"><a href="#Element-节点的属性" class="headerlink" title="Element 节点的属性"></a>Element 节点的属性</h4><h5 id="特性属性"><a href="#特性属性" class="headerlink" title="特性属性"></a>特性属性</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.attributes //返回当前元素节点的所有属性节点</span><br><span class="line">Element.id //返回指定元素的id属性，可读写</span><br><span class="line">Element.tagName //返回指定元素的大写标签名</span><br><span class="line">Element.innerHTML //返回该元素包含的HTML代码，可读写</span><br><span class="line">Element.outerHTML //返回该元素节点的所有HTML代码，包括自身和所有子元素，可读写</span><br><span class="line">Element.className //返回当前元素的class属性，可读写</span><br><span class="line">Element.classList //返回当前元素节点的所有class集合</span><br><span class="line">Element.dataset //返回元素节点中所有data-*属性</span><br></pre></td></tr></table></figure>

<h5 id="尺寸属性"><a href="#尺寸属性" class="headerlink" title="尺寸属性"></a>尺寸属性</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.clientHeight //返回元素节点可见部分的高度</span><br><span class="line">Element.clientWidth //返回元素节点可见部分的宽度</span><br><span class="line">Element.clientLeft //返回元素节点左边框的宽度</span><br><span class="line">Element.clientTop //返回元素节点顶部边框的宽度</span><br><span class="line"></span><br><span class="line">Element.scrollHeight //返回元素节点的总高度</span><br><span class="line">Element.scrollWidth //返回元素节点的总宽度</span><br><span class="line">Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值，通过设置这个属性可以改变元素滚动的位置</span><br><span class="line">Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值</span><br><span class="line"></span><br><span class="line">Element.offsetHeight //返回元素的垂直高度(包含border，padding)</span><br><span class="line">Element.offsetWidth //返回元素的水平宽度(包含border，padding)</span><br><span class="line">Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移</span><br><span class="line">Element.offsetTop //返回水平位移</span><br><span class="line"></span><br><span class="line">Element.style //返回元素节点的行内样式</span><br></pre></td></tr></table></figure>

<h5 id="节点相关属性"><a href="#节点相关属性" class="headerlink" title="节点相关属性"></a>节点相关属性</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.children //包括当前元素节点的所有子元素</span><br><span class="line">Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数</span><br><span class="line">Element.firstElementChild //返回当前节点的第一个Element子节点</span><br><span class="line">Element.lastElementChild //返回当前节点的最后一个Element子节点</span><br><span class="line">Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点</span><br><span class="line">Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML元素节点</span><br><span class="line">Element.offsetParent //返回当前元素节点的最靠近、并且CSS的position属性不等于static的父元素</span><br></pre></td></tr></table></figure>

<h4 id="Element-节点的方法"><a href="#Element-节点的方法" class="headerlink" title="Element 节点的方法"></a>Element 节点的方法</h4><h5 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getBoundingClientRect() //获取元素位置</span><br><span class="line">getClientRects() //返回当前元素在页面上的矩形区域</span><br></pre></td></tr></table></figure>

<h5 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.getAttribute() //读取指定属性</span><br><span class="line">Element.setAttribute() //设置指定属性</span><br><span class="line">Element.hasAttribute() //返回一个布尔值，表示当前元素节点是否有指定属性</span><br><span class="line">Element.removeAttribute() //移除指定属性</span><br></pre></td></tr></table></figure>

<h5 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.querySelector()</span><br><span class="line">Element.querySelectorAll()</span><br><span class="line">Element.getElementByTagName()</span><br><span class="line">Element.getElementByClassName()</span><br></pre></td></tr></table></figure>

<h5 id="事件方法-1"><a href="#事件方法-1" class="headerlink" title="事件方法"></a>事件方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.addEventListener() //添加事件的回调函数</span><br><span class="line">Element.removeEventListener() //移除事件监听函数</span><br><span class="line">Element.dispatchEvent() //触发事件</span><br><span class="line"></span><br><span class="line">//ie8</span><br><span class="line">Element.attachEvent(oneventName,listener)</span><br><span class="line">Element.detachEvent(oneventName,listener)</span><br><span class="line"></span><br><span class="line">//event对象</span><br><span class="line">var event = window.event||event</span><br><span class="line"></span><br><span class="line">//事件的目标节点</span><br><span class="line">var target = event.target || event.srcElement</span><br><span class="line"></span><br><span class="line">//事件代理</span><br><span class="line">ul.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">    if(event.target.tagName.toLowerCase() === &#x27;li&#x27;)&#123;</span><br><span class="line">        console.log(event.target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Element.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域</span><br><span class="line"></span><br><span class="line">//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。</span><br><span class="line">Element.insertAdjacentHTML(where, htmlString);</span><br><span class="line">Element.insertAdjacentHTML(&#x27;beforeBegin&#x27;, htmlString); // 在该元素前插入</span><br><span class="line">Element.insertAdjacentHTML(&#x27;afterBegin&#x27;, htmlString); // 在该元素第一个子元素前插入</span><br><span class="line">Element.insertAdjacentHTML(&#x27;beforeEnd&#x27;, htmlString); // 在该元素最后一个子元素后面插入</span><br><span class="line">Element.insertAdjacentHTML(&#x27;afterEnd&#x27;, htmlString); // 在该元素后插入</span><br><span class="line"></span><br><span class="line">Element.remove()  //用于将当前元素节点从DOM中移除</span><br><span class="line">Element.focus()   //用于将当前页面的焦点，转移到指定元素上</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二、CSS-操作"><a href="#二、CSS-操作" class="headerlink" title="二、CSS 操作"></a>二、CSS 操作</h2><h3 id="类名操作"><a href="#类名操作" class="headerlink" title="类名操作"></a>类名操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ie8以下</span><br><span class="line">Element.className  //获取元素节点的类名</span><br><span class="line">Element.className += &#x27; &#x27; + newClassName  //新增一个类名</span><br><span class="line"></span><br><span class="line">//判断是否有某个类名</span><br><span class="line">function hasClass(element,className)&#123;</span><br><span class="line">  return new RegExp(className,&#x27;gi&#x27;).test(element.className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除class</span><br><span class="line">function removeClass(element,className)&#123;</span><br><span class="line">  element.className = element.className.replace(new RegExp(&#x27;(^|\\b)&#x27; + className.split(&#x27; &#x27;).join(&#x27;|&#x27;) + &#x27;(\\b|$)&#x27;, &#x27;gi&#x27;),&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ie10</span><br><span class="line">element.classList.add(className)  //新增</span><br><span class="line">element.classList.remove(className)  //删除</span><br><span class="line">element.classList.contains(className)  //是否包含</span><br><span class="line">element.classList.toggle(className)  //toggle class</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="style-操作"><a href="#style-操作" class="headerlink" title="style 操作"></a>style 操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.setAttribute(&#x27;style&#x27;,&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">element.style.backgroundColor = &#x27;red&#x27;</span><br><span class="line"></span><br><span class="line">element.style.cssText //用来读写或删除整个style属性</span><br><span class="line"></span><br><span class="line">element.style.setProperty(propertyName,value)  //设置css属性</span><br><span class="line">element.style.getPropertyValue(property)  //获取css属性</span><br><span class="line">element.style.removeProperty(property)  //删除css属性</span><br><span class="line">操作非内联样式</span><br><span class="line">//ie8</span><br><span class="line">element.currentStyle[attrName]</span><br><span class="line">//ie9+</span><br><span class="line">window.getComputedStyle(el,null)[attrName]</span><br><span class="line">window.getComputedStyle(el,null).getPropertyValue(attrName)</span><br><span class="line">//伪类</span><br><span class="line">window.getComputedStyle(el,&#x27;:after&#x27;)[attrName]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h3><h4 id="生成实例对象"><a href="#生成实例对象" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var o = new Object()
</code></pre>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><pre><code>Object.prototype //返回原型对象
</code></pre>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>Object.keys(o) //遍历对象的可枚举属性
Object.getOwnPropertyName(o) //遍历对象不可枚举的属性
</code></pre>
<h4 id="对象实例的方法"><a href="#对象实例的方法" class="headerlink" title="对象实例的方法"></a>对象实例的方法</h4><pre><code>valueOf() //返回当前对象对应的值
toString() //返回当前对象对应的字符串形式
toLocaleString() //返回当前对象对应的本地字符串形式
hasOwnProperty() //判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性
isPrototypeof() //判断当前对象是否为另一个对象的原型
propertyIsEnumerable() //判断某个属性是否可枚举
</code></pre>
<h3 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h3><h4 id="生成实例对象-1"><a href="#生成实例对象-1" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var a = new Array()
</code></pre>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><pre><code>a.length //长度
</code></pre>
<h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h4><pre><code>Array.isArray(a) //用来判断一个值是否为数组
</code></pre>
<h4 id="Array-实例的方法"><a href="#Array-实例的方法" class="headerlink" title="Array 实例的方法"></a>Array 实例的方法</h4><pre><code>a.valueof()   //返回数组本身
a.toString()  //返回数组的字符串形式
a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。
pop()   //用于删除数组的最后一个元素，并返回该元素
join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。
concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。
shift()  //用于删除数组的第一个元素，并返回该元素。
unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。
reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组
slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。
splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。
sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。
map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。
map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。
forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。
filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。
some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。
every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。
reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）
reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）
indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置
lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。
</code></pre>
<h3 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h3><h4 id="生成对象"><a href="#生成对象" class="headerlink" title="生成对象"></a>生成对象</h4><pre><code>var n = new Number()
</code></pre>
<h4 id="Number-对象的属性"><a href="#Number-对象的属性" class="headerlink" title="Number 对象的属性"></a>Number 对象的属性</h4><pre><code>Number.POSITIVE_INFINITY：正的无限，指向Infinity。
Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。
Number.NaN：表示非数值，指向NaN。
Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。
Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。
Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。
Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。
</code></pre>
<h4 id="Number-对象实例的方法"><a href="#Number-对象实例的方法" class="headerlink" title="Number 对象实例的方法"></a>Number 对象实例的方法</h4><pre><code>toString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。
toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。
toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。
toPrecision()  //用于将一个数转为指定位数的有效数字。
</code></pre>
<h3 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h3><h4 id="生成实例对象-2"><a href="#生成实例对象-2" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var s = new String()
</code></pre>
<h4 id="String-对象的属性"><a href="#String-对象的属性" class="headerlink" title="String 对象的属性"></a>String 对象的属性</h4><pre><code>s.length //返回字符串的长度
</code></pre>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><pre><code>s.chatAt(index)   //返回指定位置的字符
s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。
s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）
s.concat(s2)  //用于连接两个字符串
s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。
s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。
s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。
s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置
s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。
s.trim()  //用于去除字符串两端的空格，返回一个新字符串
s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。
s.toUpperCase()  //全部转为大写
s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。
s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。
s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。
s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。
s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。
</code></pre>
<h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><pre><code>Math.E：常数e。
Math.LN2：2的自然对数。
Math.LN10：10的自然对数。
Math.LOG2E：以2为底的e的对数。
Math.LOG10E：以10为底的e的对数。
Math.PI：常数Pi。
Math.SQRT1_2：0.5的平方根。
Math.SQRT2：2的平方根。
</code></pre>
<h4 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h4><pre><code>Math.abs()：返回参数的绝对值
Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。
Math.floor()：向下取整
Math.max(n,n1,...)：可接受多个参数，返回最大值
Math.min(n,n1,..)：可接受多个参数，返回最小值
Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。
Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。
Math.log()：返回以e为底的自然对数值。
Math.exp()：返回e的指数，也就是常数e的参数次方。
Math.round()：四舍五入
Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。
</code></pre>
<h4 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h4><pre><code>Math.sin()：返回参数的正弦
Math.cos()：返回参数的余弦
Math.tan()：返回参数的正切
Math.asin()：返回参数的反正弦（弧度值）
Math.acos()：返回参数的反余弦（弧度值）
Math.atan()：返回参数的反正切（弧度值）
</code></pre>
<h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><pre><code>JSON.stringify()
//用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。
//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。
//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。

JSON.parse()   //用于将JSON字符串转化成对象。
</code></pre>
<h3 id="console-对象"><a href="#console-对象" class="headerlink" title="console 对象"></a>console 对象</h3><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><pre><code>console.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。
console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。
console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。
console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；
console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈
console.table()  //可以将复合类型的数据转为表格显示。
console.count()  //用于计数，输出它被调用了多少次。
console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。
console.dirxml()  //用于以目录树的形式，显示DOM节点。
console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。

//这两个方法用于计时，可以算出一个操作所花费的准确时间。
console.time()
console.timeEnd()
//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。

console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。
console.profileEnd()  //用来结束正在运行的性能测试器。

console.group()
console.groupend()
//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。
console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。

console.trace()  //显示当前执行的代码在堆栈中的调用路径。
console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之mongoDB</title>
    <url>/2019/09/09/mongoDB%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/</url>
    <content><![CDATA[<h2 id="开启-MongoDB-服务器"><a href="#开启-MongoDB-服务器" class="headerlink" title="开启 MongoDB 服务器"></a>开启 MongoDB 服务器</h2><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongod</span><br></pre></td></tr></table></figure>

<h2 id="连接-MongoDB-服务器"><a href="#连接-MongoDB-服务器" class="headerlink" title="连接 MongoDB 服务器"></a>连接 MongoDB 服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>

<h2 id="退出-MongoDB-服务器"><a href="#退出-MongoDB-服务器" class="headerlink" title="退出 MongoDB 服务器"></a>退出 MongoDB 服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li><p>show dbs</p>
<ul>
<li>查看显示所有数据库</li>
</ul>
</li>
<li><p>db</p>
<ul>
<li>产看当前操作的数据库</li>
</ul>
</li>
<li><p>use 数据库名称</p>
<ul>
<li>切换到指定的数据库（没有会新建）</li>
</ul>
</li>
<li><p>show collections</p>
<ul>
<li>显示集合</li>
</ul>
</li>
<li><p>db.cats.find()</p>
<ul>
<li>查看并显示内容</li>
</ul>
</li>
<li><p><a href="https://github.com/mongodb/node-mongodb-native">node 中使用 mongodb</a></p>
</li>
</ul>
<h2 id="使用第三方-mongoose-来操作-MongoDB-数据库"><a href="#使用第三方-mongoose-来操作-MongoDB-数据库" class="headerlink" title="使用第三方 mongoose 来操作 MongoDB 数据库"></a>使用第三方 mongoose 来操作 MongoDB 数据库</h2><ul>
<li><p><a href="https://mongoosejs.com/">mongoose</a></p>
</li>
<li><p>安装<br><code>npm install mongoose</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入包</span><br><span class="line">const mongoose = require(&#x27;mongoose&#x27;);</span><br><span class="line">//连接数据库（数据库不需要存在，在插入第一条语句，就会自动创建）</span><br><span class="line"></span><br><span class="line">mongoose.connect(&#x27;mongodb://localhost:27017/test&#x27;, &#123;useNewUrlParser: true&#125;);</span><br><span class="line"></span><br><span class="line">//设计数据库集合结构</span><br><span class="line">//创建一个Cat表</span><br><span class="line">const Cat = mongoose.model(&#x27;Cat&#x27;, &#123; name: String &#125;);</span><br><span class="line"></span><br><span class="line">//实例化一个Cat，实例对象为kitty</span><br><span class="line">const kitty = new Cat(&#123; name: &#x27;Zildjian&#x27; &#125;);</span><br><span class="line"></span><br><span class="line">//持久化保存kitty实例</span><br><span class="line">kitty.save().then(() =&gt; console.log(&#x27;meow&#x27;));</span><br></pre></td></tr></table></figure>

<ul>
<li>mongoose 的基本使用</li>
</ul>
<ul>
<li>生成模型构造函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var mongoose = require(&#x27;mongoose&#x27;);</span><br><span class="line">var Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line">//设计集合结构（表结构）schema---&gt;提要，纲要</span><br><span class="line">//字段名称就是表结构中的属性名称</span><br><span class="line">//值类型</span><br><span class="line">//约束的目的：为了保证数的完整性</span><br><span class="line">var blogSchema = new Schema(&#123;</span><br><span class="line">  title:  String,</span><br><span class="line">  author: String,</span><br><span class="line">  body:   String,</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    required: true</span><br><span class="line">  &#125;,</span><br><span class="line">  password: &#123;</span><br><span class="line">    typte: String,</span><br><span class="line">    required: true</span><br><span class="line">  &#125;</span><br><span class="line">  comments: [&#123; body: String, date: Date &#125;],</span><br><span class="line">  date: &#123; type: Date, default: Date.now &#125;,</span><br><span class="line">  hidden: Boolean,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    votes: Number,</span><br><span class="line">    favs:  Number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//将文档结构发布为模型</span><br><span class="line">// 参数一：大写单数表示数据库名称</span><br><span class="line">//         mongoose会自动将大写单数改为小写复数</span><br><span class="line">// 参数二： 架构 Schema</span><br><span class="line">// 返回值： 模型构造函数</span><br><span class="line">var User = mongoose.model(&#x27;User&#x27;, blogSchema)</span><br><span class="line">// module.exports = mongoose.model(&#x27;Student&#x27;, blogSchema)</span><br></pre></td></tr></table></figure>

<p>基于模型构造函数 生成添加一条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var admin = new User(&#123;</span><br><span class="line">    username: &#x27;admin&#x27;,</span><br><span class="line">    password: &#x27;1245435&#x27;,</span><br><span class="line">    ....</span><br><span class="line">&#125;)</span><br><span class="line">admin.save(function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#x27;保存失败&#x27;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#x27;保存成功&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>基于模型构造函数 查询数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询所有数据</span><br><span class="line">User.find(function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">         console.log(&#x27;查询失败&#x27;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//promise 查询所有</span><br><span class="line">User.find()</span><br><span class="line">    .then(function(data)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//按条件查询</span><br><span class="line"> User.find(&#123;</span><br><span class="line">    username: &#x27;xx&#x27;</span><br><span class="line"> &#125;, function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#x27;查询失败&#x27;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//查找符合条件的第一个（可以写多个条件）,没有条件的话，为第一条数据</span><br><span class="line"> User.findOne(&#123;</span><br><span class="line">    username: &#x27;xx&#x27;</span><br><span class="line"> &#125;, function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#x27;查询失败&#x27;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>基于模型构造函数 按条件更新数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Model.update(conditions, doc, [options], [callback])</span><br><span class="line">//Model.findOneAndUpdate([conditions], [update], [options], [callback])</span><br><span class="line">User.findByIdAndUpdate(&#x27;5a7d8f2sd78ag6g&#x27;,&#123;</span><br><span class="line">    username: &#x27;zs&#x27;</span><br><span class="line">&#125;, function(err, ret)&#123;</span><br><span class="line">   if(err)&#123;</span><br><span class="line">       console.log(&#x27;更新失败&#x27;)</span><br><span class="line">    else &#123;</span><br><span class="line">       console.log(&#x27;更新成功&#x27;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>基于模型构造函数 删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User.remove(&#123;</span><br><span class="line">    username: &#x27;zs&#x27;</span><br><span class="line">&#125;, function(err, ret)&#123;</span><br><span class="line">   if(err)&#123;</span><br><span class="line">       console.log(&#x27;查询失败&#x27;)</span><br><span class="line">    else &#123;</span><br><span class="line">       console.log(ret)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="补充（node-使用-mysql）"><a href="#补充（node-使用-mysql）" class="headerlink" title="补充（node 使用 mysql）"></a>补充（node 使用 mysql）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引包</span><br><span class="line">var mysql      = require(&#x27;mysql&#x27;);</span><br><span class="line">//创建连接</span><br><span class="line">var connection = mysql.createConnection(&#123;</span><br><span class="line">  host     : &#x27;localhost&#x27;,</span><br><span class="line">  user     : &#x27;me&#x27;,</span><br><span class="line">  password : &#x27;secret&#x27;,</span><br><span class="line">  database : &#x27;my_db&#x27;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> //连接数据库</span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line"> //执行数据操作,可以直接使用 SQL 语句</span><br><span class="line"> //查找</span><br><span class="line">connection.query(&#x27;SELECT * FROM `users`&#x27;, function (error, results, fields) &#123;</span><br><span class="line">  if (error) throw error;</span><br><span class="line">  console.log(&#x27;The solution is: &#x27;, results[0].solution);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//添加</span><br><span class="line"> connection.query(&#x27;INSERT INTO users VALUES(NULL, &quot;admin&quot;:&quot;123&quot;)&#x27;, function (error, results, fields) &#123;</span><br><span class="line">   if (error) throw error;</span><br><span class="line">   console.log(&#x27;The solution is: &#x27;, results[0].solution);</span><br><span class="line"> &#125;);</span><br><span class="line"> //关闭数据库</span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue响应式系统实现</title>
    <url>/2022/08/07/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="comment">// 用一个全局变量存储当前激活的effect函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="comment">// effect栈</span></span><br><span class="line"><span class="keyword">const</span> effectStack = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 调用cleanup函数完成清除工作</span></span><br><span class="line">    <span class="title function_">cleanup</span>(effectFn);</span><br><span class="line">    <span class="comment">// 当调用effect注册副作用函数时，将副作用函数赋值给activeEffect</span></span><br><span class="line">    activeEffect = effectFn;</span><br><span class="line">    <span class="comment">// 调用副作用函数之前将当前副作用函数压入栈顶</span></span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn);</span><br><span class="line">    <span class="comment">// 把fn的执行结果存储在res中</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">fn</span>();</span><br><span class="line">    <span class="comment">// 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并将activeEffect还原为之前的值</span></span><br><span class="line">    effectStack.<span class="title function_">pop</span>();</span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 将options挂载到effectFn上</span></span><br><span class="line">  effectFn.<span class="property">options</span> = options;</span><br><span class="line">  <span class="comment">// 用来存储所有与该副作用函数相关的依赖集合</span></span><br><span class="line">  effectFn.<span class="property">deps</span> = [];</span><br><span class="line">  <span class="comment">// 只有非lazy的时候，才执行</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="title function_">effectFn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// computed</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getter</span>) &#123;</span><br><span class="line">  <span class="comment">// 用来缓存上一次计算的值</span></span><br><span class="line">  <span class="keyword">let</span> value;</span><br><span class="line">  <span class="comment">// dirty标志，用来识别是否需要重新计算值，为true时则意味着“脏”，需要计算</span></span><br><span class="line">  <span class="keyword">let</span> dirty = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">scheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">        dirty = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 当计算属性依赖的响应式数据变化时，手动调用trigger函数触发响应</span></span><br><span class="line">        <span class="title function_">trigger</span>(obj, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = <span class="title function_">effectFn</span>();</span><br><span class="line">        dirty = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当读取value时，手动调用track函数进行追踪</span></span><br><span class="line">      <span class="title function_">track</span>(obj, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// watch</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb, options = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> getter;</span><br><span class="line">  <span class="comment">// 如果是函数，说明用户传递的不再是一个响应式数据，而是一个getter函数，直接把source赋值给getter</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    getter = source;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则调用traverse递归读取响应式数据属性</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义旧值和新值</span></span><br><span class="line">  <span class="keyword">let</span> oldValue, newValue;</span><br><span class="line">  <span class="comment">// cleanup用来存储用户注册的国旗回调</span></span><br><span class="line">  <span class="keyword">let</span> cleanup;</span><br><span class="line">  <span class="comment">// 定义onInvalidate函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onInvalidate</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 将过期回调存储到cleanup中</span></span><br><span class="line">    cleanup = fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提取调度器scheduler为一个独立的job函数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在scheduler中重新执行副作用函数，得到的是新值</span></span><br><span class="line">    newValue = <span class="title function_">effectFn</span>();</span><br><span class="line">    <span class="comment">// 在调用糊掉函数cb之前，先调用过期回调</span></span><br><span class="line">    <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">      <span class="title function_">cleanup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将旧值和新值作为回调函数的参数</span></span><br><span class="line">    <span class="title function_">cb</span>(newValue, oldValue);</span><br><span class="line">    <span class="comment">// 更新旧值，不然下次会得到错误的旧值</span></span><br><span class="line">    oldValue = newValue;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 使用effect注册副作用函数时，开启lazy选项，并把返回值存储到effectFn中一边后续手动调用</span></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(<span class="function">() =&gt;</span> <span class="title function_">getter</span>(), &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">scheduler</span>: job,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">immediate</span>) &#123;</span><br><span class="line">    <span class="comment">// 当immediate为true时立即执行job，从而触发回调执行</span></span><br><span class="line">    <span class="title function_">job</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 手动调用副作用函数，拿到的值就是旧值</span></span><br><span class="line">    oldValue = <span class="title function_">effectFn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">value, seen = <span class="keyword">new</span> <span class="built_in">Set</span>()</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;object&quot;</span> || value === <span class="literal">null</span> || seen.<span class="title function_">has</span>(value)) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 将数据添加到seen中，代表便利地读取过了，避免循环引用引起的死循环</span></span><br><span class="line">  seen.<span class="title function_">add</span>(value);</span><br><span class="line">  <span class="comment">// 暂时不考虑数组等其他结构</span></span><br><span class="line">  <span class="comment">// 假设value是一个对象，使用for...in读取对新啊个的每一个值，并递归调用traverse进行处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> value) &#123;</span><br><span class="line">    <span class="title function_">traverse</span>(value[k], seen);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cleanup</span>(<span class="params">effectFn</span>) &#123;</span><br><span class="line">  <span class="comment">// 遍历effectFn.deps数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; effectFn.<span class="property">deps</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// deps是依赖集合</span></span><br><span class="line">    <span class="keyword">const</span> deps = effectFn.<span class="property">deps</span>[i];</span><br><span class="line">    <span class="comment">// 将effectFn从依赖集合中移除</span></span><br><span class="line">    deps.<span class="title function_">delete</span>(effectFn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后需要重置effectFn.deps数组</span></span><br><span class="line">  effectFn.<span class="property">deps</span>.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在get拦截函数内调用track函数追踪变化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 没有activeEffect，直接return</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) <span class="keyword">return</span> target[key];</span><br><span class="line">  <span class="comment">// 根据target从“桶”中取得depsMap，也是一个Map类型：key --&gt; effects</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = bucket.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="comment">// 如果不存在depsMap，新建一个Map并与target关联</span></span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    bucket.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据key从depsMap中取得deps，它是一个Set类型，</span></span><br><span class="line">  <span class="comment">// 里面存储着所有与当前key相关联的副作用函数：effects</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后将当前激活的副作用函数添加到“桶”中</span></span><br><span class="line">  deps.<span class="title function_">add</span>(activeEffect);</span><br><span class="line">  <span class="comment">// deps就是一个与当前副作用函数存在联系的依赖集合</span></span><br><span class="line">  <span class="comment">// 将其添加到activeEffect.deps数组中</span></span><br><span class="line">  activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(deps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在set函数拦截内调用trigger函数出发变化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据target从桶中取出depsMap，它是 key --&gt; effects</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 根据key取得所有副作用函数effects</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="comment">// 在调用forEach遍历Set集合时，如果一个值已经被访问过了，</span></span><br><span class="line">  <span class="comment">// 但该值被删除并重新添加集合，如果此时forEach遍历还没结束</span></span><br><span class="line">  <span class="comment">// 该值会重新被访问，就会导致无限循环执行。</span></span><br><span class="line">  <span class="comment">// 解决方法：构造另一个Set集合遍历它</span></span><br><span class="line">  <span class="keyword">const</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">  effects &amp;&amp;</span><br><span class="line">    effects.<span class="title function_">forEach</span>(<span class="function">(<span class="params">effectFn</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果trigger触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</span></span><br><span class="line">      <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">        effectsToRun.<span class="title function_">add</span>(effectFn);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function">(<span class="params">effectFn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果一个副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递</span></span><br><span class="line">    <span class="keyword">if</span> (effectFn.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;</span><br><span class="line">      effectFn.<span class="property">options</span>.<span class="title function_">scheduler</span>(effectFn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则直接执行副作用函数</span></span><br><span class="line">      <span class="title function_">effectFn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">text</span>: <span class="string">&quot;hello world&quot;</span>, <span class="attr">ok</span>: <span class="literal">false</span>, <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 拦截读取操作</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="comment">// 将副作用函数activeEffect添加到存储副作用函数的桶中</span></span><br><span class="line">    <span class="title function_">track</span>(target, key);</span><br><span class="line">    <span class="comment">// 返回属性值</span></span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截设置操作</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置属性值</span></span><br><span class="line">    target[key] = newVal;</span><br><span class="line">    <span class="comment">// 把副作用函数从桶中取出并执行</span></span><br><span class="line">    <span class="title function_">trigger</span>(target, key);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp1, temp2;</span><br><span class="line"><span class="comment">// watch</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> obj.<span class="property">foo</span>,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">obj.<span class="property">foo</span>++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// computed</span></span><br><span class="line"><span class="comment">// const sum = computed(() =&gt; obj.foo + obj.bar);</span></span><br><span class="line"><span class="comment">// effect(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(sum.value);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.foo++;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lazy</span></span><br><span class="line"><span class="comment">// const effectFn = effect(</span></span><br><span class="line"><span class="comment">//   () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(obj.text);</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     lazy: true,</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// );</span></span><br><span class="line"><span class="comment">// effectFn();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套的effect与effect栈</span></span><br><span class="line"><span class="comment">// effect(function effectFn1() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&quot;effectFn1 执行&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   effect(function effectFn2() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&quot;effectFn2 执行&quot;);</span></span><br><span class="line"><span class="comment">//     temp2 = obj.ok;</span></span><br><span class="line"><span class="comment">//   &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   temp1 = obj.text;</span></span><br><span class="line"><span class="comment">//   obj.text += &quot;1&quot;;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支切换与cleanup</span></span><br><span class="line"><span class="comment">// effect(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;effect run&#x27;);</span></span><br><span class="line"><span class="comment">//   document.body.innerText =  obj.ok ? obj.text : &quot;not&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   obj.text = &#x27;foolishmax&#x27;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不存在的属性不添加响应式</span></span><br><span class="line"><span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   obj.text = &quot;hello vue3&quot;;</span></span><br><span class="line"><span class="comment">//   // obj.notExist = &#x27;hello vue3&#x27;</span></span><br><span class="line"><span class="comment">// &#125;, 3000);</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack配置工程师</title>
    <url>/2021/10/27/webpack%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    <content><![CDATA[<p>构建 webpack 知识体系分为下面三个层级： 1.基础–会配置 2.进阶–能优化 3.深入–懂原理</p>
<h2 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h2><span id="more"></span>

<h3 id="1-简单配置"><a href="#1-简单配置" class="headerlink" title="1.简单配置"></a>1.简单配置</h3><p>该部分需掌握：<br>1.Webpack 常规配置项有哪些？ 2.常用 loader 有哪些？如何配置？ 3.常用插件 plugin 有哪些？如何配置？<br>4.Babel 如何配置？Babel 插件如何使用？</p>
<h4 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h4><p>需要现在本地安装<strong>webpack</strong>及<strong>webpack-cli</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<h4 id="1-2-开始工作"><a href="#1-2-开始工作" class="headerlink" title="1.2 开始工作"></a>1.2 开始工作</h4><p>webpack 在 4 以后就支持 0 配置打包，我们可以测试一下 1.新建 webpack-work 项目，新建 <code>./src/index.js</code>文件，写一段简单的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = &#x27;hello foolishmax&#x27;;</span><br><span class="line">console.log(a);</span><br><span class="line">module.exports = a;</span><br></pre></td></tr></table></figure>

<p>2.直接运行<code>npx webpack</code>，启动打包<br><img src="../images/md_img/webpack-mode-error.png" alt="webpack-mode-error">)</p>
<p>打包完成，会有一个提示：<code>The &#39;mode&#39; option has not been set,...</code></p>
<p>意思就是我们没有配置 mode（告知 webpack 使用相应模式的内置优化，默认为<code>production</code>，另外还有<code>development</code>、<code>none</code>）</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>development</td>
<td>开发模式，打包更加快速，省了代码优化步骤</td>
</tr>
<tr>
<td>production</td>
<td>生产模式，打包比较慢，开启 tree-shaking 和压缩代码</td>
</tr>
<tr>
<td>none</td>
<td>不使用任何默认优化选项</td>
</tr>
</tbody></table>
<p>webpack.config.js 中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-配置文件"><a href="#1-3-配置文件" class="headerlink" title="1.3 配置文件"></a>1.3 配置文件</h4><p>虽然可以零配置打包，但是实际工作中，还是需要使用配置文件的方式来满足不同项目的需求。 1.跟路径下创建配置文件<code>webpack.config.js</code> 2.新增基本配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;, // 模式</span><br><span class="line">  entry: &#x27;./src/index.js&#x27;, // 打包入口地址</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;, // 输出文件名</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;) // 输出文件目录</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-4-loader"><a href="#1-4-loader" class="headerlink" title="1.4 loader"></a>1.4 loader</h4><p>这里我们把入口文件改成 css 文件，看下打包结果如何 1.新增<code>./src/main.css</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding: 0 20px;</span><br><span class="line">  max-width: 800px;</span><br><span class="line">  background: #f4f8fb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.修改 entry 配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./src/main.css&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.运行打包命令： <code>npx webpack</code><br><img src="../images/md_img/webpack-loader.png" alt="loader"><br>这里的报错信息是因为：webpack 默认支持处理 js 文件，其他类型都处理不了，需要借助 loader 来对不同类型的文件进行处理。</p>
<p>4.安装<code>css-loader</code>来处理 CSS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install css-loader -D</span><br></pre></td></tr></table></figure>

<p>5.配置资源加载模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./src/main.css&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.css&#x27;,</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [ // 转换规则</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.css$/, // 匹配所有css文件</span><br><span class="line">        use: &#x27;css-loader&#x27;, //对应的loader名称</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.重新运行打包命令<code>npx webpack</code>,就可以打包成功了</p>
<p>总结：loader 就是将 webpack 不认识的内容转化为认识的内容</p>
<h4 id="插件（plugin）"><a href="#插件（plugin）" class="headerlink" title="插件（plugin）"></a>插件（plugin）</h4><p>插件可以贯穿 webpack 打包的生命周期，执行不同的任务</p>
<p>1.新建<code>./src/index.html</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>如果想要打包后的资源文件，例如 js 或者 css 文件可以自动引入到 html 中，就需要使用插件<code>html-webpack-plugin</code>来做这件事情。</p>
<p>2.本地安装 <code>html-webpack-plugin</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>3.配置插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [ // 转换规则</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.css$/, // 匹配所有css文件</span><br><span class="line">        use: &#x27;css-loader&#x27;, //对应的loader名称</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/index.html&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行一下打包，打开 dist 目录下的 index.html 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到它自动引入打包好的 bundle.js</p>
<h4 id="1-6-自动清空打包目录"><a href="#1-6-自动清空打包目录" class="headerlink" title="1.6 自动清空打包目录"></a>1.6 自动清空打包目录</h4><p>每次打包的时候，打包目录都会遗留上次打包的文件，为了保持打包目录的纯净，打包前需将上次打包目录清空。</p>
<p>1.安装 <code>clean-webpack-plugin</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>2.配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">const &#123;CleanWebpackPlugin&#125; = require(&#x27;clean-webpack-plugin&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/index.html&#x27;,</span><br><span class="line">    &#125;),</span><br><span class="line">    new CleanWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-7-区分环境"><a href="#1-7-区分环境" class="headerlink" title="1.7 区分环境"></a>1.7 区分环境</h4><p>本地环境</p>
<ul>
<li>需要更快的构建速度</li>
<li>需要打印 debug 信息</li>
<li>需要 live reload 或者 hot reload 功能</li>
<li>需要 sourcemap 方便定位问题</li>
<li>…</li>
</ul>
<p>生产环境：</p>
<ul>
<li>需要更小的包体积，代码压缩+tree-shaking</li>
<li>需要进行代码分割</li>
<li>需要压缩图片体积</li>
<li>…</li>
</ul>
<p><a href="https://juejin.cn/post/7023242274876162084#heading-6">掘金</a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全</title>
    <url>/2019/10/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><span id="more"></span>

<h4 id="sql-注入"><a href="#sql-注入" class="headerlink" title="sql 注入"></a>sql 注入</h4><ul>
<li>就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，<br>最终达到欺骗服务器执行恶意的 SQL 命令</li>
</ul>
<ul>
<li>预防：比如使用基于 nodejs 的 sequelize 框架，不要裸写 sql 语句，使用常见的数据库工具即可解决</li>
</ul>
<h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ul>
<li><p>xss：跨站脚本攻击(Cross Site Scripting),攻击者通过注入非法的 html 标签<br>或者 JavaScript 代码，从而当用户浏览该网页时，控制用户浏览器。</p>
</li>
<li><p>xss 主要分为三类：</p>
<ul>
<li>DOM xss<ul>
<li>DOM 即文本对象模型，DOM 通常代表在 html、xhtml 和 xml 中的对象，使用 DOM<br>可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器<br>解析响应的直接参与，触发 XSS 靠的是浏览器端的 DOM 解析，可以认为完全是客户端<br>的事情。</li>
</ul>
</li>
<li>反射型 xss<ul>
<li>反射型 XSS 也被称为非持久性 XSS，是现在最容易出现的一种 XSS 漏洞。发出请<br>求时，XSS 代码出现在 URL 中 ，最后输入提交到服务器，服务器解析后在响应内容<br>中出现这段 XSS 代码，最后浏览器解析执行。</li>
</ul>
</li>
<li>存储型 xss<ul>
<li>存储型 XSS 又被称为持久性 XSS，它是最危险的一种跨站脚本，相比反射型 XSS<br>和 DOM 型 XSS 具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。<br>允许用户存储数据的 web 程序都可能存在存储型 XSS 漏洞，当攻击者提交一段 XSS<br>代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被 XSS，其中<br>最典型的例子就是留言板。</li>
</ul>
</li>
</ul>
</li>
<li><p>主要影响：</p>
<ul>
<li><p>利用虚假输入表单骗取用户个人信息</p>
</li>
<li><p>利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</p>
</li>
<li><p>显示伪造的文章或者图片</p>
</li>
</ul>
</li>
<li><p>防御措施：</p>
<ul>
<li><p>设置 httpOnly：在 cookie 中设置 HttpOnly 属性后，js 脚本将无法读取到 cookie 的信息。</p>
</li>
<li><p>输入检查，对于用户输入进行格式检查。</p>
<ul>
<li>移除用户上传的 DOM 属性，如 onerror 事件等。</li>
<li>移除用户上传的 style 节点、script 节点、iframe 节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>vue 中输出原生 html 需要使用 <strong>v-html</strong></li>
<li>react 中可以使用 <strong>dangerouslySetInnerHTML</strong></li>
</ul>
<h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><ul>
<li><p>csrf：跨站请求伪造(Cross-Site Request Forgeries)，冒充用户发起请求，完成<br>一些违背用户意愿的事情。</p>
</li>
<li><p>防御措施</p>
<ul>
<li><p>提交数据使用 post 请求</p>
</li>
<li><p>Token 验证：</p>
<ul>
<li>第一步：后端随机产生一个 token，把这个 token 保存在 session 状态中，同时<br>后端把 token 交给前端页面；</li>
<li>第二步：前端页面提交请求时，把 token 加入到请求数据或者头信息中，一起<br>传给后端；</li>
<li>后端验证前端传来的 token 与 session 是否一致，一致则合法，否则非法请求。</li>
</ul>
</li>
<li><p>Referer check：请求来源验证，但是不能保证 100%有效，因为服务器并不是什么<br>时候都能取到 Referer，而且低版本浏览器存在伪造 Referer 的风险。</p>
</li>
<li><p>验证码：强制用户必须和应用进行交互，完成最终请求，但用户体验比较差。</p>
</li>
</ul>
</li>
</ul>
<h4 id="clickjacking"><a href="#clickjacking" class="headerlink" title="clickjacking"></a>clickjacking</h4><ul>
<li><p>clickjacking: 点击劫持，利用透明的按钮或连接做成陷阱，覆盖在 web 页面之上，然后<br>诱使用户在不知的情况下，点击那个链接访问内容的一种攻击手段。又称为界面伪装。</p>
</li>
<li><p>大概有两种方式：</p>
<ul>
<li><p>攻击者使用一个透明 iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，<br>此时用将在不知情的情况下点击透明的 iframe 页面。</p>
</li>
<li><p>攻击者使用一张图片覆盖在网页，遮挡网页原有的位置含义。</p>
</li>
</ul>
</li>
<li><p>防御措施：</p>
<ul>
<li>X-FRAME-OPTIONS 响应头是用来给浏览器指示允许一个页面可否在<code>&lt;frame&gt;</code>,<br><code>&lt;iframe&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记。网站可以使用此功能，来确保自己网站<br>内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。</li>
</ul>
</li>
</ul>
<h5 id="控制台注入代码"><a href="#控制台注入代码" class="headerlink" title="控制台注入代码"></a>控制台注入代码</h5><h3 id="附：优化请求头（使用-helmet-协议规范）"><a href="#附：优化请求头（使用-helmet-协议规范）" class="headerlink" title="附：优化请求头（使用 helmet 协议规范）"></a>附：优化请求头（使用 helmet 协议规范）</h3>]]></content>
      <categories>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>koa-generator快速搭建koa服务</title>
    <url>/2022/03/08/koa-generator%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAkoa%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="1-全局安装koa-generator脚手架"><a href="#1-全局安装koa-generator脚手架" class="headerlink" title="1.全局安装koa-generator脚手架"></a>1.全局安装<em>koa-generator</em>脚手架</h2><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g koa-generator</span><br><span class="line"># or</span><br><span class="line">yarn global add koa-generator</span><br></pre></td></tr></table></figure>

<h2 id="创建koa项目"><a href="#创建koa项目" class="headerlink" title="创建koa项目"></a>创建<em>koa</em>项目</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">koa2 project-name</span><br><span class="line"></span><br><span class="line">// 使用ejs引擎</span><br><span class="line">koa2 -e project-name</span><br></pre></td></tr></table></figure>

<h2 id="进入项目安装依赖"><a href="#进入项目安装依赖" class="headerlink" title="进入项目安装依赖"></a>进入项目安装依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd project-name</span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure>

<h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm start</span><br><span class="line"># or</span><br><span class="line">npm run dev</span><br><span class="line"># or...</span><br></pre></td></tr></table></figure>

<h3 id="使用-pm2-启动-koa-项目"><a href="#使用-pm2-启动-koa-项目" class="headerlink" title="使用 pm2 启动 koa 项目"></a>使用 pm2 启动 koa 项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 全局安装</span><br><span class="line">npm install -g pm2</span><br><span class="line">// 启动项目</span><br><span class="line">pm2 start ./bin/www</span><br><span class="line">// pm2自动重启</span><br><span class="line">pm2 start ./bin/www/ --watch</span><br></pre></td></tr></table></figure>

<h3 id="pm2-相关命令（www-是项目名）"><a href="#pm2-相关命令（www-是项目名）" class="headerlink" title="pm2 相关命令（www 是项目名）"></a>pm2 相关命令（www 是项目名）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pm2 list          #查看所有已启动项目</span><br><span class="line">pm2 start         #启动</span><br><span class="line">pm2 restart www   #重启</span><br><span class="line">pm2 stop www      #停止</span><br><span class="line">pm2 delete www    #删除</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>React深入浅出知识链路</title>
    <url>/2021/10/05/React%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="React-的基本认识"><a href="#React-的基本认识" class="headerlink" title="React 的基本认识"></a>React 的基本认识</h2><span id="more"></span>

<ul>
<li>Fecebook 开源的一个 js 库</li>
<li>一个用来动态构建用户界面的 js 库</li>
<li>React 的特点：<ul>
<li>声明式编程</li>
<li>组件化编程</li>
<li>高效</li>
<li>单向数据流</li>
<li>支持客户端与服务端渲染</li>
</ul>
</li>
<li>React 高效的原因<ul>
<li>虚拟 DOM，不直接操作 DOM(批量更新，减少更新的次数)</li>
<li>高效的 DOM Diff 算法，最小化页面重绘(减小页面更新的区域)</li>
</ul>
</li>
</ul>
<h2 id="React-中的生命周期函数"><a href="#React-中的生命周期函数" class="headerlink" title="React 中的生命周期函数"></a>React 中的生命周期函数</h2><p>生命周期函数是指组件在某一时刻自动执行的函数</p>
<!--more-->
<img src="https://raw.githubusercontent.com/foolishmax/static/master/images/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.png"/>

<h3 id="初始化过程（Initialization）"><a href="#初始化过程（Initialization）" class="headerlink" title="初始化过程（Initialization）"></a>初始化过程（Initialization）</h3><ul>
<li>在 constructor()里面初始化 Props 和 State 属性。</li>
<li>getDefaultProps()可以设置组件的默认属性值。</li>
</ul>
<h3 id="挂载过程（Mounting）"><a href="#挂载过程（Mounting）" class="headerlink" title="挂载过程（Mounting）"></a>挂载过程（Mounting）</h3><ul>
<li>componentWillMount(): 在组件即将被挂载到页面的时刻自动执行。</li>
<li>render(): 将组件挂载到页面。</li>
<li>componentDidMount(): 组件被挂载到页面之后立即执行。</li>
</ul>
<h3 id="更新过程（Updation）"><a href="#更新过程（Updation）" class="headerlink" title="更新过程（Updation）"></a>更新过程（Updation）</h3><ul>
<li>componentWillReceiveProps()（在 16.4 版本中废弃，不推荐使用）：<br>一个组件从父组件接受参数，如果这个组件第一次存在父组件中不会执行，已经存在才会执行，<br>如果没有 Props 属性则直接跳过。</li>
<li>shouldComponentUpdate():<br>组件更新前检查是否需要更新组件，返回布尔类型。此生命周期函数可以强制关闭不需要更新的子组件<br>来提高渲染性能。</li>
<li>componentWillUpdate():<br>组件更新之前自动执行。前提是 shouldComponentUpdate()执行并返回 true<br>-render():<br>将组件更新到页面<br>-componentDidUpdate():<br>组件更新完成之后立即执行。</li>
</ul>
<h3 id="移除过程（Unmounting）"><a href="#移除过程（Unmounting）" class="headerlink" title="移除过程（Unmounting）"></a>移除过程（Unmounting）</h3><ul>
<li>componentWillUnmount():<br>当组件即将从页面中移除时执行。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>React 中的 render() 也是生命周期函数，而 constructor()并不是生命周期函数。</li>
<li>所有的组件都有生命周期函数。</li>
<li>除了 render()函数，其他函数都可以不写，因为除了 render()函数其他函数都是继承自<br>React 中内置的。</li>
<li>AJAX 请求一般都是放在 componentDidMount()里面。</li>
</ul>
<h2 id="React-状态提升"><a href="#React-状态提升" class="headerlink" title="React 状态提升"></a>React 状态提升</h2><ul>
<li><p>所谓状态提升，就是将 各个子组件的公共 state 提升到它们的父组件进行统一存储、处理<br>(单一数据源)，然后将父组件处理后的数据或者函数 props 到各个子组件中。</p>
</li>
<li><p>如果子组件要修改父组件中 state 该怎么办？</p>
<ul>
<li>做法就是将父组件中负责 setState 的函数，以 props 的形式传给子组件，然后子组件<br>需要改变 state 时调用即可。</li>
</ul>
</li>
</ul>
<h2 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h2><ul>
<li>React Router 包装了 BrowserRouter 和 HashRouter 两个组件。<ul>
<li>BrowserRouter 使用 HTML5 的 history API(pushState、replaceState 等)实现<br>UI 和 URL 的同步</li>
<li>HashRouter 使用 URL 的 hash 实现应用的 UI 和 URL 同步</li>
</ul>
</li>
</ul>
<h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><ul>
<li>useState</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用法：</span><br><span class="line"></span><br><span class="line">//useState唯一的参数就是初始state</span><br><span class="line">//返回一个数组，第一项state，第二项更新state的函数</span><br><span class="line">const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">//函数式更新</span><br><span class="line">//如果新的state需要通过使用以前的state计算得出，可以将函数传递给setState。</span><br><span class="line">//例如：</span><br><span class="line">setCount((count) =&gt; &#123;</span><br><span class="line">    return count + 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//惰性初始化state，对复杂初始数据，initialState可以是一个函数</span><br><span class="line">//函数或initialState参数只会在组件的初始渲染中起作用</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [&#123;name, number&#125;,setValue] = useState(() =&gt; &#123;</span><br><span class="line">        return &#123;name:&#x27;计数器&#x27;,number:0&#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;name&#125;:&#123;number&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setValue(&#123;number: number + 1&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">--------------</span><br><span class="line">//官网例子</span><br><span class="line">const [state, setState] = useState(() =&gt; &#123;</span><br><span class="line">    const initialState = someExpensiveComputation(props);</span><br><span class="line">    return initialState;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//useState的初始值，只在第一次有效</span><br><span class="line">//按照有序的方式使用useState不得在循环判断等条件语句中使用</span><br><span class="line">//useState不会自动合并更新对象，需使用扩展符&#123;...obj,name:&#x27;lisi&#x27;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>useEffect</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//基本使用</span><br><span class="line">//useEffect有两个参数：function(执行项)，array(依赖项)</span><br><span class="line">useEffect(() =&gt; &#123;&#125;,[name]);</span><br><span class="line"></span><br><span class="line">//如果依赖项为空数组，只会在第一次挂载后执行，类似componentDidMount</span><br><span class="line">useEffect(() =&gt; &#123;&#125;,[]);</span><br><span class="line"></span><br><span class="line">//清除副作用，模拟componentUnMount</span><br><span class="line">//通过返回一个函数来指定如何清除副作用，防止内存泄漏，函数会在组件卸载前执行</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    let timer = setInterVal(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;定时器&quot;);</span><br><span class="line">    &#125;,1000)</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        clearInterval(timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[name])</span><br><span class="line"></span><br><span class="line">//注意：可以在组件中多次使用useEffect</span><br><span class="line">//Hook 允许我们按照代码的用途分离他们，react将按照effect声明的顺序依次调用组件中的每一个effect</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>useContext</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//父组件创建上下文</span><br><span class="line">const Context = createContext();</span><br><span class="line">//并将数据传递给子组件</span><br><span class="line">const [num, setNum] = useState(0);</span><br><span class="line">&lt;Context.Provider value=&#123;&#123;num, setNum&#125;&#125;&gt;</span><br><span class="line">    &lt;Children /&gt;</span><br><span class="line">&lt;/Context.Provider&gt;</span><br><span class="line"></span><br><span class="line">//子组件接收</span><br><span class="line">const &#123;num, setNum&#125; = useContext(Context);</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    setNum(num + 1);</span><br><span class="line">&#125;,[])</span><br><span class="line">&lt;p&gt;&#123;num&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>useReducer</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//基础使用</span><br><span class="line">const initialState = &#123; count: 0 &#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action)&#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case &#x27;increment&#x27;:</span><br><span class="line">            return &#123;count:state.count + 1&#125;;</span><br><span class="line">        case &#x27;decrement&#x27;:</span><br><span class="line">            return &#123;count:state.count - 1&#125;;</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function MyUseReducer() &#123;</span><br><span class="line">    const [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            count: &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type:&#x27;decrement&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type:&#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//惰性初始化</span><br><span class="line">//稍加改造</span><br><span class="line">const initialCount = 0;</span><br><span class="line"></span><br><span class="line">function init(initialCount) &#123;</span><br><span class="line">  return &#123;count: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#x27;increment&#x27;:</span><br><span class="line">      return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#x27;decrement&#x27;:</span><br><span class="line">      return &#123;count: state.count - 1&#125;;</span><br><span class="line">    case &#x27;reset&#x27;:</span><br><span class="line">      return init(action.payload);</span><br><span class="line">    default:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function MyUseReducer() &#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, initialCount , init);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;》》</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="React-框架的关键设计思想：“组件”、“虚拟-DOM”"><a href="#React-框架的关键设计思想：“组件”、“虚拟-DOM”" class="headerlink" title="React 框架的关键设计思想：“组件”、“虚拟 DOM”"></a>React 框架的关键设计思想：“组件”、“虚拟 DOM”</h3><!--more-->

<h3 id="组件化-工程化思想在框架中的落地"><a href="#组件化-工程化思想在框架中的落地" class="headerlink" title="组件化: 工程化思想在框架中的落地"></a>组件化: 工程化思想在框架中的落地</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“封闭”：在组件自身的渲染工作流中，每个组件都只处理它的内部的渲染逻辑。</span><br><span class="line">“开放”：针对组件间通信来说，React基于“单向数据流”的原则完成组件间的通信。</span><br></pre></td></tr></table></figure>

<!--more-->

<h3 id="虚拟-DOM：核心算法的基石："><a href="#虚拟-DOM：核心算法的基石：" class="headerlink" title="虚拟 DOM：核心算法的基石："></a>虚拟 DOM：核心算法的基石：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组件初始化-&gt;render方法-&gt;生成虚拟DOM-&gt;ReactDOM.render方法-&gt;生成真实DOM</span><br><span class="line"></span><br><span class="line">组件更新-&gt;render方法-&gt;生成新的虚拟DOM-&gt;diff算法-&gt;定位两次虚拟DOM的差异-&gt;批量更新</span><br></pre></td></tr></table></figure>

<h3 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps(nextProps)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果父组件导致子组件重新渲染，即使props没有更改，也会调用此方法，如果只想处理更改，请确保当前值和变更值的比较。---React官方</span><br></pre></td></tr></table></figure>

<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">React组件会根据shouldComponentUpdate的返回值来决定是否执行后面的生命周期进而决定是否对组件进行re-render(重渲染)</span><br></pre></td></tr></table></figure>

<h3 id="getDerivedStateFromProps-新增-不是-componentWillMount-废弃-的替代品"><a href="#getDerivedStateFromProps-新增-不是-componentWillMount-废弃-的替代品" class="headerlink" title="getDerivedStateFromProps(新增)不是 componentWillMount(废弃)的替代品"></a>getDerivedStateFromProps(新增)不是 componentWillMount(废弃)的替代品</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getDerivedStateFromProps有且仅有一个用途：使用props来派生/更新state</span><br><span class="line"></span><br><span class="line">static getDerivedStateFromProps(props, state)</span><br><span class="line">1.静态方法，访问不到this</span><br><span class="line">2.参数 props(父组件)和state(自身)</span><br><span class="line">3.对象格式的返回值，用来更新自身state（更新并非覆盖式，而是替换式更新）</span><br><span class="line">4.挂载和更新都会触发此钩子</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">getDerivedStateFromProps是作为一个试图代替componentWillReceiveProps的API出现的。</span><br><span class="line">getDerivedStateFromProps不能完全和componentWillReceiveProps画等号</span><br><span class="line"></span><br><span class="line">原因：getDerivedStateFromProps仅可以代替componentWillReceiveProps来实现基于props派生state，原则来说能且只能做这一件事。</span><br></pre></td></tr></table></figure>

<h3 id="getSnapshotBeforeUpdate-新增-与-componentWillUpdate-废弃"><a href="#getSnapshotBeforeUpdate-新增-与-componentWillUpdate-废弃" class="headerlink" title="getSnapshotBeforeUpdate(新增)与 componentWillUpdate(废弃)"></a>getSnapshotBeforeUpdate(新增)与 componentWillUpdate(废弃)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)&#123;&#125;</span><br><span class="line">1. 执行时机在render方法之后，真实DOM更新之前</span><br><span class="line">2.返回值会作为第三个参数传递给componentDidUpdate</span><br></pre></td></tr></table></figure>

<h3 id="Fiber-架构（核心：可中断、可恢复、优先级）"><a href="#Fiber-架构（核心：可中断、可恢复、优先级）" class="headerlink" title="Fiber 架构（核心：可中断、可恢复、优先级）"></a>Fiber 架构（核心：可中断、可恢复、优先级）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Fiber是React16对React核心算法的一次重写</span><br><span class="line">2.Fiber会使原本同步的渲染过程变成异步的</span><br><span class="line">3.Fiber会将一个大的更新任务拆解为许多个小任务(工作单元)，这些工作单元有着不同的优先级，react可以根据优先级的高低去实现工作单元的打断和恢复</span><br><span class="line"></span><br><span class="line">Fiber架构的重要特征就是可以被打断的异步渲染模式，根据能否被打断这一标准，React16的生命周期被划分为render和commit两个阶段</span><br><span class="line">render阶段在执行过程中允许被打断（因为此阶段用户不可见，打断也无影响）</span><br><span class="line">commit阶段总是同步执行（涉及到同步渲染，会影响用户直观体验）</span><br><span class="line"></span><br><span class="line">render阶段是允许暂停、终止和重启的，这就导致render阶段的生命周期都是有可能被重复执行，所以要废弃处于render阶段的一些生命周期：componentWillMount、componenntUpdate、componentWillReceiveProps、shouldComponentUpdate(一般不会在这个生命周期中进行副作用操作，所以相对风险不大，没有被废弃)</span><br><span class="line"></span><br><span class="line">每个更新任务都会被赋予一个优先级</span><br><span class="line">若B任务的优先级高于当前任务A，那么当前处于Reconciler层的A任务就会被中断，当B任务完成后，A任务就会被重新推入Reconciler层，继续它的渲染，这便是所谓的“可恢复”</span><br><span class="line"></span><br><span class="line">Fiber架构对生命周期的影响</span><br><span class="line">react15: render开始-&gt;停不下来的递归计算(同步)-&gt;commit提交渲染</span><br><span class="line">react16: render开始-&gt;工作单元｜工作单元｜工作单元...(异步)-&gt;commit提交渲染</span><br></pre></td></tr></table></figure>

<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UI = render(data) 或 UI = f(data)</span><br><span class="line">React的视图会随着数据的变化而变化</span><br></pre></td></tr></table></figure>

<h3 id="React-Hooks-的使用原则"><a href="#React-Hooks-的使用原则" class="headerlink" title="React-Hooks 的使用原则"></a>React-Hooks 的使用原则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.只在React函数中调用Hook</span><br><span class="line">2.不要在循环、条件和嵌套函数中调用Hook(要确保hooks在每次渲染时都保持同样的执行顺序)</span><br><span class="line"></span><br><span class="line">从源码调用流程看原理：Hooks的正常运作，在底层依赖于顺序链表。</span><br><span class="line">mountState首次渲染构建链表并渲染，updateState依次遍历链表并渲染</span><br><span class="line"></span><br><span class="line">hooks的渲染就是通过依次遍历来定位每个hooks的内容，如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然就是不可控的</span><br></pre></td></tr></table></figure>

<h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟DOM本质上是JS和DOM之间的一个映射缓存，在形态上表现为一个能够描述DOM结构及其属性信息的JS对象。</span><br></pre></td></tr></table></figure>

<h3 id="Diff-逻辑的拆分与解读"><a href="#Diff-逻辑的拆分与解读" class="headerlink" title="Diff 逻辑的拆分与解读"></a>Diff 逻辑的拆分与解读</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Diff算法性能突破的关键点在于 分层对比</span><br><span class="line">2.类型一致的节点才有继续Diff的必要性</span><br><span class="line">3.key属性的设置，可以帮我们尽可能重用同一层级内的节点</span><br></pre></td></tr></table></figure>

<h3 id="setState-异步"><a href="#setState-异步" class="headerlink" title="setState 异步"></a>setState 异步</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setState-&gt;shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate</span><br><span class="line"></span><br><span class="line">批量更新：每来一个setState，就把它塞进一个队列里面存起来，等时机成熟，再把存起来的state结果做合并，最后只针对最后一次最新的state值走一次更新流程</span><br><span class="line"></span><br><span class="line">setState的表现会因为调用的场景不同而不同：</span><br><span class="line">1.在React钩子函数及合成事件中，表现为异步</span><br><span class="line">2.在setTimeout、setInterval等函数中，包括DOM原生事件中，表现为同步。</span><br></pre></td></tr></table></figure>

<h3 id="ReactDOM-render-调用栈的逻辑分层"><a href="#ReactDOM-render-调用栈的逻辑分层" class="headerlink" title="ReactDOM.render 调用栈的逻辑分层"></a>ReactDOM.render 调用栈的逻辑分层</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure>

<h3 id="React-事件系统"><a href="#React-事件系统" class="headerlink" title="React 事件系统"></a>React 事件系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当事件在具体的DOM节点上被触发后，最终都会冒泡到document上，document上所绑定的统一事件处理程序会将事件分发到具体的组件实例</span><br><span class="line"></span><br><span class="line">react合成事件：在底层抹平了不同浏览器的差异，在上层面向开发者暴漏统一的、稳定的、与DOM原生事件相同的事件接口（原生DOM事件可以通过e.nativeEvent查看）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>实现精简版useSize</title>
    <url>/2022/08/04/%E5%AE%9E%E7%8E%B0%E7%B2%BE%E7%AE%80%E7%89%88useSize/</url>
    <content><![CDATA[<p><a href="https://ahooks.gitee.io/">ahooks</a>是阿里开源的一套 React Hooks 库，里面封装了大量好用的 Hooks，最近也在项目中频繁使用到了库中<a href="https://ahooks.gitee.io/hooks/use-size">useSize</a>这个钩子函数，于是就学习了一下它的源码实现，并且实现了一个精简版<strong>useSize</strong>。</p>
<span id="more"></span>

<p>要点一：<strong>ResizeObserver</strong>监听 Element 内容区域的边界框改变</p>
<p>要点二：<strong>requestAnimationFrame</strong>优化高频刷新情况下的数据更新</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">MutableRefObject</span>,</span><br><span class="line">  useCallback,</span><br><span class="line">  useEffect,</span><br><span class="line">  useLayoutEffect,</span><br><span class="line">  useRef,</span><br><span class="line">  useState,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetValue</span>&lt;T&gt; = T | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TargetType</span> = <span class="title class_">HTMLElement</span> | <span class="title class_">Element</span> | <span class="title class_">Window</span> | <span class="title class_">Document</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">BasicTarget</span>&lt;T <span class="keyword">extends</span> <span class="title class_">TargetType</span> = <span class="title class_">Element</span>&gt; =</span><br><span class="line">  | (<span class="function">() =&gt;</span> <span class="title class_">TargetValue</span>&lt;T&gt;)</span><br><span class="line">  | <span class="title class_">TargetValue</span>&lt;T&gt;</span><br><span class="line">  | <span class="title class_">MutableRefObject</span>&lt;<span class="title class_">TargetValue</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Size</span> = &#123; <span class="attr">width</span>: <span class="built_in">number</span>; <span class="attr">height</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useSize</span>(<span class="params">target: BasicTarget</span>): <span class="title class_">Size</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState&lt;<span class="title class_">Size</span> | <span class="literal">undefined</span>&gt;();</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [resizeObserver, setResizeObserver] = useState&lt;<span class="title class_">ResizeObserver</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setRafState = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="function">(<span class="params">value: Size | ((prevState?: Size) =&gt; Size)</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cancelAnimationFrame</span>(ref.<span class="property">current</span>);</span><br><span class="line"></span><br><span class="line">      ref.<span class="property">current</span> = <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setState</span>(value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resizeObserver?.<span class="title function_">disconnect</span>();</span><br><span class="line">      <span class="title function_">cancelAnimationFrame</span>(ref.<span class="property">current</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">targetEl</span>: <span class="title class_">TargetValue</span>&lt;<span class="title class_">TargetType</span>&gt;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;current&quot;</span> <span class="keyword">in</span> target) &#123;</span><br><span class="line">      targetEl = target.<span class="property">current</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      targetEl = <span class="title function_">target</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      targetEl = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!targetEl) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resizeObserver = <span class="keyword">new</span> <span class="title class_">ResizeObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">      entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; clientWidth, clientHeight &#125; = entry.<span class="property">target</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">setRafState</span>(&#123;</span><br><span class="line">          <span class="attr">width</span>: clientWidth,</span><br><span class="line">          <span class="attr">height</span>: clientHeight,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setResizeObserver</span>(resizeObserver);</span><br><span class="line"></span><br><span class="line">    resizeObserver?.<span class="title function_">observe</span>(targetEl);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> size = <span class="title function_">useSize</span>(ref);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">border:</span> &quot;<span class="attr">1px</span> <span class="attr">solid</span> <span class="attr">red</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Try to resize the preview window <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        width: &#123;size?.width&#125;px, height: &#123;size?.height&#125;px</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅作为自己的学习积累，有什么需要改进的地方请大家多多批评指点 😅！</p>
]]></content>
      <tags>
        <tag>react-hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>常见设计模式</title>
    <url>/2019/09/27/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="SOLID-五大设计原则"><a href="#SOLID-五大设计原则" class="headerlink" title="SOLID 五大设计原则"></a>SOLID 五大设计原则</h2><span id="more"></span>

<ul>
<li><p>S 单一职责原则</p>
<p>一个程序只做好一件事，如果功能过于复杂就拆分开，每个部分保持独立</p>
</li>
<li><p>O 开放封闭原则</p>
<p>对修改封闭，对扩展开放</p>
</li>
<li><p>L 李氏置换原则</p>
<p>子类能覆盖父类</p>
</li>
<li><p>I 接口独立原则</p>
<p>保持接口的单一独立，避免出现胖接口</p>
</li>
<li><p>D 依赖倒置原则</p>
<p>面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
</li>
</ul>
<h2 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h2><ul>
<li><p>工厂模式</p>
<p>jquery、react createElement</p>
</li>
<li><p>单例模式</p>
<ul>
<li>自定义事件 EventBus 全局唯一</li>
<li>Vuex Redux 的 store 全局唯一</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">instance</span>: <span class="title class_">SingleTon</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(): <span class="title class_">SingleTon</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">SingleTon</span>.<span class="property">instance</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title class_">SingleTon</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">SingleTon</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SingleTon</span>.<span class="title function_">getInstance</span>(); <span class="comment">// 正确</span></span><br><span class="line"><span class="title class_">SingleTon</span>.<span class="property">instance</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SingleTon</span>(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>构造函数模式</p>
</li>
<li><p>建造者模式</p>
</li>
<li><p>代理模式</p>
</li>
<li><p>命令模式</p>
</li>
<li><p>观察者模式</p>
</li>
<li><p>适配器模式</p>
</li>
<li><p>职责链模式</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序</title>
    <url>/2019/10/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><span id="more"></span>

<h4 id="文件主要目录及文件作用"><a href="#文件主要目录及文件作用" class="headerlink" title="文件主要目录及文件作用"></a>文件主要目录及文件作用</h4> <!--more-->

<ul>
<li>component 组件文件夹<ul>
<li>navBar 底部组件<ul>
<li>navBar.js 底部组件的 js 代码</li>
<li>navBar.json 底部组件的配置文件</li>
<li>navBar.wxml 底部组件的 html 代码</li>
<li>navBar.wxss 底部组件的 css 代码</li>
</ul>
</li>
</ul>
</li>
<li>pages 页面文件夹<ul>
<li>index 首页<ul>
<li>index.js 首页的 js 代码</li>
<li>index.json 首页的配置文件</li>
<li>index.wxml 首页的 html 代码</li>
<li>index.wxss 首页的 css 代码</li>
</ul>
</li>
</ul>
</li>
<li>public 图片文件夹</li>
<li>utils 工具文件夹<ul>
<li>api.js 控制 api 的文件</li>
<li>md5.js 工具：MD5 加密文件</li>
<li>timestamp.js 工具：事件戳文件</li>
</ul>
</li>
<li>app.json 设置全局的基础数据等</li>
<li>app.wxss 公共样式，可通过 import 导入更多</li>
<li>project.config.json 项目配置文件</li>
</ul>
<h4 id="微信小程序生命周期"><a href="#微信小程序生命周期" class="headerlink" title="微信小程序生命周期"></a>微信小程序生命周期</h4><ul>
<li>onLoad(): 页面加载时触发，一个页面只会调用一次，可以在 onLoad 中获取打开当前页面<br>所调用的 query 参数。</li>
<li>onShow(): 页面显示/切入前台时触发，每次打开页面都会调用一次。</li>
<li>onReady(): 页面初次渲染完成时触发，一个页面只会调用一次。</li>
<li>onHide(): 页面隐藏/切入后台时触发，当 navigateTo 或底部 tab 切换时调用。</li>
<li>onUnload(): 页面卸载时触发。</li>
</ul>
<h4 id="app-json-是对当前小程序的全局配置，讲述三个配置各个项的含义"><a href="#app-json-是对当前小程序的全局配置，讲述三个配置各个项的含义" class="headerlink" title="app.json 是对当前小程序的全局配置，讲述三个配置各个项的含义?"></a>app.json 是对当前小程序的全局配置，讲述三个配置各个项的含义?</h4><ul>
<li>pages 字段：用于描述当前小程序所有页面路径，为了让微信客户端知道当前小程序页面<br>定义在那个目录。</li>
<li>window 字段：小程序所有页面的顶部背景颜色，文字颜色定义等。</li>
<li>tab 字段：小程序全局顶部 tab 或底部 tab。</li>
</ul>
<h4 id="小程序的-wxss-和-css-有哪些不一样的地方？"><a href="#小程序的-wxss-和-css-有哪些不一样的地方？" class="headerlink" title="小程序的 wxss 和 css 有哪些不一样的地方？"></a>小程序的 wxss 和 css 有哪些不一样的地方？</h4><ul>
<li>新像素单位 rpx</li>
<li>样式可直接使用 import 导入</li>
</ul>
<h4 id="小程序-wxml-和标准的-html-的异同？"><a href="#小程序-wxml-和标准的-html-的异同？" class="headerlink" title="小程序 wxml 和标准的 html 的异同？"></a>小程序 wxml 和标准的 html 的异同？</h4><p>都是用来描述页面的结构，都是由标签、属性等构成。</p>
<ul>
<li>标签名字不一样，且小程序标签更少，单一标签更多。</li>
<li>多了一些 wx:if 这样的属性和双大括号这样的表达式。</li>
<li>wxml 只能在微信小程序开发者工具中预览，html 可以在浏览器内预览。</li>
<li>组件封装不同，wxml 对组件进行了重新封装。</li>
<li>小程序运行在 JS Core 内，没有 DOM 树和 window 对象，小程序无法使用 window 对象和 document<br>对象。</li>
</ul>
<h4 id="小程序-wxss-和-css-的异同？"><a href="#小程序-wxss-和-css-的异同？" class="headerlink" title="小程序 wxss 和 css 的异同？"></a>小程序 wxss 和 css 的异同？</h4><p>都是用来描述页面的样子</p>
<ul>
<li>wxss 具有 css 大部分的特性，也做了一些扩充和修改。</li>
<li>wxss 新增了尺寸单位，wxss 在底层支持新的尺寸单位 rpx。</li>
<li>wxss 仅支持部分 css 选择器。</li>
<li>wxss 提供全局样式和局部样式。</li>
</ul>
<h4 id="小程序页面间有哪些传递数据的方法？"><a href="#小程序页面间有哪些传递数据的方法？" class="headerlink" title="小程序页面间有哪些传递数据的方法？"></a>小程序页面间有哪些传递数据的方法？</h4><ul>
<li>使用全局变量实现数据传递</li>
<li>页面跳转或重定向时，使用 url 带参数传递数据</li>
<li>使用组件模板 template 传递参数</li>
<li>使用数据库传递数据</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2019/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="什么是数据结构与算法？"><a href="#什么是数据结构与算法？" class="headerlink" title="什么是数据结构与算法？"></a>什么是数据结构与算法？</h2><span id="more"></span>

<ul>
<li>数据结构就是在计算机中，存储和组织数据的方式。<!--more-->
<pre><code>+ 常见的数据结构：
&lt;img src=&quot;http://vamknight.com/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png&quot;&gt;
&lt;!--more--&gt;
</code></pre>
</li>
<li>算法（Algorithm）的定义：<ul>
<li>算法就是解决问题的方法/步骤，数据结构的实现离不开算法。<ul>
<li>一个有限指令集，每条指令的描述不依赖于语言</li>
<li>接受一些输入（有些情况不需要输入）</li>
<li>产生输出</li>
<li>一定在有限步骤之后终止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><!--more-->

<ul>
<li><p>集合通常是由一组无序的，不能重复的元素构成。可以看成是一种特殊的数组，特殊之处在于里<br>面的元素没有顺序就意味着不能通过下标值进行访问，不能重复意味着相同的对象在同一个集合中只能存<br>在一份。</p>
<!-- more --></li>
<li><p>集合都有哪些常见的操作方法呢？</p>
<ul>
<li><p>add(value)：向集合添加一个新的项。</p>
</li>
<li><p>remove(value)：从集合移除一个值。</p>
</li>
<li><p>has(value)：如果值在集合中，返回 true，否则返回 false。</p>
</li>
<li><p>clear()：移除集合中的所有项。</p>
</li>
<li><p>size()：返回集合所包含元素的数量。与数组的 length 属性类似。</p>
</li>
<li><p>values()：返回一个包含集合中所有值的数组。</p>
</li>
</ul>
</li>
<li><p>集合之间都有哪些操作呢？</p>
<ul>
<li>并集：对于两个给定的集合，返回一个包含两个集合中所有元素的新集合。</li>
<li>交集：对于两个给定的集合，返回一个包含两个集合中公有元素的新集合。</li>
<li>差集：对于两个给定的集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的新集合。</li>
<li>子集：验证一个给定集合是否是另一个集合的子集。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/foolishmax/static/master/blogPic/%E9%9B%86%E5%90%88%E5%85%B3%E7%B3%BB.png">

<ul>
<li>集合封装的完整代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 封装集合的构造函数</span><br><span class="line">function Set() &#123;</span><br><span class="line">    // 使用一个对象来保存集合的元素</span><br><span class="line">    this.items = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 集合的操作方法</span><br><span class="line">    // 判断集合中是否有某个元素</span><br><span class="line">    Set.prototype.has = function (value) &#123;</span><br><span class="line">        return this.items.hasOwnProperty(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 向集合中添加元素</span><br><span class="line">    Set.prototype.add = function (value) &#123;</span><br><span class="line">        // 1.判断集合中是否已经包含了该元素</span><br><span class="line">        if (this.has(value)) return false</span><br><span class="line"></span><br><span class="line">        // 2.将元素添加到集合中</span><br><span class="line">        this.items[value] = value</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从集合中删除某个元素</span><br><span class="line">    Set.prototype.remove = function (value) &#123;</span><br><span class="line">        // 1.判断集合中是否包含该元素</span><br><span class="line">        if (!this.has(value)) return false</span><br><span class="line"></span><br><span class="line">        // 2.包含该元素, 那么将元素删除</span><br><span class="line">        delete this.items[value]</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空集合中所有的元素</span><br><span class="line">    Set.prototype.clear = function () &#123;</span><br><span class="line">        this.items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取集合的大小</span><br><span class="line">    Set.prototype.size = function () &#123;</span><br><span class="line">        return Object.keys(this.items).length</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        考虑兼容性问题, 使用下面的代码</span><br><span class="line">        var count = 0</span><br><span class="line">        for (var value in this.items) &#123;</span><br><span class="line">            if (this.items.hasOwnProperty(value)) &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取集合中所有的值</span><br><span class="line">    Set.prototype.values = function () &#123;</span><br><span class="line">        return Object.keys(this.items)</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        考虑兼容性问题, 使用下面的代码</span><br><span class="line">        var keys = []</span><br><span class="line">        for (var value in this.items) &#123;</span><br><span class="line">            keys.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">        return keys</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //集合之间的操作</span><br><span class="line">    //并集</span><br><span class="line">    Set.prototype.union = function (otherSet) &#123;</span><br><span class="line">        //this:集合对象A</span><br><span class="line">        //otherSet:集合对象B</span><br><span class="line">        //1.创建新的集合</span><br><span class="line">        var unionSet = new Set()</span><br><span class="line"></span><br><span class="line">        //2.将A集合中所有的元素添加到新集合中</span><br><span class="line">        var values = this.values()</span><br><span class="line">        for(var i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            unionSet.add(values[i])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.取出B集合中的元素，判断是否需要添加到新集合</span><br><span class="line">        values = otherSet.values()</span><br><span class="line">        for(var i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            unionSet.add(values[i])</span><br><span class="line">        &#125;</span><br><span class="line">        return unionSet</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //交集</span><br><span class="line">        Set.prototype.intersection = function (otherSet) &#123;</span><br><span class="line">            var intersectionSet = new Set()</span><br><span class="line">            var values = this.values()</span><br><span class="line">            //取出A集合一个个元素，判断是否同时存在于B中，存在B中，则添加到新集合中</span><br><span class="line">            for (var i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">                var item = values[i]</span><br><span class="line">                if (otherSet.has(item)) &#123;</span><br><span class="line">                    intersectionSet.add(item)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return intersectionSet</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    //差集</span><br><span class="line">    Set.prototype.difference = function (otherSet) &#123;</span><br><span class="line">        var differenceSet = new Set()</span><br><span class="line">        var values = this.values()</span><br><span class="line">        //取出A集合一个个元素，判断是否同时存在于B中，不存在B中，则添加到新集合中</span><br><span class="line">        for (var i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            var item = values[i]</span><br><span class="line">            if (!otherSet.has(item)) &#123;</span><br><span class="line">                differenceSet.add(item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return differenceSet</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 子集</span><br><span class="line">    Set.prototype.subset = function (otherSet) &#123;</span><br><span class="line">        var values = this.values()</span><br><span class="line">        for (var i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            var item = values[i]</span><br><span class="line">            if (!otherSet.has(item)) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><!--more-->

<ul>
<li><p>队列是一种受限的线性表，先进先出（FIFO First In First Out）。</p>
<ul>
<li>它只允许在表的前端（front）进行删除操作</li>
<li>在表的后端（rear）进行插入操作<!--more--></li>
</ul>
</li>
<li><p>常见应用场景： + 队列主要用在和时间有关的地方，特别是操作系统中，队列是实现多任务的重要机制。 + 消息机制可以通过队列来实现，进程调度也是使用队列来实现。</p>
<img src="https://raw.githubusercontent.com/foolishmax/static/master/blogPic/%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></li>
<li><p>队列有哪些常见的操作呢？</p>
<ul>
<li>enqueue(element): 向队列尾部添加一个（或多个）新的项。</li>
<li>dequeue(): 移除队列的第一项，并返回被移除的元素。</li>
<li>front(): 返回队列中第一个元素，队列不做任何改动。</li>
<li>isEmpty(): 如果队列中不包含任何元素，返回 true，否则返回 false。</li>
<li>size(): 返回队列包含的元素个数，与数组 length 类似。</li>
<li>toString(): 将队列中的内容，转成字符串形式。</li>
</ul>
</li>
<li><p>队列常见操作的封装：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//封装队列</span><br><span class="line">function Queue() &#123;</span><br><span class="line">    //属性</span><br><span class="line">    this.items = []</span><br><span class="line">    //将元素加入到队列中</span><br><span class="line">    Queue.prototype.enqueue = function(element) &#123;</span><br><span class="line">        this.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    //从队列中删除前端元素</span><br><span class="line">    Queue.prototype.dequeue = function() &#123;</span><br><span class="line">        return this.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    //查看前端的元素</span><br><span class="line">    Queue.prototype.front = function() &#123;</span><br><span class="line">        return this.items[0]</span><br><span class="line">    &#125;</span><br><span class="line">    //查看队列是否为空</span><br><span class="line">    Queue.prototype.isEmpty = function() &#123;</span><br><span class="line">        return this.items.length == 0</span><br><span class="line">    &#125;</span><br><span class="line">    //查看队列中元素的个数</span><br><span class="line">    Queue.prototype.size = function() &#123;</span><br><span class="line">        return this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    //toString方法</span><br><span class="line">    Queue.prototype.toString = function() &#123;</span><br><span class="line">        var resultString = &#x27;&#x27;</span><br><span class="line">        for (var i = 0; i&lt; this.items.length; i++) &#123;</span><br><span class="line">            resultString += this.items[i] + &#x27; &#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用队列函数</span><br><span class="line">var queue = new Queue()</span><br><span class="line">queue.enqueue(20)</span><br><span class="line">alert(queue)</span><br></pre></td></tr></table></figure>

<ul>
<li>面试题： 击鼓传花</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//面试题: 击鼓传花</span><br><span class="line">function passGame(nameList, num) &#123;</span><br><span class="line">    //创建一个队列结构</span><br><span class="line">    var queue = new Queue()</span><br><span class="line">    //将所有人加入到队列中</span><br><span class="line">    for(var i = 0; i &lt; nameList.length; i++) &#123;</span><br><span class="line">        queue.enqueue(nameList[i])</span><br><span class="line">    &#125;</span><br><span class="line">    //开始数数字</span><br><span class="line">    while (queue.size() &gt; 1) &#123;</span><br><span class="line">        //不是num重新加入队列末尾</span><br><span class="line">        //是num从队列中删除</span><br><span class="line">        for (var i = 0; i&lt; num - 1; i++) &#123;</span><br><span class="line">            queue.enqueue(queue.dequeue())</span><br><span class="line">        &#125;</span><br><span class="line">        queue.dequeue()</span><br><span class="line">    &#125;</span><br><span class="line">    return queque.front()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>封装优先队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//封装优先级队列</span><br><span class="line">function PriorityQueue() &#123;</span><br><span class="line">    //内部创建一个构造类</span><br><span class="line">    function QueueElement(element, priority) &#123;</span><br><span class="line">        this.element = element</span><br><span class="line">        this.priority = priority</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //属性</span><br><span class="line">    this.items = []</span><br><span class="line"></span><br><span class="line">    //实现队列元素的插入</span><br><span class="line">    PriorityQueue.prototype.enqueue = function(element, priority) &#123;</span><br><span class="line">        //创建QueueElement对象</span><br><span class="line">        var queueElement = new QueueElement(element, priority)</span><br><span class="line"></span><br><span class="line">        //判断为队列是否为空</span><br><span class="line">        if (this.items.length == 0) &#123;</span><br><span class="line">            this.items.push(queueElement)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var added = false</span><br><span class="line">            for (var i = 0; i &lt; this.items.length; i++) &#123;</span><br><span class="line">                if (queueElement.priority &lt; this.items[i].priority) &#123;</span><br><span class="line">                    this.items.splice(i, 0, queueElement)</span><br><span class="line">                    added = true</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!added) &#123;</span><br><span class="line">                this.items.push(queueElement)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        //从队列中删除前端元素</span><br><span class="line">    PriorityQueue.prototype.dequeue = function() &#123;</span><br><span class="line">        return this.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    //查看前端的元素</span><br><span class="line">    PriorityQueue.prototype.front = function() &#123;</span><br><span class="line">        return this.items[0]</span><br><span class="line">    &#125;</span><br><span class="line">    //查看队列是否为空</span><br><span class="line">    PriorityQueue.prototype.isEmpty = function() &#123;</span><br><span class="line">        return this.items.length == 0</span><br><span class="line">    &#125;</span><br><span class="line">    //查看队列中元素的个数</span><br><span class="line">    PriorityQueue.prototype.size = function() &#123;</span><br><span class="line">        return this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    //toString方法</span><br><span class="line">    PriorityQueue.prototype.toString = function() &#123;</span><br><span class="line">        var resultString = &#x27;&#x27;</span><br><span class="line">        for (var i = 0; i&lt; this.items.length; i++) &#123;</span><br><span class="line">            resultString += this.items[i].element + &#x27;-&#x27; + this.items[i].priority + &#x27; &#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试代码</span><br><span class="line">var pq = new PriorityQueue()</span><br><span class="line">pq.enqueue(&#x27;a&#x27;,10)</span><br><span class="line">pq.enqueue(&#x27;b&#x27;,100)</span><br><span class="line">pq.enqueue(&#x27;c&#x27;,50)</span><br><span class="line">alert(pq)</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><!--more-->

<ul>
<li><p>什么是链表？ + 链表的元素在内存中不必是连续的空间，链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。</p>
<!--more--></li>
<li><p>相对于数组，链表都有哪些优势？</p>
<ul>
<li>内存空间不是比是连续的. 可以充分利用计算机的内存. 实现灵活的内存动态管理。</li>
<li>链表不必在创建时就确定大小, 并且大小可以无限的延伸下去。</li>
<li>链表在插入和删除数据时, 时间复杂度可以达到 O(1). 相对数组效率高很多。</li>
</ul>
</li>
<li><p>相对于数组，链表都有哪些缺点？ + 链表访问任何一个位置的元素时, 都需要从头开始访问.(无法跳过第一个元素访问任何一个元素)。 + 无法通过下标直接访问元素, 需要从头一个个访问, 直到找到对应的问题。</p>
<!--more--></li>
<li><p>链表的数据结构：</p>
<img src="http://vamknight.com/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png"></li>
<li><p>链表有哪些常见操作？ + append(element)：向列表尾部添加一个新的项</p>
<pre><code>+ insert(position, element)：向列表的特定位置插入一个新的项。

+ update(position, element): 修改某一个位置上的元素。

+ remove(element)：从列表中移除一项。

+ indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。

// 链表中的属性
this.length = 0
this.head = null

// 链表尾部追加元素方法
LinkedList.prototype.append = function (element) &#123;
    // 1.根据新元素创建节点
    var newNode = new Node(element)

    // 2.判断原来链表是否为空
    if (this.head === null) &#123; /
+ removeAt(position)：从列表的特定位置移除一项。
</code></pre>
<p>this.next = null<br>}<br>/ 链表尾空<br>this.head = newNode<br>} else { // 链表不为空<br>// 2.1.定义变量, 保存当前找到的节点<br>var current = this.head<br>while (current.next) {<br>current = current.next<br>}</p>
<pre><code>        // 2.2.找到最后一项, 将其next赋值为node
        current.next = newNode
    &#125;

    // 3.链表长度增加1
    this.length++
&#125;

// 链表的toString方法
LinkedList.prototype.toString = function () &#123;
    // 1.定义两个变量
    var current = this.head
    var listString = &quot;&quot;

    // 2.循环获取链表中所有的元素
    while (current) &#123;
        listString += &quot;,&quot; + current.element
        current = current.next
    &#125;

    // 3.返回最终结果
    return listString.slice(1)
&#125;

// 根据下标删除元素
LinkedList.prototype.insert = function (position, element) &#123;
    // 1.检测越界问题: 越界插入失败
    if (position &lt; 0 || position &gt; this.length) return false

    // 2.定义变量, 保存信息
    var newNode = new Node(element)
    var current = this.head
    var previous = null
    index = 0

    // 3.判断是否列表是否在第一个位置插入
    if (position == 0) &#123;
        newNode.next = current
        this.head = newNode
    &#125; else &#123;
        while (index++ &lt; position) &#123;
            previous = current
            current = current.next
        &#125;

        newNode.next = current
        previous.next = newNode
    &#125;

    // 4.length+1
    this.length++

    return true
&#125;

//update方法
LinkedList.prototype.update = function (position, newData) &#123;
    if (position &lt; 0 || position &gt;= this.length) return  null

    var current = this.head
    var index = 0
    while (index++ &lt; position) &#123;
        current = current.next
    &#125;
    current.data = newData
    return true
&#125;

// 根据位置移除节点
LinkedList.prototype.removeAt = function (position) &#123;
    // 1.检测越界问题: 越界移除失败, 返回null
    if (position &lt; 0 || position &gt;= this.length) return null

    // 2.定义变量, 保存信息
    var current = this.head
    var previous = null
    var index = 0

    // 3.判断是否是移除第一项
    if (position === 0) &#123;
        this.head = current.next
    &#125; else &#123;
        while (index++ &lt; position) &#123;
            previous = current
            current = current.next
        &#125;

        previous.next = current.next
    &#125;

    // 4.length-1
    this.length--

    // 5.返回移除的数据
    return current.element
&#125;

// 根据元素获取链表中的位置
LinkedList.prototype.indexOf = function (element) &#123;
    // 1.定义变量, 保存信息
    var current = this.head
    index = 0

    // 2.找到元素所在的位置
    while (current) &#123;
        if (current.element === element) &#123;
            return index
        &#125;
        index++
        current = current.next
    &#125;

    // 3.来到这个位置, 说明没有找到, 则返回-1
    return -1
&#125;

// 根据元素删除信息
LinkedList.prototype.remove = function (element) &#123;
    var index = this.indexOf(element)
    return this.removeAt(index)
&#125;

// 判断链表是否为空
LinkedList.prototype.isEmpty = function () &#123;
    return this.length == 0
&#125;

// 获取链表的长度
LinkedList.prototype.size = function () &#123;
    return this.length
&#125;

// 获取第一个节点
LinkedList.prototype.getFirst = function () &#123;
    return this.head.element
&#125;
</code></pre>
<p>}</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 以上操作的都是单向链表，下面来认识一下双向链表。</span><br><span class="line">- 单向链表的缺点：</span><br><span class="line">    + 只能从头遍历到尾，也就是链表的相连的过程是单向的，实现的原理是上一个链表中有一个指向下一个的引用。</span><br><span class="line">    + 我们可以轻松的到达下一个节点，但是回到上一个节点是很难的，只能从头遍历。</span><br><span class="line">    + 但是，实际开发中，经常会遇到回到上一个节点的情况。</span><br><span class="line">- 双向链表：</span><br><span class="line">    + 既可以从头遍历到尾，又可以从尾遍历到头。</span><br><span class="line">    + 也就是链表相连的过程是双向的。</span><br><span class="line">    + 实现的原理就是既有先前连接的引用，也有一个向后连接的引用。</span><br><span class="line">    + 双向链表可以有效的解决单向链表的问题。</span><br><span class="line">- 双向链表的一些缺点：</span><br><span class="line">    + 每次在插入或删除某一个节点时，需要处理四个引用，实现起来比较复杂。</span><br><span class="line">    + 相对于单向链表占用的内存更大一些。</span><br><span class="line"></span><br><span class="line">- 双向链表的结构图：</span><br><span class="line">&lt;img src=&quot;http://vamknight.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png&quot;&gt;</span><br><span class="line"></span><br><span class="line">- 双向链表的特点：</span><br><span class="line">    + 可以使用一个head和一个tail分别指向头部和尾部的节点。</span><br><span class="line">    + 每个节点都是由三部分组成：前一个节点的指针（prev）、保存的元素（item）、后一个节点的指针（next）。</span><br><span class="line">    + 双向链表的第一个节点的prev是null。</span><br><span class="line">    + 双向链表的最后一个节点的next是null。</span><br><span class="line"></span><br><span class="line">- 双向链表都有哪些常见操作？</span><br><span class="line">    + append(element)：向列表尾部添加一个新的项</span><br><span class="line"></span><br><span class="line">    + insert(position, element)：向列表的特定位置插入一个新的项。</span><br><span class="line"></span><br><span class="line">    + update(position, element): 修改某一个位置上的元素。</span><br><span class="line"></span><br><span class="line">    + get(position): 获取对应位置的元素。</span><br><span class="line"></span><br><span class="line">    + remove(element)：从列表中移除一项。</span><br><span class="line"></span><br><span class="line">    + indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。</span><br><span class="line"></span><br><span class="line">    + removeAt(position)：从列表的特定位置移除一项。</span><br><span class="line"></span><br><span class="line">    + isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。</span><br><span class="line"></span><br><span class="line">    + size()：返回链表包含的元素个数。与数组的length属性类似。</span><br><span class="line"></span><br><span class="line">    + toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。</span><br><span class="line"></span><br><span class="line">    + forwardString(): 返回正向遍历的节点字符串形式。</span><br><span class="line"></span><br><span class="line">    + backwardString(): 返回反向遍历的节点字符串形式。</span><br><span class="line"></span><br><span class="line">- 双向链表常见方法的封装：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>// 创建双向链表的构造函数<br>function DoublyLinkedList() {<br>// 创建节点构造函数<br>function Node(element) {<br>this.element = element<br>this.next = null<br>this.prev = null // 新添加的<br>}</p>
<pre><code>// 定义属性
this.length = 0
this.head = null
this.tail = null // 新添加的

// 定义相关操作方法
// 在尾部追加数据
DoublyLinkedList.prototype.append = function (element) &#123;
    // 1.根据元素创建节点
    var newNode = new Node(element)

    // 2.判断列表是否为空列表
    if (this.head == null) &#123;
        this.head = newNode
        this.tail = newNode
    &#125; else &#123;
        this.tail.next = newNode
        newNode.prev = this.tail
        this.tail = newNode
    &#125;

    // 3.length+1
    this.length++
&#125;

// 在任意位置插入数据
DoublyLinkedList.prototype.insert = function (position, element) &#123;
    // 1.判断越界的问题
    if (position &lt; 0 || position &gt; this.length) return false

    // 2.创建新的节点
    var newNode = new Node(element)

    // 3.判断插入的位置
    if (position === 0) &#123; // 在第一个位置插入数据
        // 判断链表是否为空
        if (this.head == null) &#123;
            this.head = newNode
            this.tail = newNode
        &#125; else &#123;
            this.head.prev = newNode
            newNode.next = this.head
            this.head = newNode
        &#125;
    &#125; else if (position === this.length) &#123; // 插入到最后的情况
        // 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么?
        this.tail.next = newNode
        newNode.prev = this.tail
        this.tail = newNode
    &#125; else &#123; // 在中间位置插入数据
        // 定义属性
        var index = 0
        var current = this.head
        var previous = null

        // 查找正确的位置
        while (index++ &lt; position) &#123;
            previous = current
            current = current.next
        &#125;

        // 交换节点的指向顺序
        newNode.next = current
        newNode.prev = previous
        current.prev = newNode
        previous.next = newNode
    &#125;

    // 4.length+1
    this.length++

    return true
&#125;

// 根据位置删除对应的元素
DoublyLinkedList.prototype.removeAt = function (position) &#123;
    // 1.判断越界的问题
    if (position &lt; 0 || position &gt;= this.length) return null

    // 2.判断移除的位置
    var current = this.head
    if (position === 0) &#123;
        if (this.length == 1) &#123;
            this.head = null
            this.tail = null
        &#125; else &#123;
            this.head = this.head.next
            this.head.prev = null
        &#125;
    &#125; else if (position === this.length -1) &#123;
        current = this.tail
        this.tail = this.tail.prev
        this.tail.next = null
    &#125; else &#123;
        var index = 0
        var previous = null

        while (index++ &lt; position) &#123;
            previous = current
            current = current.next
        &#125;

        previous.next = current.next
        current.next.prev = previous
    &#125;

    // 3.length-1
    this.length--

    return current.element
&#125;

// 根据元素获取在链表中的位置
DoublyLinkedList.prototype.indexOf = function (element) &#123;
    // 1.定义变量保存信息
    var current = this.head
    var index = 0

    // 2.查找正确的信息
    while (current) &#123;
        if (current.element === element) &#123;
            return index
        &#125;
        index++
        current = current.next
    &#125;

    // 3.来到这个位置, 说明没有找到, 则返回-1
    return -1
&#125;

// 根据元素删除
DoublyLinkedList.prototype.remove = function (element) &#123;
    var index = this.indexOf(element)
    return this.removeAt(index)
&#125;

// 判断是否为空
DoublyLinkedList.prototype.isEmpty = function () &#123;
    return this.length === 0
&#125;

// 获取链表长度
DoublyLinkedList.prototype.size = function () &#123;
    return this.length
&#125;

// 获取第一个元素
DoublyLinkedList.prototype.getHead = function () &#123;
    return this.head.element
&#125;

// 获取最后一个元素
DoublyLinkedList.prototype.getTail = function () &#123;
    return this.tail.element
&#125;

// 遍历方法的实现
// 正向遍历的方法
DoublyLinkedList.prototype.forwardString = function () &#123;
    var current = this.head
    var forwardStr = &quot;&quot;

    while (current) &#123;
        forwardStr += &quot;,&quot; + current.element
        current = current.next
    &#125;

    return forwardStr.slice(1)
&#125;

// 反向遍历的方法
DoublyLinkedList.prototype.reverseString = function () &#123;
    var current = this.tail
    var reverseStr = &quot;&quot;

    while (current) &#123;
        reverseStr += &quot;,&quot; + current.element
        current = current.prev
    &#125;

    return reverseStr.slice(1)
&#125;

// 实现toString方法
DoublyLinkedList.prototype.toString = function () &#123;
    return this.forwardString()
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><!--more-->

<ul>
<li><p>我们知道数组是一种线性结构，可以在数组的任意位置插入或删除数据。但有些时候，我们为了实现某种功能，必须对这种 任意性 加以限制，而我们的栈和队列就是比较常见的 <strong>受限的线性结构</strong>。</p>
</li>
<li><p>栈是一种<strong>先进后出</strong>或**后进先出(LIFO Last In First Out)**的数据结构，栈内的元素只能通过列表的一端访问，这一端称为栈顶，因为<br>数据只能在栈顶添加或删除，所以只要数据的保存满足“先进后出或后进先出”的原理，都优先考虑使用栈。</p>
</li>
<li><p>栈的结构示意图：</p>
<img src="https://raw.githubusercontent.com/foolishmax/static/master/blogPic/%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<!--more--></li>
<li><p>栈常见有哪些操作？</p>
</li>
</ul>
<ul>
<li>push（element）：添加一个新元素到栈顶位置。</li>
<li>pop（）：移除栈顶的元素，同时返回被移除的元素。</li>
<li>peek（）：返回栈顶的元素，不对栈做任何修改。</li>
<li>isEmpty（）：如果栈里没有任何元素返回 true，否则返回 false。</li>
<li>size（）：返回栈里的元素个数，类似数组中的 length。</li>
<li>toString（）：将栈结构的内容以字符形式返回。</li>
</ul>
<ul>
<li>栈常见操作的封装：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Stack() &#123;</span><br><span class="line">    this.items = []</span><br><span class="line">    //将元素压入栈</span><br><span class="line">    Stack.prototype.push = function(element) &#123;</span><br><span class="line">        this.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    //从栈中移除元素</span><br><span class="line">    Stack.prototype.pop = function() &#123;</span><br><span class="line">        return this.items.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    //查看栈顶元素</span><br><span class="line">    Stack.prototype.peek = function() &#123;</span><br><span class="line">        return this.items[this.items.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">    //判断栈是否为空</span><br><span class="line">    Stack.prototype.isEmpty = function() &#123;</span><br><span class="line">        return this.items.length == 0</span><br><span class="line">    &#125;</span><br><span class="line">    //判断栈中元素个数</span><br><span class="line">    Stack.prototype.size = function() &#123;</span><br><span class="line">        return this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    //toString方法</span><br><span class="line">    Stack.prototype.toString = function() &#123;</span><br><span class="line">        var resultString = &#x27;&#x27;</span><br><span class="line">        for (var i = 0; i&lt; this.items.length; i++) &#123;</span><br><span class="line">            resultString += this.items[i] + &#x27; &#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//栈的使用</span><br><span class="line">var s = new Stack()</span><br><span class="line">s.push(23)</span><br><span class="line">alert(s)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//函数十进制转为二进制</span><br><span class="line">function dec2bin(decNumber) &#123;</span><br><span class="line">    //定义栈对象</span><br><span class="line">    var stack = new Stack()</span><br><span class="line">    while (decNumber &gt; 0) &#123;</span><br><span class="line">        //获取余数放入栈中</span><br><span class="line">        stack.push(decNumber % 2)</span><br><span class="line">        //获取除后的结果,作为下次操作的对象</span><br><span class="line">        decNumber = Math.floor(decNumber / 2)</span><br><span class="line">    &#125;</span><br><span class="line">    //从栈中取出0和1</span><br><span class="line">    var binaryString = &#x27;&#x27;</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        binaryString += stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    return binaryString</span><br><span class="line">&#125;</span><br><span class="line">//调用函数</span><br><span class="line">alert(dec2bin(100))</span><br></pre></td></tr></table></figure>

<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><!--more-->

<h4 id="五大算法"><a href="#五大算法" class="headerlink" title="五大算法"></a>五大算法</h4><ul>
<li><p>贪心算法</p>
</li>
<li><p>分治算法</p>
</li>
<li><p>动态规划</p>
</li>
<li><p>回溯法</p>
</li>
<li><p>分支限界法</p>
</li>
</ul>
<!--more-->

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bubleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (let outer = len ; outer &gt;= 2; outer--) &#123;</span><br><span class="line">        for(let inner = 0; inner &lt;=outer - 1; inner++) &#123;</span><br><span class="line">            if(arr[inner] &gt; arr[inner + 1]) &#123;</span><br><span class="line">                [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function selectSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for(let i = 0 ;i &lt; len - 1; i++) &#123;</span><br><span class="line">        for(let j = i ; j&lt;len; j++) &#123;</span><br><span class="line">            if(arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                [arr[i],arr[j]] = [arr[j],arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function insertSort(arr) &#123;</span><br><span class="line">    for(let i = 1; i &lt; arr.length; i++) &#123;  //外循环从1开始，默认arr[0]是有序段</span><br><span class="line">        for(let j = i; j &gt; 0; j--) &#123;  //j = i,将arr[j]依次插入有序段中</span><br><span class="line">            if(arr[j] &lt; arr[j-1]) &#123;</span><br><span class="line">                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    if(arr.length &lt;= 1) &#123;</span><br><span class="line">        return arr;  //递归出口</span><br><span class="line">    &#125;</span><br><span class="line">    var left = [],</span><br><span class="line">        right = [],</span><br><span class="line">        current = arr.splice(0,1);</span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if(arr[i] &lt; current) &#123;</span><br><span class="line">            left.push(arr[i])  //放在左边</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(arr[i]) //放在右边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return quickSort(left).concat(current,quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建列表类</span><br><span class="line">function ArrayList() &#123;</span><br><span class="line">    this.array = []</span><br><span class="line">    //方法</span><br><span class="line">    //插入方法</span><br><span class="line">    ArrayList.prototype.insert = function(item)&#123;</span><br><span class="line">        this.array.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    //toString 方便测试</span><br><span class="line">    ArrayList.prototype.toString = function()&#123;</span><br><span class="line">        return this.array.join(&#x27;-&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--var arr = new ArrayList()--&gt;</span><br><span class="line">&lt;!--arr.insert(1)--&gt;</span><br><span class="line">&lt;!--arr.insert(2)--&gt;</span><br><span class="line">&lt;!--arr.insert(3)--&gt;</span><br><span class="line"></span><br><span class="line">//实现排序算法</span><br><span class="line">//冒泡排序</span><br><span class="line">ArrayList.prototype.bubbleSort = function () &#123;</span><br><span class="line">    // 1.获取数组的长度</span><br><span class="line">    var length = this.array.length</span><br><span class="line"></span><br><span class="line">    // 2.反向循环, 因此次数越来越少</span><br><span class="line">    for (var i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        // 3.根据i的次数, 比较循环到i位置</span><br><span class="line">        for (var j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            // 4.如果j位置比j+1位置的数据大, 那么就交换</span><br><span class="line">            if (this.array[j] &gt; this.array[j+1]) &#123;</span><br><span class="line">                // 交换</span><br><span class="line">                this.swap(j, j+1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList.prototype.swap = function (m, n) &#123;</span><br><span class="line">    var temp = this.array[m]</span><br><span class="line">    this.array[m] = this.array[n]</span><br><span class="line">    this.array[n] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//选择排序</span><br><span class="line">ArrayList.prototype.selectionSort = function () &#123;</span><br><span class="line">    // 1.获取数组的长度</span><br><span class="line">    var length = this.array.length</span><br><span class="line"></span><br><span class="line">    // 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span><br><span class="line">    for (var i = 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">        // 3.内层循环: 从i+1位置开始, 和后面的内容比较</span><br><span class="line">        var min = i</span><br><span class="line">        for (var j = min + 1; j &lt; length; j++) &#123;</span><br><span class="line">            // 4.如果i位置的数据大于j位置的数据, 那么记录最小的位置</span><br><span class="line">            if (this.array[min] &gt; this.array[j]) &#123;</span><br><span class="line">                min = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 5.交换min和i位置的数据</span><br><span class="line">        this.swap(min, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//插入排序</span><br><span class="line">ArrayList.prototype.insertionSort = function () &#123;</span><br><span class="line">    // 1.获取数组的长度</span><br><span class="line">    var length = this.array.length</span><br><span class="line"></span><br><span class="line">    // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span><br><span class="line">    for (var i = 1; i &lt; length; i++) &#123;</span><br><span class="line">        // 3.记录选出的元素, 放在变量temp中</span><br><span class="line">        var j = i</span><br><span class="line">        var temp = this.array[i]</span><br><span class="line"></span><br><span class="line">        // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span><br><span class="line">        while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) &#123;</span><br><span class="line">            this.array[j] = this.array[j-1]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5.将选出的j位置, 放入temp元素</span><br><span class="line">        this.array[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//希尔排序</span><br><span class="line">ArrayList.prototype.shellSort = function () &#123;</span><br><span class="line">    // 1.获取数组的长度</span><br><span class="line">    var length = this.array.length</span><br><span class="line"></span><br><span class="line">    // 2.根据长度计算增量</span><br><span class="line">    var gap = Math.floor(length / 2)</span><br><span class="line"></span><br><span class="line">    // 3.增量不断变量小, 大于0就继续排序</span><br><span class="line">    while (gap &gt; 0) &#123;</span><br><span class="line">        // 4.实现插入排序</span><br><span class="line">        for (var i = gap; i &lt; length; i++) &#123;</span><br><span class="line">            // 4.1.保存临时变量</span><br><span class="line">            var j = i</span><br><span class="line">            var temp = this.array[i]</span><br><span class="line"></span><br><span class="line">            // 4.2.插入排序的内层循环</span><br><span class="line">            while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) &#123;</span><br><span class="line">                this.array[j] = this.array[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 4.3.将选出的j位置设置为temp</span><br><span class="line">            this.array[j] = temp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5.重新计算新的间隔</span><br><span class="line">        gap = Math.floor(gap / 2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//快速排序</span><br><span class="line"> // 选择枢纽</span><br><span class="line"> ArrayList.prototype.median = function (left, right) &#123;</span><br><span class="line">     // 1.求出中间的位置</span><br><span class="line">     var center = Math.floor((left + right) / 2)</span><br><span class="line"></span><br><span class="line">     // 2.判断并且进行交换</span><br><span class="line">     if (this.array[left] &gt; this.array[center]) &#123;</span><br><span class="line">         this.swap(left, center)</span><br><span class="line">     &#125;</span><br><span class="line">     if (this.array[center] &gt; this.array[right]) &#123;</span><br><span class="line">         this.swap(center, right)</span><br><span class="line">     &#125;</span><br><span class="line">     if (this.array[left] &gt; this.array[right]) &#123;</span><br><span class="line">         this.swap(left, right)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // 3.巧妙的操作: 将center移动到right - 1的位置.</span><br><span class="line">     this.swap(center, right - 1)</span><br><span class="line"></span><br><span class="line">     // 4.返回pivot</span><br><span class="line">     return this.array[right - 1]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 快速排序实现</span><br><span class="line"> ArrayList.prototype.quickSort = function () &#123;</span><br><span class="line">     this.quickSortRec(0, this.array.length - 1)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ArrayList.prototype.quickSortRec = function (left, right) &#123;</span><br><span class="line">     // 0.递归结束条件</span><br><span class="line">     if (left &gt;= right) return</span><br><span class="line"></span><br><span class="line">     // 1.获取枢纽</span><br><span class="line">     var pivot = this.median(left, right)</span><br><span class="line"></span><br><span class="line">     // 2.开始进行交换</span><br><span class="line">     // 2.1.记录左边开始位置和右边开始位置</span><br><span class="line">     var i = left</span><br><span class="line">     var j = right - 1</span><br><span class="line">     // 2.2.循环查找位置</span><br><span class="line">     while (true) &#123;</span><br><span class="line">         while (this.array[++i] &lt; pivot) &#123; &#125;</span><br><span class="line">         while (this.array[--j] &gt; pivot) &#123; &#125;</span><br><span class="line">         if (i &lt; j) &#123;</span><br><span class="line">               // 2.3.交换两个数值</span><br><span class="line">             this.swap(i, j)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             // 2.4.当i&lt;j的时候(一定不会=, 看下面解释中的序号3), 停止循环因为两边已经找到了相同的位置</span><br><span class="line">             break</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // 3.将枢纽放在正确的位置</span><br><span class="line">     this.swap(i, right - 1)</span><br><span class="line"></span><br><span class="line">     // 4.递归调用左边</span><br><span class="line">     this.quickSortRec(left, i - 1)</span><br><span class="line">     this.quickSortRec(i + 1, right)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 封装ArrayList</span><br><span class="line"> function ArrayList() &#123;</span><br><span class="line">     this.array = []</span><br><span class="line"></span><br><span class="line">     ArrayList.prototype.insert = function (item) &#123;</span><br><span class="line">         this.array.push(item)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ArrayList.prototype.toString = function () &#123;</span><br><span class="line">         return this.array.join()</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ArrayList.prototype.bubbleSort = function () &#123;</span><br><span class="line">         // 1.获取数组的长度</span><br><span class="line">         var length = this.array.length</span><br><span class="line"></span><br><span class="line">         // 2.反向循环, 因此次数越来越少</span><br><span class="line">         for (var i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">             // 3.根据i的次数, 比较循环到i位置</span><br><span class="line">             for (var j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                 // 4.如果j位置比j+1位置的数据大, 那么就交换</span><br><span class="line">                 if (this.array[j] &gt; this.array[j+1]) &#123;</span><br><span class="line">                     // 交换</span><br><span class="line">                     this.swap(j, j+1)</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ArrayList.prototype.selectionSort = function () &#123;</span><br><span class="line">         // 1.获取数组的长度</span><br><span class="line">         var length = this.array.length</span><br><span class="line"></span><br><span class="line">         // 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span><br><span class="line">         for (var i = 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">             // 3.内层循环: 从i+1位置开始, 和后面的内容比较</span><br><span class="line">             var min = i</span><br><span class="line">             for (var j = min + 1; j &lt; length; j++) &#123;</span><br><span class="line">                 // 4.如果i位置的数据大于j位置的数据, 记录最小的位置</span><br><span class="line">                 if (this.array[min] &gt; this.array[j]) &#123;</span><br><span class="line">                     min = j</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             this.swap(min, i)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ArrayList.prototype.insertionSort = function () &#123;</span><br><span class="line">         // 1.获取数组的长度</span><br><span class="line">         var length = this.array.length</span><br><span class="line"></span><br><span class="line">         // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span><br><span class="line">         for (var i = 1; i &lt; length; i++) &#123;</span><br><span class="line">             // 3.记录选出的元素, 放在变量temp中</span><br><span class="line">             var j = i</span><br><span class="line">             var temp = this.array[i]</span><br><span class="line"></span><br><span class="line">             // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span><br><span class="line">             while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) &#123;</span><br><span class="line">                 this.array[j] = this.array[j-1]</span><br><span class="line">                 j--</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             // 5.将选出的j位置, 放入temp元素</span><br><span class="line">             this.array[j] = temp</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ArrayList.prototype.shellSort = function () &#123;</span><br><span class="line">         // 1.获取数组的长度</span><br><span class="line">         var length = this.array.length</span><br><span class="line"></span><br><span class="line">         // 2.根据长度计算增量</span><br><span class="line">         var gap = Math.floor(length / 2)</span><br><span class="line"></span><br><span class="line">         // 3.增量不断变量小, 大于0就继续排序</span><br><span class="line">         while (gap &gt; 0) &#123;</span><br><span class="line">             // 4.实现插入排序</span><br><span class="line">             for (var i = gap; i &lt; length; i++) &#123;</span><br><span class="line">                 // 4.1.保存临时变量</span><br><span class="line">                 var j = i</span><br><span class="line">                 var temp = this.array[i]</span><br><span class="line"></span><br><span class="line">                 // 4.2.插入排序的内存循环</span><br><span class="line">                 while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) &#123;</span><br><span class="line">                     this.array[j] = this.array[j - gap]</span><br><span class="line">                     j -= gap</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 // 4.3.将选出的j位置设置为temp</span><br><span class="line">                 this.array[j] = temp</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             // 5.重新计算新的间隔</span><br><span class="line">             gap = Math.floor(gap / 2)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ArrayList.prototype.swap = function (m, n) &#123;</span><br><span class="line">         var temp = this.array[m]</span><br><span class="line">         this.array[m] = this.array[n]</span><br><span class="line">         this.array[n] = temp</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // 选择枢纽</span><br><span class="line">     ArrayList.prototype.median = function (left, right) &#123;</span><br><span class="line">         // 1.求出中间的位置</span><br><span class="line">         var center = Math.floor((left + right) / 2)</span><br><span class="line"></span><br><span class="line">         // 2.判断并且进行交换</span><br><span class="line">         if (this.array[left] &gt; this.array[center]) &#123;</span><br><span class="line">             this.swap(left, center)</span><br><span class="line">         &#125;</span><br><span class="line">         if (this.array[center] &gt; this.array[right]) &#123;</span><br><span class="line">             this.swap(center, right)</span><br><span class="line">         &#125;</span><br><span class="line">         if (this.array[left] &gt; this.array[right]) &#123;</span><br><span class="line">             this.swap(left, right)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 3.巧妙的操作: 将center移动到right - 1的位置.</span><br><span class="line">         this.swap(center, right - 1)</span><br><span class="line"></span><br><span class="line">         // 4.返回pivot</span><br><span class="line">         return this.array[right - 1]</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // 快速排序实现</span><br><span class="line">     ArrayList.prototype.quickSort = function () &#123;</span><br><span class="line">         this.quickSortRec(0, this.array.length - 1)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ArrayList.prototype.quickSortRec = function (left, right) &#123;</span><br><span class="line">         // 0.递归结束条件</span><br><span class="line">         if (left &gt;= right) return</span><br><span class="line"></span><br><span class="line">         // 1.获取枢纽</span><br><span class="line">         var pivot = this.median(left, right)</span><br><span class="line"></span><br><span class="line">         // 2.开始进行交换</span><br><span class="line">         var i = left</span><br><span class="line">         var j = right - 1</span><br><span class="line">         while (true) &#123;</span><br><span class="line">             while (this.array[++i] &lt; pivot) &#123; &#125;</span><br><span class="line">             while (this.array[--j] &gt; pivot) &#123; &#125;</span><br><span class="line">             if (i &lt; j) &#123;</span><br><span class="line">                 this.swap(i, j)</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 break</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 3.将枢纽放在正确的位置</span><br><span class="line">         this.swap(i, right - 1)</span><br><span class="line"></span><br><span class="line">         // 4.递归调用左边</span><br><span class="line">         this.quickSortRec(left, i - 1)</span><br><span class="line">         this.quickSortRec(i + 1, right)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><!--more-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建HashTable构造函数</span><br><span class="line">function HashTable() &#123;</span><br><span class="line">    // 定义属性</span><br><span class="line">    this.storage = []</span><br><span class="line">    this.count = 0</span><br><span class="line">    this.limit = 8</span><br><span class="line"></span><br><span class="line">    // 定义相关方法</span><br><span class="line">    // 判断是否是质数</span><br><span class="line">    HashTable.prototype.isPrime = function (num) &#123;</span><br><span class="line">        var temp = parseInt(Math.sqrt(num))</span><br><span class="line">        // 2.循环判断</span><br><span class="line">        for (var i = 2; i &lt;= temp; i++) &#123;</span><br><span class="line">            if (num % i == 0) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取质数</span><br><span class="line">    HashTable.prototype.getPrime = function (num) &#123;</span><br><span class="line">        while (!isPrime(num)) &#123;</span><br><span class="line">            num++</span><br><span class="line">        &#125;</span><br><span class="line">        return num</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 哈希函数</span><br><span class="line">    HashTable.prototype.hashFunc = function(str, max) &#123;</span><br><span class="line">        // 1.初始化hashCode的值</span><br><span class="line">        var hashCode = 0</span><br><span class="line"></span><br><span class="line">        // 2.霍纳算法, 来计算hashCode的数值</span><br><span class="line">        for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">            hashCode = 37 * hashCode + str.charCodeAt(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3.取模运算</span><br><span class="line">        hashCode = hashCode % max</span><br><span class="line">        return hashCode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入数据方法</span><br><span class="line">    HashTable.prototype.put = function (key, value) &#123;</span><br><span class="line">        // 1.获取key对应的index</span><br><span class="line">        var index = this.hashFunc(key, this.limit)</span><br><span class="line"></span><br><span class="line">        // 2.取出数组(也可以使用链表)</span><br><span class="line">        // 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ]  [ [k,v] ] ]</span><br><span class="line">        var bucket = this.storage[index]</span><br><span class="line"></span><br><span class="line">        // 3.判断这个数组是否存在</span><br><span class="line">        if (bucket === undefined) &#123;</span><br><span class="line">            // 3.1创建桶</span><br><span class="line">            bucket = []</span><br><span class="line">            this.storage[index] = bucket</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4.判断是新增还是修改原来的值.</span><br><span class="line">        var override = false</span><br><span class="line">        for (var i = 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            var tuple = bucket[i]</span><br><span class="line">            if (tuple[0] === key) &#123;</span><br><span class="line">                tuple[1] = value</span><br><span class="line">                override = true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5.如果是新增, 前一步没有覆盖</span><br><span class="line">        if (!override) &#123;</span><br><span class="line">            bucket.push([key, value])</span><br><span class="line">            this.count++</span><br><span class="line"></span><br><span class="line">            if (this.count &gt; this.limit * 0.75) &#123;</span><br><span class="line">                var primeNum = this.getPrime(this.limit * 2)</span><br><span class="line">                this.resize(primeNum)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取存放的数据</span><br><span class="line">    HashTable.prototype.get = function (key) &#123;</span><br><span class="line">        // 1.获取key对应的index</span><br><span class="line">        var index = this.hashFunc(key, this.limit)</span><br><span class="line"></span><br><span class="line">        // 2.获取对应的bucket</span><br><span class="line">        var bucket = this.storage[index]</span><br><span class="line"></span><br><span class="line">        // 3.如果bucket为null, 那么说明这个位置没有数据</span><br><span class="line">        if (bucket == null) &#123;</span><br><span class="line">            return null</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4.有bucket, 判断是否有对应的key</span><br><span class="line">        for (var i = 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            var tuple = bucket[i]</span><br><span class="line">            if (tuple[0] === key) &#123;</span><br><span class="line">                return tuple[1]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5.没有找到, return null</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除数据</span><br><span class="line">    HashTable.prototype.remove = function (key) &#123;</span><br><span class="line">        // 1.获取key对应的index</span><br><span class="line">        var index = this.hashFunc(key, this.limit)</span><br><span class="line"></span><br><span class="line">        // 2.获取对应的bucket</span><br><span class="line">        var bucket = this.storage[index]</span><br><span class="line"></span><br><span class="line">        // 3.判断同是否为null, 为null则说明没有对应的数据</span><br><span class="line">        if (bucket == null) &#123;</span><br><span class="line">            return null</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4.遍历bucket, 寻找对应的数据</span><br><span class="line">        for (var i = 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            var tuple = bucket[i]</span><br><span class="line">            if (tuple[0] === key) &#123;</span><br><span class="line">                bucket.splice(i, 1)</span><br><span class="line">                this.count--</span><br><span class="line"></span><br><span class="line">                // 缩小数组的容量</span><br><span class="line">                if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;</span><br><span class="line">                    var primeNum = this.getPrime(Math.floor(this.limit / 2))</span><br><span class="line">                    this.resize(primeNum)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return tuple[1]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5.来到该位置, 说明没有对应的数据, 那么返回null</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // isEmpty方法</span><br><span class="line">    HashTable.prototype.isEmpty = function () &#123;</span><br><span class="line">        return this.count == 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // size方法</span><br><span class="line">    HashTable.prototype.size = function () &#123;</span><br><span class="line">        return this.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 哈希表扩容</span><br><span class="line">    HashTable.prototype.resize = function (newLimit) &#123;</span><br><span class="line">        // 1.保存旧的数组内容</span><br><span class="line">        var oldStorage = this.storage</span><br><span class="line"></span><br><span class="line">        // 2.重置属性</span><br><span class="line">        this.limit = newLimit</span><br><span class="line">        this.count = 0</span><br><span class="line">        this.storage = []</span><br><span class="line"></span><br><span class="line">        // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中</span><br><span class="line">        oldStorage.forEach(function (bucket) &#123;</span><br><span class="line">            // 1.bucket为null, 说明这里面没有数据</span><br><span class="line">            if (bucket == null) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 2.bucket中有数据, 那么将里面的数据重新哈希化插入</span><br><span class="line">            for (var i = 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">                var tuple = bucket[i]</span><br><span class="line">                this.put(tuple[0], tuple[1])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>比较Vue和React？</title>
    <url>/2019/06/30/%E6%AF%94%E8%BE%83Vue%E5%92%8CReact%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="比较-Vue-和-React-的相同点和不同点？"><a href="#比较-Vue-和-React-的相同点和不同点？" class="headerlink" title="比较 Vue 和 React 的相同点和不同点？"></a>比较 Vue 和 React 的相同点和不同点？</h2><span id="more"></span>

<ul>
<li>相同点 + 都有组件化开发和 Virtual DOM + 都支持 props 进行父子组件间的数据通信 + 都支持数据驱动视图，不直接操作真实 DOM，状态数据更新页面则自动更新 + 都支持服务端渲染 + 都支持原生应用的开发方案，React 有 React Native，Vue 有 Weex</li>
<li>不同点<ul>
<li>数据绑定： Vue 实现了数据的双向绑定，React 数据流动是单向的</li>
<li>React 推荐的组件写法为 JSX，也就是把 HTML 和 CSS 全部写进 Javascript 中，即“all in js”<br>Vue 推荐的组件写法是 webpack+vue-loader 的单文件组件格式，即 html、css、js 写在同一个<br>文件</li>
<li>state 对象在 react 应用中不可变，需要使用 setState 方法更新状态；在 vue 中 state 对象不是<br>必须的，数据由 data 属性在 vue 对象中管理</li>
<li>virtual DOM 不一样，vue 会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树，<br>而对于 React 而言，每当应用的状态被改变时，全部组件都会重新渲染，所以 react 会需要<br>shouldComponentUpdate 这个生命周期函数方法进行控制。</li>
<li>React 严格上只针对 MVC 的 view 层，Vue 则是 MVVM 模式。</li>
</ul>
</li>
</ul>
<h2 id="前端框架使用-Vue-还是-React？清晰比较两者差异"><a href="#前端框架使用-Vue-还是-React？清晰比较两者差异" class="headerlink" title="前端框架使用 Vue 还是 React？清晰比较两者差异"></a>前端框架使用 Vue 还是 React？清晰比较两者差异</h2><h4 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h4><ul>
<li><p>vue</p>
<ul>
<li>vue 由尤雨溪开发，独立团队维护，大部分子项目交给团队成员打理，Vue 核心库依然<br>主要由尤雨溪亲自维护。</li>
</ul>
</li>
<li><p>react</p>
<ul>
<li>React 起源于 Facebook 的内部项目，在建设 instagram(图片分享)的时候，为了处理<br>数据流且考虑性能方面的问题，因该公司对市场上所有框架都不满意，就决定自己写一套，<br>用来架构 Instagram 的网站。并在 2013 年 5 月开源。</li>
</ul>
</li>
</ul>
<h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><ul>
<li><p>vue</p>
<ul>
<li>vue 是一款渐进式框架，采用自底向上增量开发的设计。在声明式渲染(视图模板引擎)<br>的基础上，通过添加组件系统(component)、客户端路由(vue-router)、状态管理(vuex)<br>来构建一个完整的框架。</li>
</ul>
</li>
<li><p>react</p>
<ul>
<li>react 主张函数式编程，所以推崇纯组件，数据不可变，单向数据流，</li>
</ul>
</li>
</ul>
<h4 id="编写语法"><a href="#编写语法" class="headerlink" title="编写语法"></a>编写语法</h4><ul>
<li><p>vue</p>
<ul>
<li>vue 推荐的做法是 webpack + vue-loader 的单文件格式，vue 保留了 html、css、js<br>分离的写法，数据绑定使用 mustache 风格，样式直接使用 css，在<code>&lt;style&gt;</code>标签提供<br>了一个可选的 scoped 属性，用开控制 css 仅对当前组件生效还是全局生效。</li>
</ul>
</li>
<li><p>react</p>
<ul>
<li>react 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript<br>中，即“all in js”，react 没有模板，直接就是一个渲染函数，返回一个虚拟 DOM 树，<br>在 render()编写的 JSX 语法最终会被编译成原生 JavaScript。</li>
</ul>
</li>
</ul>
<h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><ul>
<li><p>vue</p>
<ul>
<li>vue 提供了 CLI 脚手架，可以帮助我们非常容易地构建项目，全局安装后用 vue create<br>命令创建新项目，可以让用户自定义选择需要安装的模板。</li>
</ul>
</li>
<li><p>react</p>
<ul>
<li>react 提供了 create-react-app，但只提供一个构建单页面应用的默认选项。</li>
</ul>
</li>
</ul>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><ul>
<li><p>vue</p>
<ul>
<li>vue 实现双向数据绑定，view 的变化能实时让 model 改变，而 model 的变化也能实时<br>更新到 view</li>
<li>vue 采用数据劫持 + 发布-订阅模式，通过 Object.defineProperty 对数据进行操作，<br>为数据动态添加 getter 和 setter 方法，当获取数据的时候会触发对应的 getter 方法，<br>当设置数据的时候会触发对应的 setter 方法，从而进一步触发 vm 的 watcher 方法，然后<br>对数据进行更改，vm 则进一步触发视图更新操作。</li>
</ul>
</li>
<li><p>react</p>
<ul>
<li>react 是单向数据流，react 中属性是不允许更改的，状态是允许更改的。react 中组件<br>不允许通过 this.state 这种方法直接更改组件的状态。自身设置的状态，可以通过 setState<br>进行更改。</li>
<li>setState 是异步的，导致获取 dom 可能拿到的还是之前的内容，所以需要在 setState<br>第二个参数(回调函数)中获取更新后的内容。</li>
</ul>
</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul>
<li><p>vue</p>
<ul>
<li>vue 中每个组件内部自动实现了 shouldComponentUpdate 的优化，在 vue 中里面由于<br>依赖追踪系统的存在，当任意数据变动的时候，Vue 的每一个组件都能精确的知道自己是<br>否需要重绘。而在 react 中需要我们手动去优化其性能，但 s 是当数据特别多的时候 vue 中<br>的 watcher 也会特别多，从而造成页面卡顿，所以一般大西瓜项目会倾向于 react。</li>
</ul>
</li>
<li><p>react</p>
<ul>
<li>当 props 或 state 发生改变的时候会触发 shouldComponentUpdate 生命周期函数，它<br>是用来控制组件是否被重新渲染的，如果它返回 true，则执行 render 函数，更新组件；<br>如果它返回 false，则不会触发重新渲染的过程。</li>
<li>如果希望更新之前和之前的状态进行一个对比，这个时候需要重写 shouldCompnentUpdate<br>来避免不必要的 dom 操作，对比当前的 props 或 state 和更新后的 nextProps 或 nextState，<br>返回 true 时，组件更新；返回 false，不更新，节省性能。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue、React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>获取唯一id的三种方法</title>
    <url>/2022/01/04/%E8%8E%B7%E5%8F%96%E5%94%AF%E4%B8%80id%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h2><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const UUID = (len = 32) =&gt; &#123;</span><br><span class="line">  return &quot;xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx&quot;</span><br><span class="line">    .replace(/[xy]/g, function replace(c) &#123;</span><br><span class="line">      /* eslint-disable no-bitwise */</span><br><span class="line">      const r = (Math.random() * 16) | 0;</span><br><span class="line">      const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8;</span><br><span class="line"></span><br><span class="line">      return v.toString(16);</span><br><span class="line">    &#125;)</span><br><span class="line">    .substring(0, len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="nanoid"><a href="#nanoid" class="headerlink" title="nanoid"></a>nanoid</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const nanoid = (t = 21) =&gt; &#123;</span><br><span class="line">  let e = &quot;&quot;,</span><br><span class="line">    r = crypto.getRandomValues(new Uint8Array(t));</span><br><span class="line">  for (; t--; ) &#123;</span><br><span class="line">    let n = 63 &amp; r[t];</span><br><span class="line">    e +=</span><br><span class="line">      n &lt; 36</span><br><span class="line">        ? n.toString(36)</span><br><span class="line">        : n &lt; 62</span><br><span class="line">        ? (n - 26).toString(36).toUpperCase()</span><br><span class="line">        : n &lt; 63</span><br><span class="line">        ? &quot;_&quot;</span><br><span class="line">        : &quot;-&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原生方法"><a href="#原生方法" class="headerlink" title="原生方法"></a>原生方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const id = URL.createObjectURL(new Blob()).substr(-36)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>说一下浏览器的缓存机制</title>
    <url>/2019/07/10/%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><span id="more"></span>

<pre><code>缓存可以简单高效的提高性能优化，对于一个数据请求来说，分为网络请求、后端处理、浏览器
响应三个步骤，浏览器缓存可以优化网络请求和响应部分。比如：直接换用缓存而不发起请求，
或者发起请求但后端存储的数据和前端一致，就没有必要将数据回传，这样就减少的响应数据，
使得缓存文件可以重复利用，减少带宽，减低网络负荷。
</code></pre>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><pre><code>网络请求会先从缓存位置上面查找缓存，如果都没有命中，才会去请求网络资源，从缓存位置
分为四种，并且各自有优先级：
- Service Worker
- Memory Cache
- Disk Cache
- Push Cache
</code></pre>
<h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Service Worker 是运行在浏览器背后的独立线程，一般可以用<br>来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为<br>Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。<br>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、<br>如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册<br>Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问<br>的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，<br>否则就去请求数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数<br>获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级<br>去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显<br>示我们是从 Service Worker 中获取的内容。</p>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面<br>上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，<br>可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就<br>被释放了。</p>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之<br>Memory Cache 胜在容量和存储时效性上。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会<br>根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源<br>已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不<br>会再次去请求数据。</p>
<h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种<br>缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，<br>并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中<br>的缓存指令。</p>
<p><code>如果以上四种缓存都没有命中的话，只能发起网络请求来获取资源了。 为了性能上的考虑，大部分接口都应该选择好缓存策略， 浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置HTTP Header来实现的。</code></p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><pre><code>强缓存：不会向服务器发送请求，直接从缓存中读取资源，可以通过HTTP Header实现：Expires
和Cache-Control。
+ Expires：缓存过期时间，用来指定资源到期的时间，是服务端的具体的时间点，结合Last-modified
使用，Expires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

+ Cache-Control：和多个指令配合使用，实现资源缓存。

+ Expires和Cache-Control同时存在，Cache-Control优先级高于Expires。
</code></pre>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><pre><code>协商缓存就是强缓存失效后，浏览器携带缓存表示向服务器发起请求，由服务器根据缓存表示决定
是否使用缓存的过程，主要有以下两种情况：
+ 协商缓存生效，返回304和Not Modified

+ 协商缓存失效，返回200和请求结果。

+ 协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。

+ ETag是服务器响应请求时，返回当前资源文件的一个唯一标识（有服务器生成），只要资源有变化
，ETag就会重新生成。
</code></pre>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><pre><code>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用
缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和
Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，
那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；
生效则返回304，继续使用缓存
</code></pre>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>单页面应用前端路由原理</title>
    <url>/2022/03/14/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是单页面应用？"><a href="#什么是单页面应用？" class="headerlink" title="什么是单页面应用？"></a>什么是单页面应用？</h2><span id="more"></span>

<p>单页面应用是指第一次进入页面的时候会请求一个 html 文件，切换到其他组件的时候，虽然路径会发生相应的变化，但是没有新的 html 文件请求，原理是 js 会感知到 url 的变化，js 会动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这时候的路由不是后端做的而是由前端来做，来判断页面到底显示哪个组件，这个过程就是单页面的应用。</p>
<h2 id="单页面应用的优缺点"><a href="#单页面应用的优缺点" class="headerlink" title="单页面应用的优缺点"></a>单页面应用的优缺点</h2><p>优点：页面切换快，因为页面每次切换的时候，并不需要做 html 文件的请求，这样就减少的很多 http 发送的时延。</p>
<p>缺点：单页面应用的首屏加载时间比较慢，首屏加载需要一次 html 请求和一次 js 请求，时间相对较慢，而且 SEO 效果差，因为搜索引擎只认识 html 中的内容，但是单页面应用中内容很多需要靠 js 渲染出来，搜索引擎不识别这部分内容，就会导致 SEO 效果不好。</p>
<h2 id="什么是多页面应用？"><a href="#什么是多页面应用？" class="headerlink" title="什么是多页面应用？"></a>什么是多页面应用？</h2><p>多页面应用是指每一次页面跳转的时候，服务器都会返回一个新的 html 文档，这种类型的应用叫做多页应用。</p>
<h2 id="多页面应用的优缺点"><a href="#多页面应用的优缺点" class="headerlink" title="多页面应用的优缺点"></a>多页面应用的优缺点</h2><p>优点：首屏加载快，SEO 效果好，因为客户端向服务端发起请求的时候，服务器之返回了一个 html 页面，所以加载比较快。</p>
<p>缺钱：页面切换比较慢</p>
<h2 id="单页面应用和多页面应用的区别"><a href="#单页面应用和多页面应用的区别" class="headerlink" title="单页面应用和多页面应用的区别"></a>单页面应用和多页面应用的区别</h2><p>1.应用构成不同<br>多页面应用是由多个不同的页面构成，单页面应用是一个外壳页面和多个页面片段构成。</p>
<p>2.页面跳转方式不同<br>多页面应用的页面跳转是从一个页面跳转到另一个页面，而单页面则是把一个页面判断删除或隐藏，加载另一个页面片段。</p>
<p>3.跳转后公共资源是否重新加载<br>跳转后多页面应用需要重新进行加载，但是单页面不需要重新加载</p>
<p>4.用户体验不同<br>多页面应用首屏加载快但是切换慢，单页面应用首屏加载慢但是切换快</p>
<p>5.页面传递数据方式不同<br>多页面应用依靠 url、cookie、localstorage 来传递数据，单页面应用则是靠组件进行通信，相对更加简单。</p>
<h2 id="前端路由的原理"><a href="#前端路由的原理" class="headerlink" title="前端路由的原理"></a>前端路由的原理</h2><p>前端路由的原理本质上就是通过不刷新浏览器的请求下修改 url、检测 url 的变化，截获 url 的地址，通过解析、匹配路由规则从而实现 UI 的更新，路由的实现通常有两种实现：hash 模式、history 模式</p>
<h3 id="hash-路由的原理"><a href="#hash-路由的原理" class="headerlink" title="hash 路由的原理"></a>hash 路由的原理</h3><p>在 hash 模式下，在 url 中#后面的部分表示的是一个客户端状态，当这部分发生变化的时候，浏览器本身就不会刷新，这样就满足了第一个条件，即在不刷新浏览器的情况下修改浏览器链接，同事通过监听 hashChange 事件来监听 url 中 hash 值的变化，触发相关函数，改变相关组件。</p>
<h3 id="history-路由的原理"><a href="#history-路由的原理" class="headerlink" title="history 路由的原理"></a>history 路由的原理</h3><p>history 模式利用 html5 中 history API，history.pushState 和 history.replaceState 这两个方法可以在不刷新页面的情况下，操作浏览器的历史记录，然后通过 popState 事件来监听 url 的变化，从而触发相关函数，改变相关组件。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>lerna开发</title>
    <url>/2021/11/01/lerna%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="创建-npm-私服"><a href="#创建-npm-私服" class="headerlink" title="创建 npm 私服"></a>创建 npm 私服</h2><span id="more"></span>

<ul>
<li>verdaccio 是一个简单、零配置的本地私有化 npm 仓库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install verdaccio -g</span><br><span class="line"></span><br><span class="line">verdaccio</span><br><span class="line">http://localhost:4873</span><br><span class="line">npm adduser --registry http://localhost:4873/</span><br><span class="line">npm publish --registry http://localhost: 4873/</span><br></pre></td></tr></table></figure>

<h2 id="lerna-常用命令"><a href="#lerna-常用命令" class="headerlink" title="lerna 常用命令"></a>lerna 常用命令</h2><p>项目初始化<br>| 命令 | 说明 |<br>| — | — |<br>| lerna init –independent | 初始化项目 |</p>
<p>创建包<br>| 命令 | 说明 |<br>| — | — |<br>| lerna create module-1 | 创建 package |<br>| lerna add | 安装依赖 |<br>| lerna link | 链接依赖 |</p>
<p>开发和测试<br>| 命令 | 说明 |<br>| — | — |<br>| lerna exec | 执行 shell 脚本 |<br>| lerna run | 执行 npm 命令 |<br>| lerna clean | 清空依赖|<br>| lerna bootstrap | 重新安装依赖 |</p>
<p>package 依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.给指定package安装依赖</span><br><span class="line">$ lerna add lodash packages/module-1</span><br><span class="line">$ lerna add lodash --scope=module-1</span><br><span class="line">$ lerna add lodash **/module-1</span><br><span class="line">$yarn workspace module-1 add lodash</span><br><span class="line"></span><br><span class="line">2.给所有package安装依赖</span><br><span class="line">$ lerna add lodash</span><br><span class="line"></span><br><span class="line">3.workspace之间的依赖</span><br><span class="line">$ lerna add module-2 packages/module-1</span><br><span class="line">$ lerna add module-2 --scope module-1</span><br></pre></td></tr></table></figure>

<p>发布</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lerna publish</span><br></pre></td></tr></table></figure>

<h2 id="lerna-json"><a href="#lerna-json" class="headerlink" title="lerna.json"></a>lerna.json</h2><ul>
<li>version: 当前仓库的版本，independent mode 请设置为 <strong>independent</strong>.<ul>
<li>lerna 对于包的管理有两种模式：固定模式 fixed、独立模式 independent。</li>
<li>固定模式所有包是统一的版本号，每次升级所有包统一更新，无论这个包内容是否改变。 *具体体现在 lerna 的配置文件中 lerna.json 中永远会存在一个确定版本号：{“version”: “0.0.1”}</li>
<li>独立模式，每个包都是单独的版本号，每次 lerna 触发发布命令，每个包的版本都会单独变化，具体体现在 lerna 的配置文件 lerna.json 中没有一个确定的版本号，而是{“version”:”independent”}</li>
</ul>
</li>
<li>npmClient: 指定运行的客户端程序 默认为 npm</li>
<li>ignoreChanges: 一个不包含在<strong>lerna changed/publish</strong>的 glob 数组，使用这个阻止发布不必要的更新，比如修复<strong>README.md</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;useWorkspaces&quot;: true, // 使用 workspaces 配置。此项为 true 的话，将使用 package.json 的 &quot;workspaces&quot;，下面的 &quot;packages&quot; 字段将不生效</span><br><span class="line">    &quot;version&quot;: &quot;0.1.0&quot;, // 所有包版本号，独立模式-&quot;independent&quot;</span><br><span class="line">    &quot;npmClient&quot;: &quot;cnpm&quot;, // npm client，可设置为 cnpm、yarn 等</span><br><span class="line">    &quot;packages&quot;: [ // 包所在目录，可指定多个</span><br><span class="line">        &quot;packages/*&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;command&quot;: &#123; // lerna 命令相关配置</span><br><span class="line">        &quot;publish&quot;: &#123; // 发布相关</span><br><span class="line">            &quot;ignoreChanges&quot;: [ // 指定文件或目录的变更，不触发 publish</span><br><span class="line">                &quot;.gitignore&quot;,</span><br><span class="line">                &quot;*.log&quot;,</span><br><span class="line">                &quot;*.md&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;bootstrap&quot;: &#123; // bootstrap 相关</span><br><span class="line">            &quot;ignore&quot;: &quot;npm-*&quot;,  // 不受 bootstrap 影响的包</span><br><span class="line">            &quot;npmClientArgs&quot;: [ // bootstr 执行参数</span><br><span class="line">                &quot;--no-package-lock&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CRA-lerna-react-typescript-项目搭建"><a href="#CRA-lerna-react-typescript-项目搭建" class="headerlink" title="CRA + lerna + react + typescript 项目搭建"></a>CRA + lerna + react + typescript 项目搭建</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.create-react-app demo --template typescript</span><br><span class="line"></span><br><span class="line">2.cd demo</span><br><span class="line"></span><br><span class="line">3.npm run eject</span><br><span class="line"></span><br><span class="line">4.lerna init</span><br><span class="line"></span><br><span class="line">5.lerna create builder-script</span><br><span class="line"></span><br><span class="line">6.自定义builder-scripts脚本命令</span><br><span class="line"></span><br><span class="line">7.自定义 eslintrc、tsconfig、webpack等配置项</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>lerna</category>
      </categories>
      <tags>
        <tag>lerna</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题目总结</title>
    <url>/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="从浏览器地址栏输入-url-到显示页面的步骤"><a href="#从浏览器地址栏输入-url-到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入 url 到显示页面的步骤"></a>从浏览器地址栏输入 url 到显示页面的步骤</h2><span id="more"></span>

<pre><code>1. 浏览器查看缓存(浏览器对应的都会有cache文件)。
若请求有缓存且未过期，则取缓存资源提供给客户端，否则发起请求与服务器进行验证。
检验是否过期通常有两个HTTP头：Expires、Cache-control
2.浏览器需要获取域名对应的ip地址，过程如下：
1.本地host文件查找
- 浏览器解析URL获取协议、域名、端口、path路径，然后查看本地硬盘中hosts文件，看是否存在与这个域名对应的规则，如果有就直接使用hosts文件里面的ip地址。
2.路由器缓存
3.ISP DNS(Domain Name System域名系统)(情报局)缓存（互联网提供服务商）-本地DNS服务器以递归方式进行查询缓存记录，
若没有就向跟DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器，
本地DNS服务器把对应关系草存在缓存中（一边下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。
3.客户端发送HTTP请求。
4.TCP传输报文（三次握手四次挥手）
5.向客户端返回资源
6.解析HTML文档，构建DOM树，CSSOM树，下载资源，执行js脚本等。
</code></pre>
<p>扩展：<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NDY4NDgyOQ==&mid=2247491757&idx=1&sn=a956c6c62c98e2d5ee71c8ed8d3a3eb8&chksm=cecfa85ff9b82149a3e50e81789b29cc0923745cf8a8f7713619aa2499753a3de760f24e6f93&scene=132#wechat_redirect">收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？</a></p>
<h2 id="DNS-负载均衡"><a href="#DNS-负载均衡" class="headerlink" title="DNS 负载均衡"></a>DNS 负载均衡</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个域名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</span><br></pre></td></tr></table></figure>

<h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">强缓存：（expires、Cache-Control）在过期时间内，浏览器再次加载资源时，不会向服务器发起请求，直接从缓存中读取资源</span><br><span class="line"></span><br><span class="line">协商缓存：向服务器发送请求，服务器会根据请求头（request header）的一些参数（Etag、last-modified）来判断是否命中协商缓存，首先根据Etag的值判断请求的文件有没有被修改，如果Etag一致则没有被修改，命中协商缓存返回304，如果不一致则返回新的资源并带上新的Etag返回200状态码。如果没有Etag值，则对比If-Modified-Since和请求文件的最后修改时间，一致则命中协商缓存返回304，不一致则返回新的last-modified和200状态码</span><br></pre></td></tr></table></figure>

<h2 id="http-协议的特点"><a href="#http-协议的特点" class="headerlink" title="http 协议的特点"></a>http 协议的特点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.支持客户/服务器模式</span><br><span class="line">2.简单快速：客户向服务器发送请求时，只需传送请求方法和路径。</span><br><span class="line">3.灵活：http允许传输任意类型的数据对象（Content-Type内容编码类型）</span><br><span class="line"></span><br><span class="line">application/x-www-form-urlencoded 常见post提交数据格式（key-value格式）</span><br><span class="line">application/json</span><br><span class="line"></span><br><span class="line">4.无连接：限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。（原因是早期服务器需要同时面对全世界数十万、上百万的客户端的网页访问，但是每次客户端与服务端传输的数据关联性很低，就会导致大部分通过会很空闲，无端占用资源）</span><br><span class="line"></span><br><span class="line">（解决无连接）Keep-Alive：使客户端到服务端之间的Http连接保持，不会断开，当再次对服务器发送请求时，keep-Alive功能避免了重新建立连接</span><br><span class="line"></span><br><span class="line">5.无状态：Http是一个无状态协议，就是每个请求都是独立的，数据传输完毕不会记录任何信息。缺点就是如果后续处理需要前面的信息，就必须重传，就会导致每次连接传送的数据量增加，如果服务器不需要前面信息的时候应答就会很快。</span><br><span class="line"></span><br><span class="line">（解决无状态）怎样保持http连接状态呢</span><br><span class="line">Cookie（每次http请求的时候，客户端都需要发送响应的cookie信息到服务端，服务端根据cookie判断来自哪个客户端）</span><br><span class="line">服务端生成cookie，客户端保存</span><br><span class="line"></span><br><span class="line">Session</span><br><span class="line">服务端生成一个sessionid，在客户端下次请求的时候在cookie里面记录这个sessionid，然后发送给服务端，服务端再根据cookie中的sessionid来识别客户端返回资源数据。</span><br><span class="line"></span><br><span class="line">禁用cookie怎么办？</span><br><span class="line">url重写，每次http请求的时候，在url后面拼接sid=**参数</span><br><span class="line"></span><br><span class="line">withCredentials:指定在涉及到跨域请求时，是否携带cookie信息，默认为false</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>

<h2 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="headerlink" title="cookie 和 session 的区别"></a>cookie 和 session 的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.存取方式不同： cookie只能保存ASCII字符串，session能够存储任意类型的数据</span><br><span class="line">2.隐私策略不同</span><br><span class="line">3.cookie是存在客户端，session是存在服务器的</span><br><span class="line">4.浏览器的支持不同，浏览器可以禁用cookie</span><br></pre></td></tr></table></figure>

<h2 id="权限身份验证"><a href="#权限身份验证" class="headerlink" title="权限身份验证"></a>权限身份验证</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般都是通过sessionid来进行用户身份验证，sessionid一般会存放在redis中。</span><br><span class="line">1.用户向服务端发送用户名和密码进行登陆</span><br><span class="line">2.服务器验证通过后，服务器为用户创建一个session，并将session信息存储起来</span><br><span class="line">3.服务器向用户返回一个sessionid，写入用户的cookie</span><br><span class="line">4.当用户保持登陆状态时，每次后续请求都会一起发送给后端</span><br><span class="line">5.服务器将存储在cookie中的sessionid和存储在内存或者数据库中的sessin信息进行一个比较，验证用户身份，然后返回响应信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.依赖session的关键业务一定要确保客户端开启了cookie</span><br><span class="line">2.注意session的过期时间</span><br><span class="line"></span><br><span class="line">一般在http header的Authorization字段中添加token</span><br></pre></td></tr></table></figure>

<h2 id="禁用-cookie-之后-session-还能用吗？"><a href="#禁用-cookie-之后-session-还能用吗？" class="headerlink" title="禁用 cookie 之后 session 还能用吗？"></a>禁用 cookie 之后 session 还能用吗？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url重写，例如 https://javascript.cn/?session_id=xxx</span><br><span class="line">缺点是安全性降低，可以对sessionid进行一次加密后传输</span><br></pre></td></tr></table></figure>

<h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.url可见性：get参数url可见，post参数url不可见</span><br><span class="line">2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数</span><br><span class="line">3.缓存性：get请求可以缓存，post请求不可以缓存</span><br><span class="line">4.get请求网页回退时，不产生影响，post请求网页回退会重新发请求</span><br><span class="line">5.传输数据：get一般传输数据大小不超过4k，post可以传输大量数据</span><br><span class="line">6.post较get安全性较高，get是不安全的因为url可见，可能会泄漏私密信息</span><br></pre></td></tr></table></figure>

<h2 id="http-常见的请求头字段"><a href="#http-常见的请求头字段" class="headerlink" title="http 常见的请求头字段"></a>http 常见的请求头字段</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept: 浏览器可接受的数据类型</span><br><span class="line">Accept-Charset: 浏览器可接受的字符集</span><br><span class="line">Accept-Encoding：浏览器能够进行解码的数据编码方式</span><br><span class="line">Accept-Language： 浏览器所希望的语言种类</span><br><span class="line">Connection：是否需要持久连接，值“Keep-Alive”，HTTP1.1默认进行持久连接</span><br><span class="line">Cookie：cookie信息</span><br><span class="line">content-type</span><br><span class="line">If-Modified-Since：内容被修改才会返回</span><br><span class="line">User-Agent：浏览器类型</span><br><span class="line"></span><br><span class="line">响应头：</span><br><span class="line">content-Length: 表示内容长度</span><br><span class="line">content-type：文档类型</span><br><span class="line">Date：当前时间</span><br><span class="line">Expires：指定缓存过期时间</span><br><span class="line">Last-Modified：文档过期时间</span><br></pre></td></tr></table></figure>

<h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http是超文本传输协议，信息是明文传输，https是更加安全的ssl加密传输协议</span><br><span class="line">http默认是80端口，https默认是443端口</span><br><span class="line">https需要申请CA证书</span><br><span class="line">https是http + ssl/tls（数字证书）进行组合的更加安全的传输协议</span><br><span class="line"></span><br><span class="line">https工作原理（非对称加密）</span><br><span class="line">1.服务端向客户端传递证书作为公钥</span><br><span class="line">2.客户端对证书进行解析，判断证书的办法机构和过期时间等，如果都没有问题，生成一个随机值作为私钥，然后使用证书进行加密发送给服务端</span><br><span class="line">3.服务端解密得到客户端私钥</span><br><span class="line">4.之后双方利用私钥进行加密解密，完成信息的通信</span><br></pre></td></tr></table></figure>

<h2 id="xss（跨域脚本攻击）csrf（跨站请求伪造）"><a href="#xss（跨域脚本攻击）csrf（跨站请求伪造）" class="headerlink" title="xss（跨域脚本攻击）csrf（跨站请求伪造）"></a>xss（跨域脚本攻击）csrf（跨站请求伪造）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csrf: 需要用户先登陆网站A，获取cookie，利用的是网站A本身的漏洞，去请求网站A的api，---进行token验证，referer验证，只接收本站的请求</span><br><span class="line"></span><br><span class="line">xss：向网站A注入js代码，然后执行js代码，篡改网站A的内容，破坏页面正常结构，插入恶意广告。---编码转换</span><br></pre></td></tr></table></figure>

<h2 id="什么是跨域？解决跨域的方法有哪些"><a href="#什么是跨域？解决跨域的方法有哪些" class="headerlink" title="什么是跨域？解决跨域的方法有哪些?"></a>什么是跨域？解决跨域的方法有哪些?</h2><!--more-->

<ul>
<li><p>同源策略</p>
<ul>
<li>是一种浏览器的安全策略</li>
<li>协议、域名、端口号必须完全一致</li>
<li>不同源的客户端脚本在没有明确的授权的情况下，不能读取对方的资源</li>
</ul>
</li>
<li><p>跨域</p>
<ul>
<li>指一个域下的文档或脚本尝试去请求另一个域下的资源。</li>
</ul>
</li>
</ul>
<!-- more -->

<ul>
<li><p>解决跨域</p>
<ul>
<li><p>jsonp</p>
</li>
<li><p>postMessage 跨域</p>
</li>
<li><p>WebSocket 协议跨域</p>
</li>
<li><p>CORS（跨域资源共享，服务端设置 Access-Control-Allow-Origin，前端无需设置，<br>若要带 cookie 请求，前后端都要设置）</p>
</li>
<li><p>nginx 反向代理接口跨域</p>
</li>
<li><p>document.domain(两个页面通过 js 强制设置 document.domain 为基础主域，针对基础域名相同的情况)</p>
</li>
<li><p>window.name + iframe</p>
</li>
<li><p>location.hash + iframe</p>
</li>
<li><p>…</p>
</li>
</ul>
</li>
<li><p>实现 jsonp 跨域</p>
<ul>
<li>通常为了减轻 web 服务器的负载，我们把 js、css、img 等静态资源分离到另一台独立域名<br>的服务器上，在 html 页面中再通过响应的标签从不同域名加载静态资源。jsonp 就是利用此<br>原理，动态创建 script，再请求一个带参网址实现跨域通信</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var script = document.createElement(&#x27;script&#x27;)</span><br><span class="line">    script.type = &#x27;text/javascript&#x27;</span><br><span class="line"></span><br><span class="line">    //传参一个回调函数名给后端，方便后端返回时执行这个前端定义的回调函数</span><br><span class="line">    script.src = &#x27;http://www.xxx.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line"></span><br><span class="line">    //回调执行函数</span><br><span class="line">    function handleCallbak(res) &#123;</span><br><span class="line">        alert(JSOn.stringify(res))</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="http1-0、http1-1-和-http2-0-的区别"><a href="#http1-0、http1-1-和-http2-0-的区别" class="headerlink" title="http1.0、http1.1 和 http2.0 的区别"></a>http1.0、http1.1 和 http2.0 的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http/1.0 每个请求都要建立一个连接</span><br><span class="line">http/1.1 多了长连接keep-alive，若干个请求需要排队串行化单线程处理，会发生网络请求阻塞问题。</span><br><span class="line">http/2.0 同一个连接可以有多个请求，各个请求直接互不影响（进行了头部压缩和多路复用的优化）</span><br></pre></td></tr></table></figure>

<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单例模式 （class组件中new store创建store实例）</span><br><span class="line">工厂模式 （mobx store中creatLayoutStore）</span><br><span class="line">观察者模式</span><br><span class="line">发布订阅模式</span><br><span class="line">装饰器模式 （移动、pc配置同步@sync）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TCP-与-UDP-区别"><a href="#TCP-与-UDP-区别" class="headerlink" title="TCP 与 UDP 区别"></a>TCP 与 UDP 区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* TCP是面向连接的协议，发送数据前先要建立连接，TCP提供可靠的服务，通过TCP建立连接传输的数据不会丢失，没有重复，并且按照顺序到达。</span><br><span class="line">* UDP是无连接的协议，发送数据前不需要建立连接，是不可靠的</span><br><span class="line">* TCP只支持点对点通信，而UDP支持一对一，多对多</span><br><span class="line">* TCP是面向字节流的，UDP是面向报文的</span><br><span class="line">* TCP通信类似打电话，接通后需要确认身份，才可以开始通信</span><br><span class="line">* UDP类似广播直接进行通信</span><br></pre></td></tr></table></figure>

<h2 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP/IP 模型"></a>TCP/IP 模型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用层（应用层就是向用户提供通信服务的活动，提供用户程序接口HTTP、DNS）</span><br><span class="line">传输层（传输层为两台主机上的应用程序提供端到端的通信TCP，UDP）</span><br><span class="line">网络层（网络层实现数据包的选路和转发）</span><br><span class="line">数据链路层（ARP地址解析协议、RARP逆地址解析协议，使用物理地址寻找一台机器）</span><br></pre></td></tr></table></figure>

<h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正向代理是客户端代理，服务端不知道是哪个客户端发起的请求</span><br><span class="line">反向代理是服务端代理，客户端不知道是哪个服务端提供的资源</span><br></pre></td></tr></table></figure>

<h2 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用层</span><br><span class="line">表示层</span><br><span class="line">会话层</span><br><span class="line"></span><br><span class="line">传输层</span><br><span class="line"></span><br><span class="line">网络层</span><br><span class="line"></span><br><span class="line">数据链路层</span><br><span class="line">物理层</span><br></pre></td></tr></table></figure>

<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>为什么需要三次握手？<br>两次握手第二次结束后，服务端并不能保证客户端已经接收到了第二次的应答信息，如此一来服务器会一直保持通信过程，因为 TCP 通信会占用端口，造成资源浪费。</p>
<p>防止已失效的连接请求报文段突然又传送到服务端，产生错误。<br>如上述情况，如果 client 没有再次向 server 发出确认，server 收不到确认就不会建立连接，可以避免 server 端一直等待浪费资源。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul>
<li><a href="https://blog.csdn.net/rememberyf/article/details/80309148">https://blog.csdn.net/rememberyf/article/details/80309148</a></li>
</ul>
<h2 id="301-和-302-的区别"><a href="#301-和-302-的区别" class="headerlink" title="301 和 302 的区别"></a>301 和 302 的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">301 表示资源被永久移除，浏览器在拿到状态码后跳转到一个新的URL地址，可从相应头的location首部中获取，搜索引擎在抓取新内容的同时也将就地址交换为重定向之后的网址。</span><br><span class="line"></span><br><span class="line">302 表示地址资源还在，仍可以访问，搜索引擎会抓取新的内容而保存旧的地址，seo 302 优于301.</span><br><span class="line"></span><br><span class="line">重定向的原因：</span><br><span class="line">网站调整（改变网页目录结构）</span><br><span class="line">页面被移到一个新地址</span><br><span class="line">页面扩展名改变 .php -&gt;.html</span><br><span class="line">如果不做重定向会返回404页面，会白白流失用户访问量。</span><br><span class="line"></span><br><span class="line">1XX 信息性状态码，表示接受的请求正在处理</span><br><span class="line">2XX 成功状态码，表示请求被正常处理完毕</span><br><span class="line">3XX 重定向状态码，表示需要进行附加操作以完成请求</span><br><span class="line">4XX 客户端错误状态码，表示服务器无法处理请求</span><br><span class="line">    400 Bad Request请求出现语法错误</span><br><span class="line">    401 被请求的页面需要用户名和密码</span><br><span class="line">    403 forbidden 请求页面的访问被禁止</span><br><span class="line">    404 资源未找到</span><br><span class="line">5XX 服务器错误状态码，表示服务器处理请求出错</span><br><span class="line">    502 网关错误</span><br><span class="line">    503 服务器超负载或者停机维护，无法处理请求</span><br><span class="line">    504 网关超时</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul>
<li>cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据 cookie 追踪用户在不同页面的访问信息。</li>
<li>cookie 特点<ul>
<li>1.大小限制，cookie 大小限制在 4KB 以内</li>
<li>2.宽带限制，cookie 数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。</li>
<li>3.安全风险，cookie 会频繁的在网络中传送，不加密的情况下是有安全风险的。</li>
<li>4.操作复杂<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setCookie(name: string, value: string) &#123;</span><br><span class="line">    const exp = new Date();</span><br><span class="line">    //过期时间设置为一天</span><br><span class="line">    exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000);</span><br><span class="line">    document.cookie = `$&#123;name&#125;=$&#123;escape(value);expires=$&#123;exp.toString()&#125;&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="localStorage-会话存储-和-sessionStorage-本地存储"><a href="#localStorage-会话存储-和-sessionStorage-本地存储" class="headerlink" title="localStorage 会话存储 和 sessionStorage 本地存储"></a>localStorage 会话存储 和 sessionStorage 本地存储</h2><ul>
<li>1.存储容量大</li>
<li>2.零宽带，仅存储在本地，不会和服务器发生任何交互行为，不存在网络宽带占用问题。</li>
<li>3.编程接口，提供一套丰富的接口，操作数据更加方便。</li>
<li>4.独立的存储空间，不会造成数据的混乱。</li>
</ul>
<ul>
<li><p>主要区别在于数据存储的 <code>时间范围</code>和<code>页面范围</code></p>
<ul>
<li>sessionStorage: 数据只存储到窗口或标签关闭时，只在当前窗口的当前标签内可见,5M 左右，不同浏览器不同大小。</li>
<li>localStorage: 数据会一直存在除非手动清除，数据可被同源(协议、域名、端口号一致)的每个窗口或标签共享,5M 左右，不同浏览器不同大小。</li>
</ul>
</li>
<li><p>监测是否支持 web Storage</p>
<ul>
<li>1.通过 window.sessionStorage,window.localStorage 判断浏览器是否支持</li>
<li>2.通过 try{}catch{} 执行一下 storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。</li>
</ul>
</li>
</ul>
<h2 id="html5-的几种存储形式"><a href="#html5-的几种存储形式" class="headerlink" title="html5 的几种存储形式"></a>html5 的几种存储形式</h2><ul>
<li>1.本地存储 localStorage,sessionStorage</li>
<li>2.离线缓存 application cache</li>
<li><ol start="3">
<li>indexedDb,webSQL</li>
</ol>
</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.负载均衡、CDN加速、设置缓存、</span><br><span class="line">2.业务逻辑优化</span><br><span class="line">3.代码程序优化（组件按需加载、图片懒加载，代码压缩）</span><br><span class="line">4.避免重绘回流</span><br><span class="line">重绘：页面元素的样式改变不会影响它在文档流中的位置时发生重绘</span><br><span class="line">回流：DOM尺寸大小结构发生变化时</span><br><span class="line">回流一定会导致重绘</span><br><span class="line">如何避免：</span><br><span class="line">1.避免频繁操作dom，通过创建document.createDocumentFragment()一次性插入需要操作的dom</span><br><span class="line">2.具有复杂动画的Dom元素使用绝对定位，使其脱离文档流</span><br><span class="line">3.合并对于Dom中style样式的操作</span><br><span class="line">4.避免使用css表达式 calc()</span><br></pre></td></tr></table></figure>

<h2 id="fetch-和-axios"><a href="#fetch-和-axios" class="headerlink" title="fetch 和 axios"></a>fetch 和 axios</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch取消发送</span><br><span class="line">1.创建一个AbortController实例</span><br><span class="line">2.该实例具有signal属性</span><br><span class="line">3.将signal传递给fetch option</span><br><span class="line">4.调用AbortController的abort属性来取消所有使用该信号的fetch</span><br><span class="line"></span><br><span class="line">axios取消发送</span><br><span class="line">1.const cancelToken = axios.CancelToken</span><br><span class="line">2.const source = CancelToken.source()</span><br><span class="line">3.axios.get(&#x27;/xxx&#x27;,&#123;cancelToken: source.token&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="flex-常用属性，grid-布局"><a href="#flex-常用属性，grid-布局" class="headerlink" title="flex 常用属性，grid 布局"></a>flex 常用属性，grid 布局</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex属性：</span><br><span class="line">1.flex-direction属性，决定主轴方向</span><br><span class="line">2.flex-wrap属性，控制换行</span><br><span class="line">3.flex-flow属性，flex-direction和flex-wrap的简写形式，默认值flex-flow: row  nowrap;</span><br><span class="line">4.justify-content属性，项目主轴上的对齐方式</span><br><span class="line">5.align-item属性，项目在交叉轴上的对齐方式</span><br><span class="line">6.align-content属性，多个轴线的时候在元素在交叉轴的对齐方式，只有一根轴线时不起作用</span><br><span class="line">flex（子元素的属性）：</span><br><span class="line">1.order属性,定义项目的排列顺序，数值越小，排列越靠前，默认为0.</span><br><span class="line">2.align-self属性，允许单个项目与其他项目不一样的对齐方式，会覆盖align-items属性.</span><br><span class="line">3.flex属性，flex-grow、flex-shrink、flex-basis简写，默认为0 1 auto</span><br><span class="line">    auto(1 1 auto)       none(0 0 auto)</span><br><span class="line">4.flex-grow属性，定义项目的放大比例，默认为0，即如果存在剩余空间也不放大，1等分，一个项目为2，其他为1，则前者占据空间是其他的两倍。</span><br><span class="line">5.flex-shrink属性，定义项目的缩小比例，默认为1，空间不足则缩小，如果所有项目都为1，则等比例缩小，如果有的项目为0，则空间不足时为0的不缩小，负值无效</span><br><span class="line">6.flex-basis属性，项目占据的固定空间</span><br></pre></td></tr></table></figure>

<h2 id="padding-bottom-实现子元素高度等于父元素宽度问题"><a href="#padding-bottom-实现子元素高度等于父元素宽度问题" class="headerlink" title="padding-bottom 实现子元素高度等于父元素宽度问题"></a>padding-bottom 实现子元素高度等于父元素宽度问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当margin或者padding取值是百分比的时候，无论是left，right或者top，bottom，都是以父元素的width为参考物，进行提前占位</span><br></pre></td></tr></table></figure>

<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在作用域的创建阶段（预编译阶段），会生成js的变量对象（VO对象）供js引擎去访问。</span><br><span class="line">1.创建ao对象</span><br><span class="line">2.找形参和变量声明，作为ao对象的属性名，值为undefined</span><br><span class="line">3.实参和形参相统一</span><br><span class="line">4.找函数声明，如果名字和变量相同则覆盖变量声明</span><br><span class="line">5.解释执行</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.箭头函数中的this是在定义函数的时候绑定的（继承自父执行上下文中的this），而不是执行函数时绑定。</span><br><span class="line">2.箭头函数没有this，所以不能用作构造函数。</span><br></pre></td></tr></table></figure>

<h2 id="Map-和-Set-两种新的数据结构的区别？"><a href="#Map-和-Set-两种新的数据结构的区别？" class="headerlink" title="Map 和 Set 两种新的数据结构的区别？"></a>Map 和 Set 两种新的数据结构的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Map类似Object是一种键值对集合，区别在于Map的键不仅限于字符串，其他各种类型的值都可以作为Map的键</span><br><span class="line"></span><br><span class="line">2.Set是类似数组的一种数据结构，不点在于Set中没有重复的值</span><br></pre></td></tr></table></figure>

<h2 id="你对闭包了解多少？"><a href="#你对闭包了解多少？" class="headerlink" title="你对闭包了解多少？"></a>你对闭包了解多少？</h2><pre><code>解释一下作用域链是如何产生的
解释一下js执行山下文的创建、执行过程
解释一下闭包所产生的变量放在哪里
</code></pre>
<ul>
<li>闭包的定义：闭包就是能够读取其他函数内部变量的函数。</li>
<li>闭包的底层实现原理</li>
<li>js 执行上下文：</li>
<li><img src="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70" alt="image"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js运行三部曲</span><br><span class="line">1.语法分析</span><br><span class="line">2.预编译</span><br><span class="line">3.解释执行</span><br><span class="line"></span><br><span class="line">js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。</span><br><span class="line">预编译的环境需要个环境，这个环境就是执行上下文。</span><br><span class="line"></span><br><span class="line">js执行上下文分为三种：</span><br><span class="line">1.全局执行上下文：代码开始执行时首先进入的环境</span><br><span class="line">2.函数执行上下文：函数调用时，会开始执行函数中的代码</span><br><span class="line">3.eval执行上下文：不建议使用</span><br><span class="line"></span><br><span class="line">执行上下文的周期，分为两个阶段</span><br><span class="line">1.创建阶段</span><br><span class="line">    创建词法环境</span><br><span class="line">    生成变量对象VO，建立作用域链</span><br><span class="line">    确认this指向，并绑定this</span><br><span class="line">2.执行阶段</span><br><span class="line">    进行变量赋值，函数引用以及执行代码</span><br><span class="line"></span><br><span class="line">预编译发生在函数执行前，预编译四部曲：</span><br><span class="line">1.创建AO对象</span><br><span class="line">2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined</span><br><span class="line">3.将形参和实参相统一</span><br><span class="line">4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）</span><br><span class="line">5.最后程序输出变量值的时候，就是从AO对象中拿</span><br><span class="line">（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，</span><br><span class="line">就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包）</span><br></pre></td></tr></table></figure>

<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student.__proto__ === Student.prototype</span><br><span class="line">1.每个函数function都由一个prototype，即显式原型。是在定义函数的时候自动添加的，默认是一个空的Object对象</span><br><span class="line">2.每个引用类型都有一个__proto__,即隐式原型。是创建对象时自动添加的，默认值为构造函数的prototype属性值</span><br><span class="line">实例对象的隐式原型 等于 对应构造函数或类的显式原型</span><br><span class="line">能直接操作显式原型，不能直接操作隐式原型</span><br></pre></td></tr></table></figure>

<h2 id="简单说下原型链"><a href="#简单说下原型链" class="headerlink" title="简单说下原型链"></a>简单说下原型链</h2><ul>
<li><p>原型链是由原型对象组成的，每个对象都有<strong>proto</strong>属性，指向了创建该对象的构造函数的<br>原型，<strong>proto</strong>将对象连接起来组成了原型链。</p>
</li>
<li><p>原型链：用来实现继承和共享属性的有限对象链。</p>
</li>
<li><p>每个对象都有<strong>proto</strong>（隐式原型）属性，指向创建该对象的构造函数的原型。其实<br>这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能<br>访问到，所以使用 <em>proto</em> 来访问。</p>
</li>
<li><p>对象的隐式原型等于对象的构造函数的显式原型：obj.<strong>proto</strong> === Object.prototype</p>
</li>
<li><p>访问属性的时候，js 引擎会调用内部的默认。。。。。。[[Get]]操作，[[Get]]操作首先会检查对象本身是否包含这个属性<br>如果对象没有这个属性，则对象可以通过<strong>proto</strong>来寻找不属于该对象的属性，<strong>proto</strong><br>将对象和原型连接起来形成原型链</p>
</li>
<li><p>Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎创建。</p>
</li>
</ul>
<h2 id="js-的-new-操作符都做了些什么？"><a href="#js-的-new-操作符都做了些什么？" class="headerlink" title="js 的 new 操作符都做了些什么？"></a>js 的 new 操作符都做了些什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建一个空的js对象&#123;&#125;</span><br><span class="line">2. 将空对象的隐式原型__proto__指向构造函数的原型</span><br><span class="line">3. 将空对象作为构造函数的上下文（改变this指向）</span><br><span class="line">4. 对构造函数返回值做判断</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line">function create(fn, ...args) &#123;</span><br><span class="line">    let obj = Object.create(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    // obj.__proto__ = fn.prototype;</span><br><span class="line">    Object.setPrototypeOf(obj, fn.prototype);</span><br><span class="line"></span><br><span class="line">    let result = fn.apply(obj, args);</span><br><span class="line"></span><br><span class="line">    return result instanceof Object ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">在new的时候，会对构造函数的返回值做一些判断</span><br><span class="line">1. 如果返回值是基础类型数据，则忽略返回值</span><br><span class="line">2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效</span><br></pre></td></tr></table></figure>

<h2 id="calc-support-media-各自的含义及用法？"><a href="#calc-support-media-各自的含义及用法？" class="headerlink" title="calc, support, media 各自的含义及用法？"></a>calc, support, media 各自的含义及用法？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@support 主要用于检测浏览器是否支持css的某个属性，相当于条件语句，支持的话写一套样式，</span><br><span class="line">不支持写另外一套样式，例如</span><br><span class="line">    @supports (display: grid) &#123;</span><br><span class="line">      div &#123;</span><br><span class="line">        display: grid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @supports not (display: grid) &#123;</span><br><span class="line">      div &#123;</span><br><span class="line">        float: right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">calc(): 用于动态计算值，支持 + - * / 运算。</span><br><span class="line"></span><br><span class="line">@media查询：可以针对不同的媒体类型定义不同的样式。</span><br></pre></td></tr></table></figure>

<h2 id="什么是会话-cookie-什么是持久-cookie"><a href="#什么是会话-cookie-什么是持久-cookie" class="headerlink" title="什么是会话 cookie,什么是持久 cookie?"></a>什么是会话 cookie,什么是持久 cookie?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookie是服务器返回的，指定了expire（有效期）的是持久cookie,没有指定的是会话cookie</span><br></pre></td></tr></table></figure>

<h2 id="img-标签-title-和-alt-属性"><a href="#img-标签-title-和-alt-属性" class="headerlink" title="img 标签 title 和 alt 属性"></a>img 标签 title 和 alt 属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alt: 图片加载失败时，显示在网页上的替代文字</span><br><span class="line">title: 鼠标放在图片上的提示文字</span><br><span class="line"></span><br><span class="line">alt是必须属性，可以为空；title为非必须</span><br></pre></td></tr></table></figure>

<h2 id="es6-新特性"><a href="#es6-新特性" class="headerlink" title="es6 新特性"></a>es6 新特性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.let和const</span><br><span class="line">2.模版字符串</span><br><span class="line">3.箭头函数</span><br><span class="line">4.函数可以设置默认参数值</span><br><span class="line">5.扩展运算符</span><br><span class="line">6.对象和数组的解构</span><br><span class="line">7.class</span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载原理"><a href="#图片懒加载原理" class="headerlink" title="图片懒加载原理"></a>图片懒加载原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 浏览器是否发起请求是根据&lt;img /&gt;标签的src属性</span><br><span class="line">2. 所以懒加载的关键是：在图片没有进入可视区域时，</span><br><span class="line">先不给&lt;img /&gt;的src属性赋值，等到图片进入可是区域再给data-src -&gt; src赋值。</span><br><span class="line"></span><br><span class="line">当图片底边距离页面的偏移（图片高度+图片距离顶部偏移高度）</span><br><span class="line">小于等于</span><br><span class="line">浏览器底边距离页面顶部高度（浏览器一屏高度 + 滚动区域）</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="H5-新增了哪些标签？"><a href="#H5-新增了哪些标签？" class="headerlink" title="H5 新增了哪些标签？"></a>H5 新增了哪些标签？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">article、aside、audio、video、footer、header、nav、section</span><br></pre></td></tr></table></figure>

<h2 id="SVG-和-Canvas-的区别？"><a href="#SVG-和-Canvas-的区别？" class="headerlink" title="SVG 和 Canvas 的区别？"></a>SVG 和 Canvas 的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.svg:表示以XML格式定义图像的可伸缩矢量图形。</span><br><span class="line">2.canvas：通过js来绘制2D图形</span><br><span class="line"></span><br><span class="line">svg通过标签fill属性可以调整颜色</span><br></pre></td></tr></table></figure>

<h2 id="AMD-和-CMD-的区别"><a href="#AMD-和-CMD-的区别" class="headerlink" title="AMD 和 CMD 的区别"></a>AMD 和 CMD 的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共同点：</span><br><span class="line">1.两者都是框架在推广过程中对模块定义的规范产出</span><br><span class="line">2.都是异步加载模块</span><br><span class="line">不同点：</span><br><span class="line">1.AMD是RequireJs在推广过程中对模块定义的规范产出，CMD是SeaJs在推广过程中对模块定义的规范化产出</span><br><span class="line">2.AMD推崇依赖前置，CMD推崇依赖就近</span><br><span class="line">3.AMD的应用体验好，因为模块提前执行了，CMD性能好，因为只有用户需要的时候才执行</span><br></pre></td></tr></table></figure>

<h2 id="如何实现-js-倒计时的纠偏？"><a href="#如何实现-js-倒计时的纠偏？" class="headerlink" title="如何实现 js 倒计时的纠偏？"></a>如何实现 js 倒计时的纠偏？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一种通过前端定时向服务端发送请求获取最新的时间差，以此来校准倒计时时间。</span><br><span class="line">2. 通过前端根据偏差时间来自动调整下次间隔的时间来实现，首先以setTimeout递归的方式来实现倒计时，</span><br><span class="line">通过一个变量记录倒计时的秒数，根据秒数和间隔时间计算出此时无偏差时应该显示的时间，</span><br><span class="line">然后拿当前真实时间与这个时间相减，就可以得到时间的偏差大小，因此在设置下一个定时器的时候，</span><br><span class="line">间隔时间减去这个偏差大小就可以纠正时间误差。</span><br></pre></td></tr></table></figure>

<h2 id="js-的执行机制"><a href="#js-的执行机制" class="headerlink" title="js 的执行机制"></a>js 的执行机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js是单线程的，处理js任务只能一个一个顺序执行，js中把任务分为了同步任务和异步任务，</span><br><span class="line">同步任务进入主线程先执行，异步任务进入Event Table并注册函数，指定事情完成后，Event Table就会将函数移入到事件队列Event Queque中，等待主线程任务执行完毕，</span><br><span class="line">就会从事件队列中取出对应事件进入主线程执行。</span><br><span class="line"></span><br><span class="line">macro-task（宏任务）：包括整体代码script、setTimeout、setInterval</span><br><span class="line">micro-task（微任务）：Promise.then、process.nextTick</span><br><span class="line">微任务先于宏任务先执行（除了script）执行过程不同任务进入不同的event quue</span><br><span class="line"></span><br><span class="line">js先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，</span><br><span class="line">遇到宏任务放到宏任务事件队列中。</span><br><span class="line"></span><br><span class="line">然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，</span><br><span class="line">等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，</span><br><span class="line">执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，</span><br><span class="line">就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，</span><br><span class="line">以此类推。</span><br></pre></td></tr></table></figure>

<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="请说一下你对-React-的理解？"><a href="#请说一下你对-React-的理解？" class="headerlink" title="请说一下你对 React 的理解？"></a>请说一下你对 React 的理解？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. react是一个网页的UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</span><br><span class="line">2. react的核心设计思路有三个：</span><br><span class="line">声明式</span><br><span class="line">    命令式：命令程序一步一步的执行操作</span><br><span class="line">    声明式：只需告诉程序我们想要的结果，其他的交给程序去做。</span><br><span class="line">组件化</span><br><span class="line">    将视图拆分和模块复用，做到高内聚低耦合</span><br><span class="line"></span><br><span class="line">通用性</span><br><span class="line">    一次学习，随处编写。RN，react360等，跨平台底层靠虚拟DOM实现</span><br><span class="line"></span><br><span class="line">3. 缺点</span><br><span class="line">1.没有官方系统解决方案，在开发大型应用时需要向社区寻找并整合解决方案。</span><br><span class="line">2.过于灵活，需要注意代码规范</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="React-lazy-懒加载"><a href="#React-lazy-懒加载" class="headerlink" title="React.lazy 懒加载"></a>React.lazy 懒加载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// React.lazy方法可以异步加载组件</span><br><span class="line">const Foo = React.lazy(() =&gt; import(&#x27;../components/Foo&#x27;)</span><br><span class="line"></span><br><span class="line">// React.lazy不能单独使用，需要配合React.suspense,用来包裹异步组件，添加loading效果等。</span><br><span class="line">&lt;React.Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">    &lt;Foo /&gt;</span><br><span class="line">&lt;/React.Suspense&gt;</span><br><span class="line"></span><br><span class="line">React.lazy原理</span><br><span class="line">React.lazy使用import来懒加载组件，import在webpack中最终会调用requireEnsure方法，动态插入script来请求js文件，类似jsonp的形式。</span><br></pre></td></tr></table></figure>

<h2 id="类组件和函数组件之间的区别？"><a href="#类组件和函数组件之间的区别？" class="headerlink" title="类组件和函数组件之间的区别？"></a>类组件和函数组件之间的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相同点：</span><br><span class="line">接受属性返回React元素</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line">    1.编程思想不同：类组件需要创建实例，基于面向对象的方式编程。函数式组件接受输入返回输出，属于函数式编程的思想。</span><br><span class="line">    2.内存占用：类组件需要创建实例，会占用内存，函数组件不需要创建实例，可以节约内存</span><br><span class="line">    3.捕获特性：函数组件具有捕获特性</span><br><span class="line">    4.可测试性：函数组件更方便编写单元测试</span><br><span class="line">    5.状态：类组件有实例可以维护自己的状态，函数组件可以使用useState维护自己的状态</span><br><span class="line">    6.声明周期：类组件有生命周期，可以在生命周期内写逻辑，函数组件可以在useEffect中</span><br><span class="line">    7.逻辑复用：函数组件通过继承实现逻辑复用，函数组件可以通过自定义hooks实现逻辑复用</span><br><span class="line">    8.性能优化：类组件通过shouldComponentUpdate和PureComponent来跳过更新，函数组件通过React.memo</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="当调用-setState-的时候，发生了什么事？"><a href="#当调用-setState-的时候，发生了什么事？" class="headerlink" title="当调用 setState 的时候，发生了什么事？"></a>当调用 setState 的时候，发生了什么事？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将传递给setState的参数对象合并到组件的当前的状态，react遍历dom节点，计算差异，更新UI。</span><br><span class="line">https://segmentfault.com/a/1190000018250127</span><br></pre></td></tr></table></figure>

<h2 id="为什么-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么 setState 的参数是一个 callback 而不是一个对象"></a>为什么 setState 的参数是一个 callback 而不是一个对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为this.props和this.state的更新可能是异步的，不能依赖它们的值去计算下一个state</span><br><span class="line">(更新状态不要直接修改this.state，虽然状态可以改变，但不会触发组件的更新)</span><br><span class="line"></span><br><span class="line">setState何时同步何时异步？</span><br><span class="line">异步：由React控制的事件处理程序以及生命周期函数中调用setState为异步</span><br><span class="line">同步：React控制之外的原生js绑定的事件、setTimeout/setInterval等。</span><br></pre></td></tr></table></figure>

<h2 id="setState-什么时候同步什么时候异步？"><a href="#setState-什么时候同步什么时候异步？" class="headerlink" title="setState 什么时候同步什么时候异步？"></a>setState 什么时候同步什么时候异步？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">react三个模式：</span><br><span class="line">1.legacy模式： 通过ReactDOM.render(&lt;App /&gt;, rootNode)创建的，当前react的使用方式</span><br><span class="line">2.blocking模式：通过ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;),实验阶段，作为迁移到concurrent模式的第一个步骤</span><br><span class="line">3.concurrent模式，通过ReactDOM.createRoot(rootNode).render(&lt;App /&gt;),实验阶段，未来react的默认开发模式</span><br><span class="line"></span><br><span class="line">setState 只在合成事件（react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件）和钩子函数（生命周期中）是异步的，在原生事件和setTimeout中都是同步的。</span><br><span class="line"></span><br><span class="line">不同模式执行结果不同，legacy模式命中batchedUpadates（批处理）时异步，为命中时同步</span><br><span class="line">concurrent模式都是异步的</span><br><span class="line"></span><br><span class="line">setState异步并不是说内部由异步代码实现，其本身执行过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了“异步”</span><br><span class="line"></span><br><span class="line">可以通过第二个参数的callback回调函数中拿到最新的值，在异步中如果对同一个值进行多次setState，那么setState的批量更新策略会将其覆盖，去最后一次的执行，如果同时setState多个值，会在更新时对其进行合并批量更新。</span><br></pre></td></tr></table></figure>

<h2 id="react-渲染机制"><a href="#react-渲染机制" class="headerlink" title="react 渲染机制"></a>react 渲染机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先打开页面会渲染出一颗DOM树，更新数据会生成一颗虚拟DOM树，通过diff算法，</span><br><span class="line">比较两颗DOM树的差异，找到更新的地方进行批量改动。</span><br><span class="line"></span><br><span class="line">diff：计算一棵树形结构到另一颗树形结构的最少操作。</span><br><span class="line"></span><br><span class="line">1.把树形结构按照层级分解，只比较同级元素</span><br><span class="line">2.给列表结构的每个单元添加唯一的 key 属性，方便比较</span><br><span class="line">3.diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。（官方也不推荐）</span><br></pre></td></tr></table></figure>

<h2 id="React-StrictMode-目前有助于："><a href="#React-StrictMode-目前有助于：" class="headerlink" title="React.StrictMode 目前有助于："></a>React.StrictMode 目前有助于：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">识别不安全的生命周期</span><br><span class="line">关于使用过时字符串 ref API 的警告</span><br><span class="line">关于使用废弃的 findDOMNode 方法的警告</span><br><span class="line">检测意外的副作用</span><br><span class="line">检测过时的 context API</span><br></pre></td></tr></table></figure>

<h2 id="虚拟-DOM-优点"><a href="#虚拟-DOM-优点" class="headerlink" title="虚拟 DOM 优点"></a>虚拟 DOM 优点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 减少不必要的DOM操作</span><br><span class="line">    1.1虚拟dom可以将多次操作合并为一次操作，比如添加100个节点，确是一个一个操作的</span><br><span class="line">    1.2虚拟dom借助dom diff可以将多余的操作省略掉，比如添加100个节点，其中10个是新增的</span><br><span class="line"></span><br><span class="line">2. 跨平台渲染</span><br><span class="line">    1.因为虚拟dom本质上是一个js对象</span><br><span class="line"></span><br><span class="line">react虚拟dom结构:</span><br><span class="line"></span><br><span class="line">const vNode = &#123;</span><br><span class="line">    key: null,</span><br><span class="line">    props:&#123;</span><br><span class="line">        children: [</span><br><span class="line">            &#123;type: &#x27;span&#x27;, ....&#125;,</span><br><span class="line">        ],</span><br><span class="line">        className: &#x27;red&#x27;,</span><br><span class="line">        onClick: () =&gt; &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ref: null,</span><br><span class="line">    type: &#x27;div&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建虚拟dom：React.createElement</span><br></pre></td></tr></table></figure>

<h2 id="diff-策略"><a href="#diff-策略" class="headerlink" title="diff 策略"></a>diff 策略</h2><p>`<br>策略一： tree diff<br>1.React 对树进行分层比较，两颗虚拟 DOM 树只会对同一层级的 DOM 节点进行比较。<br>如果存在跨层级的操作，只会进行创建和删除 2.如果节点是组件就进行 Component diff 3.如果节点是标签就进行 Element diff</p>
<p>策略二：component diff<br>如果为非同类型组件的话标记组件为 dirty component，替换组件下所有子节点，<br>类型相同更新属性，然后深入组件进行 Tree diff（递归遍历对比）</p>
<p>策略三：element diff<br>如果节点是原生标签，则看标签名<br>标签名不同直接替换，相同更新属性，然后进入标签进行 Tree diff（递归遍历对比）<br>`</p>
<h2 id="shouldComponentUpdate-nextProps-nextState-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-nextProps-nextState-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)是做什么的，（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate(nextProps, nextState)是做什么的，（react 性能优化是哪个周期函数？）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新绘制dom,</span><br><span class="line">由于渲染dom非常消耗性能，合理的调用shouldComponentUpdate方法可以极大的提高性能。</span><br></pre></td></tr></table></figure>

<h2 id="createElement-和-cloneElement-有什么区别？"><a href="#createElement-和-cloneElement-有什么区别？" class="headerlink" title="createElement 和 cloneElement 有什么区别？"></a>createElement 和 cloneElement 有什么区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">React.createElement()构建React元素。</span><br><span class="line">接受三个参数，第一个参数为标签名，如div、span等，或者react组件，第二个参数为传入的属性，第三个为组件的子组件。</span><br><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">React.cloneElement(),第一个参数传入react元素不是标签名，第二个参数传入属性，新添加的属性会并入原有的属性，第三个参数为子组件</span><br><span class="line">React.cloneElement(</span><br><span class="line">    element,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="虚拟-DOM-的优缺点？"><a href="#虚拟-DOM-的优缺点？" class="headerlink" title="虚拟 DOM 的优缺点？"></a>虚拟 DOM 的优缺点？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优点：</span><br><span class="line">1. 处理了浏览器兼容性问题，避免了用户操作真实DOM</span><br><span class="line">2.内容经过xss处理，可以防范xss攻击</span><br><span class="line">3.跨平台开发</span><br><span class="line">4.更新的时候可以实现差异化更新，减少更新DOM的操作</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1.虚拟DOM需要消耗额外的内存</span><br><span class="line">2.首次渲染不一定会更快</span><br></pre></td></tr></table></figure>

<h2 id="React-中创建组件的方式"><a href="#React-中创建组件的方式" class="headerlink" title="React 中创建组件的方式"></a>React 中创建组件的方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">React.createClass()、ES6 class组件 无无状态函数式组件</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="react-中-key-的作用"><a href="#react-中-key-的作用" class="headerlink" title="react 中 key 的作用"></a>react 中 key 的作用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key在react中用于追踪哪些列表中元素被修改、添加或者移除的辅助标识。</span><br><span class="line"></span><br><span class="line">在开发中，需要保证某个元素的key在同级元素中具有唯一性。</span><br><span class="line"></span><br><span class="line">diff算法会借助元素的key值来判断元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染</span><br></pre></td></tr></table></figure>

<h2 id="react-优势"><a href="#react-优势" class="headerlink" title="react 优势"></a>react 优势</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 速度快：不直接操作dom，采用虚拟dom的概念</span><br><span class="line">2.跨浏览器兼容，兼容性好</span><br><span class="line">3.一切都是component，代码更加模块化，可维护性高</span><br><span class="line">4.单向数据流，采用Flux单向数据层架构</span><br></pre></td></tr></table></figure>

<h2 id="react-事件机制"><a href="#react-事件机制" class="headerlink" title="react 事件机制"></a>react 事件机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">react的事件机制利用了事件委托机制，事件并没有真正的绑定在真实的dom节点上，</span><br><span class="line">而是把事件绑定在结构的最外层document，使用统一的事件监听器，所有事件都由这个监听器统一分发。</span><br><span class="line"></span><br><span class="line">组件挂载和更新时，会将绑定的事件分门别类的放进一个叫EvnentPluginHub的事件池中。</span><br><span class="line"></span><br><span class="line">事件触发时，根据事件产生的Event对象找到触发事件的组件，再通过组件标识和事件类型</span><br><span class="line">从事件池中找到对应的事件监听回调，然后执行相关的监听函数。</span><br></pre></td></tr></table></figure>

<h2 id="异步回调中怎么使用-syntheticEvent？"><a href="#异步回调中怎么使用-syntheticEvent？" class="headerlink" title="异步回调中怎么使用 syntheticEvent？"></a>异步回调中怎么使用 syntheticEvent？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在合成事件机制里，一旦事件监听回调执行，合成事件对象就会被销毁，异步回调执行的时候</span><br><span class="line">合成事件对象早就被销毁了。</span><br><span class="line">解决方法：执行event.persist(),通知react不需要回收。</span><br></pre></td></tr></table></figure>

<h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">React 16推出Fiber之后，如果要开启async rendering，那么在render函数之前的所有函数都有可能被执行多次</span><br><span class="line"></span><br><span class="line">废弃：</span><br><span class="line">componentWillMount</span><br><span class="line">componentWillReceiveProps(nextProps)</span><br><span class="line">componentWillUpdate(nextProps, nextState)</span><br><span class="line">代替：</span><br><span class="line">静态函数：static getDerivedStateFromProps(nextProps, prevState)</span><br><span class="line"></span><br><span class="line">静态函数：static getDerivedStateFromError(error) // 渲染备用UI</span><br><span class="line">此生命周期return的值会自动调用setState，将值和state合并</span><br><span class="line">运行事件节点：子组件被渲染发生错误后且在页面更新前</span><br><span class="line"></span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) 此生命周期的返回值将作为参数传递给componentDidUpdate()</span><br><span class="line"></span><br><span class="line">componentDidCatch(error, info) // 打印错误信息</span><br><span class="line"></span><br><span class="line">错误边界无法捕获的错误：</span><br><span class="line">1.组件自身的错误</span><br><span class="line">2.异步错误，setTimeout</span><br><span class="line">3.事件中的错误，比如click事件中发生错误</span><br></pre></td></tr></table></figure>

<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 构建action，通过创建一个函数，返回一个对象，需要携带type属性</span><br><span class="line"></span><br><span class="line">2. 构建reducer，用来响应action，然后通过return把数据传回store</span><br><span class="line"></span><br><span class="line">3. 利用createStore来构建store，把reducer作为参数传入</span><br><span class="line"></span><br><span class="line">4. 利用store.subscribe()注册监听</span><br><span class="line"></span><br><span class="line">5. 利用store.dispatch()发送action</span><br><span class="line"></span><br><span class="line">6. 利用store.getState()拿到值</span><br></pre></td></tr></table></figure>

<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><h2 id="ts-中-type-和-interface-的区别"><a href="#ts-中-type-和-interface-的区别" class="headerlink" title="ts 中 type 和 interface 的区别"></a>ts 中 type 和 interface 的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相同点：</span><br><span class="line">1.都可以描述一个对象和函数</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface SetUser &#123;</span><br><span class="line">    (name: string): void;</span><br><span class="line">&#125;</span><br><span class="line">type User = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">type SetUser = (name: string): void;</span><br><span class="line"></span><br><span class="line">2.扩展与交叉类型</span><br><span class="line">interface可以extends进行类型扩展，type可以通过交叉类型实现interface的extend行为。</span><br><span class="line">interface可以exteds  type，type也可以与interface类型交叉（&amp;符号）</span><br><span class="line">不同点：</span><br><span class="line">1.type可以声明基本类型别名，联合类型，元祖等类型</span><br><span class="line">基本类型别名</span><br><span class="line">type Name = string;</span><br><span class="line">联合类型</span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wang();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line">type Pet = Dog | Cat;</span><br><span class="line">元祖类型</span><br><span class="line">type PetList = [Dog, Cat];</span><br><span class="line"></span><br><span class="line">2. interface能够声明合并</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface User &#123;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">=</span><br><span class="line">/**</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="ts-中如何实现一个函数的重载"><a href="#ts-中如何实现一个函数的重载" class="headerlink" title="ts 中如何实现一个函数的重载"></a>ts 中如何实现一个函数的重载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js是动态类型语言，所以是没有overload的，但js可以在运行的时候判断类型</span><br><span class="line">ts的重载只是重载函数声明，函数的实现还是只有一个</span><br></pre></td></tr></table></figure>

<h2 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Observable //被观察者</span><br><span class="line">Observer // 观察者</span><br><span class="line">Reaction //响应</span><br><span class="line"></span><br><span class="line">mobx底层对数据的观察是使用Object.defineProperty(mobx4)或Proxy(mobx5)</span><br><span class="line">observer这个装饰器，对react组件的render方法进行跟踪，将render方法加入到各个observable的依赖中，当observale发生变化的时候，就会调用forceUpdate更新组件</span><br><span class="line">（mobx4将Array用类数组对象来模拟的，通过包装类封装为一个对象）</span><br></pre></td></tr></table></figure>

<h2 id="webpack-常用-loader"><a href="#webpack-常用-loader" class="headerlink" title="webpack 常用 loader"></a>webpack 常用 loader</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">样式：style-loader、css-loader、less-loader、sass-loader</span><br><span class="line">文件：file-loader、url-loader</span><br><span class="line">编译：babel-loader、ts-loader</span><br><span class="line">校验：eslint-loader</span><br><span class="line"></span><br><span class="line">常用的plugin</span><br><span class="line">html-webpack-plugin</span><br><span class="line">webpack-bundle-analyzer 打包分析</span><br><span class="line">HotModuleReplacementPlugin 热更新</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自己写webpack插件：</span><br><span class="line">主要就是通过访问compliler和compilation拦截webpack的执行</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">垃圾收集器会定期（周期性）的找出那些不再继续使用的变量，释放其内存，因为开销比较大，所以会按照固定的时间间隔周期性的执行</span><br><span class="line"></span><br><span class="line">最常用的两种方法：标记清除（常用）和引用计数</span><br><span class="line"></span><br><span class="line">标记清除：变量进入作用域，进行标记，离开作用域进行清除回收</span><br><span class="line"></span><br><span class="line">引用计数：就是跟踪记录每个值被引用的次数，引用一次加1，删除减1，引用计数为0时，进行回收，（循环引用可能会导致内存泄漏）</span><br><span class="line"></span><br><span class="line">常见的内存泄漏原因：</span><br><span class="line">全局变量过多引起内存泄漏</span><br><span class="line">闭包</span><br><span class="line">dom事件未清除</span><br><span class="line">循环引用</span><br></pre></td></tr></table></figure>

<h2 id="谈谈你对-webpack-的理解？"><a href="#谈谈你对-webpack-的理解？" class="headerlink" title="谈谈你对 webpack 的理解？"></a>谈谈你对 webpack 的理解？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack是一个打包模块化js的工具，在webpack里一切文件皆模块</span><br><span class="line">，通过loader转换，通过plugin注入钩子，最后输出由多个</span><br><span class="line">模块组合成的文件，webpack专注构建模块化。WebPack可</span><br><span class="line">以看做是模块的打包机器：它做的事情是，分析你的项目</span><br><span class="line">结构，找到js模块及其它的一些浏览器不能直接运行的</span><br><span class="line">拓展语言，例如：Scss，TS等，并将其打包为合适的格式</span><br><span class="line">以供浏览器使用。</span><br></pre></td></tr></table></figure>

<h2 id="说说-webpack-与-grunt、gulp-的不同？"><a href="#说说-webpack-与-grunt、gulp-的不同？" class="headerlink" title="说说 webpack 与 grunt、gulp 的不同？"></a>说说 webpack 与 grunt、gulp 的不同？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三者都是前端构建工具，grunt和gulp在早期比较流行，</span><br><span class="line">现在webpack相对来说比较主，不过一些轻量化的任务</span><br><span class="line">还是会用gulp来处理，比如单独打包CSS文件等。</span><br><span class="line"></span><br><span class="line">grunt和gulp是基于任务和流（Task、Stream）的。</span><br><span class="line">类似jQuery，找到一个（或一类）文件，对其做一</span><br><span class="line">系列链式操作，更新流上的数据，整条链式操作</span><br><span class="line">构成了一个任务，多个任务就构成了web的构建流程。</span><br><span class="line"></span><br><span class="line">webpack是基于入口的。webpack会自动地递归解析</span><br><span class="line">入口所需要加载的所有资源文件，然后用不同的</span><br><span class="line">Loader来处理不同的文件，用Plugin来扩展webpack功能。</span><br><span class="line"></span><br><span class="line">所以，从构建来说，gulp和grunt需要开发者将整个</span><br><span class="line">前端构建过程拆分成多个`Task`，并合理控制所有`Task`的</span><br><span class="line">调用关系；webpack需要开发者找到入口，并需要清楚对</span><br><span class="line">于不同的资源应该使什么Loader做何种解析和加工对</span><br><span class="line">于知识背景来说，gulp更像后端开发者的思路，</span><br><span class="line">需要对于整个流程了如指掌webpack更倾向于前端开发者的思路</span><br></pre></td></tr></table></figure>

<h2 id="什么是-bundle-什么是-chunk，什么是-module"><a href="#什么是-bundle-什么是-chunk，什么是-module" class="headerlink" title="什么是 bundle,什么是 chunk，什么是 module?"></a>什么是 bundle,什么是 chunk，什么是 module?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bundle：是由webpack打包出来的文件</span><br><span class="line">chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割</span><br><span class="line">module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块</span><br></pre></td></tr></table></figure>

<h2 id="什么是-Loader-什么是-Plugin"><a href="#什么是-Loader-什么是-Plugin" class="headerlink" title="什么是 Loader?什么是 Plugin?"></a>什么是 Loader?什么是 Plugin?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Loaders是用来告诉webpack如何转化处理某一类型的文件，</span><br><span class="line">并且引入到打包出的文中</span><br><span class="line">2）Plugin是用来自定义webpack打包过程的方式，</span><br><span class="line">一个插件是含有apply方法的一个，通过这个方法可以参与</span><br><span class="line">到整个webpack打包的各个流程(生命周期)。</span><br></pre></td></tr></table></figure>

<h2 id="有哪些常见的-Loader？他们是解决什么问题的？"><a href="#有哪些常见的-Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的 Loader？他们是解决什么问题的？"></a>有哪些常见的 Loader？他们是解决什么问题的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file-loader：把文件输出到一个文件夹中，在代码中通过</span><br><span class="line">相对URL去引用输出的文件</span><br><span class="line">url-loader：和file-loader类似，但是能在文件很小的情况下</span><br><span class="line">以base64的方式把文件内容注入到代码中去</span><br><span class="line">source-map-loader：加载额外的Source Map文件，以方便断点调试</span><br><span class="line">image-loader：加载并且压缩图片文件</span><br><span class="line">babel-loader：把ES6转换成ES5</span><br><span class="line">css-loader：加载CSS，支持模块化、压缩、文件导入等特性</span><br><span class="line">style-loader：把CSS代码注入到JavaScript中，通过DOM操作去加载CSS。</span><br><span class="line">eslint-loader：通过ESLint检查JavaScript代码</span><br></pre></td></tr></table></figure>

<h2 id="有哪些常见的-Plugin？他们是解决什么问题的？"><a href="#有哪些常见的-Plugin？他们是解决什么问题的？" class="headerlink" title="有哪些常见的 Plugin？他们是解决什么问题的？"></a>有哪些常见的 Plugin？他们是解决什么问题的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define-plugin：定义环境变量</span><br><span class="line">commons-chunk-plugin：提取公共代码</span><br><span class="line">uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</span><br></pre></td></tr></table></figure>

<h2 id="Loader-和-Plugin-的不同？"><a href="#Loader-和-Plugin-的不同？" class="headerlink" title="Loader 和 Plugin 的不同？"></a>Loader 和 Plugin 的不同？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不同的作用</span><br><span class="line">Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，</span><br><span class="line">但是webpack原生是只能解析js文件，如果想将其他文件</span><br><span class="line">也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</span><br><span class="line"></span><br><span class="line">Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br><span class="line"></span><br><span class="line">不同的用法</span><br><span class="line">Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么</span><br><span class="line">类型的文件（test），使用什么加载(loader)和使用的参数（options）</span><br><span class="line"></span><br><span class="line">Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</span><br></pre></td></tr></table></figure>

<h2 id="webpack-的构建流程是什么"><a href="#webpack-的构建流程是什么" class="headerlink" title="webpack 的构建流程是什么?"></a>webpack 的构建流程是什么?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</span><br><span class="line">初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</span><br><span class="line">开始编译：用上一步得到的参数初始化Compiler对象，</span><br><span class="line">加载所有配置的插件，执行对象的 run 方法开始执行编译；</span><br><span class="line"></span><br><span class="line">确定入口：根据配置中的 entry 找出所有的入口文件；</span><br><span class="line"></span><br><span class="line">编译模块：从入口文件出发，调用所有配置的 Loader</span><br><span class="line">对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到</span><br><span class="line">所有入口依赖的文件都经过了本步骤的处理；</span><br><span class="line"></span><br><span class="line">完成模块编译：在经过第4步使用Loader翻译完所有模块后，</span><br><span class="line">得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</span><br><span class="line"></span><br><span class="line">输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk转换成一个单独的文件加入到输</span><br><span class="line">出列表，这步是可以修改输出内容的最后机会；</span><br><span class="line"></span><br><span class="line">输出完成：在确定好输出内容后，根据配置确定输出的</span><br><span class="line">路径和文件名，把文件内容写入到文件系统。</span><br><span class="line"></span><br><span class="line">在以上过程中，Webpack会在特定的时间点广播出特定</span><br><span class="line">的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，</span><br><span class="line">并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</span><br></pre></td></tr></table></figure>

<h2 id="描述一下编写-loader-或-plugin-的思路？"><a href="#描述一下编写-loader-或-plugin-的思路？" class="headerlink" title="描述一下编写 loader 或 plugin 的思路？"></a>描述一下编写 loader 或 plugin 的思路？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，</span><br><span class="line">并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。</span><br><span class="line">编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。</span><br><span class="line">相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br></pre></td></tr></table></figure>

<h2 id="如何利用-webpack-来优化前端性能？"><a href="#如何利用-webpack-来优化前端性能？" class="headerlink" title="如何利用 webpack 来优化前端性能？"></a>如何利用 webpack 来优化前端性能？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用webpack优化前端性能是指优化webpack的输出结果，</span><br><span class="line">让打包的最终结果在浏览器运行快速高效。</span><br><span class="line"></span><br><span class="line">压缩代码。删除多余的代码、注释、简化代码的写法等等方式。</span><br><span class="line">可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件</span><br><span class="line">，利用cssnano（css-loader?minimize）来压缩css</span><br><span class="line"></span><br><span class="line">利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对</span><br><span class="line">应的路径。可以利用webpack对于output参数和各loader的publicPath</span><br><span class="line">参数来修改资源路径</span><br><span class="line"></span><br><span class="line">删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。</span><br><span class="line"></span><br><span class="line">可以通过在启动webpack时追加参数--optimize-minimize来</span><br><span class="line">实现提取公共代码。</span><br></pre></td></tr></table></figure>

<h2 id="如何提高-webpack-的构建速度？"><a href="#如何提高-webpack-的构建速度？" class="headerlink" title="如何提高 webpack 的构建速度？"></a>如何提高 webpack 的构建速度？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多入口情况下，使用CommonsChunkPlugin来提取公共代码</span><br><span class="line">通过externals配置来提取常用库</span><br><span class="line">利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，</span><br><span class="line">再通过DllReferencePlugin将预编译的模块加载进来。</span><br><span class="line">使用Happypack 实现多线程加速编译</span><br><span class="line">使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</span><br><span class="line">使用Tree-shaking和Scope Hoisting来剔除多余代码</span><br></pre></td></tr></table></figure>

<h2 id="怎么配置单页应用？怎么配置多页应用？"><a href="#怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="怎么配置单页应用？怎么配置多页应用？"></a>怎么配置单页应用？怎么配置多页应用？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用webpack的AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。</span><br><span class="line">多页应用中要注意的是：每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表,随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</span><br></pre></td></tr></table></figure>

<h2 id="vue-项目中实现按需加载？"><a href="#vue-项目中实现按需加载？" class="headerlink" title="vue 项目中实现按需加载？"></a>vue 项目中实现按需加载？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。</span><br><span class="line">不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。</span><br><span class="line"></span><br><span class="line">单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</span><br><span class="line"></span><br><span class="line">通过import(*)语句来控制加载时机，webpack内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个chunk。当代码执行到import(*)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill</span><br></pre></td></tr></table></figure>

<p>自主搭建、灵活定制、高效复用</p>
<p>1.单向链表的创建、插入和反转 2.二叉搜索树的查找、插入、删除思想，写伪代码<br>3.tcp 链接和释放过程，http，https，tcp 和 udp 比较 4.链表顺序翻转</p>
<h2 id="如何阻止冒泡"><a href="#如何阻止冒泡" class="headerlink" title="如何阻止冒泡?"></a>如何阻止冒泡?</h2><pre><code>W3C的方法e.stopPropagation(),IE使用e.cancelBubble = true;

封装：
    //阻止冒泡行为
    function stopBubble(e) &#123;
        //如果提供了事件对象，则这是一个非IE浏览器
        if (e &amp;&amp; e.stopPropagation) e.stopPropagation()
        //IE的方法
        else window.event.cancelBubble = true
    &#125;
</code></pre>
<h2 id="如何阻止默认事件？"><a href="#如何阻止默认事件？" class="headerlink" title="如何阻止默认事件？"></a>如何阻止默认事件？</h2><pre><code>W3C的方法是e.preventDefault(),IE使用e.returnValue = false

封装：
    //阻止浏览器的默认行为
    function stopDefault (e) &#123;
        if (e &amp;&amp; e.preventDefault) e.preventDefault()
        //IE中阻止默认事件的方法
        else window.event.returnValue = false
        return false
    &#125;
</code></pre>
<h2 id="补充：事件绑定的封装"><a href="#补充：事件绑定的封装" class="headerlink" title="补充：事件绑定的封装"></a>补充：事件绑定的封装</h2><pre><code>function addEvent(element,type,handle) &#123;
    if(element.addEventListener)&#123;
        element.addEventListener(type,handle,false);
    &#125;else if(element.attachEvent)&#123;
        element.attachEvent(&#39;on&#39;+type,function () &#123;
            handle.call(element);
        &#125;)
    &#125;else &#123;
        element[&#39;on&#39;+type] = handle;
    &#125;
&#125;
</code></pre>
<h2 id="JS-如何设置获取盒子模型对应的宽和高？"><a href="#JS-如何设置获取盒子模型对应的宽和高？" class="headerlink" title="JS 如何设置获取盒子模型对应的宽和高？"></a>JS 如何设置获取盒子模型对应的宽和高？</h2><ul>
<li><p>dom.style.width/height</p>
</li>
<li><p>dom.currentStyle.width/height (ie 支持)</p>
</li>
<li><p>window.getComputedStyle(dom).width/height</p>
</li>
<li><p>dom.getBoundingClientRect().width/height</p>
</li>
</ul>
<h4 id="如何判断一个对象是否为数组"><a href="#如何判断一个对象是否为数组" class="headerlink" title="如何判断一个对象是否为数组"></a>如何判断一个对象是否为数组</h4><pre><code>1. Array.prototype.isPrototypeOf(obj)方法，判断Array.prototype是不是在obj的原型链中，
如果在，则返回true，否则返回false。

2. obj instanceof Array

3. Object.prototype.toString.call(obj); //(===&quot;[object Array]&quot;)

4.Array.isArray(obj)
</code></pre>
<h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><pre><code>1.macro-task(宏任务)：包括整体代码script、setTimeout、setInterval
2.micro-task(微任务)：Promise.then、process.nextTick
</code></pre>
<h4 id="Http-的持久连接和管线化"><a href="#Http-的持久连接和管线化" class="headerlink" title="Http 的持久连接和管线化"></a>Http 的持久连接和管线化</h4><pre><code>1. 什么是持久连接？
    HTTP1.1规定了默认保持持久连接，数据传输完成也保持TCP连接不断开，等待同域名下
    继续使用这个通道传输数据,在一个TCP连接上传输多个HTTP请求和响应。

    持久连接避免了重新建立连接，大大减少了建立和关闭连接的消耗和延迟，HTTP的连接是建立
    在TCP协议之上的，建立一条TCP连接需要三次握手，TCP连接关闭需要四次挥手，这些都需要时间。

2. 什么是管线化？
    持久连接：
        请求1 ——&gt; 响应1 ——&gt; 请求2 ——&gt; 响应2
    管线化：
        请求1 ——&gt; 请求2 ——&gt; 响应1 ——&gt; 响应2

    管线化机制需要通过持久化连接完成。

    持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后，
    才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。
    实现并行发送请求。

    只有GET和HEAD请求可以进行管线化，而POST有所限制。

    初次建立连接不应启动管线机制，因为对方服务器不一定支持HTTP1.1版本的协议。
</code></pre>
<h4 id="为什么利用多个域名来存储网站资源会更有效？"><a href="#为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="为什么利用多个域名来存储网站资源会更有效？"></a>为什么利用多个域名来存储网站资源会更有效？</h4><pre><code>1.CDN 是构建在网络之上的内容分发网络，可以使用户就近获取资源，减低网络拥塞，提高用户
访问的响应效率以及命中率。

2.突破浏览器的并发限制，同一时间针对同一域名下的请求有一定的数量限制，超过限定数目
的请求会被阻塞。

3.节约cookie带宽

4.减少主域名的连接数，优化页面响应速度

5.防止不必要的安全问题
</code></pre>
<h4 id="CSS-权重（156-进制）"><a href="#CSS-权重（156-进制）" class="headerlink" title="CSS 权重（156 进制）"></a>CSS 权重（156 进制）</h4><pre><code>1. ！import  权值：infinite 无穷大

2. 内联样式， 权值1000

3. ID选择器， 权值： 100

4. 类、伪类、属性选择器， 权值： 10

5.标签、伪元素选择器， 权值： 1

6.通配符选择器 *，子选择器 &gt;,相邻选择器 +，权值： 0

权值相等，后来居上
</code></pre>
<h4 id="html5-的新特性"><a href="#html5-的新特性" class="headerlink" title="html5 的新特性"></a>html5 的新特性</h4><pre><code>1. 添加了video、radio标签
2. 添加了canvas画布和svg渲染矢量图片
3. 添加了一些语义化的标签 header、footer、main、section...
4. input的type值新添加了很多属性（email，search，color，number...）
5. 添加了地理位置定位功能 Geolocation API
6. 添加了web Storage存储功能，localStorage和sessionStorage
7. 使用html5，通过创建cache manifest文件，可以轻松地创建web应用的离线版本
8. web worker创造多线程环境，是运行在后台的javaScript。
9。 服务端推送（EventSource用于接受服务端发送事件通知）
</code></pre>
<h4 id="CSS3-新添加的特性？"><a href="#CSS3-新添加的特性？" class="headerlink" title="CSS3 新添加的特性？"></a>CSS3 新添加的特性？</h4><pre><code>1. 媒体查询
2. transform，transition，translate，scale，rotate等相关动画效果
3. box-shadow，text-shadow等特效
4. CSS3 @font-face规则，可以引入任意字体
5. CSS3 @keyframes规则，创建动画(配合animation使用)
6. 2D、3D转化
7. 添加了border-radius、border-image、column-count、resize、box-sizing
、outline-offset等属性
</code></pre>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><pre><code>基本数据类型：Null、Undefined、String、Boolean、Number
ES6：Symbol
ES10：Bigint（可以突破安全整数限制，安全的存储和操作最大整数之外的整数，不会损失精度）
</code></pre>
<h2 id="牛客学习"><a href="#牛客学习" class="headerlink" title="牛客学习"></a>牛客学习</h2><ul>
<li><p>超链接</p>
<ul>
<li>a 标签的 href 的属性值是 url，里面必须包含协议，没有协议就会解析成相对路径。</li>
</ul>
</li>
<li><p>HTTP 状态码分类：</p>
<ul>
<li>1** 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2** 成功，操作被成功接受并处理。<ul>
<li>200 服务端成功处理了请求并返回内容</li>
</ul>
</li>
<li>3** 重定向，需要进一步的操作以完成请求<ul>
<li>301 永久重定向</li>
<li>302 临时重定向</li>
<li>304 资源未被修改，返回一个 304 状态吗然后从本地缓存中加载请求的资源</li>
</ul>
</li>
<li>4** 客户端错误，请求包含语法错误或无法完成请求。<ul>
<li>404 （页面丢失）未找到资源</li>
<li>403 服务器拒绝请求</li>
<li>408 （请求超时） 服务器等候请求时发生超时</li>
</ul>
</li>
<li>5** 服务器错误，服务器在处理请求的过程中发生错误 + 503 服务器暂时不可用 + 504 服务器内部错误<!--more--></li>
</ul>
</li>
<li><p>HTTP 协议的特征：</p>
<ul>
<li>C/S(客户端/服务器)模式：只要客户端和服务器知道如何处理数据内容，任何类型的数据<br>都可以通过 HTTP 来发送，客户端和服务器指定合适的 MIME-type 内容类型。</li>
<li>简单快速</li>
<li>灵活</li>
<li>无连接：限制每次连接只处理一个请求，收到客户的应答后即断开连接，可以节省传输时间。</li>
<li>无状态：对于事物处理没有记忆能力，意味着如果后续处理需要前面的信息，则必须重传，<br>这样就会导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就会很快。</li>
</ul>
</li>
<li><p>get 和 post 的请求区别？</p>
<ul>
<li>区别一：<ul>
<li>get 重点是从服务器上获取资源</li>
<li>post 重点是向服务器发送数据</li>
</ul>
</li>
<li>区别二：<ul>
<li>get 传输数据通过 url 请求，以 field（字段）=value 的形式放在 url 后，用“？”连接，<br>多个请求数据间用“&amp;”连接，过程用户可见。</li>
<li>post 传输数据放在请求体（request body）中发送给服务器，用户不可见。</li>
</ul>
</li>
<li>区别三：<ul>
<li>get 传输数据大小有限制，但效率较高</li>
<li>post 可以传输大量数据，所以上传文件用 post 方式</li>
</ul>
</li>
<li>区别四：<ul>
<li>get 请求不安全，因为参数直接暴露在 url 上，不能用来传递敏感信息。</li>
<li>post 较 get 安全性较高。</li>
</ul>
</li>
<li>区别五：<ul>
<li>get 方式只能支持 ASCII 字符，向服务传的中文字符可能会乱码。</li>
<li>post 支持标准字符集，可以正确传递中文字符。</li>
</ul>
</li>
<li>区别六：<ul>
<li>get 在浏览器回退是无害的，而 post 会再次提交请求。</li>
</ul>
</li>
<li>区别七<ul>
<li>get 请求会被浏览器主动 cache（缓存），而 post 不会除非手动设置。</li>
</ul>
</li>
</ul>
</li>
<li><p>iframe 有哪些缺点？</p>
<ul>
<li><p>iframe 会阻塞主页面的 onload 事件</p>
</li>
<li><p>通过 oIframe.contentWindow 寻找子 window 对象</p>
</li>
<li><p>通过 window.parent 寻找父级窗体</p>
</li>
<li><p>通过 window.top 寻找顶级窗体</p>
</li>
<li><p>window.location.hash 解决父页面向子页面传值</p>
</li>
<li><p>window.name 解决子页面向父页面传值</p>
</li>
<li><p>不利于 SEO，搜索引擎的检索程序无法解读这种页面（百度 spider 不收录，浏览器对 iframe 框架的兼容问题）</p>
</li>
<li><p>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</p>
</li>
<li><p>如果需要使用 iframe，最好通过 javascript 动态给 iframe 添加 src 属性值。</p>
</li>
</ul>
</li>
<li><p>xhtml 和 html 有什么区别？</p>
<ul>
<li><p>性能方面</p>
<ul>
<li>XHTML 兼容性好，兼容各大浏览器、手机以及 PDA，使浏览器可以快速正确编译网页</li>
</ul>
</li>
<li><p>书写习惯方面</p>
<ul>
<li><p>HTML 标签不区分大小写，XHTML 所有标签必须小写</p>
</li>
<li><p>XHTML 必须成双成对</p>
</li>
<li><p>HTML 对标签顺序要求不严格，XHTML 标签顺序必须正确</p>
</li>
<li><p>等等</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>html 和 xml 的区别？</p>
<ul>
<li><p>xml 被设计用来传输和存储数据，其焦点是数据的内容</p>
</li>
<li><p>html 被设计用来显示数据，其焦点是数据的外观</p>
</li>
<li><p>html 旨在显示信息，而 xml 旨在传输信息</p>
</li>
<li><p>xml 在定义标记时区分大小写，而 html 不区分大小写</p>
</li>
</ul>
</li>
<li><p>link 和@import 的区别：<br><strong>两者都是外部引用 CSS 的方式，但有一定的区别</strong></p>
<pre><code>+ link是XHTML标签，除了加载CSS外，还可以加载其他文件；@import只能加载CSS。

+ 解析到link时，页面会同步加载Css；@import在页面加载完后加载Css。

+ link是XHTML标签，无兼容问题；@import是在**CSS2.1**之后提出的，只有再IE5以上才能识别。

+ link可以js动态引入，@import不行

+ @import的最佳写法： @import url(style.css),其他写法：@import &#39;style.css&#39;、
@import &quot;style.css&quot;、@import url(&#39;style.css&#39;)、@import url(&quot;style.css&quot;)
</code></pre>
</li>
<li><p>viewport</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  // width            设置viewport宽度，为一个正整数，或字符串‘device-width’</span><br><span class="line">  // device-width     设备宽度</span><br><span class="line">  // height           设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置</span><br><span class="line">  // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数</span><br><span class="line">  // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数</span><br><span class="line">  // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数</span><br><span class="line">  // user-scalable    是否允许手动缩放</span><br></pre></td></tr></table></figure>

<ul>
<li><p>单行文本溢出省略号</p>
<p>overflow: hidden;</p>
<p>text-overflow:ellipsis;</p>
<p>white-space: nowrap;</p>
</li>
<li><p>多行文本溢出省略号</p>
<p>display: -webkit-box;</p>
<p>-webkit-box-orient: vertical;</p>
<p>-webkit-line-clamp: 3;</p>
<p>overflow: hidden;</p>
</li>
<li><p>换行标签</p>
<p>word-wrap: break-word</p>
</li>
</ul>
<h2 id="深度封装-typeof-判断"><a href="#深度封装-typeof-判断" class="headerlink" title="深度封装 typeof 判断"></a>深度封装 typeof 判断</h2><pre><code>function myTypeof(val) &#123;
    var type = typeof(val)
    var res = &#123;
        &#39;[object Object]&#39; : &#39;object&#39;,
        &#39;[object Array]&#39; : &#39;array&#39;,
        &#39;[object Number]&#39; : &#39;object number&#39;,
        &#39;[object String]&#39; : &#39;object string&#39;,
        &#39;[object Boolean]&#39; : &#39;object boolean&#39;
    &#125;
    if (val === null) &#123;
        return &#39;null&#39;
    &#125; else if (type == &#39;object&#39;) &#123;
        var str = Object.prototype.toString.call(val)
        return res[str]
    &#125; else &#123;
        return type
    &#125;
&#125;
</code></pre>
<h2 id="浏览器的-reflow-和-repaint"><a href="#浏览器的-reflow-和-repaint" class="headerlink" title="浏览器的 reflow 和 repaint"></a>浏览器的 reflow 和 repaint</h2><ul>
<li>reflow（回流||重排）：当浏览器上某一个位置的布局发生了改变，浏览器会重新从根部开始计算该节点的</li>
</ul>
<p>布局。比如：向页面中添加、删除某一元素等，dom 节点的宽高位置改变，只要这些操作影响了</p>
<p>页面的元素位置或大小的变化，都会引起 reflow。</p>
<ul>
<li>repaint（重绘）：如果只改变页面元素的颜色、字体等不影响布局的属性时，浏览器会进行 repaint。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由上可见，相比repaint操作，reflow的耗时要更多。只要是动态的对页面进行修改，浏览器的reflow</span><br><span class="line"></span><br><span class="line">和repaint的操作就不可避免，我们要做的就是尽可能的减少浏览器的reflow和repaint的次数。</span><br></pre></td></tr></table></figure>

<h2 id="浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？"><a href="#浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？" class="headerlink" title="浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？"></a>浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？</h2><ul>
<li><p>在线的情况下：浏览器发现 html 头部有 manifest 属性，会请求 manifest 文件，如果是<br>第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并进行离线缓存。如果<br>已经离线存储了，浏览器会使用离线的资源加载页面，然后浏览器会比对新的 manifest 文件<br>与旧的 manifest 文件，如果文件没有发生改变，就不要做任何操作，如果文件改变，就会重新<br>下载文件中的资源并进行离线存储。</p>
</li>
<li><p>离线的情况下：浏览器就直接使用离线存储的资源。</p>
</li>
</ul>
<h2 id="如何清除-token"><a href="#如何清除-token" class="headerlink" title="如何清除 token"></a>如何清除 token</h2><ul>
<li><p>浏览器关闭会出发 <strong>beforeunload</strong> ，<strong>unload</strong> 这两个事件。</p>
</li>
<li><p>浏览器刷新也会触发，还会触发<strong>load</strong>事件</p>
</li>
<li><p>方案一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.onbeforeunload = function () &#123;</span><br><span class="line">    localStorage.removeItem(&quot;token&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点： 刷新也会清空 token</p>
</li>
<li><p>方案二</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.onunload = function() &#123;</span><br><span class="line">    localStorage.setItem(&quot;lastTime&quot;,new Date().getTime())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">    let lastTime = localStorage.getItem(&quot;lastTime&quot;);</span><br><span class="line">    const interval = 3 * 1000;</span><br><span class="line">    // 如果时间间隔大于3s，则清除token</span><br><span class="line">    if (!lastTime || new Date().getTime() - lastTime &gt; interval) &#123;</span><br><span class="line">        localStorage.remove(&quot;token&quot;);</span><br><span class="line">        console.log(&quot;remove token&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;time is less than not remove token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>补充<br>可以使用 sessionStorage 代替 localStorage 来存储 token，当关闭浏览器时会自动清除 token，sessionStorage 不是持久化的本地存储，而是会话级别的存储，而 localStorage 是持久化的本地存储，除非主动删除数据，否则数据是不会过期的。</p>
</li>
</ul>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><!--more-->

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 举个例子：</span></span><br><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;^13.4.6&quot;</span>, <span class="comment">// 只锁定主版本号 major</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;~13.4.6&quot;</span>, <span class="comment">// 锁定主版本号和次版本号 major + minor</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;13.4.6&quot;</span>,  <span class="comment">// 锁定版本</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;*&quot;</span>,       <span class="comment">// 最新版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// major: 13, minor: 4, patch: 6</span></span><br><span class="line"></span><br><span class="line">$ npm info jquery <span class="comment">// 查看 jquery 信息</span></span><br><span class="line">$ npm view jquery versions <span class="comment">// 查看 jquery 所有版本</span></span><br><span class="line">$ npm list | grep gulp <span class="comment">// 过滤 gulp</span></span><br><span class="line">$ npm outdated <span class="comment">// 查看过期版本</span></span><br><span class="line">$ npm update <span class="comment">//更新版本</span></span><br><span class="line">$ npm cache clean --force <span class="comment">// 清楚缓存</span></span><br><span class="line">$ npm ls <span class="comment">// 查看项目引用了哪些包</span></span><br><span class="line">$ npm unpublish --force <span class="comment">// 从npm卸载包</span></span><br><span class="line"><span class="comment">// 执行顺序</span></span><br><span class="line">$ npm run script1 &amp; npm run script2 <span class="comment">//并行执行</span></span><br><span class="line">$ npm run script1 &amp;&amp; npm run script2 <span class="comment">// 继发执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cross-env: 运行跨平台设置和使用环境变量的脚本</span></span><br><span class="line"><span class="comment">// cross-env可以设置NODE_ENV环境变量，process.env.NODE_ENV === &#x27;production&#x27;</span></span><br><span class="line">$ npm install --save-dev cross-env</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;scripts&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">$ npm config get registry <span class="comment">// 查看当前源</span></span><br><span class="line">$ npm config set registry <span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org //切换镜像源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// npx</span></span><br><span class="line"><span class="comment">// --no-install: 让npx强制使用本地模块，不下载远程模块，如果本地不存在，就会报错</span></span><br><span class="line">$ npx --no-install http-server</span><br><span class="line"><span class="comment">// --ignore-existing: 忽略本地的同名模块，强制安装远程模块</span></span><br><span class="line">$ npx --ignore-existing http-server</span><br></pre></td></tr></table></figure>

<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><ul>
<li><p>客户端的本地存储：</p>
<ul>
<li><p>localStorage - 生命周期永久生效，除非手动删除，否则关闭页面也会存在 - 可以在同一浏览器多窗口共享 - 以键值对的形式存储使用 - 方法： + 存储数据：localStorage.setItem(key, value) + 获取数据：localStorage.getItem(key) + 删除数据：localStorage.removeItem(key) + 删除所有数据：localStorage.clear()</p>
</li>
<li><p>sessionStorage</p>
<ul>
<li><p>声明周期为关闭浏览器窗口</p>
</li>
<li><p>在同一个窗口中数据可以共享</p>
</li>
<li><p>以键值对的形式存储</p>
</li>
<li><p>方法：</p>
<ul>
<li>存储数据：sessionStorage.setItem(key, value)</li>
<li>获取数据：sessionStorage.getItem(key)</li>
<li>删除数据：sessionStorage.removeItem(key)</li>
<li>删除所有数据：sessionStorage.clear()</li>
</ul>
<p><a href='https://www.cnblogs.com/pengc/p/8714475.html'>localStorage 和 sessionStorage</a></p>
<p><a href='https://www.cnblogs.com/8023-CHD/p/11067141.html'>cookie 和 session</a></p>
</li>
</ul>
</li>
<li><p>IndexDB 离线存储，当网络断开，可以从浏览器中读取数据，用来做一些离线应用</p>
</li>
<li><p>Cookie</p>
<ul>
<li>包含字段<ul>
<li>name: cookie 名称</li>
<li>value: 值</li>
<li>domain: cookie 生效的域名</li>
<li>path: cookie 生效的路径</li>
<li>expires/max-age: cookie 过期时间</li>
<li>size: 大小</li>
<li>HttpOnly: 用户端不可更改</li>
</ul>
</li>
<li>存储用户信息，通过在客户端记录信息确定用户身份，最大为 4kb</li>
<li>会话 Cookie，若不设置过期时间，表示这个 cookie 的生命周期为浏览器会话期间，浏览器<br>关闭，cookie 就消失，会话 cookie 会保存在内存中而不是硬盘上。</li>
<li>持久 Cookie，若设置了过期时间，浏览器会把 cookie 保存在硬盘上，关闭浏览器仍然有效直到<br>超过设定的过期时间。</li>
<li>cookie 数据始终在同源的 http 请求中携带(即使不需要)，即会在浏览器和服务器之间来回传递。</li>
<li>Cookie 具有不可跨域名性，例如浏览器访问百度不会带上谷歌的 cookie</li>
</ul>
</li>
</ul>
</li>
<li><p>服务端的存储：</p>
<ul>
<li>Session<ul>
<li>Session 服务器端一种记录客户端状态的机制</li>
<li>cookie 数据存放在客户的浏览器上，session 将数据存放在服务器端</li>
<li>Session 相对 Cookie 来说比较安全，别人可以分析本地存放的 cookie 进行 cookie 欺骗</li>
<li>Session 会在一定时间内保存在服务器上，访问量较多的时候会比较占用服务器的性能，<br>考虑到减轻服务器性能方面的时候，应当使用 cookie</li>
<li>可以将登陆等重要信息保存在 session，其他信息放在 cookie 中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><!--more-->

<pre><code>Date.now()  //获取当前时间毫秒数
var dt = new Date() //构造一个实例对象
dt.getTime()    //获取毫秒数
dt.getFullYear() //年
dt.getMonth()   //月（0-11）
dt.getDate()    //日 （0-31）
dt.getHours()   //小时（0-23）
dt.getMinutes() //分钟（0-59）
dt.getSeconds() //秒（0-59）
dt.getDay()     //星期几（0-6）
</code></pre>
<h3 id="如何监听未处理的异常"><a href="#如何监听未处理的异常" class="headerlink" title="如何监听未处理的异常"></a>如何监听未处理的异常</h3><ul>
<li>try…catch<ul>
<li>无法捕捉到语法错误，只能捕捉运行时错误</li>
<li>可以拿到出错的信息(出错的文件，行号，列号)</li>
</ul>
</li>
<li>window.onerror<ul>
<li>由于 try…catch 只能捕获块里面的错误，全局的一些错误可以用 window.onerror 来捕获</li>
</ul>
</li>
</ul>
<h3 id="http-和-https-的区别-1"><a href="#http-和-https-的区别-1" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h3><ul>
<li>http 是一种一种广泛使用的网络协议，是一个客户端和服务器请求和应答的标准。</li>
<li>http 工作在 TCP 协议的 80 端口，https 工作在 TCP 协议的 443 端口</li>
<li>http 协议运行在 TCP 协议之上，所有的传输内容都是明文，https 运行在 SSL/TLS 之上，<br>SSL/TLS 运行在 TCP 之上，所有的传输内容都是经过加密的。</li>
<li>https 是以安全为目标的 http 通道，是 http 的安全版。是 http 加上 SSL 层对传输的信息和 url 做了一些加密处理，更加安全</li>
</ul>
<h3 id="为什么-https-不会被截取信息"><a href="#为什么-https-不会被截取信息" class="headerlink" title="为什么 https 不会被截取信息"></a>为什么 https 不会被截取信息</h3><ul>
<li>完成 TCP 三次同步握手</li>
<li>客户端验证服务器数字证书，通过，进入步骤 3</li>
<li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li>
<li>SSL 安全加密隧道协商完成</li>
<li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；<br>用协商的 hash 算法进行数据完整性保护，保证数据不被篡改</li>
</ul>
<h3 id="浏览器如何缓存"><a href="#浏览器如何缓存" class="headerlink" title="浏览器如何缓存"></a>浏览器如何缓存</h3><ul>
<li>html meta 标签控制缓存<ul>
<li><code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cahce&quot;&gt;</code> //告诉浏览器当前页面不被缓存</li>
</ul>
</li>
<li>http 头信息控制缓存<ul>
<li>Expires ——&gt; 过期时间</li>
<li>Cache-Control 响应头信息(no-cache、no-store、max-age、public)</li>
</ul>
</li>
</ul>
<h3 id="TCP-协议如何保证传输的可靠性"><a href="#TCP-协议如何保证传输的可靠性" class="headerlink" title="TCP 协议如何保证传输的可靠性"></a>TCP 协议如何保证传输的可靠性</h3><ul>
<li>校验和</li>
<li>确认应答 + 序列号</li>
<li>超时重传</li>
<li>流浪控制</li>
<li>拥塞控制</li>
<li>TCP 的连接管理</li>
<li>滑动窗口</li>
</ul>
<h3 id="UDP-amp-TCP-的区别"><a href="#UDP-amp-TCP-的区别" class="headerlink" title="UDP &amp; TCP 的区别"></a>UDP &amp; TCP 的区别</h3><ul>
<li><p>相同点：</p>
<ul>
<li>UDP 协议 和 TCP 协议 都是运输层协议</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li><p>UDP 特点：</p>
<ul>
<li>无连接 —— 知道对端的 IP 和端口号就直接进行传输，不需要建立连接</li>
<li>不可靠 —— 没有确认机制，没有重传机制，即使因为网络故障无法发送到<br>对方，UDP 协议也不会给应用层返回任何错误信息</li>
<li>面向数据报</li>
<li>传输速 度块</li>
</ul>
</li>
<li><p>TCP 特点：</p>
<ul>
<li>面向连接，在客户端和服务器进行交换数据前，必须先在双方之间建立一个<br>TCP 连接</li>
<li>可靠传输，具有确认应答机制、超时重传机制、拥塞控制、流量控制、<br>滑动窗口机制、延迟应答等。</li>
<li>面向字节流</li>
</ul>
</li>
</ul>
</li>
<li><p>UDP 的响应速度优于 TCP，安全性和数据可靠性不如 TCP</p>
</li>
<li><p>UDP 一般用在网络负担非常重，但对响应速度要求高，数据类型都是短消息的情况下</p>
</li>
</ul>
<h3 id="样式导入方式及优先级？"><a href="#样式导入方式及优先级？" class="headerlink" title="样式导入方式及优先级？"></a>样式导入方式及优先级？</h3><ul>
<li><p>引入方式</p>
<ul>
<li>行内样式</li>
<li>内联式</li>
<li>外链式</li>
<li>导入式: @import url(reset.css)</li>
</ul>
</li>
<li><p>各种方式的优先级</p>
<ul>
<li>行内样式 &gt; 外链式 &gt; 内联式 &gt; @import 导入式</li>
</ul>
</li>
</ul>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC(block formatting context)翻译为“块级格式化上下文”，它会生成独立的渲染区域<br>(不影响外面的元素，同时也不受外部元素的影响)，它有一下规则：</p>
<ul>
<li>内部的 box 会在垂直方向上一个接一个的放置。</li>
<li>内部 box 在垂直方向上的距离由 margin 决定，同属一个 BFC 内的相邻 box 会发生 margin 重叠。</li>
<li>BFC 的区域不会与 float box 发生重叠。</li>
<li>计算 BFC 的高度时，浮动元素也参与计算(清除浮动)</li>
</ul>
<p>触发 BFC 的条件：</p>
<ul>
<li>float 属性不为 none</li>
<li>position 为 absolute 或者 fixed</li>
<li>display 为 inline-block、table-cell、table-caption、flex、inline-flex</li>
<li>overflow 不为 visible</li>
</ul>
<h2 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h2><h4 id="for-遍历"><a href="#for-遍历" class="headerlink" title="for 遍历"></a>for 遍历</h4><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var flag;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        flag = 1;
        var newLen = newStr.length;
        for(var j=0; j&lt;newLen; j++)&#123;
            if(str[i] == newStr[j])&#123;
                flag = 0;
                break;
            &#125;
        &#125;
        if(flag)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h4 id="indexOf-方法"><a href="#indexOf-方法" class="headerlink" title="indexOf 方法"></a>indexOf 方法</h4><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(newStr.indexOf(str[i])==-1)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h4 id="search-方法"><a href="#search-方法" class="headerlink" title="search 方法"></a>search 方法</h4><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(newStr.search(str[i])==-1)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h4 id="对象属性法"><a href="#对象属性法" class="headerlink" title="对象属性法"></a>对象属性法</h4><pre><code>function removeRepeatStr(str)&#123;
    var obj = &#123;&#125;;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(!obj[str[i]])&#123;
            newStr = newStr + str[i];
            obj[str[i]] = 1;//注意，这里的1是给对象属性赋值，这个值可以任意取。意思是把每个遍历的字符作为对象属性并赋值保存，保证该属性的唯一性
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h2 id="同步和异步的区别，怎么异步加载-javascript"><a href="#同步和异步的区别，怎么异步加载-javascript" class="headerlink" title="同步和异步的区别，怎么异步加载 javascript?"></a>同步和异步的区别，怎么异步加载 javascript?</h2><!--more-->

<ul>
<li><p>同步模式<br>同步模式，又称阻塞模式，javascript 在默认情况下是会阻塞加载的，当前面的</p>
<p>javascript 请求没有处理和执行完时，会阻止浏览器的后续处理</p>
</li>
<li><p>异步模式<br>异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理</p>
</li>
<li><p>异步加载 JavaScript</p>
<ul>
<li><p>动态添加 script 标签</p>
</li>
<li><p>defer</p>
</li>
<li><p>async</p>
</li>
</ul>
<p>defer 属性和 async 都是属于 script 标签上面的属性，两者都能实现 JavaScript 的</p>
<p>异步加载。不同之处在于：async 在异步加载完成的时候就马上开始执行了，defer 会等到</p>
<p>html 加载完毕之后再执行。</p>
</li>
</ul>
<h2 id="有哪些常见的-meta-标签？"><a href="#有哪些常见的-meta-标签？" class="headerlink" title="有哪些常见的 meta 标签？"></a>有哪些常见的 meta 标签？</h2><!--more-->

<ul>
<li><p>指定文档编码</p>
<ul>
<li><code>&lt;meta charset = &quot;UTF-8&quot;&gt;</code></li>
</ul>
</li>
<li><p>name 属性</p>
<ul>
<li><p><code>1.&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;：在移动设备浏览器上，禁用缩放（zooming） 功能，用户只能滚动屏幕。</code></p>
</li>
<li><p><code>2.&lt;meta name=”description” content=””&gt;：告诉搜索引擎，当前页面的主要内容是xxx。</code></p>
</li>
<li><p><code>3.&lt;meta name=”keywords” content=””&gt;：告诉搜索引擎，当前页面的关键字。</code></p>
</li>
<li><p><code>4.&lt;meta name=”author” content=””&gt;：告诉搜索引擎，标注网站作者是谁。</code></p>
</li>
<li><p><code>5.&lt;meta name=”copyright” content=””&gt;：标注网站的版权信息。</code></p>
</li>
</ul>
</li>
<li><p>http-equiv 属性</p>
<ul>
<li><p><code>1.&lt;meta http-equiv=”Set-Cookie” content=”cookievalue=xxx; expires=Friday,12-Jan-2001 18:18:18 GMT; path=/”&gt;:如果网页过期， 那么存盘的cookie将被删除。必须使用GMT的时间格式。</code></p>
</li>
<li><p><code>2.&lt;meta http-equiv=&#39;expires&#39; content=&#39;时间&#39; &gt;：用于设定网页的到期时间。 一旦网页过期，必须到服务器上重新传输。</code></p>
</li>
<li><p><code>3.&lt;meta http-equiv=”Refresh” content=”5;URL”&gt;：告诉浏览器在 【数字】秒后跳转到【一个网址】</code></p>
</li>
<li><p><code>4.&lt;meta http-equiv=”content-Type” content=”text/html; charset=utf-8″&gt;： 设定页面使用的字符集。</code></p>
</li>
</ul>
<p>-<code>5.&lt;meta http-equiv=”Pragma” content=”no-cache”&gt;：禁止浏览器从本地 计算机的缓存中访问页面内容。访问者将无法脱机浏览。</code></p>
<ul>
<li><p><code>6.&lt;meta http-equiv=”Window-target” content=”_top”&gt;：用来防止 别人在iframe(框架)里调用自己的页面，这也算是一个非常实用的属性。</code></p>
</li>
<li><p><code>7.&lt;meta http-equiv=&#39;X-UA-Compatible&#39; content=&#39;IE=edge,chrome=1&#39;&gt; :强制浏览器按照特定的版本标准进行渲染。但不支持IE7及以下版本。如果是 ie浏览器就用最新的ie渲染，如果是双核浏览器就用chrome内核。</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="什么是-FOUC？如何避免？"><a href="#什么是-FOUC？如何避免？" class="headerlink" title="什么是 FOUC？如何避免？"></a>什么是 FOUC？如何避免？</h2><!--more-->

<h4 id="一、为什么会有白屏和-FOUC-呢？"><a href="#一、为什么会有白屏和-FOUC-呢？" class="headerlink" title="一、为什么会有白屏和 FOUC 呢？"></a>一、为什么会有白屏和 FOUC 呢？</h4><blockquote>
<p>浏览器再渲染的时候没有请求到或请求时间过长造成的，那么浏览器怎么应对的呢？</p>
<ul>
<li>白屏：CSS 全部载入解析完成后渲染展示页面，如果没有加载完，就会出现白屏。</li>
<li>FOUC(Flash of Unstyled Content)无样式内容闪烁：用户定义样式表加载之前浏览器<br>使用默认样式显示文档，用户样式表加载渲染之后，再重新显示文档，造成页面闪烁。</li>
</ul>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><blockquote>
<ul>
<li>使用 link 标签将样式表放在顶部<head>标签中，防止白屏问题出现。</li>
<li>将 JS 放在<body>标签底部，原因如下：<ul>
<li>脚本会阻塞后面内容的呈现</li>
<li>脚本会阻塞其后组件的下载</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="什么是-DOCTYPE-及其作用？"><a href="#什么是-DOCTYPE-及其作用？" class="headerlink" title="什么是 DOCTYPE 及其作用？"></a>什么是 DOCTYPE 及其作用？</h2><ul>
<li><p>DOCTYPE 是 document type（文档类型）的缩写。</p>
<!--more--></li>
<li><p>写法：<!DOCTYPE html>(声明了浏览器就会进入标准模式，按照 W3C 标准渲染页面)</p>
</li>
<li><p>DOCTYPE 的作用：</p>
<ul>
<li>DOCTYPE 是用来声明文档类型和 DTD 规范的，校验文件和代码的合法性。</li>
<li>告诉浏览器通过哪种规范（文档类型，DTD）来解析文档。</li>
</ul>
</li>
<li><p>DTD（document type definition）文档类型定义是一系列的语法规则，用来定义 XML<br>或 HTML 的文件类型。浏览器会根据它来判断文档类型，决定使用哪种协议来解析，以及切换<br>浏览器的模式。</p>
</li>
<li><p>浏览器模式</p>
<p>为了能够很好的显示满足标准的页面，又能最大程度兼容不合法的 HTML，浏览器厂商会提供两种<br>浏览器模式。</p>
<ul>
<li>标准模式：根据 W3C 标准来渲染页面。</li>
<li>混杂模式（兼容模式、怪异模式）：浏览器采用更加宽松、向后兼容的方式来渲染页面。</li>
</ul>
</li>
</ul>
<h2 id="CSS-清除浮动"><a href="#CSS-清除浮动" class="headerlink" title="CSS-清除浮动"></a>CSS-清除浮动</h2><!--more-->

<p><a href="https://segmentfault.com/a/1190000004865198">原文链接</a></p>
<h3 id="什么是-CSS-清除浮动"><a href="#什么是-CSS-清除浮动" class="headerlink" title="什么是 CSS 清除浮动?"></a>什么是 CSS 清除浮动?</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left</span><br><span class="line">或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到</span><br><span class="line">容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行</span><br><span class="line">的CSS处理，就叫CSS清除浮动。</span><br></pre></td></tr></table></figure>

<!--more-->

<h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ul>
<li>方法一：使用带 clear 属性的空元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在浮动元素后使用一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，并在CSS中赋予</span><br><span class="line">.clear&#123;clear:both;&#125;属性即可清理浮动。亦可使用&lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt;</span><br><span class="line">来进行清理。</span><br><span class="line">优点：简单，代码少，浏览器兼容好。</span><br><span class="line">缺点：需要添加大量的无语义的html元素，代码不够优雅，后期不容易维护。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：使用 CSS 的 overflow 属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法三：给浮动的元素的容器添加浮动（不太推荐）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，</span><br><span class="line">不推荐使用。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法四：使用邻接元素处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么都不做，给浮动元素后面的元素添加clear:both属性。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法五：使用 CSS 的：after 伪元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现</span><br><span class="line">元素末尾添加一个看不见的块元素（Block element）清理浮动。</span><br><span class="line"></span><br><span class="line">.clearfix::after&#123;</span><br><span class="line">  content: &quot;020&quot;;</span><br><span class="line">  display: block;</span><br><span class="line">  height: 0;</span><br><span class="line">  clear: both;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Chrome-打开一个页面需要启动多少线程？分别有哪些线程？"><a href="#Chrome-打开一个页面需要启动多少线程？分别有哪些线程？" class="headerlink" title="Chrome 打开一个页面需要启动多少线程？分别有哪些线程？"></a>Chrome 打开一个页面需要启动多少线程？分别有哪些线程？</h2><!--more-->

<pre><code>最新Chrome浏览器包括：一个浏览器(Browser)主线程、一个GPU进程、一个网络(NetWork)
进程、多个渲染进程和多个插件进程
</code></pre>
<ul>
<li><p>线程：</p>
<ul>
<li><p>浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。</p>
</li>
<li><p>渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，<br>排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个<br>Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
</li>
<li><p>GPU 进程：Chrome 刚开始的时候是没有 GPU 进程的，而 GPU 使用的使用初衷是为了实现<br>3D CSS 效果，之后随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 称为<br>浏览器普遍的需求，最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
</li>
<li><p>网络进程：主要负责网页的网络资源加载，之前是作为一个模块运行在浏览器进程里面<br>的，最近才独立出来，称为一个单独的进程。</p>
</li>
<li><p>插件进程：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以<br>保证插件进程崩溃不会对浏览器和页面造成影响。</p>
</li>
</ul>
</li>
</ul>
<h2 id="CommonJS、AMD、CMD-是什么及区别？"><a href="#CommonJS、AMD、CMD-是什么及区别？" class="headerlink" title="CommonJS、AMD、CMD 是什么及区别？"></a>CommonJS、AMD、CMD 是什么及区别？</h2><!--more-->

<ul>
<li>CommonJS 是服务器端 js 模块化的规范，NodeJS 是这种规范的实现，加载模块使用 require 方法，</li>
</ul>
<p>导出使用 exports</p>
<ul>
<li>AMD 和 CMD 都是为了解决浏览器端模块化问题而产生的，AMD 规范对应的库 Require.js,</li>
</ul>
<p>CMD 规范对应的库 Sea.js</p>
<ul>
<li><p>AMD 和 CMD 的区别:</p>
<ul>
<li><p>AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</p>
</li>
<li><p>CMD 推崇就近依赖，只有在用到的某个模块的时候再去 require</p>
</li>
<li><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行，但 RequireJS(AMD)从 2.0 开始，也改为延迟执行</p>
</li>
<li><p>AMD 的 API 默认是一个当多个，CMD 的 API 严格区分，推崇职责单一</p>
</li>
</ul>
</li>
</ul>
<h2 id="js-加载-浏览器加载-时间线"><a href="#js-加载-浏览器加载-时间线" class="headerlink" title="js 加载(浏览器加载)时间线"></a>js 加载(浏览器加载)时间线</h2><pre><code>理论：它是根据js出生的那一刻开始记录的一系列浏览器按照顺序做的事，

就是加载顺序及一些优化
</code></pre>
 <!--more-->

<ul>
<li><p>创建 Document 对象，开始解析 web 页面，这个阶段 document.readyState = ‘loading’</p>
</li>
<li><p>遇见 link 外部 css，创建线程 加载，并继续解析文档</p>
</li>
<li><p>遇见 script 外部 js，并且没有设置 async、defer，浏览器加载，并阻塞，等待 js 加载完成</p>
</li>
</ul>
<p>并执行该脚本，然后继续解析文档</p>
<ul>
<li>遇见 script 外部 js，并且设置了 async、defer，浏览器创建线程 加载，并继续解析文档，对于</li>
</ul>
<p>async 属性的脚本，加载完成后立即执行。（异步加载禁止使用 document.write(),它会清除文档流）</p>
<ul>
<li><p>遇见 img 等，先正常解析 dom 结构，然后浏览器异步加载 src，并继续解析文档</p>
</li>
<li><p>文档解析完成，document.readyState = ‘interactive’</p>
</li>
<li><p>文档解析完成后，所有设置 defer 的脚本会按照顺序执行。（也禁止使用 document.write()）</p>
</li>
<li><p>之后 document 对象触发 DOMContentLoaded 事件，标志程序执行从同步脚本执行阶段，转化为</p>
</li>
</ul>
<p>事件驱动阶段</p>
<ul>
<li>当所有 async 的脚本加载并执行后、img 等加载完成后，document.readyState = ‘complete’,</li>
</ul>
<p>这是 window 对象触发 load 事件。</p>
<ul>
<li>…</li>
</ul>
<h2 id="异步加载-js"><a href="#异步加载-js" class="headerlink" title="异步加载 js"></a>异步加载 js</h2><pre><code>javascript 异步加载的三种方案:
</code></pre>
<ul>
<li>defer 异步加载，但要等到 dom 文档全部解析完成才会被执行，只有 IE 能用，可以将 js 代码写在</li>
</ul>
<p>script 标签内部。</p>
<ul>
<li>async 异步加载，加载完就执行，async 只能加载 外部脚本，不能把 js 写在 script 标签中，执行</li>
</ul>
<p>时也不会阻塞页面。</p>
<ul>
<li>动态创建 script，插入到 dom 中，加载完毕后 callback。<br>简单实例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var script = document.createElement(&#x27;script&#x27;)</span><br><span class="line"></span><br><span class="line">script.type = &#x27;text/javascript&#x27;</span><br><span class="line"></span><br><span class="line">script.src = demo.js</span><br><span class="line"></span><br><span class="line">script.onload = function() &#123; //兼容性很好，除了IE</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.head.appendChild(script)</span><br></pre></td></tr></table></figure>

<p>动态加载函数封装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function asyncLoaded(url,callback)&#123;</span><br><span class="line">    var script = document.createElement(&quot;script&quot;);</span><br><span class="line">//  script.src = url;   假如说网速非常好，直接执行完成了，后面就监听不到状态的改变了</span><br><span class="line">    if(script.readyState)&#123;</span><br><span class="line">        script.onreadystatechange = function()&#123;</span><br><span class="line">            if(script.readyState == &quot;complete&quot; || script.readyState ==&quot;loaded&quot;)&#123;</span><br><span class="line">//  执行某个函数</span><br><span class="line">                callback()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        script.onload = function()&#123;</span><br><span class="line">//  执行某个函数</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = url;    //异步的过程</span><br><span class="line">    document.head.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncLoaded(&#x27;demo.js&#x27;, function()&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="getomputedstyle-和-style-的区别？"><a href="#getomputedstyle-和-style-的区别？" class="headerlink" title="getomputedstyle 和 style 的区别？"></a>getomputedstyle 和 style 的区别？</h2><!--more-->

<ul>
<li><p>getComputedStyle 方法是只读的，只能获取样式，不能设置；而 element.style 能读写。</p>
</li>
<li><p>getComputedStyle 方法获取的是最终应用在元素上的所有 Css 属性样式(即使没有 css 代码)，<br>而 element.style 只能获取元素 style 属性中的 css 样式。</p>
</li>
<li><p>getComputedStyle 可以获取伪元素的样式。</p>
</li>
<li><p>兼容性：getComputedStyle 方法在 IE6~IE8 是不支持的。</p>
</li>
</ul>
<h2 id="什么是-HTML-语义化？"><a href="#什么是-HTML-语义化？" class="headerlink" title="什么是 HTML 语义化？"></a>什么是 HTML 语义化？</h2><!--more-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据内容的结构化，选择合适的标签，便于开发者阅读和写出更优雅的代码的同时利于SEO的优化。</span><br></pre></td></tr></table></figure>

<h2 id="为什么要语义化？"><a href="#为什么要语义化？" class="headerlink" title="为什么要语义化？"></a>为什么要语义化？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；</span><br><span class="line">-  用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；</span><br><span class="line">- 有利于SEO ：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息： 爬虫依赖于</span><br><span class="line">标签来确定上下文和各个关键字的权重；</span><br><span class="line">- 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</span><br><span class="line">- 便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的</span><br><span class="line">团队都遵循这个标准，可以减少差异化。</span><br></pre></td></tr></table></figure>

<h2 id="构建打包优化（webpack-bundle-analyzer-分析各个打包文件）"><a href="#构建打包优化（webpack-bundle-analyzer-分析各个打包文件）" class="headerlink" title="构建打包优化（webpack-bundle-analyzer 分析各个打包文件）"></a>构建打包优化（webpack-bundle-analyzer 分析各个打包文件）</h2><p>速度优化:</p>
<ul>
<li><p>exclude/include</p>
<p>通过 exclude、include 配置来确保转译尽可能少的文件</p>
</li>
<li><p>cache</p>
</li>
<li><p>thread-loader</p>
</li>
<li><p>resolve.alias</p>
<p>webpack 直接根据对应别名的目录查找模块，减少搜索时间</p>
</li>
<li><p>模块懒加载</p>
</li>
<li><p>externals + CDN</p>
</li>
</ul>
<h2 id="V8-垃圾回收机制"><a href="#V8-垃圾回收机制" class="headerlink" title="V8 垃圾回收机制"></a>V8 垃圾回收机制</h2><ul>
<li><p>V8 会把堆分为新生代和老生代</p>
</li>
<li><p>新生代（副垃圾回收器）</p>
<ul>
<li>存放生存时间短的对象</li>
<li>通常只支持 1 ～ 8M 的容量</li>
<li>分为对象区和空闲区<ul>
<li>对对象区域中的垃圾做标记，标记完成进入垃圾清理阶段，把存活的对象复制到空闲区域，把这些对象有序的排列起来</li>
<li>完成复制后，对象区和空闲区进行角色翻转</li>
</ul>
</li>
</ul>
</li>
<li><p>老生代（主垃圾回收器）</p>
<ul>
<li>对象存放生存时间久</li>
<li>对象占用空间大</li>
</ul>
</li>
<li><p>副垃圾回收器采用对象晋升策略：移动那些经过两次垃圾回收依然还存活的对象到老生代中</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">V8实现了精准式GC，GC算法采用了分代式垃圾回收机制。因此，V8将内存（堆）分为新生代和老生代两部分。</span><br><span class="line"></span><br><span class="line">新生代算法</span><br><span class="line">新生代中的对象一般存活时间较短，使用Scavenge GC算法。</span><br><span class="line">在新生代空间中，内存空间分为两部分，分别为From空间和To空间。</span><br><span class="line">在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。</span><br><span class="line">新分配的对象会被放入From空间中，当From空间被占满时，新生代GC就会启动。</span><br><span class="line">算法会检查From空间中存活的对象并复制到To空间中，如果失活的对象就会销毁。</span><br><span class="line">当复制完成后将From空间和To空间互换，这样GC就结束了。</span><br><span class="line"></span><br><span class="line">老生代算法</span><br><span class="line">老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是 标记清除算法 和 标记压缩算法。</span><br><span class="line">在将算法前，先来说下什么情况下对象会出现在老生代空间中：</span><br><span class="line">● 新生代中的对象是否已经经历过一次Scavenge算法，如果经历过的话，会将对象从新生代空间移到老生代空间。</span><br><span class="line">● To空间的对象占比大于25%。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</span><br><span class="line"></span><br><span class="line">以下情况会启动 标记清除算法：</span><br><span class="line">● 某一空间没有分块的时候</span><br><span class="line">● 空间中对象超过一定限制</span><br><span class="line">● 空间不能保证新生代中的对象移动时</span><br><span class="line"></span><br><span class="line">清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动 压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清除不需要的内存。</span><br></pre></td></tr></table></figure>

<h2 id="浏览器在渲染时遇到-javascript-文件要怎么处理？"><a href="#浏览器在渲染时遇到-javascript-文件要怎么处理？" class="headerlink" title="浏览器在渲染时遇到 javascript 文件要怎么处理？"></a>浏览器在渲染时遇到 javascript 文件要怎么处理？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt; 中没有 defer 或 async ，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</span><br><span class="line">&lt;script&gt; 中有 async 属性表示异步执行引入的 JavaScript ，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</span><br><span class="line">&lt;script&gt; 中有 defer 属性表示延迟执行引入的 JavaScript ，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</span><br><span class="line">有 defer 属性的 &lt;script&gt; 相比普通 &lt;script&gt; ，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。 在加载多个JS脚本的时候， async 是无顺序的加载，而 defer 是有顺序的加载。</span><br></pre></td></tr></table></figure>

<h2 id="如何处理-TCP-的粘包"><a href="#如何处理-TCP-的粘包" class="headerlink" title="如何处理 TCP 的粘包?"></a>如何处理 TCP 的粘包?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发生TCP粘包或拆包有很多原因，现列出常见的几点：</span><br><span class="line"></span><br><span class="line">要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</span><br><span class="line">待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</span><br><span class="line">要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</span><br><span class="line">接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关键点：如何给每个数据包添加边界信息</span><br><span class="line"></span><br><span class="line">发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</span><br><span class="line"></span><br><span class="line">发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</span><br><span class="line"></span><br><span class="line">可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</span><br></pre></td></tr></table></figure>

<h2 id="请说说-HTTPS-的握手过程？"><a href="#请说说-HTTPS-的握手过程？" class="headerlink" title="请说说 HTTPS 的握手过程？"></a>请说说 HTTPS 的握手过程？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTPS的握手过程主要包括以下步骤：</span><br><span class="line"></span><br><span class="line">  客户端向服务端发送一个加密过的客户端随机数和客户端支持的加密算法列表，同时请求建立SSL/TLS连接。</span><br><span class="line"></span><br><span class="line">  服务端在接收到请求后，向客户端发送一个包含服务端随机数、服务器支持的加密算法列表以及服务器的数字证书的报文。</span><br><span class="line"></span><br><span class="line">  客户端在接收到服务器的响应后，会对证书进行校验。如果证书被认为是合法的，那么客户端将使用证书中包含的公钥对一个随机数进行加密，并将加密后的随机数发送给服务端。</span><br><span class="line"></span><br><span class="line">  服务端在接收到客户端的响应后，使用私钥对加密的随机数进行解密，得到客户端生成的随机数。同时，服务端也会生成一个加密的会话密钥，并使用客户端和服务端的随机数以及协商出的加密算法对该密钥进行加密，最后将加密后的密钥发送给客户端。</span><br><span class="line"></span><br><span class="line">  客户端接收到服务端发送的加密的会话密钥后，使用服务端公布的公钥进行解密，得到原始的会话密钥。</span><br><span class="line"></span><br><span class="line">  客户端和服务端都会使用会话密钥进行加密和解密，从而实现安全的通信。</span><br><span class="line"></span><br><span class="line">  这个过程中，客户端和服务端会进行多次来回的通信，以建立安全的SSL/TLS连接。其中数字证书的校验和会话密钥的生成都是关键步骤，它们保证了通信的安全性。</span><br></pre></td></tr></table></figure>

<h2 id="请说说什么是数字证书？它有什么作用"><a href="#请说说什么是数字证书？它有什么作用" class="headerlink" title="请说说什么是数字证书？它有什么作用?"></a>请说说什么是数字证书？它有什么作用?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数字证书是一种加密技术，用于验证在线交互中的身份和信息安全性。它是由可信任的第三方机构（例如数字证书颁发机构）颁发的一份电子文档，其中包含了一些加密信息，如公钥、数字签名等。数字证书的作用是确保通信双方的身份和数据的完整性和保密性。</span><br><span class="line"></span><br><span class="line">在使用数字证书进行加密通信时，服务端会向证书颁发机构申请一份数字证书。数字证书包含了服务端的公钥，以及一些描述服务端身份的信息，例如域名、组织名称等。客户端在与服务端建立连接时，会向服务端请求数字证书，并验证证书的真实性和合法性。如果验证成功，客户端就可以使用服务端的公钥加密数据并发送给服务端了。同时，服务端也可以使用客户端的公钥进行数据的加密和验证。这样就可以确保通信过程中的数据不被窃听或篡改。</span><br><span class="line"></span><br><span class="line">数字证书的使用广泛，特别是在网站安全和电子商务领域。它可以用来验证网站的真实性和合法性，确保网站访问过程中的信息安全。此外，数字证书还可以用于文件签名、电子邮件加密等其他领域。</span><br></pre></td></tr></table></figure>

<h2 id="使用-git-commit-后，如何修改-commit-的信息？"><a href="#使用-git-commit-后，如何修改-commit-的信息？" class="headerlink" title="使用 git commit 后，如何修改 commit 的信息？"></a>使用 git commit 后，如何修改 commit 的信息？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<h2 id="在-less-中如何将-px-转换为-vw？"><a href="#在-less-中如何将-px-转换为-vw？" class="headerlink" title="在 less 中如何将 px 转换为 vw？"></a>在 less 中如何将 px 转换为 vw？</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.pxToVW</span> (<span class="keyword">@px</span>, @<span class="attribute">attr</span>: <span class="attribute">width</span>) &#123;</span><br><span class="line">  <span class="keyword">@vw</span>: (@px / <span class="number">750</span>) * <span class="number">100</span>;</span><br><span class="line">  @&#123;attr&#125;:~<span class="string">&quot;@&#123;vw&#125;vw&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.title</span>&#123;</span><br><span class="line">	<span class="selector-class">.pxToVW</span>(<span class="number">300</span>,<span class="attribute">width</span>)</span><br><span class="line">	<span class="selector-class">.pxToVW</span>(<span class="number">32</span>,<span class="attribute">font-size</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里是指，设计图是按照<span class="number">750px</span>的宽度进行设计的,</span><br><span class="line">title 中所有的值都是直接取的设计图的值，通过函数进行统一换算</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3源码调试</title>
    <url>/2022/01/02/vue3%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="vue3-源码调试步骤"><a href="#vue3-源码调试步骤" class="headerlink" title="vue3 源码调试步骤"></a>vue3 源码调试步骤</h2><span id="more"></span>

<h3 id="clone-项目"><a href="#clone-项目" class="headerlink" title="clone 项目"></a>clone 项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/vuejs/vue-next.git</span><br></pre></td></tr></table></figure>

<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn --ignore-scripts</span><br></pre></td></tr></table></figure>

<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改<strong>package.json</strong>中的 scripts 下 dev 的配置，后面添加 <em>–sourcemap</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;node scripts/dev.js&quot;</span><br><span class="line">// ⬇</span><br><span class="line">&quot;dev&quot;: &quot;node scripts/dev.js --sourcemap&quot;</span><br></pre></td></tr></table></figure>

<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn run dev</span><br></pre></td></tr></table></figure>

<p>当终端出现<strong>waiting for changes…<strong>表示编译成功，可以</strong>ctrl+c</strong>结束进程查看源码了</p>
<p>打包完成之后，examples 下面的文件会引用 dist 文件下的文件（dist 文件是我们刚才编译后生成的文件）<br><img src="../images/md_img/vue3-dist.jpg" alt="vue3-dist"></p>
<h3 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h3><p>我们直接在<strong>package/vue/examples</strong>目录下添加<strong>demo/test.html</strong>文件，并引用**../../dist/vue.global.js**文件就可以使用 vue3 了，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;../../dist/vue.global.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;template id=&quot;foo&quot;&gt;</span><br><span class="line">      &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      const App = &#123;</span><br><span class="line">        template: &#x27;#foo&#x27;,</span><br><span class="line">        data: function () &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            name: &#x27;foolishmax&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Vue.createApp(App).mount(&#x27;#app&#x27;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来在浏览器中打开就可以进行 vue3 的代码调试了。</p>
<p><img src="../images/md_img/vue3-debugger.jpg" alt="vue3-debugger"></p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>面试优质手写题</title>
    <url>/2022/03/31/%E9%9D%A2%E8%AF%95%E4%BC%98%E8%B4%A8%E6%89%8B%E5%86%99%E9%A2%98/</url>
    <content><![CDATA[<h1 id="手写部分"><a href="#手写部分" class="headerlink" title="手写部分"></a>手写部分</h1><span id="more"></span>

<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// indexOf</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="title function_">indexOf</span>(arr[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(arrp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// includes</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.<span class="title function_">includes</span>(item)) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用filter</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item, index, array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array.<span class="title function_">indexOf</span>(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用Es6中的Set数据结构(扩展运算符)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = (<span class="params">arr</span>) =&gt; [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.form 方法将set结构转换为数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = (<span class="params">arr</span>) =&gt; <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br></pre></td></tr></table></figure>

<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// let res = arr.flat(Infinity)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let res = JSON.parse(&quot;[&quot;+JSON.stringify(arr).replace(/\[|\]/g,&quot;&quot;) + &quot;]&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatArr</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accu, curr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> accu.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(curr) ? <span class="title function_">flatArr</span>(curr) : curr);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatArr</span>(arr));</span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只考虑对象类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObj[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.assign()</span></span><br><span class="line"><span class="comment">// arr.slice(0)</span></span><br><span class="line"><span class="comment">// arr.concat()</span></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只考虑普通对象属性，不考虑内置对象和函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObj[key] =</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span> ? <span class="title function_">deepClone</span>(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON.parse(JSON.stringify())</span></span><br><span class="line"><span class="comment">// lodash: _.cloneDeep()</span></span><br></pre></td></tr></table></figure>

<h2 id="实现一个-compose-组合-函数"><a href="#实现一个-compose-组合-函数" class="headerlink" title="实现一个 compose(组合)函数"></a>实现一个 compose(组合)函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!fn.<span class="property">length</span>) <span class="keyword">return</span> <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line">    <span class="keyword">if</span>(fn.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> fn[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accu, curr</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">accu</span>(<span class="title function_">curr</span>(...args)) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn4</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">compose</span>(fn1, fn2, fn3, fn4);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">res</span>(<span class="number">5</span>)); <span class="comment">// 5+4+3+2+1=15</span></span><br></pre></td></tr></table></figure>

<h2 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">assign</span> = <span class="keyword">function</span> (<span class="params">target, ...source</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (target === <span class="literal">null</span> || target === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot convert undefined or null to object&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="title class_">Object</span>(target);</span><br><span class="line"></span><br><span class="line">  source.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">          result[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索联想，用户在不断输入时，用防抖来节约请求资源</span></span><br><span class="line"><span class="comment">// window触发resize的时候</span></span><br></pre></td></tr></table></figure>

<h2 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = +<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">      previous = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标不断点击触发，可以使其单位时间内只触发以此</span></span><br><span class="line"><span class="comment">// 监听滚动事件</span></span><br><span class="line"><span class="comment">// 防止高频点击提交</span></span><br></pre></td></tr></table></figure>

<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 需要柯里化的函数fn，也可以支持初始参数的传入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//参数缓存在args里面,合并上次参数和本次参数</span></span><br><span class="line">    args = [...args, ...<span class="variable language_">arguments</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数个数，不够继续递归</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &lt; fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">curry</span>(fn, ...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//参数足够返回函数执行结果</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">curry</span>(bar);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>), <span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>), <span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<h2 id="如何把字符串中大小写取反"><a href="#如何把字符串中大小写取反" class="headerlink" title="如何把字符串中大小写取反"></a>如何把字符串中大小写取反</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;LiBoShi&quot;</span>;</span><br><span class="line"></span><br><span class="line">str = str.<span class="title function_">replace</span>(<span class="regexp">/[a-zA-Z]/g</span>, <span class="function">(<span class="params">content</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> content.<span class="title function_">toUpperCase</span>() === content</span><br><span class="line">    ? content.<span class="title function_">toLowerCase</span>()</span><br><span class="line">    : content.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="从-S-中查找-T-字符串，找到返回索引值，没有则返回-1，类似-indexOf"><a href="#从-S-中查找-T-字符串，找到返回索引值，没有则返回-1，类似-indexOf" class="headerlink" title="从 S 中查找 T 字符串，找到返回索引值，没有则返回-1，类似 indexOf"></a>从 S 中查找 T 字符串，找到返回索引值，没有则返回-1，类似 indexOf</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myIndexOf</span>(<span class="params">T</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="variable language_">this</span>.<span class="property">length</span> - T.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">substr</span>(i, T.<span class="property">length</span>) === T) &#123;</span><br><span class="line">      <span class="keyword">return</span> (index = i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myIndexOf</span> = myIndexOf;</span><br><span class="line"><span class="comment">// 正则方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myIndexOf</span>(<span class="params">T</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(T);</span><br><span class="line">  <span class="keyword">let</span> res = reg.<span class="title function_">exec</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res === <span class="literal">null</span> ? -<span class="number">1</span> : res.<span class="property">index</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">  ctx[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = ctx[fn](...args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> ctx[fn];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">desc</span>: <span class="keyword">function</span> (<span class="params"><span class="keyword">from</span>, to</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>来自<span class="subst">$&#123;<span class="keyword">from</span>&#125;</span>去往<span class="subst">$&#123;to&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lbs&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">desc</span>.<span class="title function_">myCall</span>(person, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context, args = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">  ctx[fn] = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> res = ctx[fn](...args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> ctx[fn];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">content, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">newFn</span>(<span class="params">...newFnArgs</span>) &#123;</span><br><span class="line">    <span class="comment">// 检测 New</span></span><br><span class="line">    <span class="comment">// 如果当前函数的this指向的是构造函数中的this 则判定为new 操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> newFn) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">fn</span>(...args, ...newFnArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">myApply</span>(context, [...args, ...newFnArgs]);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 通过left.<span class="property">__proto__</span>.<span class="property">__proto__</span>这种方式从下往上的获取原型对象</span><br><span class="line"><span class="number">2.</span> 通过<span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)的实例是没有原型链</span><br><span class="line"><span class="number">3.</span> 有原型链的实例的尽头都是<span class="title class_">Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">instanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!left.<span class="property">__proto__</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(right === <span class="title class_">Object</span> || left.<span class="property">__proto__</span> === right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">instanceof</span>(left.<span class="property">__proto__</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-Object-is"><a href="#手写-Object-is" class="headerlink" title="手写 Object.is"></a>手写 Object.is</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">is</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="comment">// x,y都为0，但是1 / +0 = +Infinity,1 / -0 = -Infinity 是不一样的</span></span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//NaN === NaN = false是不对的，做一个拦截操作</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">method, url, headers, body</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> req = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      req = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      req = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.<span class="title function_">open</span>(method, url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> headers) &#123;</span><br><span class="line">      req.<span class="title function_">setRequestHeader</span>(key, headers[key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.<span class="title function_">onreadystatechange</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (req.<span class="property">readystate</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; req.<span class="property">status</span> &lt;= <span class="number">300</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(req.<span class="property">responseText</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(req);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    req.<span class="title function_">send</span>(body);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行async函数，返回的都是Promise对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">test1</span>(), <span class="title function_">test2</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.then 成功的情况对应的就是await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> p;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test3</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.catch 异常对应 try...catch</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test4</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;异常了&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> p;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test4</span>();</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span> (<span class="params">fn, toThis</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">const</span> _this = toThis || <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = fn.<span class="title function_">call</span>(_this, arr[i], i, arr);</span><br><span class="line">    result.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写-promise"><a href="#手写-promise" class="headerlink" title="手写 promise"></a>手写 promise</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise1</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">REJECTED</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Promise</span>.<span class="property">PENDING</span>; <span class="comment">//默认状态，进行中</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>; <span class="comment">//成功值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span>; <span class="comment">// 失败原因</span></span><br><span class="line">    <span class="comment">// 解决异步问题</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Promise</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Promise</span>.<span class="property">FULFILLED</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> <span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">value</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Promise</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Promise</span>.<span class="property">REJECTED</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> <span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">reason</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      onFulfilled = <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      onRejected = <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">reason</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise1</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Promise</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise1</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">parse</span>(<span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>), resolve, reject);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise1</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">parse</span>(<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">value</span>), resolve, reject);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Promise</span>.<span class="property">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise1</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">parse</span>(<span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>), resolve, reject);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Promise</span>.<span class="property">REJECTED</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise1</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">parse</span>(<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>), resolve, reject);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">parse</span>(<span class="params">result, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise1</span>) &#123;</span><br><span class="line">        result.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise1</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise1</span>) &#123;</span><br><span class="line">        value.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise1</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise1</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.<span class="property">length</span> === promises.<span class="property">length</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise1</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aaa = <span class="keyword">new</span> <span class="title class_">Promise1</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;lbs&quot;</span>);</span><br><span class="line">  <span class="comment">//     reject(&#x27;error&#x27;)</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">aaa.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aaa);</span><br></pre></td></tr></table></figure>

<h2 id="手写-event-bus"><a href="#手写-event-bus" class="headerlink" title="手写 event bus"></a>手写 event bus</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">maxListeners</span> = maxListeners || <span class="title class_">Infinity</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">event, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cbs = <span class="variable language_">this</span>.<span class="property">events</span>[event];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;没有这个事件函数&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cbs.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">event, cb</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">maxListeners</span> !== <span class="title class_">Infinity</span> &amp;&amp;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="property">length</span> &gt;= <span class="variable language_">this</span>.<span class="property">maxListeners</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;当事件超过了最大监听数&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">push</span>(cb);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">once</span>(<span class="params">event, cb</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(event, fn);</span><br><span class="line">      cb.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(event, func);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">event, cb</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cb) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event] = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event] = <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item !== cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;lbs&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;lbs&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">//寄生式组合继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = obj.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, obj);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = obj.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object.create()</span></span><br><span class="line"><span class="comment">// 方法创建一个新对象，使用现有的对象来提供新创建对象的__proto__</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">Student</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;lbs&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student);</span><br></pre></td></tr></table></figure>

<h2 id="createElement-手写"><a href="#createElement-手写" class="headerlink" title="createElement 手写"></a>createElement 手写</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolFor = <span class="title class_">Symbol</span>.<span class="property">for</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REACT_ELEMENT_TYPE</span> = <span class="title function_">symbolFor</span>(<span class="string">&quot;react.element&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RESERVED_PROPS</span> = &#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">ref</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">__self</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">__source</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, config, children</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config !== <span class="literal">null</span>) &#123;</span><br><span class="line">    key = config.<span class="property">key</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable constant_">RESERVED_PROPS</span>.<span class="title function_">hasOwnProperty</span>(propName)) &#123;</span><br><span class="line">      props[propName] = config[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> childrenLength = <span class="variable language_">arguments</span>.<span class="property">length</span> - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.<span class="property">children</span> = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childArray = <span class="title class_">Array</span>(childrenLength);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = <span class="variable language_">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    props.<span class="property">children</span> = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_ELEMENT_TYPE</span>,</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    props,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写正则，验证一个-6-～-16-位的字符串，必须同时包含大小写字母和数字"><a href="#编写正则，验证一个-6-～-16-位的字符串，必须同时包含大小写字母和数字" class="headerlink" title="编写正则，验证一个 6 ～ 16 位的字符串，必须同时包含大小写字母和数字"></a>编写正则，验证一个 6 ～ 16 位的字符串，必须同时包含大小写字母和数字</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">正向预查 ？= 必须</span><br><span class="line">反向预查 ？！必须不</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?!^[a-zA-Z]+$)(?!^[0-9]+$)(?!^[a-z0-9]+$)(?!^[A-Z0-9]+$)^[a-zA-Z0-9]&#123;6,16&#125;$/</span>;</span><br><span class="line"></span><br><span class="line">补充：数字、字母、下划线组成字符串，必须有_</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?=_)\w/</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?!^[a-zA-Z0-9]+$)^\w&#123;1,10&#125;$/</span>; 限制<span class="number">1</span>-<span class="number">10</span>位</span><br></pre></td></tr></table></figure>

<h2 id="获取所有属性为-name，值为-value-的元素集合"><a href="#获取所有属性为-name，值为-value-的元素集合" class="headerlink" title="获取所有属性为 name，值为 value 的元素集合"></a>获取所有属性为 name，值为 value 的元素集合</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则\b单词边界</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getElements</span>(<span class="params">property, value</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">  elements = <span class="title class_">Array</span>.<span class="title function_">from</span>(elements);</span><br><span class="line">  elements.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当前元素property对应的值</span></span><br><span class="line">    <span class="keyword">let</span> itemValue = item.<span class="title function_">getAttribute</span>(propertype);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">&quot;class&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`\b<span class="subst">$&#123;value&#125;</span>\b`</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (reg.<span class="title function_">test</span>(itemValue)) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (itemValue === value) &#123;</span><br><span class="line">      arr.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="英文字母汉字组成的字符串，用正则给英文单词前后加空格"><a href="#英文字母汉字组成的字符串，用正则给英文单词前后加空格" class="headerlink" title="英文字母汉字组成的字符串，用正则给英文单词前后加空格"></a>英文字母汉字组成的字符串，用正则给英文单词前后加空格</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;中国hello你好&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\b[a-z]+\b/gi</span>;</span><br><span class="line"></span><br><span class="line">str = str</span><br><span class="line">  .<span class="title function_">replace</span>(reg, <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">` <span class="subst">$&#123;value&#125;</span> `</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">trim</span>(); <span class="comment">// 去除首尾空格</span></span><br></pre></td></tr></table></figure>

<h2 id="js-实现斐波那契数列的几种方法"><a href="#js-实现斐波那契数列的几种方法" class="headerlink" title="js 实现斐波那契数列的几种方法"></a>js 实现斐波那契数列的几种方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.尾递归(每次调用都在收集结果，避免了线性递归不收集结果只依次展开消耗内存的坏处)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n, res1 = <span class="number">1</span>, res2 = <span class="number">1</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> res2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>, res2, res1 + res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> num2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum = num1 + num2;</span><br><span class="line">    num1 = num2;</span><br><span class="line">    num2 = sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;输入的数字不能小于0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      arr[i] = arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发加载"><a href="#并发加载" class="headerlink" title="并发加载"></a>并发加载</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">limitLoad</span>(<span class="params">urls, handler, limit</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sequence = [].<span class="title function_">concat</span>(urls);</span><br><span class="line">  <span class="keyword">let</span> promises = [];</span><br><span class="line"></span><br><span class="line">  promises = sequence.<span class="title function_">splice</span>(<span class="number">0</span>, limit).<span class="title function_">map</span>(<span class="function">(<span class="params">url, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">handler</span>(url).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>(promises);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sequence.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    p = p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      promises[res] = <span class="title function_">handler</span>(sequence[i]).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(promises);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>(promises);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadImg</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//             console.log(url.info + &#x27;---OK!!!&#x27;)</span></span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, url.<span class="property">time</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> urls = [</span><br><span class="line">  &#123; <span class="attr">info</span>: <span class="number">1</span>, <span class="attr">time</span>: <span class="number">2000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">info</span>: <span class="number">2</span>, <span class="attr">time</span>: <span class="number">1000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">info</span>: <span class="number">3</span>, <span class="attr">time</span>: <span class="number">3000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">info</span>: <span class="number">4</span>, <span class="attr">time</span>: <span class="number">4000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">info</span>: <span class="number">5</span>, <span class="attr">time</span>: <span class="number">5000</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="title function_">limitLoad</span>(urls, loadImg, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="前端内存处理"><a href="#前端内存处理" class="headerlink" title="前端内存处理"></a>前端内存处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 内存的生命周期</span><br><span class="line">    内存分配：声明变量、函数对象的时候，js会自动分配内存</span><br><span class="line">    内存使用</span><br><span class="line">    内存回收</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> js中的垃圾回收机制</span><br><span class="line">    引用计数：缺点循环引用无法清除</span><br><span class="line">    标记清除</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 常见内存泄漏</span><br><span class="line">    全局变量（记得手动回收）</span><br><span class="line">    未被清除的定时器</span><br><span class="line">    闭包</span><br><span class="line">    dom的引用</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 怎么避免内存泄漏</span><br><span class="line">    减少不必要的全局变量</span><br><span class="line">    使用完数据，及时解除引用</span><br><span class="line"></span><br><span class="line">实现sizeOf，传入object，计算其所占字节大小</span><br><span class="line"><span class="attr">number</span>: <span class="number">8</span> 字节</span><br><span class="line"><span class="attr">string</span>: <span class="number">2</span> 字节</span><br><span class="line">boolean; <span class="number">4</span> 字节</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sizeOfObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = keys[i];</span><br><span class="line">        bytes += <span class="title function_">calculator</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj[key] !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.<span class="title function_">has</span>(obj[key])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            seen.<span class="title function_">add</span>(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes += <span class="title function_">calculator</span>(obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculator</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> objType = <span class="keyword">typeof</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(objType) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> obj.<span class="property">length</span> * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;object&#x27;</span>: &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj.<span class="title function_">map</span>(calculator).<span class="title function_">reduce</span>(<span class="function">(<span class="params">accu, curr</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> accu + curr</span><br><span class="line">                &#125;, <span class="number">0</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">sizeOfObject</span>(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数据结构就是在计算机中存储和组织数据的方式。</p>
<p>算法（Algorithm）解决问题的逻辑或步骤</p>
<h2 id="栈-封装"><a href="#栈-封装" class="headerlink" title="栈(封装)"></a>栈(封装)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Stack</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">  <span class="comment">// 1. 将元素压入栈</span></span><br><span class="line">  <span class="title class_">Stack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 2.从栈中取出元素</span></span><br><span class="line">  <span class="title class_">Stack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 3.查看一下栈顶元素</span></span><br><span class="line">  <span class="title class_">Stack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 4.判断栈是否为空</span></span><br><span class="line">  <span class="title class_">Stack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isEmpty</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 5.获取栈中元素个数</span></span><br><span class="line">  <span class="title class_">Stack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">size</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">item</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 6. toString方法</span></span><br><span class="line">  <span class="title class_">Stack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      res += <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span> `</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例：将十进制转换成二进制</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dec2bin</span>(<span class="params">decimalNumber</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">  <span class="keyword">let</span> binary = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (decimalNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    stack.<span class="title function_">push</span>(decimalNumber % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    decimalNumber = <span class="title class_">Math</span>.<span class="title function_">floor</span>(decimalNumber / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!stack.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    binary += stack.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> binary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平衡括号问题"><a href="#平衡括号问题" class="headerlink" title="平衡括号问题"></a>平衡括号问题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">  <span class="keyword">const</span> open = <span class="string">&quot;&#123;[(&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> close = <span class="string">&quot;&#125;])&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> balanced = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; str.<span class="property">length</span> &amp;&amp; balanced) &#123;</span><br><span class="line">    <span class="keyword">if</span> (open.<span class="title function_">includes</span>(str[index])) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(str[index]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> top = stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (open.<span class="title function_">indexOf</span>(top) === close.<span class="title function_">indexOf</span>(str[index])) &#123;</span><br><span class="line">        balanced = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        balanced = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (balanced &amp;&amp; stack.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&quot;&#123;([][])&#125;&quot;</span>);</span><br><span class="line"><span class="title function_">check</span>(<span class="string">&quot;&#123;[(])&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseList</span>(<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.<span class="property">next</span> === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="title function_">reverseList</span>(head.<span class="property">next</span>);</span><br><span class="line"></span><br><span class="line">  head.<span class="property">next</span>.<span class="property">nexd</span> = head;</span><br><span class="line">  head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">elements, value, _start, _end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> end = _end || elements.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> start = _start || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> povitIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((start + end) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (elements[povitIndex] === value) &#123;</span><br><span class="line">    <span class="keyword">return</span> povitIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (value &lt; elements[povitIndex]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">binarySearch</span>(elements, value, <span class="number">0</span>, povitIndex - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">binarySearch</span>(elements, value, povitIndex + <span class="number">1</span>, end);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">elements</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (elements.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> elements;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(elements.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> [pivot] = elements.<span class="title function_">splice</span>(pivotIndex, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> left = [];</span><br><span class="line">  <span class="keyword">let</span> right = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elements[i] &lt; pivot) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(elements[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(elements[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>([pivot], <span class="title function_">quickSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> elements = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">quickSort</span>(elements));</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">elements</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> elementLength = elements.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elementLength - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; elementLength - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elements[j] &gt; elements[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = elements[j];</span><br><span class="line">        elements[j] = elements[j + <span class="number">1</span>];</span><br><span class="line">        elements[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> elements = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">bubbleSort</span>(elements);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(elements)</span></span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//满二叉树：每层节点数都达到最大值，第n层节点数为2^(n - 1),总节点数为2^n -1(2的n次方减一)</span></span><br><span class="line"><span class="comment">//完全二叉树：除最后一层外，其他各层节点数都达到最大个数，最后一层所有节点集中在最左边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入前比较</span></span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">node, newNode</span>) &#123;</span><br><span class="line">    <span class="comment">// 右侧插入</span></span><br><span class="line">    <span class="keyword">if</span> (newNode.<span class="property">value</span> &gt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode.<span class="property">value</span> &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      <span class="comment">// 左侧插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">preOrderTraversalNode</span>(<span class="params">node, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">callback</span>(node.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraversalNode</span>(node.<span class="property">left</span>, callback);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraversalNode</span>(node.<span class="property">right</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先序遍历</span></span><br><span class="line">  <span class="title function_">preOrderTraversal</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inOrderTraversalNode</span>(<span class="params">node, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderTraversalNode</span>(node.<span class="property">left</span>, callback);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">callback</span>(node.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderTraversalNode</span>(node.<span class="property">right</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="title function_">inOrderTraversal</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">postOrderTraversalNode</span>(<span class="params">node, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraversalNode</span>(node.<span class="property">left</span>, callback);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraversalNode</span>(node.<span class="property">right</span>, callback);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">callback</span>(node.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="title function_">postOrderTraversal</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//最大值</span></span><br><span class="line">  <span class="title function_">max</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">while</span> (node.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最小值</span></span><br><span class="line">  <span class="title function_">min</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">while</span> (node.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找指定值是否存在</span></span><br><span class="line">  <span class="title function_">search</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">        node = node.<span class="property">left</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node.<span class="property">value</span>) &#123;</span><br><span class="line">        node = node.<span class="property">right</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bst = <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line"></span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">3</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">2</span>);</span><br><span class="line">bst.<span class="title function_">insert</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bst.preOrderTraversal((nodeValue) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(nodeValue)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bst.inOrderTraversal((nodeValue) =&gt;&#123;</span></span><br><span class="line"><span class="comment">//     console.log(nodeValue)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bst.postOrderTraversal((nodeValue) =&gt;&#123;</span></span><br><span class="line"><span class="comment">//     console.log(nodeValue)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(bst.max())</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bst.<span class="title function_">search</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bst);</span><br></pre></td></tr></table></figure>

<h2 id="翻转链表-1"><a href="#翻转链表-1" class="headerlink" title="翻转链表"></a>翻转链表</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.<span class="property">next</span> === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> res = <span class="title function_">reverseList</span>(head.<span class="property">next</span>);</span><br><span class="line"></span><br><span class="line">  head.<span class="property">next</span>.<span class="property">next</span> = head;</span><br><span class="line">  head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cur === <span class="literal">null</span> || cur.<span class="property">next</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="keyword">const</span> t = cur.<span class="property">next</span>;</span><br><span class="line">    cur.<span class="property">next</span> = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cur.next = null</span></span><br><span class="line">    <span class="comment">// cur.next.next = cur</span></span><br><span class="line">    <span class="comment">// cur = cur.nexxt</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="算法-1-Two-Sum"><a href="#算法-1-Two-Sum" class="headerlink" title="算法 1: Two Sum"></a>算法 1: Two Sum</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">example</span>:</span><br><span class="line">given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">because num[<span class="number">0</span>] + num[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">twoSum</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> complement = target - nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(complement)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [map.<span class="title function_">get</span>(complement), i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(nums[i], i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>装箱：基本类型到引用类型的一个转换<br>拆箱：将引用类型到基本类型的转换（toPrimitive）</p>
<p>编码和解码：<br>escape(str) unescape(str)<br>encodeURI() decodeURI()<br>encodeURIComponent() decodeURIComponent()<br>btoa() atob()</p>
<p>回流：相当与刷新页面<br>重绘： 不刷新，动态更新内容<br>重绘不一定引起回流，回流一定引起重绘</p>
<h2 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h2><pre><code>1. 常见的sort打乱数组的方法

function shuffle(arr) &#123;
   return arr.sort (function () &#123;
        return Math.random() - 0.5
    &#125;)
&#125;
var arr = [1,2,3,4,5,6,7]
shuffle(arr)

更加简洁的ES6写法

function shuffle(arr) &#123;
    return arr.sort(() =&gt; Math.random() - 0.5)
&#125;

但是这种写法有问题，并不能真正地随机打乱数组，经过大量的实验发现
每个元素仍然有很大的几率出现在它原来的位置附近。

2.洗牌算法
    从最后一个数据开始往前，每次随机一个位置，将两者的位置进行交换，直到数组交换完毕。


ES6实现：

function shuffle(arr) &#123;
    let i =  arr.length;
    while(i) &#123;
        let j = Math.floor(Math.random() * i--);
        [arr[j], arr[i]] = [arr[i], arr[j]];
    &#125;
    return arr
&#125;

var arr = [1,2,3,4,5,6,7]
shuffle(arr)
</code></pre>
<h2 id="封装函数使字符串以驼峰式命名"><a href="#封装函数使字符串以驼峰式命名" class="headerlink" title="封装函数使字符串以驼峰式命名"></a>封装函数使字符串以驼峰式命名</h2><ul>
<li>已知字符串 foo = ‘get-element-by-id’,写一个函数将其转换为驼峰式命名“getElementById”<!--more--></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//详细过程分析：</span><br><span class="line">var foo = &#x27;get-element-by-id&#x27;;</span><br><span class="line"></span><br><span class="line">//根据某个字符进行分割</span><br><span class="line">var arr = foo.split(&#x27;-&#x27;);</span><br><span class="line"></span><br><span class="line">//分割成四个片段保存在数组内</span><br><span class="line">console.log(arr) // (4) [&quot;get&quot;, &quot;element&quot;, &quot;by&quot;, &quot;id&quot;]</span><br><span class="line"></span><br><span class="line">//将下标为1的数组元素第一个字符元素转为大写</span><br><span class="line">console.log(arr[1].charAt(0).toUpperCase()) //E</span><br><span class="line"></span><br><span class="line">//截取后面字符元素</span><br><span class="line">console.log(arr[1].substr(1, arr[1].length - 1)) //lement</span><br><span class="line"></span><br><span class="line">//遍历</span><br><span class="line">for(var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1)</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr) //(4) [&quot;get&quot;, &quot;Element&quot;, &quot;By&quot;, &quot;Id&quot;]</span><br><span class="line"></span><br><span class="line">//根据某一个字符将数组转换为字符串</span><br><span class="line">console.log(arr.join(&#x27;&#x27;));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//封装</span><br><span class="line">function toString(foo) &#123;</span><br><span class="line">    var arr = foo.split(&#x27;-&#x27;);</span><br><span class="line"></span><br><span class="line">    for(var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr.join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(toString(&#x27;get-element-by-id&#x27;))</span><br></pre></td></tr></table></figure>

<p>把 the-first-name 变成 theFirstName</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reg = /-(\w)/g</span><br><span class="line">var str = &quot;the-first-name&quot;</span><br><span class="line">console.log(str.replace(reg, function($, $1)&#123;</span><br><span class="line">    return $1.toUpperCase()</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>把 aabb 换成 bbaa</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reg = /(\w)\1(\w)\2/g;</span><br><span class="line">var str = &quot;aabb&quot;;</span><br><span class="line">// console.log(str.replace(reg,&quot;$2$2$1$1&quot;));//&quot;bbaa&quot;</span><br><span class="line">console.log(str.replace(reg,function($,$1,$2)&#123;</span><br><span class="line">  return $2+$2+$1+$1;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>正则简单的去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;aaaabbbbbccccc&quot;;</span><br><span class="line">var reg = /(\w)\1*/g;</span><br><span class="line">console.log.replace(reg,&quot;$1&quot;));//abc</span><br><span class="line">           ~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           把&quot;1000000000&quot;变成&quot;100.000.000&quot;这种写法，把后面往前面查，三位加个点</span><br><span class="line">           ~~~</span><br><span class="line">           var str = &quot;100000000&quot;;</span><br><span class="line">           var reg = /(?=(\B)(\d&#123;3&#125;)+$)/g;</span><br><span class="line">           console.log(str.replace(reg,&quot;.&quot;))//&quot;100.000.000&quot;</span><br><span class="line">           ||</span><br><span class="line">           string.replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, &quot;.&quot;) //先行断言?=,后行断言(?!\d)</span><br><span class="line">           ||</span><br><span class="line">           (25435345.22).toLocaleString(str(&#x27;en-US&#x27;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
