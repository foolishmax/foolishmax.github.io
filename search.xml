<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>13个超实用的JavaScript数组操作技巧</title>
    <url>/2020/07/18/13%E4%B8%AA%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84JavaScript%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="13个超实用的JavaScript数组操作技巧"><a href="#13个超实用的JavaScript数组操作技巧" class="headerlink" title="13个超实用的JavaScript数组操作技巧"></a>13个超实用的JavaScript数组操作技巧</h2><h3 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fruits &#x3D; [&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;&quot;watermelon&quot;,&quot;apple&quot;,&quot;orrage&quot;]</span><br><span class="line">&#x2F;&#x2F;第一种方法</span><br><span class="line">let uniqueFruits &#x3D; Array.from(new Set(fruits))</span><br><span class="line">&#x2F;&#x2F;第二种方法</span><br><span class="line">let uniqueFruits2 &#x3D; [...new Set(fruits)]</span><br></pre></td></tr></table></figure>

<h3 id="2-替换数组中的特定值"><a href="#2-替换数组中的特定值" class="headerlink" title="2.替换数组中的特定值"></a>2.替换数组中的特定值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用.splice(start,value to remove,valueToAdd),返回删除对象，并修改原数组</span><br><span class="line">let fruits &#x3D; [&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;,&quot;watermelon&quot;,&quot;apple&quot;,&quot;orrage&quot;]</span><br><span class="line">fruits.splice(0,2,&quot;potato&quot;,&quot;tomato&quot;)</span><br><span class="line">console.log(fruits)</span><br></pre></td></tr></table></figure>

<h3 id="3-不使用-map-映射数组"><a href="#3-不使用-map-映射数组" class="headerlink" title="3.不使用.map()映射数组"></a>3.不使用.map()映射数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let friends &#x3D; [</span><br><span class="line">    &#123; name: &#39;John&#39;, age: 22 &#125;,</span><br><span class="line">    &#123; name: &#39;Peter&#39;, age: 23 &#125;,</span><br><span class="line">    &#123; name: &#39;Mark&#39;, age: 24 &#125;,</span><br><span class="line">    &#123; name: &#39;Maria&#39;, age: 22 &#125;,</span><br><span class="line">    &#123; name: &#39;Monica&#39;, age: 21 &#125;,</span><br><span class="line">    &#123; name: &#39;Martha&#39;, age: 19 &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let friendsNames &#x3D; Array.from(friends, (&#123;name&#125;) &#x3D;&gt; name)</span><br><span class="line"></span><br><span class="line">console.log(friendsNames)&#x2F;&#x2F;returns [&quot;John&quot;, &quot;Peter&quot;, &quot;Mark&quot;, &quot;Maria&quot;, &quot;Monica&quot;, &quot;Martha&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="4-清空数组"><a href="#4-清空数组" class="headerlink" title="4.清空数组"></a>4.清空数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fruits &#x3D; [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;grape&quot;, &quot;apple&quot;];</span><br><span class="line">&#x2F;&#x2F;要清空数组，仅需要将数组的长度设置为0</span><br><span class="line">fruits.length &#x3D; 0;</span><br><span class="line">console.log(fruits); &#x2F;&#x2F; returns []</span><br></pre></td></tr></table></figure>

<h3 id="5-数组转对象"><a href="#5-数组转对象" class="headerlink" title="5.数组转对象"></a>5.数组转对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fruits &#x3D; [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;];</span><br><span class="line"></span><br><span class="line">let fruitsObj &#x3D; &#123;...fruits&#125;;</span><br><span class="line"></span><br><span class="line">console.log(fruitsObj) &#x2F;&#x2F; returns &#123;0: &quot;banana&quot;, 1: &quot;apple&quot;, 2: &quot;orange&quot;, 3: &quot;watermelon&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-用数据填充数组"><a href="#6-用数据填充数组" class="headerlink" title="6.用数据填充数组"></a>6.用数据填充数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let newArray &#x3D; new Array(10).fill(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">console.log(newArray)</span><br></pre></td></tr></table></figure>

<h3 id="7-合并数组"><a href="#7-合并数组" class="headerlink" title="7.合并数组"></a>7.合并数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fruits &#x3D; [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];</span><br><span class="line">var meat &#x3D; [&quot;poultry&quot;, &quot;beef&quot;, &quot;fish&quot;];</span><br><span class="line">var vegetables &#x3D; [&quot;potato&quot;, &quot;tomato&quot;, &quot;cucumber&quot;];</span><br><span class="line">&#x2F;&#x2F;使用扩展运算符...</span><br><span class="line">var food &#x3D; […fruits, …meat, …vegetables];</span><br><span class="line">console.log(food); </span><br></pre></td></tr></table></figure>

<h3 id="8-求数组的交集"><a href="#8-求数组的交集" class="headerlink" title="8.求数组的交集"></a>8.求数组的交集</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr1 &#x3D; [0,2,3,5,6,8,6]</span><br><span class="line">var arr2 &#x3D; [1,2,3,4,5,6,4]</span><br><span class="line">var duplicatedValues &#x3D; [...new Set(arr1)].filter(item&#x3D;&gt;arr2.includes(item))</span><br><span class="line">console.log(duplicatedValues)</span><br></pre></td></tr></table></figure>

<h3 id="9-从数组中删除虚值"><a href="#9-从数组中删除虚值" class="headerlink" title="9.从数组中删除虚值"></a>9.从数组中删除虚值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;虚值有：false、0、null、NaN、undefined、&quot;&quot;.</span><br><span class="line">var mixedArr &#x3D; [0,&quot;blue&quot;,&quot;&quot;,NaN,9,true,undefined,&quot;white&quot;,false]</span><br><span class="line">var trueArr &#x3D; mixedArr.filter(Boolean)</span><br><span class="line">console.log(trueArr)</span><br></pre></td></tr></table></figure>

<h3 id="10-从数组中获取随机值"><a href="#10-从数组中获取随机值" class="headerlink" title="10.从数组中获取随机值"></a>10.从数组中获取随机值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var colors &#x3D; [&quot;blue&quot;, &quot;white&quot;, &quot;green&quot;, &quot;navy&quot;, &quot;pink&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;];</span><br><span class="line"></span><br><span class="line">var randomColor &#x3D; colors[(Math.floor(Math.random() * (color.length)))]</span><br></pre></td></tr></table></figure>

<h3 id="11-反转数组"><a href="#11-反转数组" class="headerlink" title="11.反转数组"></a>11.反转数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var colors &#x3D; [“blue”, “white”, “green”, “navy”, “pink”, “purple”, “orange”, “yellow”, “black”, “brown”];</span><br><span class="line">var reversedColors &#x3D; colors.reverse();</span><br><span class="line">console.log(reversedColors); </span><br></pre></td></tr></table></figure>

<h3 id="12-lastIndexOf-方法"><a href="#12-lastIndexOf-方法" class="headerlink" title="12.lastIndexOf()方法"></a>12.lastIndexOf()方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查找给定元素的最后依次出现的索引</span><br><span class="line">var nums &#x3D; [1, 5, 2, 6, 3, 5, 2, 3, 6, 5, 2, 7];</span><br><span class="line">var lastIndex &#x3D; nums.lastIndexOf(5);</span><br><span class="line">console.log(lastIndex); &#x2F;&#x2F; returns 9</span><br></pre></td></tr></table></figure>

<h3 id="13-对数组中所有值求和"><a href="#13-对数组中所有值求和" class="headerlink" title="13.对数组中所有值求和"></a>13.对数组中所有值求和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nums &#x3D; [1,5,4,3]</span><br><span class="line">var sum &#x3D; nums.reduce((x,y)&#x3D;&gt;x+y)</span><br><span class="line">console.log(sum)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-清除浮动</title>
    <url>/2019/07/07/CSS-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="CSS-清除浮动"><a href="#CSS-清除浮动" class="headerlink" title="CSS-清除浮动"></a>CSS-清除浮动</h2><p><a href="https://segmentfault.com/a/1190000004865198">原文链接</a></p>
<h3 id="什么是CSS清除浮动"><a href="#什么是CSS清除浮动" class="headerlink" title="什么是CSS清除浮动?"></a>什么是CSS清除浮动?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left</span><br><span class="line">或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到</span><br><span class="line">容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行</span><br><span class="line">的CSS处理，就叫CSS清除浮动。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ul>
<li>方法一：使用带clear属性的空元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在浮动元素后使用一个空元素如&lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;，并在CSS中赋予</span><br><span class="line">.clear&#123;clear:both;&#125;属性即可清理浮动。亦可使用&lt;br class&#x3D;&quot;clear&quot; &#x2F;&gt;或&lt;hr class&#x3D;&quot;clear&quot; &#x2F;&gt;</span><br><span class="line">来进行清理。</span><br><span class="line">优点：简单，代码少，浏览器兼容好。</span><br><span class="line">缺点：需要添加大量的无语义的html元素，代码不够优雅，后期不容易维护。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：使用CSS的overflow属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法三：给浮动的元素的容器添加浮动（不太推荐）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，</span><br><span class="line">不推荐使用。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法四：使用邻接元素处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">什么都不做，给浮动元素后面的元素添加clear:both属性。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法五：使用CSS的：after伪元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现</span><br><span class="line">元素末尾添加一个看不见的块元素（Block element）清理浮动。</span><br><span class="line"></span><br><span class="line">.clearfix::after&#123;</span><br><span class="line">  content: &quot;020&quot;; </span><br><span class="line">  display: block; </span><br><span class="line">  height: 0; </span><br><span class="line">  clear: both; </span><br><span class="line">  visibility: hidden;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome打开一个页面需要启动多少线程？分别有哪些线程？</title>
    <url>/2019/10/14/Chrome%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E9%9C%80%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="Chrome打开一个页面需要启动多少线程？分别有哪些线程？"><a href="#Chrome打开一个页面需要启动多少线程？分别有哪些线程？" class="headerlink" title="Chrome打开一个页面需要启动多少线程？分别有哪些线程？"></a>Chrome打开一个页面需要启动多少线程？分别有哪些线程？</h2><pre><code>最新Chrome浏览器包括：一个浏览器(Browser)主线程、一个GPU进程、一个网络(NetWork)
进程、多个渲染进程和多个插件进程
</code></pre>
<ul>
<li><p>线程：</p>
<ul>
<li>浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。</li>
<li>渲染进程：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，<br>排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个<br>Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li>GPU进程：Chrome刚开始的时候是没有GPU进程的，而GPU使用的使用初衷是为了实现<br>3D CSS效果，之后随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU称为<br>浏览器普遍的需求，最后，Chrome在其多进程架构上也引入了GPU进程。</li>
<li>网络进程：主要负责网页的网络资源加载，之前是作为一个模块运行在浏览器进程里面<br>的，最近才独立出来，称为一个单独的进程。</li>
<li>插件进程：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以<br>保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM基本操作</title>
    <url>/2019/08/11/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h2><ul>
<li><p>获取Dom节点</p>
<ul>
<li>document代表整个文档</li>
<li>document.getElementById()</li>
<li>document.getElementByTagName()</li>
<li>document.getElementByName() //只有部分标签name可生效，表单之类的</li>
<li>document.getElementByClassName()</li>
<li>querySelector() //静态的，不是实时的，保存的是当时的状态，是一个副本</li>
<li>querySelectorAll() //即使以后元素发生了改变，该值也不会改变</li>
</ul>
</li>
<li><p>遍历节点树</p>
<ul>
<li>parentNode -&gt; 父节点（最顶端parentNode为#document）</li>
<li>childNodes -&gt; 子节点们</li>
<li>firstChild -&gt; 第一个子节点</li>
<li>lastChild  -&gt; 最后一个子节点</li>
<li>nextSibling -&gt; 后一个兄弟节点</li>
<li>previousSibling -&gt;前一个兄弟节点</li>
</ul>
</li>
<li><p>遍历元素节点树</p>
<ul>
<li>parentElement -&gt; 返回当前元素的父元素节点（IE9以下不兼容）</li>
<li>children -&gt; 返回当前元素的元素子节点</li>
<li>node.childElementCount === node.children.length 返回当前元素的子元素节点个数（IE9以下不兼容）</li>
<li>firstElementChild -&gt; 返回第一个元素节点（IE9以下不兼容）</li>
<li>lastElementChild -&gt; 返回最后一个元素节点（IE9以下不兼容）</li>
<li>nextElementSibling -&gt; 返回后一个元素节点（IE9以下不兼容）</li>
<li>previousElementSibling -&gt; 返回前一个元素节点（IE9以下不兼容）</li>
</ul>
</li>
<li><p>节点的类型</p>
<ul>
<li>元素节点 —— 1</li>
<li>属性节点 —— 2</li>
<li>文本节点 —— 3</li>
<li>注释节点（Comment）—— 8</li>
<li>document —— 9</li>
<li>DocumentFragment —— 11</li>
<li>获取节点类型 nodeType</li>
</ul>
</li>
<li><p>节点的四个属性</p>
<ul>
<li>nodeName <ul>
<li>元素的标签名，以大写形式表示，只读</li>
</ul>
</li>
<li>nodeValue<ul>
<li>Text节点或Comment节点的文本内容，可读写</li>
</ul>
</li>
<li>nodeType<ul>
<li>该节点的类型，只读</li>
</ul>
</li>
<li>attributes<ul>
<li>Element节点的属性集合</li>
</ul>
</li>
</ul>
</li>
<li><p>节点的一个方法</p>
<ul>
<li>Node.hasChildNodes()<ul>
<li>所有节点都有hasChildNodes()方法，判断有无子节点，有一个或多个返回true</li>
</ul>
</li>
</ul>
</li>
<li><p>Dom基本操作——增</p>
<ul>
<li>document.createElement()</li>
<li>document.createTextNode()</li>
<li>document.createComment()</li>
<li>document.createDocumentFragment()</li>
</ul>
</li>
<li><p>Dom基本操作——插</p>
<ul>
<li>parentNode.appendChild()</li>
<li>parentNode.insertBefore(a, b)</li>
</ul>
</li>
<li><p>Dom基本操作——删</p>
<ul>
<li>parent.removeChild()</li>
<li>child.remove()</li>
</ul>
</li>
<li><p>Dom基本操作-替换</p>
<ul>
<li>parent.replaceChild(new, origin)</li>
</ul>
</li>
<li><p>Element节点的一些属性</p>
<ul>
<li>innerHTML</li>
<li>innerText(火狐不兼容)/textContent(老版本IE不兼容)</li>
</ul>
</li>
<li><p>Element节点的一些方法</p>
<ul>
<li>ele.setAttribute()</li>
<li>ele.getAttribute()</li>
</ul>
</li>
<li><p>查看元素的几何尺寸</p>
<ul>
<li>domEle.getBoundingClientRect() </li>
<li>兼容性很好</li>
<li>返回一个对象，里面有left、top、right、bottom、width、height。</li>
</ul>
<p>  left和top代表元素左上角的X和Y坐标，right和bottom代表元素右下角的X和Y坐标</p>
<ul>
<li>height和width属性老版本IE未实现</li>
<li>返回的结果不是“实时的”</li>
</ul>
</li>
<li><p>查看元素的宽高尺寸<br>  dom.offsetWidth</p>
<p>  dom.offsetHeight</p>
</li>
<li><p>查看元素的位置<br>  dom.offsetLeft</p>
<p>  dom.offsetTop</p>
<p>  对于无定位父级的元素，返回相对文档的坐标。</p>
<p>  对于有定位的父级元素，返回相对最近的有定位的父级的坐标，无论距离是怎么产生的</p>
</li>
<li><p>dom.offsetParent<br>  返回最近的有定位的父级，若无，返回body，body.offsetParent返回nul</p>
</li>
<li><p>让滚动条滚动</p>
<ul>
<li>window上的三个方法：scroll()==scrollTo()、scrollBy()</li>
<li>scroll()和scrollTo()将x、y坐标传入，让滚动条滚动到当前位置</li>
<li>scrollBy() 会在之前的数据基础上累加，可以利用scrollBy()实现快速阅读的功能</li>
</ul>
</li>
<li><p>查询计算样式</p>
<ul>
<li>window.getComputedStyle(ele, null)[style]</li>
<li>第二个参数null，放的是伪元素，可以获取伪元素的属性</li>
<li>计算样式只读</li>
<li>返回的计算样式都是绝对值，没有相对单位</li>
<li>IE8及以下不兼容（ele.currentStyle[style]）</li>
</ul>
</li>
</ul>
<ul>
<li><p>封装函数，返回元素的第n层祖先元素节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function retParent(elem, n) &#123;</span><br><span class="line">    while(elem &amp;&amp; n) &#123;</span><br><span class="line">        elem &#x3D; elem.parentElement</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">    return elem</span><br><span class="line">&#125;</span><br><span class="line">var i &#x3D; document.getElementByTagName(&#39;i&#39;)[0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型上封装函数myChildren获取子元素，解决一千浏览器的兼容性问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.prototype.myChildren &#x3D; function () &#123;</span><br><span class="line">    var child &#x3D; this.childNodes</span><br><span class="line">    var len &#x3D; child.length</span><br><span class="line">    for (var i &#x3D; 0;i &lt; len; i++) &#123;</span><br><span class="line">        if(child[i].nodeType &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            arr.push(child[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var div &#x3D; document.getElementByTagName(&#39;div&#39;)[0]</span><br></pre></td></tr></table></figure></li>
<li><p>自己封装hasChildren()方法，不可用children属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.prototype.hasChildren &#x3D; function () &#123;</span><br><span class="line">    var child &#x3D; this.childNodes</span><br><span class="line">    var len &#x3D; child.length</span><br><span class="line">    for (var i &#x3D; 0;i &lt; len; i++) &#123;</span><br><span class="line">        if(child[i].nodeType &#x3D;&#x3D; 1) &#123;</span><br><span class="line">           return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var div &#x3D; document.getElementByTagName(&#39;div&#39;)[0]</span><br></pre></td></tr></table></figure></li>
<li><p>封装函数，返回元素e的第n个兄弟元素节点，n为正，返回后面的兄弟元素节点，n为负，返回前面的，n为0，返回自己</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function retSibling(e, n) &#123;</span><br><span class="line">    while(e &amp;&amp; n) &#123;</span><br><span class="line">        if(n &gt; 0) &#123;</span><br><span class="line">            if(e.nextElementSibling) &#123;</span><br><span class="line">                e.nextElementSibling</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for(e &#x3D; e.nextSibling; e &amp;&amp; e.nodeType !&#x3D; 1; e &#x3D; e.nextSibling)</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if(e.previousElementSibling) &#123;</span><br><span class="line">                e &#x3D; e.previousElementSibling</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for(e &#x3D; e.previousSibling; e &amp;&amp; e.nodeType !&#x3D; 1; e &#x3D; e.previousSibling)</span><br><span class="line">            &#125;</span><br><span class="line">            n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装insertAfter(),功能类似与insertBefore(new, origin),直接在Element.prototype上编程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.prototype.insertAfter &#x3D; function(new, origin) &#123;</span><br><span class="line">    var beforeNode &#x3D; origin.nextElementSibling</span><br><span class="line">    if (beforeNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">        this.appendChild(new)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.insertBefore(new, beforeNode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装滚动条的x轴、y轴的距离函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getScrollOffset() &#123;</span><br><span class="line">    if (window.pageXOffset) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: window.pageXOffset,</span><br><span class="line">            y: window.pageYOffset</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: document.body.scrollLeft + document.documentElement.scrollLeft,</span><br><span class="line">            y: document.body.scrollTop + document.documentElement.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装可视区窗口大小的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getViewportOffset() &#123;</span><br><span class="line">    if (window.innerWidth) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            w: window.innerWidth,</span><br><span class="line">            h: window.innerHeight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (document.compatMode &#x3D;&#x3D;&#x3D; &#39;BackCompat&#39;) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                w: document.body.clientWidth,</span><br><span class="line">                h: document.body.clientHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                w: document.documentElement.clientWidth,</span><br><span class="line">                h: document.documentElement.clientHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装样式获取的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getStyle(elem, prop) &#123;</span><br><span class="line">    if(window.getComputedStyle) &#123;</span><br><span class="line">        return window.getComputedStyle(elem, null)[prop]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return elem.currentStyle[prop]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之数字操作</title>
    <url>/2019/08/12/ES6%E4%B9%8B%E6%95%B0%E5%AD%97%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="ES6之数字操作"><a href="#ES6之数字操作" class="headerlink" title="ES6之数字操作"></a>ES6之数字操作</h3><ul>
<li><p>二进制和八进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 二进制Binary，以0（零）开头，第二个位置b</span><br><span class="line">let binary &#x3D; 0B010101</span><br><span class="line">console.log(binary) &#x2F;&#x2F;21</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;八进制Octal，以0（零）开头，第二个位置O</span><br><span class="line">let b &#x3D; 0o226;</span><br><span class="line">console.log(b)  &#x2F;&#x2F;150</span><br></pre></td></tr></table></figure></li>
<li><p>数字验证 Number.isFinite(*)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以使用Number.isFinite()进行数字验证，只要是数字，无论是浮点型</span><br><span class="line">还是整形都会返回true，其他的返回false</span><br><span class="line">let a &#x3D; 10&#x2F;3</span><br><span class="line">Number.isFinite(a)  &#x2F;&#x2F;true</span><br><span class="line">Number.isFinite(&#39;foolishmax&#39;)   &#x2F;&#x2F;false</span><br><span class="line">Number.isFinite(NaN)    &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure></li>
<li><p>NaN验证： Number.isNaN()</p>
</li>
<li><p>判断是否为整数：Number.isInteger()</p>
</li>
<li><p>转换为整数：Number.parseInt()</p>
</li>
<li><p>转换为浮点型：Number.parseFloat()</p>
</li>
<li><p>最大安全整数：Number.MAX_SAFE_INTEGER</p>
</li>
<li><p>最小安全整数：Number.MIN_SAFE_INTEGER</p>
</li>
<li><p>安全整数判断：Number.isSafeInteger()</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之字符串</title>
    <url>/2019/08/12/ES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="ES6之字符串"><a href="#ES6之字符串" class="headerlink" title="ES6之字符串"></a>ES6之字符串</h3><ul>
<li>ES5的字符串拼接<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name &#x3D; &#39;foolishmax&#39;</span><br><span class="line">let blog &#x3D; &#39;你好，我是&#39;+name+&#39;,是你的新朋友。&#39;</span><br><span class="line">console.log(blog)   &#x2F;&#x2F; 你好，我是foolishmax,是你的新朋友。</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li>ES6采用${name}的形式,同时里面支持HTML标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name &#x3D; &#39;foolishmax&#39;</span><br><span class="line">let blog &#x3D; &#96;&lt;h3&gt;你好，我是$&#123;name&#125;,是你的新朋友。&lt;&#x2F;h3&gt;&#96;</span><br><span class="line">document.write(blog)   &#x2F;&#x2F; 你好，我是foolishmax,是你的新朋友。</span><br></pre></td></tr></table></figure></li>
<li>对运算也支持<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 1</span><br><span class="line">let b &#x3D; 2</span><br><span class="line">let result &#x3D; &#96;$&#123;a + b&#125;&#96;</span><br><span class="line">console.log(result) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure></li>
<li>查找是否存在<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;includes</span><br><span class="line">let name &#x3D; &#39;foolishmax&#39;</span><br><span class="line">let str &#x3D; &#39;hello world, foolishmax&#39;</span><br><span class="line">console.log(str.includes(name)) &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li>
<li>判断开头是否存在<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.startsWith(name)</span><br></pre></td></tr></table></figure></li>
<li>判断结尾是否存在<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.endsWith(name)</span><br></pre></td></tr></table></figure></li>
<li>复制字符串<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;hello &#39;.repeat(3))</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数组常见的API</title>
    <url>/2019/07/18/ES6%E4%B9%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="数组常见的API"><a href="#数组常见的API" class="headerlink" title="数组常见的API"></a>数组常见的API</h2><span id="more"></span>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><pre><code>遍历所有数组元素,会自动省略为空的数组元素
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line"></span><br><span class="line">array1.forEach(function(element) &#123;</span><br><span class="line">  console.log(element);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; a b c</span><br></pre></td></tr></table></figure>

<h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><pre><code>判断所有元素是否都符合条件
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3]</span><br><span class="line">var result &#x3D; arr.every(function(item, index)&#123;</span><br><span class="line">    if (item &lt; 4) &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure>

<h4 id="some"><a href="#some" class="headerlink" title="some"></a>some</h4><pre><code>判断是否有至少一个元素符合条件
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">var even &#x3D; function(element) &#123;</span><br><span class="line">  &#x2F;&#x2F; checks whether an element is even</span><br><span class="line">  return element % 2 &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(array.some(even));</span><br><span class="line">&#x2F;&#x2F; expected output: true</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><pre><code>排序
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 4, 3, 2, 5]</span><br><span class="line">var arr2 &#x3D; arr.sort(function(a, b)&#123;</span><br><span class="line">    &#x2F;&#x2F;从小到达</span><br><span class="line">    return a - b</span><br><span class="line">    &#x2F;&#x2F;从大到小</span><br><span class="line">    &#x2F;&#x2F;return b- a</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2)</span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><pre><code>过滤符合条件的元素
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;filter回调函数会返回一个boolean值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;true：当返回true时，函数内部会自动将这次回调的item加入到新的数组中arr2</span><br><span class="line">&#x2F;&#x2F;false：当返回false时，函数内部会过滤掉这次的item</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1, 2, 3]</span><br><span class="line">var arr2 &#x3D; arr.filter(function(item, index)&#123;</span><br><span class="line">    if (item &gt;&#x3D; 2) &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2)</span><br></pre></td></tr></table></figure>


<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><pre><code>对元素重新组装，生成新数组(该数组中的每个元素都调用一个提供的函数后返回的
结果。)
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array1 &#x3D; [1, 4, 9, 16];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pass a function to map</span><br><span class="line">const map1 &#x3D; array1.map(x &#x3D;&gt; x * 2);</span><br><span class="line"></span><br><span class="line">console.log(map1);</span><br><span class="line">&#x2F;&#x2F; expected output: Array [2, 8, 18, 32]</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><pre><code>reduce作用是对数组中所有内容进行汇总
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3].reduce(function(prev, curr)&#123;</span><br><span class="line">    return prev + curr</span><br><span class="line">&#125;, 0)  &#x2F;&#x2F;6</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F;计算小于100，并二倍之后的和</span><br><span class="line">const nums &#x3D; [10, 20, 111, 222, 444, 40, 50]</span><br><span class="line"></span><br><span class="line">let total &#x3D; nums.filter(function(n)&#123;</span><br><span class="line">    return n &lt; 100</span><br><span class="line">&#125;).map(function(n)&#123;</span><br><span class="line">    return n * 2</span><br><span class="line">&#125;).reduce(function(pre, curr)&#123;</span><br><span class="line">    return pre + curr</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">let total &#x3D; nums.filter(n &#x3D;&gt; n &lt; 100).map(n &#x3D;&gt; n * 2)</span><br><span class="line">.reduce((pre, curr) &#x3D;&gt; pre + curr)</span><br><span class="line"></span><br><span class="line">console.log(total) &#x2F;&#x2F;240</span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><pre><code>间隔数组元素
let arr = [&#39;hello&#39;, &#39;world&#39;, &#39;foolish&#39;]
console.log(arr.join(&#39;|&#39;))
// hello|world|foolish
</code></pre>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><pre><code>let arr = [&#39;hello&#39;, &#39;world&#39;, &#39;foolish&#39;]
console.log(arr.toString())
// hello,world,foolish
</code></pre>
<h4 id="includes-ES7"><a href="#includes-ES7" class="headerlink" title="includes() //ES7"></a>includes() //ES7</h4><pre><code>includes() 函数用来判断一个数组是否包含一个指定的值，如果包含则返回true，否则返回false
类似indexOf()
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用indexOf()验证数组中是否存在某个元素，根据返回值是否为-1来判断</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [&#39;react&#39;, &#39;angular&#39;, &#39;vue&#39;]</span><br><span class="line"></span><br><span class="line">if (arr.indexOf(&#39;react&#39;) !&#x3D;&#x3D; -1) &#123;</span><br><span class="line">    console.log(&#39;react存在&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用ES7的includes()方法</span><br><span class="line">let arr &#x3D; [&#39;react&#39;, &#39;angular&#39;, &#39;vue&#39;]</span><br><span class="line"></span><br><span class="line">if (arr.includes(&#39;react&#39;)) &#123;</span><br><span class="line">    console.log(&#39;react存在&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h4><pre><code>在ES7中引入了指数操作符 ** ,** 具有和Math.pow(a, b)等效的计算结果
</code></pre>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><pre><code>JSON数组格式（多个length属性）转换为数组
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let json &#x3D; &#123;</span><br><span class="line">    &#39;0&#39;: &#39;hello&#39;,</span><br><span class="line">    &#39;1&#39;: &#39;world&#39;,</span><br><span class="line">    &#39;2&#39;: &#39;foolishmax&#39;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;</span><br><span class="line">let arr &#x3D; Array.from(json)</span><br><span class="line">console.log(arr)</span><br></pre></td></tr></table></figure>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><pre><code>负责把一堆文本或者变量转换成数组
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 数字</span><br><span class="line">let arr &#x3D; Array.of(1, 2, 3, 4)</span><br><span class="line">console.log(arr)    &#x2F;&#x2F;[1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">let arr &#x3D; Array.of(&#39;hello&#39;, &#39;world&#39;)</span><br><span class="line">console.log(arr)    &#x2F;&#x2F;[&quot;hello&quot;, &quot;world&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="find-实例方法"><a href="#find-实例方法" class="headerlink" title="find()实例方法"></a>find()实例方法</h4><pre><code>所谓的实例方法并不是以Array对象开始的，而是必须有一个已经存在的数组，
实例数组调用的方法，就是实例方法.

find接受一个方法作为参数，方法内部返回一个条件
find会遍历所有元素，执行给定的函数
符合该条件的元素会作为find方法的返回值
如果遍历结束没有符合条件的元素，则返回undefined   
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;value: 表示当前查找的值</span><br><span class="line">&#x2F;&#x2F;index: 表示当前查找的数组索引</span><br><span class="line">&#x2F;&#x2F;arr: 表示当前数组</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [2,3,4,5,6,7,8]</span><br><span class="line">let result &#x3D; arr.find(function(value, index, arr)&#123;</span><br><span class="line">    return value &gt; 5</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result) &#x2F;&#x2F;6</span><br></pre></td></tr></table></figure>

<h4 id="fill-实例方法"><a href="#fill-实例方法" class="headerlink" title="fill()实例方法"></a>fill()实例方法</h4><pre><code>fill()作用是把数组进行填充，接受三个参数，一个参数填充的变量，第二个
是填充的位置，第三个是填充到的位置
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4,5,6,7,8,9]</span><br><span class="line">arr.fill(&#39;hello&#39;, 1, 3)</span><br><span class="line">console.log(arr)    &#x2F;&#x2F; [1, &quot;hello&quot;, &quot;hello&quot;, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<h4 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [&#39;hello&#39;, &#39;world&#39;, &#39;foolishmax&#39;]</span><br><span class="line">for(let item of arr)&#123;</span><br><span class="line">    console.log(item)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; hello world foolishmax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let arr &#x3D; [&#39;hello&#39;, &#39;world&#39;, &#39;foolishmax&#39;]</span><br><span class="line">for(let index of arr.keys()) &#123;</span><br><span class="line">    console.log(index)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0 1 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let arr &#x3D; [&#39;hello&#39;, &#39;world&#39;, &#39;foolishmax&#39;]</span><br><span class="line">for (let [index, val] of arr.entries())&#123;</span><br><span class="line">    console.log(index+&#39;:&#39;+val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;0:hello</span><br><span class="line">&#x2F;&#x2F;1:world</span><br><span class="line">&#x2F;&#x2F;2:foolishmax</span><br></pre></td></tr></table></figure>

<h4 id="entries-实例方法"><a href="#entries-实例方法" class="headerlink" title="entries()实例方法"></a>entries()实例方法</h4><pre><code>entries() 实例方法生成的是Iterator形式的数组，好处就是可以让我们在需要的时候
用next()手动跳转到下一个值
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [&#39;hello&#39;, &#39;world&#39;, &#39;foolishmax&#39;]</span><br><span class="line">let list &#x3D; arr.entries();</span><br><span class="line">console.log(list.next().value);</span><br><span class="line">console.log(list.next().value);</span><br><span class="line">console.log(list.next().value);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonJS、AMD、CMD是什么及区别？</title>
    <url>/2019/08/13/CommonJS%E3%80%81AMD%E3%80%81CMD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8F%8A%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="CommonJS、AMD、CMD是什么及区别？"><a href="#CommonJS、AMD、CMD是什么及区别？" class="headerlink" title="CommonJS、AMD、CMD是什么及区别？"></a>CommonJS、AMD、CMD是什么及区别？</h2><ul>
<li>CommonJS是服务器端js模块化的规范，NodeJS是这种规范的实现，加载模块使用require方法，</li>
</ul>
<p>导出使用exports</p>
<ul>
<li>AMD和CMD都是为了解决浏览器端模块化问题而产生的，AMD规范对应的库Require.js,</li>
</ul>
<p>CMD规范对应的库Sea.js</p>
<ul>
<li>AMD 和 CMD的区别:<ul>
<li>AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li>
<li>CMD 推崇就近依赖，只有在用到的某个模块的时候再去require</li>
<li>对于依赖的模块，AMD是提前执行，CMD是延迟执行，但RequireJS(AMD)从2.0开始，也改为延迟执行</li>
<li>AMD的API默认是一个当多个，CMD的API严格区分，推崇职责单一</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6实用技巧</title>
    <url>/2020/10/07/ES6%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="ES6实用技巧"><a href="#ES6实用技巧" class="headerlink" title="ES6实用技巧"></a>ES6实用技巧</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;js变量命名：小驼峰，前缀应当是名词，例如 maxCount、tableTitle</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;js常量：全大写，单词以_分割</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;js函数命名：小驼峰，前缀应当是动词，例如 setCount、getTitle</span><br><span class="line">&#x2F;&#x2F;常见动词：can has is get set load</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类 &amp; 构造函数：大驼峰，首字母大写</span><br><span class="line">&#x2F;&#x2F; class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类的成员</span><br><span class="line">&#x2F;&#x2F;公共属性和方法：跟变量和函数的命名一样</span><br><span class="line">&#x2F;&#x2F;私有属性和方法，前缀为_(下划线)，同上</span><br><span class="line">&#x2F;&#x2F;private _name: string;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="let-amp-const"><a href="#let-amp-const" class="headerlink" title="let &amp; const"></a>let &amp; const</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ES6新增了let和const两个命令，let用来定义变量，const用于定义常量，let和const都是块级作用域。</span><br><span class="line">const对于对象类型使用的是指针式引用，常量只是指向了对象的指针，对象本身的内容却依然可以被修改。</span><br><span class="line">在使用中，建议使用let和const完全代替var命令</span><br></pre></td></tr></table></figure>

<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const foo &#x3D; &#96;this is a $&#123;example&#125;&#96;;</span><br></pre></td></tr></table></figure>

<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转换</span><br><span class="line">Number.parseInt —— 将字符串或数字转换为整数</span><br><span class="line">Number.parseFloat —— 将字符串或数字转换为浮点数</span><br><span class="line"></span><br><span class="line">上述两个方法与parseInt和parseFloat功能一致，在ES6中推荐使用Number.的方法调用，目的是为了减少全局性方法，使语言逐步模块化。</span><br></pre></td></tr></table></figure>

<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;合并数组</span><br><span class="line">let a &#x3D; [1,2]</span><br><span class="line">let b &#x3D; [3]</span><br><span class="line">let c &#x3D; [...a, ...b]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Array.from() 将伪数组对象或可遍历对象转换为真数组</span><br><span class="line">&#x2F;&#x2F;典型的伪数组有：函数的arguments对象，以及大多数DOM元素，还有字符串</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;快速转换为数组</span><br><span class="line">Array.of(3, 4, 5)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断对象是否为数组</span><br><span class="line">if(Array.isArray(obj))&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检索数据中是否有5</span><br><span class="line">[1, 2, 3].includes(5) &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找出第一个匹配表达式的结果，只要匹配到一项，函数就返回</span><br><span class="line">let a &#x3D;[1, 3, 4, -89].find((value, index, arr) &#x3D;&gt; &#123;</span><br><span class="line">    return value &lt; 0;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a); &#x2F;&#x2F;-89</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找出第一个匹配表达式的结果的下标</span><br><span class="line">let a &#x3D; [1, 2, 3, -2].findIndex((value, index, arr) &#x3D;&gt; &#123;</span><br><span class="line">    return value &lt; 0;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a); &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;内容过滤</span><br><span class="line">let a &#x3D; [1, 2, 3, -4].filter((item) &#x3D;&gt; &#123;</span><br><span class="line">    return item &gt; 0;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a); &#x2F;&#x2F;[1, 2, 3]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;内容实例</span><br><span class="line">.keys() —— 获得数组中所有元素的键名(索引下标)</span><br><span class="line">.values() —— 获得数组中所有元素的数据</span><br><span class="line">.entries() —— 获得数组中所有数据的键名和数据</span><br><span class="line">类似Object中的同名函数</span><br></pre></td></tr></table></figure>

<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对象内容合并</span><br><span class="line">let a &#x3D; &#123;a:1,b:2&#125;, &#x2F;&#x2F;&#123;a: 1, b: 4&#125;</span><br><span class="line">    b &#x3D; &#123;b:3&#125;,</span><br><span class="line">    c &#x3D; &#123;b:4,c:5&#125;</span><br><span class="line">let d &#x3D; Object.assign(a, b, c) &#x2F;&#x2F;&#123;a: 1, b: 4, c: 5&#125;</span><br><span class="line">&#x2F;&#x2F; 合并的同时更新a对象的内容</span><br><span class="line">&#x2F;&#x2F; a自身没有的属性不会被添加，只会更新</span><br><span class="line">&#x2F;&#x2F; 只会影响a第一个，不会影响后面的b、c</span><br><span class="line">&#x2F;&#x2F; 推荐使用下面这种</span><br><span class="line">let d &#x3D; Object.assign(&#123;&#125;, a, b, c)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对象内容</span><br><span class="line">Object.keys() —— 获取所有键名，以数组形式返回</span><br><span class="line">Object.values() —— 获取所有值内容，以数组形式返回</span><br><span class="line">Object.entries() —— 获取所有键名和值内容，以数组形式返回，成员内容也是数组形式 例如：[[&#39;a&#39;, 1],[&#39;b&#39;, 2]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断对象是否为数组对象</span><br><span class="line">if(Object.isArray(obj))&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断对象是否为空对象</span><br><span class="line">if(obj &amp;&amp; Object.keys(obj).length)</span><br></pre></td></tr></table></figure>

<h3 id="Destructuring解构赋值"><a href="#Destructuring解构赋值" class="headerlink" title="Destructuring解构赋值"></a>Destructuring解构赋值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [a, b, c] &#x3D; [1, 2, 3] &#x2F;&#x2F;如果个数不匹配，没有对应上的为undefined</span><br><span class="line"></span><br><span class="line">let [a, b, c &#x3D; &#39;default&#39;] &#x3D; [12, 23] &#x2F;&#x2F;指定默认值</span><br><span class="line"></span><br><span class="line">let [a, ...b] &#x3D; [1, 2, 3] &#x2F;&#x2F;b的值为[2, 3]</span><br><span class="line"></span><br><span class="line">let [a, b, c] &#x3D; &#39;yes&#39; &#x2F;&#x2F;a的值为y，b的值为e，c的值为s</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果名称是字符串的自带属性，则会获得属性的值</span><br><span class="line">let &#123; length &#125; &#x3D; &#39;yes&#39; &#x2F;&#x2F;length 为3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解构赋值使用实例，作为函数传参，使用默认值</span><br><span class="line">let obj &#x3D; &#123;a: 1, b: 2&#125;</span><br><span class="line">function test(&#123;a &#x3D; 10, b&#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">test(obj)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象结构解构赋值</span><br><span class="line">let obj &#x3D; &#123;a: 1, b: 2&#125;;</span><br><span class="line">let &#123; a, b &#125; &#x3D; obj; &#x2F;&#x2F;a &#x3D; 1,b &#x3D; 2,需要严格匹配名称，数组的模式是严格匹配下标。</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;a: 1, b: 2&#125;;</span><br><span class="line">let &#123; a &#x3D; 0, b &#x3D; 3 &#125; &#x3D; obj; &#x2F;&#x2F;赋值并给定默认值</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123; a: 1, b: 2&#125;;</span><br><span class="line">let &#123;a: A, b&#125; &#x3D; obj; &#x2F;&#x2F;获得内容后，将变量会从新命名</span><br><span class="line"></span><br><span class="line">let a &#x3D; 0;</span><br><span class="line">(&#123;a, b&#125; &#x3D; obj);&#x2F;&#x2F;对已存在的a进行修改值，并生成新的变量b</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解构的同时使用重命名和设置默认值的语法</span><br><span class="line">const person &#x3D; &#123;name: &quot;zhangsan&quot;,sex: &quot;male&quot;&#125;;</span><br><span class="line">const &#123;name: middleName &#x3D; &quot;zhangxiaosan&quot;&#125; &#x3D; person;</span><br><span class="line">console.log(middleName); &#x2F;&#x2F;&quot;zhangsan&quot;</span><br><span class="line">&#x2F;&#x2F; 首先声明middleName这个变量，查询person的middle属性，如果存在则赋值给middleNmae，如果不存在使用默认值&quot;zhangxiaosan&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;多层解构赋值</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    arr: [&#39;aaa&#39;, &#123;a: 1&#125;]</span><br><span class="line">&#125;</span><br><span class="line">let &#123;arr: [b, &#123;a&#125;]&#125; &#x3D; obj; &#x2F;&#x2F;b为&#39;aaa&#39;,a为1，注意结构要对应。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组转化为对象</span><br><span class="line">const points &#x3D; [</span><br><span class="line">    [1,2],</span><br><span class="line">    [3,4]</span><br><span class="line">];</span><br><span class="line">let newPoints &#x3D; points.map(item &#x3D;&gt; &#123;</span><br><span class="line">    const [x,y] &#x3D; item;</span><br><span class="line">    return &#123;x, y&#125;;</span><br><span class="line">&#125;)</span><br><span class="line">or</span><br><span class="line">let newPoints &#x3D; points.map(([x, y]) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;x, y&#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newPoints);</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  &#123;x:1,y:2&#125;,</span><br><span class="line">&#x2F;&#x2F;  &#123;x:3,y:4&#125;</span><br><span class="line">&#x2F;&#x2F;]</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错</span><br><span class="line">&#x2F;&#x2F;报错，会报SyntaxError</span><br><span class="line">let count &#x3D; num &#x3D;&gt; &#123;base: 50&#125;;</span><br><span class="line">&#x2F;&#x2F;正确返回方式</span><br><span class="line">let count &#x3D; num &#x3D;&gt; (&#123;base: 50&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;特点：更简洁的函数和封闭上下文的this指向。</span><br></pre></td></tr></table></figure>

<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基本用法</span><br><span class="line">let name &#x3D; Symbol(&quot;name&quot;);</span><br><span class="line">console.log(name); &#x2F;&#x2F;Symbol(name)</span><br><span class="line">console.log(typeof name); &#x2F;&#x2F;&quot;symbol&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Symbol 函数不能用new命令，因为Symbol是原始数据类型，不是对象</span><br><span class="line">&#x2F;&#x2F; Symbol表示独一无二的值，因此带有相同参数的两个Symbol值也不相等</span><br><span class="line">let name1 &#x3D; Symbol();</span><br><span class="line">let name2 &#x3D; Symbol();</span><br><span class="line">name1 &#x3D;&#x3D;&#x3D; name2;&#x2F;&#x2F; false</span><br><span class="line">let name1 &#x3D; Symbol(&quot;name&quot;);</span><br><span class="line">let name2 &#x3D; Symbol(&quot;name&quot;);</span><br><span class="line">name1 &#x3D;&#x3D;&#x3D; name2; &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Symbol不能进行隐式类型转换</span><br><span class="line">let name &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">console.log(&quot;nihao&quot; + name);</span><br><span class="line">&#x2F;&#x2F;浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a string.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Symbol值可以显示转换为字符串</span><br><span class="line">let name &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">String(name); &#x2F;&#x2F;&quot;Symbol(foo)&quot;</span><br><span class="line">name.toString(); &#x2F;&#x2F;&quot;Symbol(foo)&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Symbol值不能转换为数字</span><br><span class="line">let name &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">Number(name);</span><br><span class="line">&#x2F;&#x2F;浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a number.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Symbol值可以转换为布尔值</span><br><span class="line">let name &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">Boolean(name); &#x2F;&#x2F;true</span><br><span class="line">!name &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Symbol变量不能作为webStorage的键使用</span><br><span class="line">let name &#x3D; Symbol();</span><br><span class="line">localStorage.setItem(name,&quot;aaaa&quot;);</span><br><span class="line">&#x2F;&#x2F;浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a string.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用场景</span><br><span class="line">&#x2F;&#x2F;作为对象属性名</span><br><span class="line">&#x2F;&#x2F;不能用.只能用[]</span><br><span class="line">let name &#x3D; Symbol();</span><br><span class="line">let obj &#x3D; &#123;&#125;;</span><br><span class="line">obj[name] &#x3D; &quot;zhangsan&quot;;</span><br><span class="line">console.log(obj); &#x2F;&#x2F;&#123;Symbol():&quot;zhangsan&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Symbol作为属性名时，该属性时公有属性不是私有属性，可以在类的外部访问，但是不会出现在for...in,for...of的循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。</span><br><span class="line">&#x2F;&#x2F;可以通过Object.getOwnPropertySymbols()和Reflect.ownKeys()取到。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义常量，保证唯一性</span><br><span class="line">const COLOR_RED &#x3D; Symbol(&quot;red&quot;);</span><br><span class="line">const MY_RED &#x3D; Symbol(&quot;red&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Symbol.for() </span><br><span class="line">&#x2F;&#x2F;作用：用于将描述相同的Symbol变量指向同一个Symbol值</span><br><span class="line">&#x2F;&#x2F;Symbol()定义的值每次都是新建的，即使描述相同值也不同</span><br><span class="line">&#x2F;&#x2F;Symbol.for() 会先检查给定的描述是否存在，不存在才会新建一个值，并将这个值登记在全局环境中供搜索。</span><br><span class="line">let a1 &#x3D; Symbol.for(&#39;a&#39;);</span><br><span class="line">let a2 &#x3D; Symbol.for(&#39;a&#39;);</span><br><span class="line">a1 &#x3D;&#x3D;&#x3D; a2 &#x2F;&#x2F;true</span><br><span class="line">typeof a1 &#x2F;&#x2F;&quot;symbol&quot;</span><br><span class="line">typeof a2 &#x2F;&#x2F;&quot;symbol&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Symbol.keyFor()</span><br><span class="line">&#x2F;&#x2F;检测Symbol值是否被登记过，返回一个已登记的Symbol类型值的key</span><br><span class="line">let a1 &#x3D; Symbol.for(&#39;a&#39;);</span><br><span class="line">Symbol.keyFor(a1); &#x2F;&#x2F;&quot;a&quot;</span><br><span class="line"></span><br><span class="line">let a2 &#x3D; Symbol(&#39;a&#39;);</span><br><span class="line">Symbol.keyFor(a2); &#x2F;&#x2F;undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Symbol的属性</span><br><span class="line">&#x2F;&#x2F;Symbol.peorotype.description 用于返回Symbol数据的描述</span><br><span class="line">let a &#x3D; Symbol(&quot;accc&quot;);</span><br><span class="line">a.description &#x2F;&#x2F;&quot;accc&quot;</span><br></pre></td></tr></table></figure>

<h3 id="排除Object中不需要的键值"><a href="#排除Object中不需要的键值" class="headerlink" title="排除Object中不需要的键值"></a>排除Object中不需要的键值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;a:1,b:2,c:3&#125;;</span><br><span class="line"></span><br><span class="line">const &#123;a,...rest&#125; &#x3D; obj; &#x2F;&#x2F;获取除了a之外的所有属性</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用reduce对象数组的某一个属性求和</span><br><span class="line">const obj &#x3D; [</span><br><span class="line">    &#123;name: &quot;lilei&quot;,score: 98&#125;,</span><br><span class="line">    &#123;name: &quot;hanmeimei&quot;,score: 90&#125;</span><br><span class="line">]</span><br><span class="line">const scoreTotal &#x3D; objs.reduce((total, obj) &#x3D;&gt; &#123;</span><br><span class="line">    return total + obj.score;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用reduce同时做到map和filter的作用</span><br><span class="line">const number &#x3D; [10,20,30,40];</span><br><span class="line">const doubledOver50 &#x3D; number.reduce((finalList, num) &#x3D;&gt; &#123;</span><br><span class="line">    num &#x3D; num * 2;</span><br><span class="line"></span><br><span class="line">    if(num &gt; 50) &#123;</span><br><span class="line">        finalList.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    return finalList;</span><br><span class="line">&#125;,[]);</span><br><span class="line">doubledOver50; &#x2F;&#x2F;[60, 80]</span><br></pre></td></tr></table></figure>

<h3 id="import-动态加载"><a href="#import-动态加载" class="headerlink" title="import() 动态加载"></a>import() 动态加载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;把import作为一个函数可以实现动态加载模块</span><br><span class="line">if(true) &#123;</span><br><span class="line">    import(&#39;.&#x2F;module.js).then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML语义化</title>
    <url>/2019/09/30/HTML%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>什么是HTML语义化？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据内容的结构化，选择合适的标签，便于开发者阅读和写出更优雅的代码的同时利于SEO的优化。</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要语义化？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；</span><br><span class="line">-  用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；</span><br><span class="line">- 有利于SEO ：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息： 爬虫依赖于</span><br><span class="line">标签来确定上下文和各个关键字的权重；</span><br><span class="line">- 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</span><br><span class="line">- 便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的</span><br><span class="line">团队都遵循这个标准，可以减少差异化。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>JS创建对象的几种方式</title>
    <url>/2019/08/13/JS%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="JS有哪几种创建对象的方式？"><a href="#JS有哪几种创建对象的方式？" class="headerlink" title="JS有哪几种创建对象的方式？"></a>JS有哪几种创建对象的方式？</h2><ul>
<li><p>对象字面量</p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Object构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; new Object()</span><br></pre></td></tr></table></figure></li>
<li><p>工厂模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    var o &#x3D; new Object()</span><br><span class="line">    o.age &#x3D; age</span><br><span class="line">    o.name &#x3D; name</span><br><span class="line">    o.say &#x3D; function() &#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">    return o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 缺点：每次通过Person创建对象的say方法都一样，却存储了多次，浪费资源</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person (name, age) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">    this.say &#x3D; function() &#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person(&#39;foolish&#39;, 18)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造函数在最后都会隐式返回return this，所以如果缺少new的时候，会将属性和方法</span><br><span class="line">添加给全局window对象，必须new，可以通过call和apply指定this。</span><br></pre></td></tr></table></figure></li>
<li><p>原型模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype.name &#x3D; &#39;foolish&#39;</span><br><span class="line">Person.prototype.say &#x3D; function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现了方法与属性的共享，可以动态添加对象的属性和方法。但是没有办法创建实例</span><br><span class="line">自己的属性和方法，也没有办法传递参数</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数和原型组合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person (name, age) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say &#x3D; function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person(&#39;hello&#39;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之箭头函数</title>
    <url>/2019/08/12/ES6%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="ES6之箭头函数"><a href="#ES6之箭头函数" class="headerlink" title="ES6之箭头函数"></a>ES6之箭头函数</h2><ul>
<li>默认值<br>  在ES6中给我们增加了默认值的操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a, b &#x3D; 1) &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr(1))</span><br><span class="line">&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>主动抛出错误 throw new Error(‘This is error’)</p>
</li>
<li><p>函数中的严格模式  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a,b&#x3D;1)&#123;</span><br><span class="line">    &#39;use strict&#39;</span><br><span class="line">    if(a &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        throw new Error(&#39;This is error&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">     return a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(add(1));</span><br></pre></td></tr></table></figure>
<p>  上面代码运行会出现报错，原因就是如果使用了默认值，再使用严格模式的话，就会<br>  有冲突，需要取消默认值的操作。</p>
</li>
<li><p>获得需要传递的参数个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">    &#39;use strict&#39;</span><br><span class="line">    if(a &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        throw new Error(&#39;This is error&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">     return a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(add.length); &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>
<p>  add.length 可以查看 必须 传递值的参数个数<br>  如果去掉严格模式，再第二个参数加上默认值的话，add.length的值就变成了1</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中判断数据类型</title>
    <url>/2019/07/16/JavaScript%E4%B8%AD%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="JavaScript中判断数据类型的几种方法"><a href="#JavaScript中判断数据类型的几种方法" class="headerlink" title="JavaScript中判断数据类型的几种方法"></a>JavaScript中判断数据类型的几种方法</h2><h4 id="一、typeof直接返回数据类型，但是无法判断数组、null、对象"><a href="#一、typeof直接返回数据类型，但是无法判断数组、null、对象" class="headerlink" title="一、typeof直接返回数据类型，但是无法判断数组、null、对象"></a>一、typeof直接返回数据类型，但是无法判断数组、null、对象</h4><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof 1</span><br><span class="line">&quot;number&quot;</span><br><span class="line"></span><br><span class="line">typeof NaN</span><br><span class="line">&quot;number&quot;</span><br><span class="line"></span><br><span class="line">typeof &quot;1&quot;</span><br><span class="line">&quot;string&quot;</span><br><span class="line"></span><br><span class="line">typeof true</span><br><span class="line">&quot;boolean&quot;</span><br><span class="line"></span><br><span class="line">typeof undefined</span><br><span class="line">&quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">typeof null</span><br><span class="line">&quot;object&quot;</span><br><span class="line"></span><br><span class="line">typeof []</span><br><span class="line">&quot;object&quot;</span><br><span class="line"></span><br><span class="line">typeof &#123;&#125;</span><br><span class="line">&quot;object&quot;</span><br></pre></td></tr></table></figure>
<pre><code>其中，null、[]、&#123;&#125;都返回“object”。null可是原始数据类型的啊，怎么就是&#39;object&#39;
了呢？？原来这个已经是历史问题了，在 JS 的最初版本中使用的是 32 位系统，为了性能
考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，
所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个
 Bug 却是一直流传下来。
</code></pre>
<h4 id="二、instanceof"><a href="#二、instanceof" class="headerlink" title="二、instanceof"></a>二、instanceof</h4><pre><code>检测的是 原型，只能用来判断两个对象是否属于实例关系，而不能判断
一个对象实例具体属于哪种类型
</code></pre>
<p><code>MDN: instanceof 运算符用于测试构造函数的prototype属性是否出现在对象的原型链中。</code></p>
<pre><code>f instanceof Foo 的判断逻辑为：
f 的 __proto__ 一层一层往上，是否能找到对应的Foo.prototype
之后再判断f instanceof Object

如何判断一个数组？
方法1：instanceof
arr instanceof Array

方法2：Array.isArray()
Array.isArray([])
</code></pre>
<h4 id="三、constructor"><a href="#三、constructor" class="headerlink" title="三、constructor"></a>三、constructor</h4><pre><code>当一个函数被定义时，JS引擎会为其添加prototype原型，然后再再prototype上添加一个
constructor属性，并让其指向该函数的引用，在实例对象的__proto__属性上面。

null 和 undefined 是无效的对象，因此是不会有constructor存在的，这两种类型需要其他方式
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function F()&#123;&#125;</span><br><span class="line">var f &#x3D; new F</span><br><span class="line">f.constructor &#x3D;&#x3D; F &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">F.prototype &#x3D; &#123;a:1&#125;</span><br><span class="line">var f &#x3D; new F</span><br><span class="line">f.constructor &#x3D;&#x3D; F &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>
<pre><code>函数的constructor是不稳定的，主要体现在自定义对象上，当开发者重写prototype时，
原有的constructor引用会丢失，constructor会默认为Object

因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证
对象实例的类型不被篡改
</code></pre>
<h4 id="四、使用Object-prototype-toString-call-判断"><a href="#四、使用Object-prototype-toString-call-判断" class="headerlink" title="四、使用Object.prototype.toString.call()判断"></a>四、使用Object.prototype.toString.call()判断</h4><pre><code>call()方法可以改变this的指向，把Object.prototype.toString.call()方法指向
不同的数据上面，返回不同的结果。
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(1)</span><br><span class="line">&quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(NaN);</span><br><span class="line">&quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&quot;1&quot;);</span><br><span class="line">&quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true)</span><br><span class="line">&quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null)</span><br><span class="line">&quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined)</span><br><span class="line">&quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(function a() &#123;&#125;);</span><br><span class="line">&quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([]);</span><br><span class="line">&quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;);</span><br><span class="line">&quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>

<p><code>最后我们可以定义一个完美的判断数据类型的方法_typeof()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function _typeof(obj)&#123;</span><br><span class="line">  var s &#x3D; Object.prototype.toString.call(obj);</span><br><span class="line">  return s.match(&#x2F;\[object (.*?)\]&#x2F;)[1].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_typeof([12,3,343]);</span><br><span class="line">&quot;array&quot;</span><br><span class="line"></span><br><span class="line">_typeof(&#123;name: &#39;zxc&#39;, age: 18&#125;);</span><br><span class="line">&quot;object&quot;</span><br><span class="line"></span><br><span class="line">_typeof(1);</span><br><span class="line">&quot;number&quot;</span><br><span class="line"></span><br><span class="line">_typeof(&quot;1&quot;);</span><br><span class="line">&quot;string&quot;</span><br><span class="line"></span><br><span class="line"> _typeof(null);</span><br><span class="line">&quot;null&quot;</span><br><span class="line"></span><br><span class="line">_typeof(undefined);</span><br><span class="line">&quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">_typeof(NaN);</span><br><span class="line">&quot;number&quot;</span><br><span class="line"></span><br><span class="line">_typeof(Date);</span><br><span class="line">&quot;function&quot;</span><br><span class="line"></span><br><span class="line">_typeof(new Date());</span><br><span class="line">&quot;date&quot;</span><br><span class="line"></span><br><span class="line">_typeof(new RegExp());</span><br><span class="line">&quot;regexp&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript什么时候必须加分号？</title>
    <url>/2019/08/07/JavaScript%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BF%85%E9%A1%BB%E5%8A%A0%E5%88%86%E5%8F%B7%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="JavaScript什么时候必须加分号？"><a href="#JavaScript什么时候必须加分号？" class="headerlink" title="JavaScript什么时候必须加分号？"></a>JavaScript什么时候必须加分号？</h2><ul>
<li><p>当一行代码以 ( 开头的时候，在前面补一个分号避免一些语法错误</p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function say() &#123;</span><br><span class="line">    console.log(&#39;hello world&#39;)</span><br><span class="line">&#125;</span><br><span class="line">say()</span><br><span class="line"></span><br><span class="line">;(function () &#123;</span><br><span class="line">    console.log(&#39;hello&#39;)</span><br><span class="line">&#125;</span><br><span class="line">)()</span><br></pre></td></tr></table></figure></li>
<li><p>当一行代码以 [ 开头的时候</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;[&#39;hello&#39;, &#39;world&#39;].forEach(function (item) &#123;</span><br><span class="line">    console.log(item)   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>当一行代码以 ` 开头的时候</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;&#96;hello&#96;.toString()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS垃圾回收机制</title>
    <url>/2019/10/19/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="谈谈JS垃圾回收机制？"><a href="#谈谈JS垃圾回收机制？" class="headerlink" title="谈谈JS垃圾回收机制？"></a>谈谈JS垃圾回收机制？</h2> <span id="more"></span>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><pre><code>Javascript中的内存管理是自动执行的，而且是不可见的。在我们创建基本类型、对象、函数
时，这些都需要内存，当不需要某样东西时，JavaScript引擎会利用垃圾回收机制清除它。

在局部作用域中，当函数执行完毕，局部变量也就没必要存在了，因此垃圾收集器很容易
做出判断回收。但是全局变量什么时候需要自动释放内存空间很难判断，因此在开发中，
需要尽量避免使用全局变量。
</code></pre>
<h4 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h4><p>JavaScript中内存管理的主要概念是可达性。</p>
<p>当一些值以某种方式可访问或可用，它们会被存储在内存中，叫做可达值。</p>
<ul>
<li>一些固有可达值，由于显而易见的原因无法删除。例如：<ul>
<li>本地函数的局部变量或参数</li>
<li>当前嵌套调用链上的其他函数的变量和参数</li>
<li>全局变量等</li>
</ul>
</li>
</ul>
<p>这些值 称为 根</p>
<ul>
<li>如果引用或引用链 可以从根访问任何其他值，则认为该值是可访问的。<ul>
<li>一个对象引用另一个对象的属性，则该对象是为可达性。</li>
</ul>
</li>
</ul>
<p>JavaScript引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除哪些不可访问的对象。</p>
<h4 id="内部算法"><a href="#内部算法" class="headerlink" title="内部算法"></a>内部算法</h4><p>v8的垃圾回收策略基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同<br>的算法。</p>
<p>新生代采用Scavenge算法(赋值算法)</p>
<ul>
<li><p>Scavenge为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分<br>为from和to两个空间。每次gc,会将from空间的存活对象复制到to空间。然后两个空间角色<br>对换(又称反转)。</p>
</li>
<li><p>该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。</p>
</li>
</ul>
<p>老生代采用Mark-Sweep(标记清除)和Mark-Compact(标记整理)</p>
<ul>
<li>标记-清除算法，定期执行一下“垃圾回收”步骤：<ul>
<li>垃圾回收器获取根并“标记”它们</li>
<li>然后访问并标记所有来自它们的引用</li>
<li>然后访问标记的对象 并 标记它们的引用</li>
<li>以此类推，知道有为访问的引用为止</li>
<li>除了标记的对象外，所有对象都被删除。</li>
</ul>
</li>
</ul>
<p>Mark-Compact算法(标记整理)</p>
<ul>
<li>标记清除存在一个问题，清除死亡对象后会造成内存空间不连续，这时候v8会使用<br>Mark-Compact算法(标记整理)，它会在标记完成之后将活着的对象往一端移动，移动完成<br>后直接清理掉边界外的内存。</li>
</ul>
<p>Reference Counting(引用计数算法)</p>
<ul>
<li>引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时<br>更新计数器，如果计数器值为0则直接回收内存。 很明显，引用计数最大的优势是暂停时间短</li>
</ul>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li><p>增量回收：如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费<br>一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分，然后<br>各个部分分别执行，这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。</p>
</li>
<li><p>空闲时间收集：垃圾回收器只在CPU空闲时运行，以减少对执行的可能影响。</p>
</li>
</ul>
<h4 id="v8的内存限制"><a href="#v8的内存限制" class="headerlink" title="v8的内存限制"></a>v8的内存限制</h4><ul>
<li>64位系统最大约为1.4G</li>
<li>32位系统最大约为0.7G</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery学习</title>
    <url>/2020/09/05/Jquery%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="jQuery学习"><a href="#jQuery学习" class="headerlink" title="jQuery学习"></a>jQuery学习</h2><h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><ul>
<li>jQuery入口函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    &#x2F;&#x2F;执行代码</span><br><span class="line">&#125;)</span><br><span class="line">或者（简写）</span><br><span class="line">$(function()&#123;</span><br><span class="line">    &#x2F;&#x2F;执行代码</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li>javascript入口函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    &#x2F;&#x2F;执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>jQuery的入口函数是在html的所有标签DOM都加载之后，就会执行包裹的代码，可以执行多次，并且不会覆盖上次。</li>
<li>javascript的window.onload事件是等到所有内容，包括外部图片之类的文件加载完成后，才会执行，只能执行一次，如果第二次会把第一次的执行覆盖。</li>
</ul>
<h3 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h3><ul>
<li><p>元素选择器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>id选择器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#test&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>class选择器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.test&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>属性选择器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;[href]&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>:empty 选择器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;:empty&quot;)</span><br><span class="line">&#x2F;&#x2F;选择空的元素，既不不含子元素也不包含文本的元素</span><br><span class="line">$(&quot;div:empty&quot;) &#x2F;&#x2F;选择div中为空的div元素</span><br></pre></td></tr></table></figure></li>
<li><p>:parent选择器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;td:parent&quot;)</span><br><span class="line">&#x2F;&#x2F;选取所有带有子元素或文本的&lt;td&gt;标签元素</span><br></pre></td></tr></table></figure></li>
<li><p>:contains 选择器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;div:contains(&#39;hello&#39;)&quot;)</span><br><span class="line">&#x2F;&#x2F;找到div中包含文本hello的指定元素</span><br></pre></td></tr></table></figure></li>
<li><p>:has选择器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;div:has(p)&quot;)</span><br><span class="line">&#x2F;&#x2F;找到包含p标签元素的div</span><br></pre></td></tr></table></figure></li>
<li><p>补充</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;:button&quot;) &#x2F;&#x2F;获取所有type为button的&lt;input&gt;元素和&lt;button&gt;元素，去掉冒号，只能获取&lt;button&gt;元素。</span><br></pre></td></tr></table></figure>
<h3 id="常用jQuery事件方法"><a href="#常用jQuery事件方法" class="headerlink" title="常用jQuery事件方法"></a>常用jQuery事件方法</h3></li>
<li><p>click() 点击事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).click(function()&#123;</span><br><span class="line">    $(this).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>dblclick() 双击事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).dblclick(function()&#123;</span><br><span class="line">    $(this).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>mouseenter() 鼠标指针穿过元素时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseenter(function()&#123;</span><br><span class="line">    alert(&quot;您的鼠标移到了p标签元素上！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>mouseleave() 鼠标指针离开元素时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseleave(function()&#123;</span><br><span class="line">    alert(&quot;您的鼠标离开了该p标签元素！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>mouseup() 当在元素上松开鼠标时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseup(()&#x3D;&gt;&#123;</span><br><span class="line">    alert(&quot;鼠标在p标签上松开！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>hover() 模拟光标悬停事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).hover(</span><br><span class="line">    function()&#123;</span><br><span class="line">        alert(&quot;你进入了p标签！&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function()&#123;</span><br><span class="line">        alert(&quot;你离开了p标签！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>focus()  当元素获得焦点时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;input&quot;).focus(function()&#123;</span><br><span class="line">    $(this).css(&quot;background-color&quot;,&quot;#ccc&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>blur() 当元素失去焦点时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;input&quot;).blur(function()&#123;</span><br><span class="line">    $(this).css(&quot;background-color&quot;,&quot;#fff&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>keypress,keydown,keyup</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取按键代码或ASCII码</span><br><span class="line">$(window).keydown(function(event)&#123;</span><br><span class="line">    &#x2F;&#x2F;通过event.which可以拿到按键代码，如果是keypress事件中则拿到ASCII码。</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;获取事件对象</span><br><span class="line">$(window).keypress(function(event)&#123;    </span><br><span class="line">    &#x2F;&#x2F;获取事件对象，里面包含各种有用的信息。</span><br><span class="line">    console.log(event);</span><br><span class="line">    &#x2F;&#x2F;console.log(event.which);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;keypress事件获取键入的字符</span><br><span class="line">$(window).keypress(function(event)&#123;</span><br><span class="line">    &#x2F;&#x2F;event.which是获取ASCII码，前面的函数是将ASCII码转换成字符，空格键和Enter键输出均为空白。</span><br><span class="line">    console.log(String.fromCharCode(event.which));</span><br><span class="line">    &#x2F;&#x2F;从event对象中key属性获取字符，但是Enter键的key值为&quot;Enter&quot;，空白键还是空白&quot; &quot;。</span><br><span class="line">    console.log(event.key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>off() 事件移除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).off() &#x2F;&#x2F;移除所有button元素身上绑定的事件</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).off(&quot;click&quot;) &#x2F;&#x2F;移除所有的click事件，移除指定类型</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).off(&quot;click&quot;, test) &#x2F;&#x2F;移除click事件中的test回调方法，移除指定类型的事件</span><br></pre></td></tr></table></figure></li>
<li><p>阻止事件冒泡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.son&quot;).click(function(event)&#123;</span><br><span class="line">    alert(&quot;son&quot;)</span><br><span class="line">    &#x2F;&#x2F;return false;</span><br><span class="line">    event.stopPropagation(); &#x2F;&#x2F;阻止事件冒泡</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;.father&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;father&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>阻止默认行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;a标签跳转、submit提交按钮等</span><br><span class="line">$(&quot;a&quot;).click(function(event)&#123;</span><br><span class="line">    alert(&quot;弹出注册框！&quot;);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>trigger()、triggerHandler() 自动触发事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;触发绑定到被选元素的所有事件</span><br><span class="line">$(&quot;.father&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;father&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.father&quot;).trigger(&quot;click&quot;);   &#x2F;&#x2F;方法一:会触发事件冒泡</span><br><span class="line">$(&quot;.father&quot;).triggerHandler(&quot;click&quot;); &#x2F;&#x2F;方法二:只触发事件，不会触发事件冒泡</span><br><span class="line">-------------------------------</span><br><span class="line">$(&quot;input[type&#x3D;&#39;submit&#39;]&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;submit&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;input[type&#x3D;&#39;submit&#39;]&quot;).trigger(&quot;click&quot;); &#x2F;&#x2F;方法一：触发事件的同时，还会触发默认行为。</span><br><span class="line">$(&quot;input[type&#x3D;&#39;submit&#39;]&quot;).triggerHandler(&quot;click&quot;) &#x2F;&#x2F;方法二：只触发事件，不触发默认行为。</span><br><span class="line">&#x2F;&#x2F;注意：这里&lt;a&gt;标签有点特殊，这两个方法都不会触发默认行为，如果想使用trigger()触发&lt;a&gt;标签的事件和默认行为的话，可以在&lt;a&gt;标签中添加一个&lt;span&gt;,例如&lt;a href &#x3D;&quot;#&quot;&gt;&lt;span&gt;百度&lt;&#x2F;span&gt;&lt;&#x2F;a&gt; 这种写法。</span><br></pre></td></tr></table></figure></li>
<li><p>自定义事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 想要自定义事件，必须满足两个条件</span><br><span class="line">* 1.事件必须是通过on绑定的</span><br><span class="line">* 2.事件必须通过trigger来触发</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).on(&quot;myClick&quot;,function()&#123;</span><br><span class="line">    alert(&quot;son&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).trigger(&quot;myClick&quot;);</span><br><span class="line">or</span><br><span class="line">$(&quot;.son&quot;).triggerHandler(&quot;myClick&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>事件命名空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 想要事件的命名空间有效，必须满足两个条件</span><br><span class="line">* 1.事件通过on来绑定(自定义事件)</span><br><span class="line">* 2.通过trigger()或者triggerHandler()来触发</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).on(&quot;eventName.zs&quot;,function()&#123;</span><br><span class="line">    alert(&quot;click zhangsan&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.son&quot;).on(&quot;eventName.ls&quot;,function()&#123;</span><br><span class="line">    alert(&quot;click lisi&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.son&quot;).trigger(&quot;click.zs&quot;);</span><br><span class="line">or</span><br><span class="line">$(&quot;.son&quot;).triggerHandler(&quot;click.zs&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="隐藏和显示"><a href="#隐藏和显示" class="headerlink" title="隐藏和显示"></a>隐藏和显示</h3><ul>
<li><p>hide() 隐藏html元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#hide&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>show() 显示html元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#show&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).show();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>语法 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(selector).hide(speed,callback);</span><br><span class="line"></span><br><span class="line">$(selector).show(speed,callback);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可选的speed参数表示规定显示&#x2F;隐藏的速度(slow、fast、毫秒)</span><br><span class="line">&#x2F;&#x2F;可选的callback参数是隐藏或显示完成后所执行的函数名称</span><br><span class="line"></span><br><span class="line">$(&quot;.hidebtn&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;div&quot;).hide(1000,&quot;linear&quot;,function()&#123;</span><br><span class="line">        alert(&quot;Hide() 方法已完成!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二个参数是一个字符串，表示过渡使用哪种缓动函数，jQuery自身提供(linear、swing)</span><br><span class="line">&#x2F;&#x2F;补充：callback函数名后面加上括号，会立刻执行函数体，而不是等到显示&#x2F;隐藏之后才执行,如add()作为callback参数会立即执行，而add作为参数则不会，callback函数可以是匿名函数，$(selector)选中的元素个数为n个，则callback函数会执行n次。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>toggle() 切换hide()和show()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).toggle();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><ul>
<li><p>fadeIn() 用于淡入以隐藏的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeIn(3000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法： $(selector).fadeIn(speed, callback)</span><br><span class="line">&#x2F;&#x2F; 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">&#x2F;&#x2F; 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure></li>
<li><p>fadeOut() 用于淡出可见元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeOut(&quot;slow&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法： $(selector).fadeOut(speed, callback)</span><br><span class="line">&#x2F;&#x2F; 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">&#x2F;&#x2F; 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure></li>
<li><p>fadeToggle() 用于在fadeIn()与fadeOut()方法之间进行切换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeToggle();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法： $(selector).fadeToggle(speed, callback)</span><br><span class="line">&#x2F;&#x2F; 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">&#x2F;&#x2F; 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure></li>
<li><p>fadeTo() 允许渐变为给定的不透明度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.3);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法：$(selector).fadeTo(speed, opacity, callback)</span><br><span class="line">&#x2F;&#x2F;必须的speed参数规定效果时长(slow、fast、毫秒)</span><br><span class="line">&#x2F;&#x2F;必须的opacity规定不透明度(介于0-1之间)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="滑动方法"><a href="#滑动方法" class="headerlink" title="滑动方法"></a>滑动方法</h3><ul>
<li><p>slideDown() 用于元素向下滑动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideDown();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法：$(selector).slideDown(speed,callback)</span><br><span class="line">&#x2F;&#x2F;可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">&#x2F;&#x2F;可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure></li>
<li><p>slideUp() 用于元素向上滑动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideUp();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法：$(selector).slideUp(speed,callback)</span><br><span class="line">&#x2F;&#x2F;可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">&#x2F;&#x2F;可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure></li>
<li><p>slideToggle() 在slideDown()与slideUp()方法之间进行切换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideToggle();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法：$(selector).slideToggle(speed,callback)</span><br><span class="line">&#x2F;&#x2F;可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">&#x2F;&#x2F;可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul>
<li><p>animate()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;默认情况下，所有html元素都有一个静态位置，且无法移动。</span><br><span class="line">&#x2F;&#x2F;先将p标签元素设置为position:relative&#x2F;absolute&#x2F;fixed</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;p&quot;).animate(&#123;</span><br><span class="line">      left:&#39;250px&#39;,</span><br><span class="line">      opacity:&#39;0.5&#39;,</span><br><span class="line">      height:&#39;400px&#39;,</span><br><span class="line">      width: &#39;400px&#39;,</span><br><span class="line">      paddingLeft:&#39;10px&#39;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法： $(selector).animate(&#123;params&#125;,speed,callback)</span><br><span class="line">&#x2F;&#x2F; params参数可以操作几乎所有的css属性，但名字要采用camel标记法</span><br></pre></td></tr></table></figure></li>
<li><p>stop() 停止动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $(&quot;#flip&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;#panel&quot;).slideDown(5000);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">$(&quot;#stop&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;#panel&quot;).stop();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">语法: $(selector).stop(stopAll,goToEnd)</span><br><span class="line">&#x2F;&#x2F;可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停&#x2F;止活动的动画，允许任何排入队列的动画向后执行。</span><br><span class="line">&#x2F;&#x2F;可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。</span><br></pre></td></tr></table></figure></li>
<li><p>jQuery方法链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;)</span><br><span class="line">  .slideUp(2000)</span><br><span class="line">  .slideDown(2000);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jQuery获取内容和属性"><a href="#jQuery获取内容和属性" class="headerlink" title="jQuery获取内容和属性"></a>jQuery获取内容和属性</h3><ul>
<li><p>获取内容 text()、html()、val()</p>
<ul>
<li>text() 设置或返回所选元素的文本内容</li>
<li>html() 设置或返回所选元素的内容(包括html标记)</li>
<li>val() 设置或返回表单字段的值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).text());</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;-----------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).html())</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;------------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  alert($(&quot;input&quot;).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>获取属性 attr()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;项目QC刚用过</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    console.log($(&quot;p&quot;).attr(&quot;data-text&quot;));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>补充：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prop()函数返回相应属性或空字符串。</span><br><span class="line">attr()函数返回相应属性或undefined</span><br><span class="line">1.对于HTML元素本身就带有的固有属性，在处理时使用prop方法</span><br><span class="line">2.对HTML元素我们自己定义的DOM属性，在处理时使用attr方法</span><br><span class="line">3.具有true和false两个属性的属性，如checked、selected或者disabled使用prop()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置内容和属性"><a href="#设置内容和属性" class="headerlink" title="设置内容和属性"></a>设置内容和属性</h3><ul>
<li><p>设置内容 text()、html()、val()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).text(&quot;hello&quot;));</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;-----------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).html(&quot;hello&quot;))</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;------------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  alert($(&quot;input&quot;).val(&quot;hello&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>text()、html() 以及 val() 的回调函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).text(function(i,orignText)&#123;</span><br><span class="line">        &#x2F;&#x2F;i 为被选元素列表中当前元素的下标</span><br><span class="line">        &#x2F;&#x2F;orignText 为原来的值</span><br><span class="line">        &#x2F;&#x2F;return 为返回的新值</span><br><span class="line"></span><br><span class="line">        return &quot;hello&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>设置属性 attr()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).attr(&quot;data-text&quot;,&quot;hello world&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 允许同时设置多个属性</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).attr(&#123;</span><br><span class="line">        &quot;data-text&quot;,&quot;hello world&quot;,</span><br><span class="line">        &quot;title&quot;,&quot;jQuery学习！&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>attr() 也存在回调函数(同上)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;#runoob&quot;).attr(&quot;href&quot;, function(i,origValue)&#123;</span><br><span class="line">    return origValue + &quot;&#x2F;jquery&quot;; </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><ul>
<li><p>removeAttr()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;span&quot;).removeAttr(&quot;class name&quot;);</span><br><span class="line">&#x2F;&#x2F;表示同时删除span标签的class和name属性</span><br></pre></td></tr></table></figure></li>
<li><p>removeProp()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;span&quot;).removeProp(&quot;class&quot;);</span><br><span class="line">&#x2F;&#x2F;表示删除所有span标签的class属性</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jQuery-添加元素"><a href="#jQuery-添加元素" class="headerlink" title="jQuery 添加元素"></a>jQuery 添加元素</h3><ul>
<li><p>append/prepend 是在选择元素内容嵌入(文本或标签)</p>
</li>
<li><p>after/before 实在元素外部追加(文本或标签)</p>
</li>
<li><p>参数可以是多个，可以是一个list</p>
</li>
</ul>
<h3 id="jQuery-删除元素"><a href="#jQuery-删除元素" class="headerlink" title="jQuery 删除元素"></a>jQuery 删除元素</h3><ul>
<li><p>remove() 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).remove()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;remove() 方法删除被选元素及其子元素</span><br></pre></td></tr></table></figure></li>
<li><p>empty() 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).empty()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;empty() 方法删除被选元素的子元素而不删除自身</span><br></pre></td></tr></table></figure></li>
<li><p>过滤被删除的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).remove(&quot;.italic&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示删除所有&lt;p&gt;标签元素中class &#x3D; &quot;italic&quot;的元素</span><br><span class="line">&#x2F;&#x2F;过滤时，只能作用于同级元素之间</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jQuery-获取并设置CSS类"><a href="#jQuery-获取并设置CSS类" class="headerlink" title="jQuery 获取并设置CSS类"></a>jQuery 获取并设置CSS类</h3><ul>
<li><p>addClass() 向不用的元素添加class属性，在添加类时可以选取多个元素,也可以设置多个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">	$(&quot;h1, h3, p&quot;).addClass(&quot;fontColor fontSize&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>removeClass() 在不同元素中删除指定的class属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">	$(&quot;h1, h3, p&quot;).removeClass(&quot;fontSize&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>toggleClass() 对被选元素进行添加/删除类的切换操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.btn2&quot;).click(function()&#123;</span><br><span class="line">	$(&quot;h1, h3, p&quot;).toggleClass(&quot;fontColor2&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="css-方法"><a href="#css-方法" class="headerlink" title="css() 方法"></a>css() 方法</h3><ul>
<li>返回css属性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).css(&quot;background-color&quot;);</span><br></pre></td></tr></table></figure></li>
<li>设置css属性,可以同时设置多个<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).css(&#123;&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><ul>
<li><p>width()、height()</p>
<ul>
<li>width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）</li>
<li>height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).width() &#x2F;&#x2F;获取</span><br><span class="line">$(&quot;p&quot;).width(20) &#x2F;&#x2F;设置</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>innerWidth()、innerHeight()</p>
<ul>
<li>innerWidth() 方法返回元素的宽度（包括内边距）。</li>
<li>innerHeight() 方法返回元素的高度（包括内边距）。</li>
</ul>
</li>
<li><p>outerWidth()、outerHeight()</p>
<ul>
<li>outerWidth() 方法返回元素的宽度（包括内边距和边框）。</li>
<li>outerHeight() 方法返回元素的高度（包括内边距和边框）。</li>
</ul>
</li>
<li><p>offset()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.son&quot;).offset().left &#x2F;&#x2F;元素距离窗口的偏移距离</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).offset(&#123;</span><br><span class="line">    left: 20,</span><br><span class="line">&#125;) &#x2F;&#x2F;设置元素距离窗口的偏移距离</span><br></pre></td></tr></table></figure></li>
<li><p>position()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.son&quot;).position().left &#x2F;&#x2F;获取元素距离定位元素的偏移距离</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意点：position() 方法只能获取不能设置</span><br></pre></td></tr></table></figure></li>
<li><p>scrollTop() </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;scroller&quot;).scrollTop() &#x2F;&#x2F;获取元素相对滚动条顶部的偏移</span><br><span class="line"></span><br><span class="line">$(&quot;scroller&quot;).scrollTop(300) &#x2F;&#x2F;设置元素相对滚动条顶部的偏移</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取网页滚动的偏移(考虑兼容)</span><br><span class="line">$(&quot;body&quot;).scrollTop() + $(&quot;html&quot;).scrollTop() &#x2F;&#x2F;ie-&gt;body,chrome...-&gt;html</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置网页滚动的偏移(考虑兼容)</span><br><span class="line">$(&quot;html,body&quot;).scrollTop(300) </span><br></pre></td></tr></table></figure></li>
<li><p>补充：设置了box-sizing后，width()=width - padding - border</p>
</li>
</ul>
<h3 id="jQuery遍历"><a href="#jQuery遍历" class="headerlink" title="jQuery遍历"></a>jQuery遍历</h3><h4 id="祖先"><a href="#祖先" class="headerlink" title="祖先"></a>祖先</h4><ul>
<li><p>parent() 返回元素的直接父元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>parents() 返回被选元素的所有祖先元素，直到文档根元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents();</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;过滤所有祖先，并且是&lt;ul&gt;元素</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents(&quot;ul&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>parentsUntil() 返回给定的两个元素之间的所有祖先元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;返回&lt;span&gt;与&lt;div&gt;元素之间的所有祖先元素</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parentsUntil(&quot;div&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="后代"><a href="#后代" class="headerlink" title="后代"></a>后代</h4><ul>
<li><p>children() 返回被选元素的所有直接子元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;div&quot;).children();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以使用可选参数来过滤子元素的搜索</span><br><span class="line">$(&quot;div&quot;).children(&quot;p.aaa&quot;); &#x2F;&#x2F;返回类名为aaa的&lt;p&gt;元素，且是div的直接子元素。</span><br></pre></td></tr></table></figure></li>
<li><p>find() 返回被选元素的后代元素，一路向下直到最后一个后代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;div&quot;).find(&quot;span&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="同胞"><a href="#同胞" class="headerlink" title="同胞"></a>同胞</h4><ul>
<li><p>siblings() 返回被选元素的所有同胞元素，可以使用可选参数过滤搜索。</p>
</li>
<li><p>next() 返回被选元素的下一个同胞元素，只返回一个元素</p>
</li>
<li><p>nextAll() 返回被选元素的所有跟随的同胞元素</p>
</li>
<li><p>nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素</p>
</li>
<li><p>pre()、prevAll()、prevUntil() 同上，方向相反</p>
</li>
</ul>
<h4 id="过滤：缩小搜索元素的范围"><a href="#过滤：缩小搜索元素的范围" class="headerlink" title="过滤：缩小搜索元素的范围"></a>过滤：缩小搜索元素的范围</h4><ul>
<li><p>first() 返回被选元素的首个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).first();</span><br></pre></td></tr></table></figure></li>
<li><p>last() 返回被选元素的最后一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).last();</span><br></pre></td></tr></table></figure></li>
<li><p>eq() 返回被选元素中带有指定索引号的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).eq(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;索引号从0开始，eq(1)选择的是第二个&lt;p&gt;元素</span><br></pre></td></tr></table></figure></li>
<li><p>filter() 允许规定一个标准，返回匹配的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).filter(&quot;.className&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回带有类名className的所有&lt;p&gt;元素</span><br></pre></td></tr></table></figure></li>
<li><p>not() 返回所有不匹配的元素，与filter()相反</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).not(&quot;.className&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回所有不带有类名className的&lt;p&gt;元素</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之http</title>
    <url>/2019/09/06/Node-js%E4%B9%8Bhttp/</url>
    <content><![CDATA[<h3 id="创建一个简单的http服务"><a href="#创建一个简单的http服务" class="headerlink" title="创建一个简单的http服务"></a>创建一个简单的http服务</h3><span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;加载http核心模块</span><br><span class="line">var http &#x3D; require(&#39;http&#39;)</span><br><span class="line"></span><br><span class="line">var server &#x3D; http.createServer()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;服务器要做的处理事情</span><br><span class="line">server.on(&#39;request&#39;, function() &#123;</span><br><span class="line">    console.log(&#39;收到客户端的请求了&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绑定端口号，启动服务器</span><br><span class="line">server.listen(3000, function()&#123;</span><br><span class="line">    console.log(&#39;server start.....&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;)</span><br><span class="line"></span><br><span class="line">var server &#x3D; http.createServer()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;request 请求处理函数，需要接受两个参数</span><br><span class="line">server.on(&#39;request&#39;, function(request, response) &#123;</span><br><span class="line">&#x2F;&#x2F;  request 请求对象</span><br><span class="line">&#x2F;&#x2F;  请求对象可以获取客户端的一些请求信息，如请求路径</span><br><span class="line">    console.log(&#39;收到客户端的请求了,路径是：&#39;+ request.url)</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;  response 响应对象</span><br><span class="line">&#x2F;&#x2F;  响应数据只能是二进制数据或者字符串</span><br><span class="line">&#x2F;&#x2F;  响应对象可以用开给客户端发送响应消息</span><br><span class="line">&#x2F;&#x2F;  response对象中：write给客户端发送响应数据，最后使用end结束</span><br><span class="line">    response.write(&#39;hello&#39;)</span><br><span class="line">    response.write(&#39; nodejs &#39;)</span><br><span class="line">    response.end(request.url)</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;  或者直接end的同时发送响应数据：</span><br><span class="line">&#x2F;&#x2F;  response.end(&#39;hello nodejs&#39;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(3000, function()&#123;</span><br><span class="line">    console.log(&#39;server start.....&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Content-Type设置编码"><a href="#Content-Type设置编码" class="headerlink" title="Content-Type设置编码"></a>Content-Type设置编码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;)</span><br><span class="line">var server &#x3D; http.createServer()</span><br><span class="line"></span><br><span class="line">server.on(&#39;request&#39;,function (req,res) &#123;</span><br><span class="line">    &#x2F;&#x2F;设置服务器响应内容的编码</span><br><span class="line">    res.setHeader(&#39;Content-Type&#39;,&#39;text&#x2F;plain;charset&#x3D;utf-8&#39;)</span><br><span class="line">    res.end(&#39;hello 世界&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000, function () &#123;</span><br><span class="line">    console.log(&#39;server is running...&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之mongoDB</title>
    <url>/2019/09/09/Node-js%E4%B9%8BmongoDB/</url>
    <content><![CDATA[<h2 id="开启MongoDB服务器"><a href="#开启MongoDB服务器" class="headerlink" title="开启MongoDB服务器"></a>开启MongoDB服务器</h2><span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod</span><br></pre></td></tr></table></figure>

<h2 id="连接MongoDB服务器"><a href="#连接MongoDB服务器" class="headerlink" title="连接MongoDB服务器"></a>连接MongoDB服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>

<h2 id="退出MongoDB服务器"><a href="#退出MongoDB服务器" class="headerlink" title="退出MongoDB服务器"></a>退出MongoDB服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li><p>show dbs</p>
<ul>
<li>查看显示所有数据库</li>
</ul>
</li>
<li><p>db</p>
<ul>
<li>产看当前操作的数据库</li>
</ul>
</li>
<li><p>use 数据库名称</p>
<ul>
<li>切换到指定的数据库（没有会新建）</li>
</ul>
</li>
<li><p>show collections</p>
<ul>
<li>显示集合</li>
</ul>
</li>
<li><p>db.cats.find()</p>
<ul>
<li>查看并显示内容</li>
</ul>
</li>
<li><p><a href="https://github.com/mongodb/node-mongodb-native">node中使用mongodb</a></p>
</li>
</ul>
<h2 id="使用第三方mongoose来操作MongoDB数据库"><a href="#使用第三方mongoose来操作MongoDB数据库" class="headerlink" title="使用第三方mongoose来操作MongoDB数据库"></a>使用第三方mongoose来操作MongoDB数据库</h2><ul>
<li><p><a href="https://mongoosejs.com/">mongoose</a></p>
</li>
<li><p>安装<br><code>npm install mongoose</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引入包</span><br><span class="line">const mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">&#x2F;&#x2F;连接数据库（数据库不需要存在，在插入第一条语句，就会自动创建）</span><br><span class="line"></span><br><span class="line">mongoose.connect(&#39;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;test&#39;, &#123;useNewUrlParser: true&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设计数据库集合结构</span><br><span class="line">&#x2F;&#x2F;创建一个Cat表</span><br><span class="line">const Cat &#x3D; mongoose.model(&#39;Cat&#39;, &#123; name: String &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例化一个Cat，实例对象为kitty</span><br><span class="line">const kitty &#x3D; new Cat(&#123; name: &#39;Zildjian&#39; &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;持久化保存kitty实例</span><br><span class="line">kitty.save().then(() &#x3D;&gt; console.log(&#39;meow&#39;));</span><br></pre></td></tr></table></figure>

<ul>
<li>mongoose的基本使用</li>
</ul>
<ul>
<li>生成模型构造函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">var Schema &#x3D; mongoose.Schema;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设计集合结构（表结构）schema---&gt;提要，纲要</span><br><span class="line">&#x2F;&#x2F;字段名称就是表结构中的属性名称</span><br><span class="line">&#x2F;&#x2F;值类型</span><br><span class="line">&#x2F;&#x2F;约束的目的：为了保证数的完整性</span><br><span class="line">var blogSchema &#x3D; new Schema(&#123;</span><br><span class="line">  title:  String,</span><br><span class="line">  author: String,</span><br><span class="line">  body:   String,</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    required: true</span><br><span class="line">  &#125;,</span><br><span class="line">  password: &#123;</span><br><span class="line">    typte: String,</span><br><span class="line">    required: true      </span><br><span class="line">  &#125;</span><br><span class="line">  comments: [&#123; body: String, date: Date &#125;],</span><br><span class="line">  date: &#123; type: Date, default: Date.now &#125;,</span><br><span class="line">  hidden: Boolean,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    votes: Number,</span><br><span class="line">    favs:  Number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将文档结构发布为模型</span><br><span class="line">&#x2F;&#x2F; 参数一：大写单数表示数据库名称</span><br><span class="line">&#x2F;&#x2F;         mongoose会自动将大写单数改为小写复数</span><br><span class="line">&#x2F;&#x2F; 参数二： 架构 Schema</span><br><span class="line">&#x2F;&#x2F; 返回值： 模型构造函数</span><br><span class="line">var User &#x3D; mongoose.model(&#39;User&#39;, blogSchema)</span><br><span class="line">&#x2F;&#x2F; module.exports &#x3D; mongoose.model(&#39;Student&#39;, blogSchema)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>基于模型构造函数 生成添加一条数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var admin &#x3D; new User(&#123;</span><br><span class="line">    username: &#39;admin&#39;,</span><br><span class="line">    password: &#39;1245435&#39;,</span><br><span class="line">    ....</span><br><span class="line">&#125;)</span><br><span class="line">admin.save(function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#39;保存失败&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#39;保存成功&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>基于模型构造函数 查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查询所有数据</span><br><span class="line">User.find(function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">         console.log(&#39;查询失败&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;promise 查询所有</span><br><span class="line">User.find()</span><br><span class="line">    .then(function(data)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">&#x2F;&#x2F;按条件查询</span><br><span class="line"> User.find(&#123;</span><br><span class="line">    username: &#39;xx&#39;</span><br><span class="line"> &#125;, function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#39;查询失败&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;查找符合条件的第一个（可以写多个条件）,没有条件的话，为第一条数据</span><br><span class="line"> User.findOne(&#123;</span><br><span class="line">    username: &#39;xx&#39;</span><br><span class="line"> &#125;, function(err, ret)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#39;查询失败&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>基于模型构造函数 按条件更新数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Model.update(conditions, doc, [options], [callback])</span><br><span class="line">&#x2F;&#x2F;Model.findOneAndUpdate([conditions], [update], [options], [callback])</span><br><span class="line">User.findByIdAndUpdate(&#39;5a7d8f2sd78ag6g&#39;,&#123;</span><br><span class="line">    username: &#39;zs&#39;</span><br><span class="line">&#125;, function(err, ret)&#123;</span><br><span class="line">   if(err)&#123;</span><br><span class="line">       console.log(&#39;更新失败&#39;)</span><br><span class="line">    else &#123;</span><br><span class="line">       console.log(&#39;更新成功&#39;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>基于模型构造函数 删除数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User.remove(&#123;</span><br><span class="line">    username: &#39;zs&#39;</span><br><span class="line">&#125;, function(err, ret)&#123;</span><br><span class="line">   if(err)&#123;</span><br><span class="line">       console.log(&#39;查询失败&#39;)</span><br><span class="line">    else &#123;</span><br><span class="line">       console.log(ret)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="补充（node使用mysql）"><a href="#补充（node使用mysql）" class="headerlink" title="补充（node使用mysql）"></a>补充（node使用mysql）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引包</span><br><span class="line">var mysql      &#x3D; require(&#39;mysql&#39;);</span><br><span class="line">&#x2F;&#x2F;创建连接</span><br><span class="line">var connection &#x3D; mysql.createConnection(&#123;</span><br><span class="line">  host     : &#39;localhost&#39;,</span><br><span class="line">  user     : &#39;me&#39;,</span><br><span class="line">  password : &#39;secret&#39;,</span><br><span class="line">  database : &#39;my_db&#39;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;连接数据库</span><br><span class="line">connection.connect();</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;执行数据操作,可以直接使用 SQL 语句</span><br><span class="line"> &#x2F;&#x2F;查找</span><br><span class="line">connection.query(&#39;SELECT * FROM &#96;users&#96;&#39;, function (error, results, fields) &#123;</span><br><span class="line">  if (error) throw error;</span><br><span class="line">  console.log(&#39;The solution is: &#39;, results[0].solution);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加</span><br><span class="line"> connection.query(&#39;INSERT INTO users VALUES(NULL, &quot;admin&quot;:&quot;123&quot;)&#39;, function (error, results, fields) &#123;</span><br><span class="line">   if (error) throw error;</span><br><span class="line">   console.log(&#39;The solution is: &#39;, results[0].solution);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#x2F;&#x2F;关闭数据库</span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之实现读写文件操作</title>
    <url>/2019/08/29/Node.js%E4%B9%8B%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="用nodejs实现读取文件操作"><a href="#用nodejs实现读取文件操作" class="headerlink" title="用nodejs实现读取文件操作"></a>用nodejs实现读取文件操作</h2><span id="more"></span>
<pre><code> const fs = require(&quot;fs&quot;)
 
//fs 核心模块提供了一个fs.readFile方法，用来读取指定目录下的文件

//fs.readFile有三个参数
// 1. 读取文件的路径
// 2. 读取文件的编码格式
// 3. 当文件读取完成，调用这个callback回调函数来读取文件的结果

fs.readFile(&#39;./data/hello.txt&#39;,&#39;utf-8&#39;,function(err,data)&#123;
    if(err)&#123;
        console.log(err)    //第一个参数是err对象
        return
    &#125; else &#123;
        console.log(data)   //第二个参数才是data数据    
    &#125;
&#125;)
</code></pre>
<h2 id="用nodejs实现写入文件操作"><a href="#用nodejs实现写入文件操作" class="headerlink" title="用nodejs实现写入文件操作"></a>用nodejs实现写入文件操作</h2><pre><code>const fs = require(&#39;fs&#39;)

let msg = &#39;hello world&#39;

//fs.writeFile有三个参数
// 1. 第一个参数为写入的文件路径
// 2. 第二个参数为写入的内容
// 3. 第三个参数为可选参数，表示写文件的编码格式
// 4. 第四个参数为回调函数，回调函数只有一个参数err，判断是否写入成功。

fs.writeFile(&#39;./data/hello.txt&#39;,msg,&#39;utf-8&#39;,function(err)&#123;
    if(err)&#123;
        console.log(&#39;写入错误&#39; + err)
    &#125; else &#123;
        console.log(&#39;ok&#39;)
    &#125;
&#125;)
</code></pre>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之特性</title>
    <url>/2019/08/29/Node.js%E4%B9%8B%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么?"></a>Node.js是什么?</h3><ul>
<li><p>Node.js是一个JavaScript运行时环境，可以解析和执行js代码。</p>
<span id="more"></span></li>
<li><p>构建于 Chrome 的V8引擎之上</p>
</li>
<li><p>没有BOM、DOM，有EcmaScript语法。</p>
</li>
<li><p>node中有很多具名的核心模块</p>
<ul>
<li>fs 文件操作模块</li>
<li>http 服务器构建模块</li>
<li>path 路径模块</li>
<li>os 操作系统信息模块</li>
</ul>
</li>
<li><p>在核心模块中提供了一些服务器级别的操作API</p>
<ul>
<li>文件读写</li>
<li>网络服务的构建</li>
<li>网络通信</li>
<li>http服务器<!--more-->
<h3 id="node都有哪些特性？"><a href="#node都有哪些特性？" class="headerlink" title="node都有哪些特性？"></a>node都有哪些特性？</h3></li>
</ul>
</li>
<li><p>单线程</p>
<ul>
<li>不会为每个用户连接创建一个新的线程，仅仅使用一个线程，减少了操作系统的线程创建<br>和销毁的时间开销。缺点就是一个用户造成线程的崩溃会导致整个服务的崩溃。</li>
<li>减少内存的开销</li>
</ul>
</li>
<li><p>事件驱动 event-driven</p>
<ul>
<li>node中一个时刻只能执行一个事件回调函数，但是执行过程中，可以转而处理<br>其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。</li>
</ul>
</li>
<li><p>非阻塞I/O</p>
<ul>
<li>I/O数据传输操作会阻塞代码的执行，极大降低了程序的执行效率,因为一个线程只能处理<br>一项任务，要想提高吞吐量必须通过多线程。非阻塞I/O机制，可以将异步操作的处理<br>代码放在回调函数中，从而提高了程序的执行效率。</li>
</ul>
</li>
</ul>
<h3 id="浏览器的进程和线程"><a href="#浏览器的进程和线程" class="headerlink" title="浏览器的进程和线程"></a>浏览器的进程和线程</h3><ul>
<li>一个程序可以有多个进程</li>
<li>一个进程可以有多个线程</li>
<li>进程在执行u欧城中拥有独立的内存单元，而多个线程共享内存。</li>
<li>多个线程之间可以相互通信</li>
<li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口</li>
<li>线程不能独立执行，必须依存在应用程序中</li>
</ul>
<h3 id="Node-js适合开发什么？"><a href="#Node-js适合开发什么？" class="headerlink" title="Node.js适合开发什么？"></a>Node.js适合开发什么？</h3><ul>
<li>善于I/O,不善于计算，因为Node.js最擅长的就是任务调度，不适合于利用CPU进行过多的运算的程序。</li>
<li>当应用程序需要处理大量并发的I/O,而在向客户端发出响应之前，应用程序内部不需要<br>进行非常复杂处理的时候，Node.js非常合适。</li>
<li>Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。<ul>
<li>用户表单</li>
<li>考试系统</li>
<li>聊天室</li>
<li>图文直播</li>
</ul>
</li>
</ul>
<h3 id="nodejs能做什么？"><a href="#nodejs能做什么？" class="headerlink" title="nodejs能做什么？"></a>nodejs能做什么？</h3><ul>
<li>Node.js可以生成动态页面内容</li>
<li>Node.js可以创建，打开，读取，写入，删除和关闭服务器上的文件</li>
<li>Node.js可以收集表单数据</li>
<li>Node.js可以添加，删除，修改数据库中的数据</li>
</ul>
<h3 id="服务端渲染和客户端渲染的区别"><a href="#服务端渲染和客户端渲染的区别" class="headerlink" title="服务端渲染和客户端渲染的区别"></a>服务端渲染和客户端渲染的区别</h3><ul>
<li>客户端渲染不利于SEO搜索引擎优化</li>
<li>服务器渲染可以被爬虫抓取</li>
<li>例如：京东商品列表是服务端渲染，用户评论是客户端渲染（提高用户体验）</li>
</ul>
<h4 id="小补充：使用cnpm"><a href="#小补充：使用cnpm" class="headerlink" title="小补充：使用cnpm"></a>小补充：使用cnpm</h4><ul>
<li>方法一 安装cnpm<ul>
<li><code>npm install --global cnpm</code></li>
</ul>
</li>
<li>方法二 改变registry<ul>
<li><code>npm install jquery --registry=https://registry.npm.taobao.org</code></li>
</ul>
</li>
<li>方法三 加入配置选项<ul>
<li><code>npm config set registry https://registry.npm.taobao.org</code></li>
<li><code>npm config list</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2019/08/12/Promise/</url>
    <content><![CDATA[<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><span id="more"></span>
<pre><code>promise: 用来解决两个问题：
    1. 回调地狱，代码难以维护，不易阅读。
    2. promise可以支持多个并发的请求，获取并发请求中的数据。
    
Promise对象有三个状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)
Promise状态一旦改变，结果就定死了，就不会再变了。

all方法：
    所有异步操作都执行成功，才会执行成功的回调，有一个失败就会执行失败的回调。
    
race方法：
    谁先执行完就返回谁的状态和回调。
    
finally() 允许指定最终的逻辑 （ES9新特性）
一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。而在某些情况下
想要在无论成功还是失败运行相同的代码，例如：清除，删除对话，关闭数据库连接等。
这时，.finally()可以允许你指定最终的逻辑

function doSomething() &#123;
    doSomething1()
    .then(doSomething2)
    .then(doSomething3)
    .catch(err =&gt; &#123;
        console.log(arr)
    &#125;)
    .finally(() =&gt; &#123;
        // 最终执行逻辑
    &#125;)
&#125;

=========================
</code></pre>
<p>   //实例演示(node中读取文件)：<br>   var fs = require(‘fs’)<br>   var p1 = new Promise(function(resolve, reject){<br>    fs.readFile(‘./data/a.txt’, ‘utf8’, function(err, data){<br>        if(err){<br>            reject(err)<br>        } else {<br>            resolve(data)<br>        }<br>    })<br>   })</p>
<p>   var p2 = new Promise(function(resolve, reject){<br>       fs.readFile(‘./data/b.txt’, ‘utf8’, function(err, data){<br>           if(err){<br>               reject(err)<br>           } else {<br>               resolve(data)<br>           }<br>       })<br>      })</p>
<p>   // 返回promise对象时，可以进行链式调用<br>   p1<br>   .then(function(data){<br>    console.log(data)<br>    return p2<br>   }, function(err){<br>    console.log(‘读取文件失败’, err)<br>   })<br>   .then(function(data){<br>    console.log(data)<br>    //return p3<br>   },function(err){<br>    console.log(err)<br>   )</p>
<p>   =====================<br>   //用promise封装node中readFile API<br>   var fs = require(‘fs’)</p>
<p>   function ReadFile(filePath){<br>    return new Promise(function(resolve, reject){<br>        fs.readFile(filePath, ‘utf8’, function(err, data){<br>            if(err){<br>                reject(err)<br>            } else {<br>                resolve(data)<br>            }<br>        })<br>    })<br>   }</p>
<p>   ReadFile(‘./data/a.txt’)<br>   .then(function(data){<br>    console.log(data)<br>   })</p>
<p>   ========================</p>
<p>   //promise封装ajax中get请求<br>   function pGet(url, callback){<br>    return new Promise(function(resolve, reject){<br>        var xhr = new XMLHttpRequest()<br>        xhr.onload = function(){<br>            callback &amp;&amp; callback(JSON.parse(xhr.responseText))<br>            resolve(JSON.parse(xhr.responseText))<br>        }<br>        xhr.onerror = function(err){<br>            reject(err)<br>        }<br>        xhr.open(“get”, url, true) //为true则是异步执行<br>        xhr.send()<br>    })<br>   }</p>
<p>手写promise</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myPromise(constructor)&#123;</span><br><span class="line">    let self&#x3D;this;</span><br><span class="line">    self.status&#x3D;&quot;pending&quot; &#x2F;&#x2F;定义状态改变前的初始状态</span><br><span class="line">    self.value&#x3D;undefined;&#x2F;&#x2F;定义状态为resolved的时候的状态</span><br><span class="line">    self.reason&#x3D;undefined;&#x2F;&#x2F;定义状态为rejected的时候的状态</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        &#x2F;&#x2F;两个&#x3D;&#x3D;&#x3D;&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status&#x3D;&#x3D;&#x3D;&quot;pending&quot;)&#123;</span><br><span class="line">          self.value&#x3D;value;</span><br><span class="line">          self.status&#x3D;&quot;resolved&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        &#x2F;&#x2F;两个&#x3D;&#x3D;&#x3D;&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status&#x3D;&#x3D;&#x3D;&quot;pending&quot;)&#123;</span><br><span class="line">          self.reason&#x3D;reason;</span><br><span class="line">          self.status&#x3D;&quot;rejected&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;捕获构造异常</span><br><span class="line">    try&#123;</span><br><span class="line">       constructor(resolve,reject);</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">       reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同时再myPromise的原型上定义链式调用的then方法：</span><br><span class="line"></span><br><span class="line">myPromise.prototype.then&#x3D;function(onFullfilled,onRejected)&#123;</span><br><span class="line">   let self&#x3D;this;</span><br><span class="line">   switch(self.status)&#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2019/07/29/Vue/</url>
    <content><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h4 id="vue的特点（优点）"><a href="#vue的特点（优点）" class="headerlink" title="vue的特点（优点）"></a>vue的特点（优点）</h4><ul>
<li>vue关注视图层，用数据操作的方式代替了dom操作</li>
<li>vue通过响应式的数据绑定实现了数据和视图之间的更新交互</li>
<li>vue通过组件化开发让工程结构更加明确，更易于维护</li>
<li>vue通过虚拟DOM，优化了DOM操作，实现了性能提高</li>
<li>vue拥有自己的vue-cli脚手架工具，对良好的工程化性能</li>
</ul>
<h4 id="Vue的双向数据绑定原理是什么？"><a href="#Vue的双向数据绑定原理是什么？" class="headerlink" title="Vue的双向数据绑定原理是什么？"></a>Vue的双向数据绑定原理是什么？</h4><pre><code>vue.js 是采用 数据劫持 结合 发布-订阅者 模式的方式，通过Object.defineProperty()
来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：
1.当把一个普通JavaScript对象传给Vue实例当作它的data选项的时候，Vue会遍历它的属性，
用Object.defineProperty劫持各个属性的setter、getter，给这个对象的某一个值赋值，
就会触发setter，就能监听到数据的变化
2. compile解析模板指令，将模板中的变量替换成数据，然后渲染页面视图，并将每个指令对应的
节点添加监听数据的订阅者Watcher，一旦数据由变动，收到通知更新视图
3. 通过Observer来监听model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭
起Observer和Compile之间的桥梁，达到数据变化-&gt;视图更新，视图变化-&gt;数据更新。
</code></pre>
<span id="more"></span>

<h4 id="Proxy-与-Object-defineProperty-优劣对比？"><a href="#Proxy-与-Object-defineProperty-优劣对比？" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比？"></a>Proxy 与 Object.defineProperty 优劣对比？</h4><ul>
<li>Proxy的优势如下：<ul>
<li>Proxy可以监听对象，而Object.defineProperty只能监听属性。</li>
<li>Proxy还可以直接监听数组的变化。</li>
<li>Proxy有多大13种的拦截方法，不限于apply、ownKeys、deletePreperty等，这些<br>都是Object.defineProperty不具备的。</li>
<li></li>
</ul>
</li>
<li>Object.defineProperty的优势：<ul>
<li>兼容性好，支持IE9，而Proxy存在浏览器兼容问题。</li>
</ul>
</li>
</ul>
<h4 id="解释单向数据流和双向数据绑定"><a href="#解释单向数据流和双向数据绑定" class="headerlink" title="解释单向数据流和双向数据绑定"></a>解释单向数据流和双向数据绑定</h4><pre><code>单向数据流： 数据流是单向的，数据流动方向可以追踪，流动单一，追查问题可以更加方便快捷，
缺点就是写起来不太方便，要是UI发生变更就必须创建各种action来维护对应的state

双向数据绑定： 数据之间是相同的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的
场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，添加了出错debug的难度
</code></pre>
<h4 id="请详细说下你对Vue生命周期的理解？"><a href="#请详细说下你对Vue生命周期的理解？" class="headerlink" title="请详细说下你对Vue生命周期的理解？"></a>请详细说下你对Vue生命周期的理解？</h4><pre><code>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后

    beforeCreate 创建前执行（vue实例的挂载元素$el和数据对象data都为undefined，还未初始化）
    
    created 完成创建 （完成了data数据初始化，el还未初始化）
    
    beforeMount 载入前（vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。）
    
    mounted 载入后html已经渲染(vue实例挂载完成，data.message成功渲染。)
    
    beforeUpdate 更新前状态（view层的数据变化前，不是data中的数据改变前）
    
    updated 更新状态后
    
    beforeDestroy 销毁前
    
    destroyed 销毁后 （在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在）
    

说一下每一个阶段可以做的事情
    
    beforeCreate:可以在这里加一个loading事件，在加载实例时触发。
    
    created: 初始化完成时的事件写这里，如果这里结束了loading事件，异步请求也在这里调用。
    
    mounted: 挂载元素，获取到DOM节点
    
    updated: 对数据进行处理的函数写这里。
    
    beforeDestroy: 可以写一个确认停止事件的确认框。
    
</code></pre>
<h4 id="vue-router有哪几种导航钩子？"><a href="#vue-router有哪几种导航钩子？" class="headerlink" title="vue-router有哪几种导航钩子？"></a>vue-router有哪几种导航钩子？</h4><pre><code>三种

1. 全局导航钩子（跳转前进行判断拦截）

    + to: Route:即将要进入的目标 路由对象
    + from: Route:当前导航正要离开的路由
    + next: Function: 一定要调用该方法来resolve这个钩子，执行结果依赖于next方法的调用参数
        - next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。
        
        - next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。
        
        - next(&#39;/&#39;) 或者 next(&#123; path: &#39;/&#39; &#125;): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。
        
        - next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。
       

    router.beforeEach(to, from, next),  //全局前置守卫
    
    router.beforeResolve(to, from, next),   //全局解析守卫，在 2.5.0+ 
    你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 
    类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，
    解析守卫就被调用。
    
    router.afterEach(to, from )    //全局后置守卫，钩子不会接受 next 函数也不会改变导航本身

2. 组件内钩子

    beforeRouteEnter(to, from, next)    //跳转到这个组件时
    
    beforeRouteUpdate(to, from, next)   //当前路由改变，但是该组件被复用时调用
    
    beforeRouteLeave(to, from, next)    //离开这个组件时

3. 单独路由独享组件
    用法同全局守卫，只是将其写进其中一个路由对象中，只在这个路由下起作用。

    beforeEnter(to, from, next)
    
    
完整的导航解析流程：

    1. 导航被触发。
    2. 在失活的组件里调用离开守卫。
    3. 调用全局的 beforeEach 守卫。
    4. 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
    5. 在路由配置里调用 beforeEnter。
    6. 解析异步路由组件。
    7. 在被激活的组件里调用 beforeRouteEnter。
    8. 调用全局的 beforeResolve 守卫 (2.5+)。
    9. 导航被确认。
    10. 调用全局的 afterEach 钩子。
    11. 触发 DOM 更新。
    12. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
    
</code></pre>
<h4 id="动态路由定义和获取？"><a href="#动态路由定义和获取？" class="headerlink" title="动态路由定义和获取？"></a>动态路由定义和获取？</h4><pre><code>在 router 目录下的 index.js 文件中，对 path 属性加上 /:id。

使用 router 对象的 params.id 获取
</code></pre>
<h4 id="key值的作用？"><a href="#key值的作用？" class="headerlink" title="key值的作用？"></a>key值的作用？</h4><pre><code>key是为了高效的实现DOM渲染。
</code></pre>
<h4 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h4><pre><code>1.v-bind绑定一个value属性，监听message
2.v-on指令给当前元素绑定input事件
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--等价于下面--&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type&#x3D;&quot;text&quot;</span><br><span class="line">    v-bind:value&#x3D;&quot;message&quot;</span><br><span class="line">    v-on:input&#x3D;&quot;message&#x3D;$event.target.value&quot;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-model-修饰符"><a href="#v-model-修饰符" class="headerlink" title="v-model 修饰符"></a>v-model 修饰符</h4><ul>
<li>1.lazy 修饰符<ul>
<li>1.1 默认情况下，v-model默认是在input事件中同步输入框的数据的</li>
<li>1.2 一旦有数据发生改变对应的data中的数据就会自动发生改变</li>
<li>1.3 lazy是修饰符可以让数据在失去焦点或者回车时才会更新</li>
</ul>
</li>
<li>2.number 修饰符<ul>
<li>2.1 默认情况下，在输入框中我们输入数字还是字母，都会被当作字符串类型进行处理</li>
<li>2.2 但是如果我们希望处理的是是数字类型，那么最好直接将内容当作数字处理</li>
<li>2.3 number修饰符可以让输入框中输入的内容自动转成数字类型</li>
</ul>
</li>
<li>3.trim 修饰符（移除的字符包括空格、行终止符、制表符、换行符、回车符、换页符等）<ul>
<li>如果输入的内容首尾有很多空格，通常我们希望将其去除</li>
<li>trim修饰符可以过滤内容左右两边的空格</li>
<li>补充：str.replace(/\s/g, “”); //去除字符串所有空格</li>
</ul>
</li>
</ul>
<h4 id="v-on-修饰符"><a href="#v-on-修饰符" class="headerlink" title="v-on 修饰符"></a>v-on 修饰符</h4><ul>
<li><p>.stop 调用event.stopPropagation()</p>
</li>
<li><p>.prevent 调用event.preventDefault()</p>
</li>
<li><p>.{keyCode|keyAlias} 只当事件是从特定键触发时才触发回调</p>
</li>
<li><p>.native 监听组件根元素的原生事件</p>
</li>
<li><p>.once 只能触发一次回调</p>
</li>
</ul>
<h4 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set"></a>Vue.set</h4><pre><code>//Vue中不允许动态添加根级别的响应式属性，Vue.set方法可以向嵌套对象添加
响应式属性。
//参数一：要修改的对象
//参数二：索引值
//参数三：修改后的值

Vue.set(vm.obj, 2, &#39;b&#39;)
vm.$set(vm.obj, 2, &#39;b&#39;)
</code></pre>
<h4 id="vue-router使用params与query传参有什么区别？"><a href="#vue-router使用params与query传参有什么区别？" class="headerlink" title="vue-router使用params与query传参有什么区别？"></a>vue-router使用params与query传参有什么区别？</h4><pre><code>vue-router可以通过params与query进行传参
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;传递</span><br><span class="line">this.$router.push(&#123;path: &#39;.&#x2F;xxx&#39;, params: &#123;xx:xxx&#125;&#125;)</span><br><span class="line">this.$router.push(&#123;path: &#39;.&#x2F;xxx&#39;, query: &#123;xx:xxx&#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接受</span><br><span class="line">this.$route.params</span><br><span class="line">this.$route.query</span><br></pre></td></tr></table></figure>
<ul>
<li><p>params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系</p>
</li>
<li><p>params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题</p>
</li>
</ul>
<h4 id="Vue如何取出URL中的"><a href="#Vue如何取出URL中的" class="headerlink" title="Vue如何取出URL中的 #"></a>Vue如何取出URL中的 <code>#</code></h4><pre><code>vue-router 默认使用hash模式，所以路由加载时候，项目中的url会自带#，如果不想使用#，可以使用
vue-router 的另一种模式history

new Router (&#123;
    mode: &#39;history&#39;,
    routes: []
&#125;)
</code></pre>
<h4 id="对MVC、MVVM的理解？"><a href="#对MVC、MVVM的理解？" class="headerlink" title="对MVC、MVVM的理解？"></a>对MVC、MVVM的理解？</h4><pre><code>1. MVC：所有的通信都是单向的

    View传送指令到Controller
    Controller 完成业务逻辑后，要求Model改变状态
    Model将新的数据发送到View，用户得到反馈
    
2.MVVM（类似MVP——Model View Presenter）

    View层：视图层
    Model层：数据层
    ViewModel层：视图模型层
        视图模型层时view和model沟通的桥梁
        一方面实现了Data Binding，数据绑定，将model的改变实时反应到view中
        另一方面实现了DOM Listener，也就是DOM监听，发生事件改变，改变对应的data
       
    一种前端架构模式，model为数据模型，view为视图UI层,view和model之间
    并没有直接的联系，通过viewmodel实现双向数据的绑定。各部分通信都是双向的
    因此开发者只需关注业务层，无需手动操作DOM，无需关心数据状态的同步问题，复杂
    的数据状态维护完全由MVVM来统一管理。
    采用双向数据绑定，View的变动自动反应在ViewModel，反之亦然
</code></pre>
<h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><pre><code>为什么需要虚拟DOM？

    浏览器加载一个HTML文件需要做那些事？
    创建DOM tree ——&gt; 创建CSS tree ——&gt; 构建Render tree ——&gt; 布局Layout ——&gt; 绘制Painting
    如果用传统的原生api或jQuery操作DOM时，浏览器会从构建DOM树开始从头到尾
    执行一边流程，就会浪费掉很多性能。
    
1. state数据

2.（JSX）模板

3. 数据 + 模板生成虚拟DOM（虚拟DOM就是一个JS对象，用来描述真实的DOM）

4. 用虚拟DOM的结构生成真实的DOM来显示

5. state数据发生改变

6. 数据 + 模板生成新的虚拟DOM

7. 比较原始虚拟DOM和新的虚拟DOM的区别，找到不同点
    通过diff算法，将不同的比较内容结果保存到本地的一个js对象中，最终一次性
    的将这个js对象attach应用到DOM树上，通知浏览器执行绘制工作，避免了大量的
    无畏计算。

8. 直接操作DOM，改变内容。
</code></pre>
<h4 id="nextTick的应用场景"><a href="#nextTick的应用场景" class="headerlink" title="nextTick的应用场景"></a>nextTick的应用场景</h4><pre><code>Vue.nextTick 用于延迟执行一段代码，它的回调函数会在DOM更新完成后调用。

在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调
函数中

在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于
徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。

原理：
        nextTick实际上就是创建一个新的宏任务，vue中双向绑定的数据赋值时需要调用
    watcher的update方法(比如某个div绑定了一个数据，那么该div就会生成一个
    watcher，而update的方法就是更新自身的innerHTML，当然中间还有一层虚拟DOM)，
    而watcher的update就是通过nextTick来执行的。
</code></pre>
<h4 id="Vue组件中data为什么必须是函数？"><a href="#Vue组件中data为什么必须是函数？" class="headerlink" title="Vue组件中data为什么必须是函数？"></a>Vue组件中data为什么必须是函数？</h4><pre><code>如果data是一个对象，那么 由于对象本身属于引用类型，当我们修改其中一个属性值的之后，
会影响到所有Vue实例的数据。如果将data作为一个函数返回一个对象，那么每一个实例的data
属性都是独立的，相互不会影响。例如：在同一个组件复用的时候，就类似给每个组件实例
创建了一个私有的数据空间，让各自的组件实例维护各自的数据。
</code></pre>
<h4 id="计算属性computed、watch和事件methods有什么区别？"><a href="#计算属性computed、watch和事件methods有什么区别？" class="headerlink" title="计算属性computed、watch和事件methods有什么区别？"></a>计算属性computed、watch和事件methods有什么区别？</h4><pre><code>computed： 计算属性是会基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时
才会重新求值。

computed属性有两个方法：set、get
`fullName: &#123;
    //赋值
    set: function(newValue)&#123;const names = newValue.split(&#39; &#39;);
    this.firstName = names[0];this.lastName = names[1];&#125;,//一般用不着,使用的时候有参数
    //取值
    get: function()&#123;return this.firstName + &#39; &#39; + this.lastName&#125;
&#125;
`

watch：更多的的是观察作用，类似于某些数据的监听回调，每当监听的数据变化时都
会执行相应的回调进行后续的操作。

method：不管数据是否改变，只要发生重新渲染，methods都会调用执行。
</code></pre>
<ul>
<li>运用场景：<ul>
<li>当需要进行数值计算，并且依赖于其他数据时，应该使用computed，利用computed的<br>缓存特性，避免每次获取值时，都需要重新计算。</li>
<li>当需要在数据变化时执行异步或者开销较大的操作时，使用watch。</li>
</ul>
</li>
</ul>
<h4 id="Vue父子组件之间如何传值？"><a href="#Vue父子组件之间如何传值？" class="headerlink" title="Vue父子组件之间如何传值？"></a>Vue父子组件之间如何传值？</h4><pre><code>父组件从后端获取数据，vue官方推荐使用axios来进行前后端交互，使用
axios.get(),返回一个Promise，然后用.then()在里面写个接收函数来接受返回值ret，
ret的返回值就可以对应的赋值给data里面定义的key-value值。

父传子： 在父组件中使用的子组件标签上通过 v-bind:xxx=&quot;&quot;,然后再回到子组件中，
通过props&#123;list: Array&#125;来接收从父组件传过来的值，接收的值就可以在子组件中使用，
这样就完成了将数据传输到子组件的全过程。

子传父： 子组件向父组件传值一般都是通过事件决定，例如click，当子组件上绑定
被点击事件触发时，可以在这个触发事件的函数中，使用vue自带的
this.$emit(&#39;父组件接收的事件名&#39;， 要传输的参数)，然后再父组件中使用的子组件
标签上通过 @事件名 = &#39;func&#39;，然后再父组件的method中补全这个func，然后func
中将从子组件中传递过来的值赋给父组件的data中，这样就完成了子组件向父组件传值了。

props 数据验证：

`不支持驼峰标识，驼峰需要改成 **-** 连接 的形式`

1.都支持哪数据类型?
    String、Number、Boolean、Array、Object、Date、Function、Symbol
2.props也支持自定义类型：
Vue.component(&#39;my-component&#39;, &#123;
    props: &#123;
        //基础类型检查（&#39;null&#39;匹配任何类型）
        propA: Number,
        //多个可能的值类型
        propB: [String, Number],
        //是否是必填的字符串
        propC: &#123;
            type: String,
            required: true
        &#125;,
        //带有默认值的数字
        propD: &#123;
            type: Number,
            default: 100
        &#125;,
        //对象或数组默认值必须从一个工厂函数获取
        propE: &#123;
            type: Object,
            default: function()&#123;
                return &#123;&#125;
            &#125;
            ========
            type: Array,
            default: function()&#123;
                return []
            &#125;
        &#125;,
        //自定义验证函数
        propF: &#123;
            validate: function(value)&#123;
                return [&#39;success&#39;,&#39;warning&#39;,&#39;danger&#39;].indexOf(value)!== -1
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<h4 id="为什么需要浅拷贝？"><a href="#为什么需要浅拷贝？" class="headerlink" title="为什么需要浅拷贝？"></a>为什么需要浅拷贝？</h4><pre><code>js变量的引用类型在进行复制操作的时候会复制地址，导致两个变量指向同一份数据。

在对一个对象进行操作并且不希望影响原对象的时候，应该先进行拷贝操作。
</code></pre>
<h4 id="父子组件的访问方式"><a href="#父子组件的访问方式" class="headerlink" title="父子组件的访问方式"></a>父子组件的访问方式</h4><ul>
<li><p>父组件访问子组件： </p>
<ul>
<li>$children ——用的比较少</li>
<li>$refs ——用的较多</li>
</ul>
</li>
<li><p>子组件访问父组件：</p>
<ul>
<li>$parent ——用的较少</li>
</ul>
</li>
<li><p>子组件访问根组件：</p>
<ul>
<li>$root ——用的较多</li>
</ul>
</li>
</ul>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><ul>
<li>插槽</li>
<li>具名插槽</li>
<li>作用域插槽：父组件替换插槽的标签，但是内容有子组件来提供。</li>
</ul>
<h4 id="keep-alive-遇见-vue-router"><a href="#keep-alive-遇见-vue-router" class="headerlink" title="keep-alive 遇见 vue-router"></a>keep-alive 遇见 vue-router</h4><ul>
<li><p>keep-alive是vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染</p>
<ul>
<li>两个重要的属性：</li>
<li>include - 字符串或正则表达，只有匹配的组件会被缓存</li>
<li>exclude - 字符串或正则表达，任何匹配的组件不会被缓存</li>
</ul>
</li>
<li><p>router-view 也是一个组件，如果直接被包在keep-aive里面，所有路径匹配的视图组件<br>都会被缓存。</p>
</li>
<li><p>对应两个钩子函数activated和deactivated，当组件被激活时，触发activated，组件<br>被移除时，触发deactivated。</p>
</li>
</ul>
<h4 id="为什么选择axios？"><a href="#为什么选择axios？" class="headerlink" title="为什么选择axios？"></a>为什么选择axios？</h4><ul>
<li><p>axios：ajax i/o system(个人理解)</p>
</li>
<li><p>尤大 在2016-11-3，公告以后vue-resource不再维护，官方推荐新的ajax库用axios。</p>
</li>
<li><p>功能特点</p>
<ul>
<li>在浏览器中发送XMLHttpRequest请求</li>
<li>在node.js中发送http请求</li>
<li>支持Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="谈谈对-Vue-SSR-的理解"><a href="#谈谈对-Vue-SSR-的理解" class="headerlink" title="谈谈对 Vue SSR 的理解"></a>谈谈对 Vue SSR 的理解</h4><ul>
<li><p>SSR大致的意思就是vue在客户端将标签渲染成的整个html片段的工作在服务端<br>完成，服务端形成html片段直接返回给客户端这个过程就交租服务端渲染。</p>
</li>
<li><p>服务端渲染SSR的优缺点：</p>
<ul>
<li>优点：<ul>
<li><p>更好的SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具<br>并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面<br>通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面<br>（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</p>
</li>
<li><p>首屏加载更快：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开<br>始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；<br>SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，<br>所以 SSR 有更快的内容到达时间；</p>
</li>
</ul>
</li>
<li>缺点：<ul>
<li>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个<br>钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中<br>运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA<br>不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：更多的服务器负载：在 Node.js 中渲染完整的应用程序，<br>显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源<br>(CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic )<br>下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="你有对Vue项目进行哪些优化？"><a href="#你有对Vue项目进行哪些优化？" class="headerlink" title="你有对Vue项目进行哪些优化？"></a><a href="https://juejin.im/post/5d548b83f265da03ab42471d">你有对Vue项目进行哪些优化？</a></h4><ul>
<li><p>代码层面的优化：</p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>合理使用 computed 和 watch</li>
<li>v-for 遍历必须为item添加 key，且避免同时使用v-if</li>
<li>长列表性能优化(通过Object.freeze冻结一个对象，之后就不能修改了，避免了Object<br>.defineProperty对数据的劫持)</li>
<li>事件的销毁(在js中使用addEventListener等方式创建的事件不会自动销毁，需要手动<br>移除对这些事件的监听，避免造成内存泄漏)</li>
<li>图片资源懒加载(vue-lazyload插件)</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
</li>
<li><p>Webpack层面的优化</p>
<ul>
<li>webpack对图片进行压缩</li>
<li>多个页面的公共代码抽离成单独的文件</li>
</ul>
</li>
<li><p>基础的Web技术优化</p>
<ul>
<li>开启gzip压缩</li>
<li>浏览器缓存</li>
<li>CDN的使用</li>
<li>使用Chrome Performance查找性能瓶颈</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/2019/08/23/TypeScript/</url>
    <content><![CDATA[<h3 id="什么是TypeScript？"><a href="#什么是TypeScript？" class="headerlink" title="什么是TypeScript？"></a>什么是TypeScript？</h3><span id="more"></span>
<ul>
<li><p>TypeScript是JavaScript的超集，任何合法的js程序都是合法的TypeScript程序</p>
</li>
<li><p>TypeScript通过向JavaScript增加可选的静态类型声明把JavaScript变成强类型程序<br>语言</p>
</li>
<li><p>提供静态类型声明可约束函数、变量、属性等程序实体</p>
</li>
</ul>
<h3 id="为什么要使用TypeScript？"><a href="#为什么要使用TypeScript？" class="headerlink" title="为什么要使用TypeScript？"></a>为什么要使用TypeScript？</h3><ol>
<li><p>提供了静态类型系统，大大增强了代码的可读性以及可维护性</p>
</li>
<li><p>提供最新和不断发展的javascript特性，能让我们建立 更健壮的组件</p>
</li>
<li><p>TS具有防患于未然的静态检查，以及干净利落的只能提示</p>
</li>
</ol>
<h3 id="TypeScript中的数据类型"><a href="#TypeScript中的数据类型" class="headerlink" title="TypeScript中的数据类型"></a>TypeScript中的数据类型</h3><blockquote>
<p>typescript中为了使编写的代码更规范，更利于维护，增加了类型校验，在typescript中<br>主要提供了以下数据类型：</p>
</blockquote>
<ul>
<li>布尔类型 bolean</li>
<li>数字类型 number</li>
<li>字符串类型 string</li>
<li>数组类型 array</li>
<li>元组类型 tuple</li>
<li>枚举类型 enum</li>
<li>任意类型 any</li>
<li>null和undefined</li>
<li>void类型</li>
<li>never类型</li>
</ul>
<blockquote>
<p>typescript中为了使编写的代码更规范，更有利于维护，增加了类型校验，写ts代码必须指定类型</p>
</blockquote>
<h3 id="未声明类型的变量-如果变量在声明的时候，未指定其类型，那么他会被识别为任意类"><a href="#未声明类型的变量-如果变量在声明的时候，未指定其类型，那么他会被识别为任意类" class="headerlink" title="未声明类型的变量: 如果变量在声明的时候，未指定其类型，那么他会被识别为任意类"></a>未声明类型的变量: 如果变量在声明的时候，未指定其类型，那么他会被识别为任意类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let something;</span><br><span class="line"></span><br><span class="line">something &#x3D; &#39;seven&#39;</span><br><span class="line"></span><br><span class="line">something &#x3D; 7</span><br><span class="line">&#x2F;&#x2F;不会报错</span><br></pre></td></tr></table></figure>

<h3 id="如果没有明确的指定类型，那么typescript会依照类型推论的规则推导出一个规则"><a href="#如果没有明确的指定类型，那么typescript会依照类型推论的规则推导出一个规则" class="headerlink" title="如果没有明确的指定类型，那么typescript会依照类型推论的规则推导出一个规则"></a>如果没有明确的指定类型，那么typescript会依照类型推论的规则推导出一个规则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let num &#x3D; &#39;seven&#39;</span><br><span class="line">num &#x3D; 7</span><br><span class="line">&#x2F;&#x2F;会报错</span><br><span class="line">&#x2F;&#x2F;上面代码等价于：</span><br><span class="line">let num:string &#x3D; &#39;seven&#39;</span><br><span class="line">num &#x3D; 7</span><br><span class="line">&#x2F;&#x2F;typescript自动推测出num属于string类型</span><br></pre></td></tr></table></figure>

<h3 id="联合类型：表示取值可以为多种类型中的一种"><a href="#联合类型：表示取值可以为多种类型中的一种" class="headerlink" title="联合类型：表示取值可以为多种类型中的一种"></a>联合类型：表示取值可以为多种类型中的一种</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let flag:string | number</span><br><span class="line">flag &#x3D; &#39;seven&#39;</span><br><span class="line">flag &#x3D; 7</span><br><span class="line">&#x2F;&#x2F;联合类型使用 | 分隔每个类型，表示允许flag为string类型或者number类型</span><br><span class="line">---------------------------------------</span><br><span class="line">&#x2F;&#x2F;访问联合类型的属性或者方法</span><br><span class="line">&#x2F;&#x2F;当typescript不确定一个联合类型的变量到底是哪个类型的时候，</span><br><span class="line">我们只能访问联合类型的所有类型中共有的属性和方法</span><br><span class="line"></span><br><span class="line">function getLength(something:string|number):number&#123;</span><br><span class="line">    return something.length</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;上面代码会报错，因为length不是string和number共有的属性</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以访问共有属性toString()</span><br><span class="line">function getString(something:string|number):string &#123;</span><br><span class="line">    return something.toString()</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------</span><br><span class="line">&#x2F;&#x2F;联合属性在赋值的时候，会根据类型推论的规则推断出一个类型</span><br><span class="line">let a:string|number</span><br><span class="line">a &#x3D; &#39;seven&#39;</span><br><span class="line">console.log(a.length) &#x2F;&#x2F;5，a被推断为string，有length属性</span><br><span class="line">a &#x3D; 7</span><br><span class="line">console.log(a.length) &#x2F;&#x2F;编译时报错，被推断为number，无length属性</span><br></pre></td></tr></table></figure>

<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数组类型定义(不允许出现其他类型，数组方法参数也有限制，</span><br><span class="line">如push(&#39;7&#39;)会报错，不能为字符串)</span><br><span class="line">let arr:number[] &#x3D; [1,2,3]</span><br><span class="line">let arr:(number | string)[] &#x3D; [1,&#39;1&#39;,2]</span><br><span class="line">---------------------------------</span><br><span class="line">&#x2F;&#x2F;数组泛型</span><br><span class="line">let arr:Array&lt;number&gt; &#x3D; [1,2,3]</span><br><span class="line">----------------------------------</span><br><span class="line">&#x2F;&#x2F;用接口表示数组</span><br><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index:number]:number</span><br><span class="line">&#125;</span><br><span class="line">let arr:NumberArray &#x3D; [1,2,3]</span><br><span class="line">&#x2F;&#x2F;NumberArray表示，只要index的类型时number，那么值的类型也必须时number</span><br><span class="line">-----------------------------------</span><br><span class="line">&#x2F;&#x2F;any在数组中的应用</span><br><span class="line">let arr:any[] &#x3D; [&#39;hello&#39;, 24, &#123;a:1&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;函数声明（不允许输入多余或者少于要求的参数）</span><br><span class="line">function sum(x:number, y: number):number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">sum(1,2) &#x2F;&#x2F;right</span><br><span class="line">sum(1,2,3) &#x2F;&#x2F;false</span><br><span class="line">sum(1) &#x2F;&#x2F;false</span><br><span class="line">----------------------------------------------</span><br><span class="line">&#x2F;&#x2F;函数表达式</span><br><span class="line">let sum:(x:number, y: number) &#x3D;&gt; number &#x3D; function(x:number, y:number):number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line">&#x2F;&#x2F;可选参数（使用 ? 表示可选的参数，只能放在参数的最后，后面不允许出现必须参数）</span><br><span class="line">function buildName(firstName:string, lastName?:string):string &#123;</span><br><span class="line">    if (lastName) &#123;</span><br><span class="line">        return firstName + &#39; &#39; + lastName</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return firstName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat &#x3D; buildName(&#39;tom&#39;, &#39;cat&#39;)</span><br><span class="line">let tom &#x3D; buildName(&#39;tom&#39;)</span><br><span class="line">--------------------------------------------------</span><br><span class="line">&#x2F;&#x2F;参数默认值（typescript会将添加了默认值的参数识别为可选参数）</span><br><span class="line">    function buildName(firstName:string, lastName:string &#x3D; &#39;cat&#39;):string &#123;</span><br><span class="line">        if (lastName) &#123;</span><br><span class="line">            return firstName + &#39; &#39; + lastName</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return firstName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tomcat &#x3D; buildName(&#39;tom&#39;, &#39;cat&#39;)</span><br><span class="line">    let tom &#x3D; buildName(&#39;tom&#39;)</span><br><span class="line">----------------------------------------------------</span><br><span class="line">&#x2F;&#x2F;剩余参数，可以使用...rest的方式获取函数中的剩余参数</span><br><span class="line">function push(array: any[], ...items:any[]) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let a &#x3D; []</span><br><span class="line">push(a, 1,2,3,4)</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">&#x2F;&#x2F;重载：允许一个函数接受不同数量或者类型的参数时，做出不同的处理</span><br><span class="line">&#x2F;&#x2F;例如，数字或者字符串的反转输出</span><br><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));</span><br><span class="line">    &#125; else if (typeof x &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ts</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex &amp; Redux工作流程</title>
    <url>/2019/09/18/Vuex-Redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Vue-核心原理"><a href="#Vue-核心原理" class="headerlink" title="Vue 核心原理"></a>Vue 核心原理</h2><span id="more"></span>

<img src="https://raw.githubusercontent.com/foolishmax/static/master/images/vuex.png" width="450" />

<ul>
<li><p>Store : 统一的状态管理容器对象</p>
</li>
<li><p>Vue Components : Vue组件</p>
</li>
<li><p>dispatch : 操作行为触发方法，是唯一能执行action的方法</p>
</li>
<li><p>actions : 操作行为处理模块。 负责处理Vue Components接收的所有交互行为，</p>
</li>
<li><p>commit : 状态改变提交操作方法，对mutation进行提交，是唯一能执行mutation<br>的方法</p>
</li>
<li><p>mutation : 状态改变操作方法，Vuex中修改state的唯一推荐方法，该方法只能<br>进行同步操作</p>
</li>
<li><p>getter : state对象读取方法，类似computed计算属性。</p>
</li>
</ul>
<blockquote>
<p>过程：Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要<br>改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，<br>重新渲染Vue Components，界面随之更新。</p>
</blockquote>
<h2 id="Redux-核心原理"><a href="#Redux-核心原理" class="headerlink" title="Redux 核心原理"></a>Redux 核心原理</h2><img src="https://raw.githubusercontent.com/foolishmax/static/master/images/redux.png" width="450" />

<ul>
<li><p>只使用redux，流程是这样的：</p>
<blockquote>
<p>component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component</p>
</blockquote>
</li>
<li><p>使用react-redux 之后，流程是这样的：</p>
<blockquote>
<p>component –&gt; actionCreator(data) –&gt; reducer –&gt; component</p>
</blockquote>
</li>
</ul>
<p>store的三大功能：dispatch,subscribe,getState都不需要手动来写了，react-redux帮我们<br>做了这些，同时提供了Provider 和 connect</p>
<ul>
<li><p>注意点:</p>
<ul>
<li>store是唯一的</li>
<li>只有store能够改变自己的内容</li>
<li>reducer必须是一个纯函数（给定固定的输入，一定会有固定的输出，不会产生副作用）</li>
</ul>
</li>
<li><p>核心API</p>
<ul>
<li>createStore(reducer)<ul>
<li>创建store，并将reducer传递给store</li>
</ul>
</li>
<li>store.dispatch(action)<ul>
<li>创建action之后，负责将action传给store</li>
<li>action是一个对象形式，会包含Type(告诉store要做的事情)、Value(参数结果)</li>
</ul>
</li>
<li>store.getState()<ul>
<li>获取store内容</li>
</ul>
</li>
<li>store.subscribe()<ul>
<li>订阅store改变，只要store发生改变，其中的回调函数就会被执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Vuex-和-Redux-的区别？"><a href="#Vuex-和-Redux-的区别？" class="headerlink" title="Vuex 和 Redux 的区别？"></a>Vuex 和 Redux 的区别？</h2><ul>
<li><p>都是状态管理系统，除了具备床柜的状态管理的功能之外，也针对自身框架进行一些优化特性。</p>
</li>
<li><p>状态注入组件：</p>
<ul>
<li>React-Redux: 通过<code>&lt;Provider/&gt;</code>组件拿到store之后，还需要显示指定容器组件，<br>即用connect包装一下该组件。</li>
<li>Vue通过Vue.use(Vuex)将vuex应用为全局的插件，将store传入跟实例，就可以<br>使得store对象运行在任何vue组件中。</li>
</ul>
</li>
<li><p>vuex借鉴redux，通过弱化概念（action、reducer），弱化了dispatch的存在感，<br>任何东西都没做实质性消减，但同时使得整套框架更加易于理解了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB前端性能优化</title>
    <url>/2019/07/17/WEB%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="WEB前端性能优化常见方法"><a href="#WEB前端性能优化常见方法" class="headerlink" title="WEB前端性能优化常见方法"></a>WEB前端性能优化常见方法</h1><p>前端性能优化针对不用资源有不同的性能优化方式</p>
<span id="more"></span>
<ul>
<li><p>内容优化</p>
<ul>
<li>(1)减少HTTP请求数：因为一个完整的请求要经过    DNS寻址，与服务器建立连接，发送数据，<br>等待服务器响应，接受数据等消耗时间成本和资源成本的复杂过程。<ul>
<li>常见解决方法：</li>
</ul>
<ul>
<li>资源和并和压缩：合并多个CSS文件和js文件并使用相应的工具对js、css、图片等进行压缩处理</li>
<li>雪碧图（精灵图）：减少请求数</li>
<li>合理设置http缓存：原则就是能缓存的越多越好，越久越好，通过http header中<br>设置Expires过期时间，或者Last-Modifed进行请求验证</li>
<li>减少http请求头、配置多个域名和CDN加速、使用缓存<br>（HTTP缓存、浏览器缓存、应用缓存）、优化cookie</li>
</ul>
</li>
<li>（2）避免重定向：减少不必要的http跳转</li>
<li>（3）延迟加载组件，预加载组件，图片懒加载</li>
<li>（4）减少DOM元素数量：页面中存在大量DOM元素，会导致JavaScript遍历DOM的效率变慢。</li>
</ul>
</li>
<li><p>服务器优化</p>
<ul>
<li>（1）使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度</li>
<li>（2）Gzip压缩</li>
<li>（3）设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。</li>
<li>（4）提前刷新缓冲区</li>
<li>（5）避免空的图像src</li>
</ul>
</li>
<li><p>Cookie优化</p>
<ul>
<li>（1）减少Cookie的大小</li>
<li>（2）针对Web组件使用域名无关的Cookie</li>
</ul>
</li>
<li><p>CSS优化</p>
<ul>
<li>将CSS代码放在HTML页面的顶部</li>
<li>避免使用CSS表达式</li>
<li>使用<link>来代替@import</li>
<li>避免使用Filters</li>
</ul>
</li>
<li><p>JavaScript优化</p>
<ul>
<li>(1) 将JavaScript脚本放在页面的底部。</li>
<li>(2) 将JavaScript和CSS作为外部文件来引用：在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。</li>
<li>(3) 最小化DOM的访问：使用JavaScript访问DOM元素比较慢。</li>
<li>(4) document.getElement…将获取到的元素长度提取出来</li>
<li>(5) 尽量减少会产生reflow和repaint的操作，因为它们都是需要消耗资源的</li>
<li>(6) 慎用with，with他会修改编译时的词法作用域，修改了执行环境，访问非局部属性的<br>时候，会从指定obj作用域上开始查找，相当于增长了作用域长度，而过长的作用域链会造成<br>查找性能下降。</li>
<li>(7) 慎用eval和Function,需要js引擎将源代码转换成可执行代码，这是很消耗资源的操作，<br>同时，也不利于压缩工具进行压缩。</li>
<li>(8) 减少作用域链的查找，访问非本作用域下的变量，在循环遍历的时候使用局部变量缓存该变量，<br>遍历结束后再重写那个变量，尤其是全局变量处于作用域的最顶端，访问时查找次数最多</li>
</ul>
</li>
<li><p>图像优化</p>
<ul>
<li>(1)优化图片大小</li>
<li>（2）通过CSS    Sprites优化图片</li>
<li>（3）不要在HTML中使用压缩图片</li>
<li>（4）favicon.ico要小而且可缓存</li>
</ul>
</li>
<li><p>robots.txt<br>  搜索引擎蜘蛛访问网站时会第一个访问robots.txt文件，robots.txt用于指导搜索引擎<br>  蜘蛛禁止抓取网站的某些内容和只允许抓取哪些内容，放在站点根目录。</p>
</li>
<li><p>dns-prefetch</p>
<ul>
<li><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.bootcss.com&quot;&gt;</code></li>
<li>使用dns-prefetch对项目中使用的域名进行DNS预解析，减少DNS查询。  </li>
</ul>
</li>
<li><p>URL优化<br>  越短越好<br>  避免太多参数<br>  目录层次尽量少<br>  文件及目录名具有描述性<br>  字母全部小写<br>  连词符使用-而不是_<br>  URL中包括关键字</p>
</li>
<li><p>TDK优化<br>  TDK为title，description，keywords三个的统称。<br>  title：分隔符一般有 ， - _,其中_对百度比较友好，-对谷歌比较友好，title长度pc端一般<br>  30个中文，移动端20个，超过会截断为省略号。</p>
</li>
<li><p>其他<br>  标签语义化<br>  img设置alt属性<br>  不需要跟踪爬行的链接，设置 rel = “nofollow”  </p>
</li>
</ul>
<p>[参考]：（<a href="https://segmentfault.com/a/1190000008829958%EF%BC%89">https://segmentfault.com/a/1190000008829958）</a></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js之express</title>
    <url>/2019/09/08/Node-js%E4%B9%8Bexpress/</url>
    <content><![CDATA[<h2 id="Node-js之express"><a href="#Node-js之express" class="headerlink" title="Node.js之express"></a>Node.js之express</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引包</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于原来的http.createServer</span></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//公开指定目录</span></span><br><span class="line">app.use(<span class="string">&#x27;/puclic/&#x27;</span>, express.static(<span class="string">&#x27;./public/&#x27;</span>))</span><br><span class="line"><span class="comment">//当省略第一个参数的时候，可以通过省略/public的方式访问</span></span><br><span class="line"><span class="comment">//app.use(express.static(&#x27;./public/&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当服务器收到get请求 / 的时候，执行回调函数</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;hello exporess&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/about&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于server.listen</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;app is running at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Express使用art-template"><a href="#Express使用art-template" class="headerlink" title="Express使用art-template"></a>Express使用art-template</h2><ul>
<li><a href="http://aui.github.io/art-template/express/">Express&amp;art-template官网</a></li>
<li>Install<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save art-templates</span><br><span class="line">npm install --save express-art-template    </span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>Example<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; view engine setup</span><br><span class="line">app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;));</span><br><span class="line">app.set(&#39;view&#39;, &#123;</span><br><span class="line">    debug: process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">&#125;);</span><br><span class="line">app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;));</span><br><span class="line">app.set(&#39;view engine&#39;, &#39;art&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; routes</span><br><span class="line">app.get(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class="line">    res.render(&#39;index.art&#39;, &#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">            name: &#39;aui&#39;,</span><br><span class="line">            tags: [&#39;art&#39;, &#39;template&#39;, &#39;nodejs&#39;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h2><ul>
<li><p>在Express中没有内置获取表单POST请求体的API，需要引入一个第三方包：body-parser</p>
</li>
<li><p>Install</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save body-parser</span><br></pre></td></tr></table></figure></li>
<li><p>config</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;)</span><br><span class="line">var bodyParser &#x3D; require(&#39;body-parser&#39;)</span><br><span class="line">var app &#x3D; express()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置 body-parser,req对象上就会多出来一个 body 属性</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended: false&#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br></pre></td></tr></table></figure></li>
<li><p>use</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(function(req, res)&#123;</span><br><span class="line">    res.setHeader(&#39;Content-Type&#39;, &#39;text&#x2F;plain&#39;)</span><br><span class="line">    res.write(&#39;hello&#39;)</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React</title>
    <url>/2019/07/01/React/</url>
    <content><![CDATA[<h2 id="React的基本认识"><a href="#React的基本认识" class="headerlink" title="React的基本认识"></a>React的基本认识</h2><ul>
<li>Fecebook开源的一个js库</li>
<li>一个用来动态构建用户界面的js库</li>
<li>React的特点：<ul>
<li>声明式编程</li>
<li>组件化编程</li>
<li>高效</li>
<li>单向数据流</li>
<li>支持客户端与服务端渲染</li>
</ul>
</li>
<li>React高效的原因<ul>
<li>虚拟DOM，不直接操作DOM(批量更新，减少更新的次数)</li>
<li>高效的DOM Diff算法，最小化页面重绘(减小页面更新的区域)</li>
</ul>
</li>
</ul>
<h2 id="React中的生命周期函数"><a href="#React中的生命周期函数" class="headerlink" title="React中的生命周期函数"></a>React中的生命周期函数</h2><p>生命周期函数是指组件在某一时刻自动执行的函数</p>
<span id="more"></span>
<img src="https://raw.githubusercontent.com/foolishmax/static/master/images/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.png"/>

<h3 id="初始化过程（Initialization）"><a href="#初始化过程（Initialization）" class="headerlink" title="初始化过程（Initialization）"></a>初始化过程（Initialization）</h3><ul>
<li>在constructor()里面初始化Props和State属性。</li>
<li>getDefaultProps()可以设置组件的默认属性值。</li>
</ul>
<h3 id="挂载过程（Mounting）"><a href="#挂载过程（Mounting）" class="headerlink" title="挂载过程（Mounting）"></a>挂载过程（Mounting）</h3><ul>
<li>componentWillMount(): 在组件即将被挂载到页面的时刻自动执行。</li>
<li>render(): 将组件挂载到页面。</li>
<li>componentDidMount(): 组件被挂载到页面之后立即执行。</li>
</ul>
<h3 id="更新过程（Updation）"><a href="#更新过程（Updation）" class="headerlink" title="更新过程（Updation）"></a>更新过程（Updation）</h3><ul>
<li>componentWillReceiveProps()（在16.4版本中废弃，不推荐使用）：<br>  一个组件从父组件接受参数，如果这个组件第一次存在父组件中不会执行，已经存在才会执行，<br>  如果没有Props属性则直接跳过。</li>
<li>shouldComponentUpdate():<br>  组件更新前检查是否需要更新组件，返回布尔类型。此生命周期函数可以强制关闭不需要更新的子组件<br>  来提高渲染性能。</li>
<li>componentWillUpdate():<br>  组件更新之前自动执行。前提是shouldComponentUpdate()执行并返回true</li>
<li>render():<br>   将组件更新到页面</li>
<li>componentDidUpdate():<br>   组件更新完成之后立即执行。</li>
</ul>
<h3 id="移除过程（Unmounting）"><a href="#移除过程（Unmounting）" class="headerlink" title="移除过程（Unmounting）"></a>移除过程（Unmounting）</h3><ul>
<li>componentWillUnmount():<br>  当组件即将从页面中移除时执行。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>React中的render() 也是生命周期函数，而constructor()并不是生命周期函数。</li>
<li>所有的组件都有生命周期函数。</li>
<li>除了render()函数，其他函数都可以不写，因为除了render()函数其他函数都是继承自<br>  React中内置的。</li>
<li>AJAX请求一般都是放在componentDidMount()里面。</li>
</ul>
<h2 id="React状态提升"><a href="#React状态提升" class="headerlink" title="React状态提升"></a>React状态提升</h2><ul>
<li><p>所谓状态提升，就是将  各个子组件的公共state提升到它们的父组件进行统一存储、处理<br>(单一数据源)，然后将父组件处理后的数据或者函数props到各个子组件中。</p>
</li>
<li><p>如果子组件要修改父组件中state该怎么办？</p>
<ul>
<li>做法就是将父组件中负责setState的函数，以props的形式传给子组件，然后子组件<br>需要改变state时调用即可。</li>
</ul>
</li>
</ul>
<h2 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h2><ul>
<li>React Router包装了BrowserRouter和HashRouter两个组件。<ul>
<li>BrowserRouter使用HTML5的history API(pushState、replaceState等)实现<br>UI和URL的同步</li>
<li>HashRouter使用URL的hash实现应用的UI和URL同步</li>
</ul>
</li>
</ul>
<h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><ul>
<li><p>useState</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;用法：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;useState唯一的参数就是初始state</span><br><span class="line">&#x2F;&#x2F;返回一个数组，第一项state，第二项更新state的函数</span><br><span class="line">const [number, setNumber] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数式更新</span><br><span class="line">&#x2F;&#x2F;如果新的state需要通过使用以前的state计算得出，可以将函数传递给setState。</span><br><span class="line">&#x2F;&#x2F;例如：</span><br><span class="line">setCount((count) &#x3D;&gt; &#123;</span><br><span class="line">    return count + 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;惰性初始化state，对复杂初始数据，initialState可以是一个函数</span><br><span class="line">&#x2F;&#x2F;函数或initialState参数只会在组件的初始渲染中起作用</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [&#123;name, number&#125;,setValue] &#x3D; useState(() &#x3D;&gt; &#123;</span><br><span class="line">        return &#123;name:&#39;计数器&#39;,number:0&#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;name&#125;:&#123;number&#125;&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setValue(&#123;number: number + 1&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">--------------</span><br><span class="line">&#x2F;&#x2F;官网例子</span><br><span class="line">const [state, setState] &#x3D; useState(() &#x3D;&gt; &#123;</span><br><span class="line">    const initialState &#x3D; someExpensiveComputation(props);</span><br><span class="line">    return initialState;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;useState的初始值，只在第一次有效</span><br><span class="line">&#x2F;&#x2F;按照有序的方式使用useState不得在循环判断等条件语句中使用</span><br><span class="line">&#x2F;&#x2F;useState不会自动合并更新对象，需使用扩展符&#123;...obj,name:&#39;lisi&#39;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>useEffect</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基本使用</span><br><span class="line">&#x2F;&#x2F;useEffect有两个参数：function(执行项)，array(依赖项)</span><br><span class="line">useEffect(() &#x3D;&gt; &#123;&#125;,[name]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果依赖项为空数组，只会在第一次挂载后执行，类似componentDidMount</span><br><span class="line">useEffect(() &#x3D;&gt; &#123;&#125;,[]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;清除副作用，模拟componentUnMount</span><br><span class="line">&#x2F;&#x2F;通过返回一个函数来指定如何清除副作用，防止内存泄漏，函数会在组件卸载前执行</span><br><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    let timer &#x3D; setInterVal(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;定时器&quot;);</span><br><span class="line">    &#125;,1000)</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">        clearInterval(timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[name])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：可以在组件中多次使用useEffect</span><br><span class="line">&#x2F;&#x2F;Hook 允许我们按照代码的用途分离他们，react将按照effect声明的顺序依次调用组件中的每一个effect</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>useContext</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件创建上下文</span><br><span class="line">const Context &#x3D; createContext();</span><br><span class="line">&#x2F;&#x2F;并将数据传递给子组件</span><br><span class="line">const [num, setNum] &#x3D; useState(0);</span><br><span class="line">&lt;Context.Provider value&#x3D;&#123;&#123;num, setNum&#125;&#125;&gt;</span><br><span class="line">    &lt;Children &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Context.Provider&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子组件接收</span><br><span class="line">const &#123;num, setNum&#125; &#x3D; useContext(Context);</span><br><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    setNum(num + 1);</span><br><span class="line">&#125;,[])</span><br><span class="line">&lt;p&gt;&#123;num&#125;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>useReducer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基础使用</span><br><span class="line">const initialState &#x3D; &#123; count: 0 &#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action)&#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case &#39;increment&#39;:</span><br><span class="line">            return &#123;count:state.count + 1&#125;;</span><br><span class="line">        case &#39;decrement&#39;:</span><br><span class="line">            return &#123;count:state.count - 1&#125;;</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function MyUseReducer() &#123;</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, initialState);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            count: &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type:&#39;decrement&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type:&#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;惰性初始化</span><br><span class="line">&#x2F;&#x2F;稍加改造</span><br><span class="line">const initialCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">function init(initialCount) &#123;</span><br><span class="line">  return &#123;count: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;increment&#39;:</span><br><span class="line">      return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#39;decrement&#39;:</span><br><span class="line">      return &#123;count: state.count - 1&#125;;</span><br><span class="line">    case &#39;reset&#39;:</span><br><span class="line">      return init(action.payload);</span><br><span class="line">    default:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function MyUseReducer() &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(reducer, initialCount , init);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;reset&#39;, payload: initialCount&#125;)&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;》》</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>call、apply、bind三者比较及实现</title>
    <url>/2019/08/14/call%E3%80%81apply%E3%80%81bind%E4%B8%89%E8%80%85%E6%AF%94%E8%BE%83%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="apply、call、bind三者比较"><a href="#apply、call、bind三者比较" class="headerlink" title="apply、call、bind三者比较"></a>apply、call、bind三者比较</h4><span id="more"></span>
<pre><code>1. apply、call、bind三者都是用来改变函数的this对象的指向的

2. apply、call、bind三者第一个参数都是this要指向的对象，也就是指向指定的上下文

3. apply、call、bind三者都可以利用后续参数进行传参

4. bind返回对应函数，可以稍后调用执行；apply、call则是立即调用

5.apply、call的接受参数不同，call将参数按顺序传递进去，apply则采用参数数组的形式
</code></pre>
<h4 id="实现call"><a href="#实现call" class="headerlink" title="实现call"></a>实现call</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.call2 &#x3D; function () &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;改变this指向，将目标函数作为这个对象的属性</span><br><span class="line">    var context &#x3D; arguments[0] || window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;利用arguments类数组对象实现参数不定长</span><br><span class="line">    var args &#x3D; [];</span><br><span class="line">    for(var i &#x3D; 1, len &#x3D; arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&#39;arguments[&#39; + i + &#39;]&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将不定长的参数传递给函数</span><br><span class="line">    var result &#x3D; eval(&#39;context.fn(&#39; + args.join(&#39;,&#39;) +&#39;)&#39;);</span><br><span class="line">    &#x2F;&#x2F; context.fn(...args)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不能增加对象的属性，所以结尾要删除delete</span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现apply"><a href="#实现apply" class="headerlink" title="实现apply"></a>实现apply</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.apply2 &#x3D; function (context, arr) &#123;</span><br><span class="line">    var context &#x3D; Object(context) || window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result &#x3D; context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        var args &#x3D; [];</span><br><span class="line">        for (var i &#x3D; 0, len &#x3D; arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&#39;arr[&#39; + i + &#39;]&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        result &#x3D; eval(&#39;context.fn(&#39; + args + &#39;)&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class="line">    var fbound &#x3D; function () &#123;</span><br><span class="line">        self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line">    &#125;</span><br><span class="line">    fNOP.prototype &#x3D; this.prototype;</span><br><span class="line">    fbound.prototype &#x3D; new fNOP();</span><br><span class="line">    return fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bind(fn, obj) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return fn.apply(obj, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie封装以及元素拖拽记录位置</title>
    <url>/2019/08/08/cookie%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%83%E7%B4%A0%E6%8B%96%E6%8B%BD%E8%AE%B0%E5%BD%95%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="cookie封装以及元素拖拽记录位置"><a href="#cookie封装以及元素拖拽记录位置" class="headerlink" title="cookie封装以及元素拖拽记录位置"></a>cookie封装以及元素拖拽记录位置</h2><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #demo&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            left: 100px;</span><br><span class="line">            top: 100px;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height:100px;</span><br><span class="line">            background: orange;</span><br><span class="line">            color: #fff;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;demo&quot;&gt;demo&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var oDemo &#x3D; document.getElementById(&#39;demo&#39;);</span><br><span class="line">        var manageCookie &#x3D; &#123;</span><br><span class="line">            setCookie: function (key, value, date) &#123;&#x2F;&#x2F;增，改</span><br><span class="line">                var oDate &#x3D; new Date();</span><br><span class="line">                oDate.setDate(oDate.getDate() + date);</span><br><span class="line">                document.cookie &#x3D; key + &#39;&#x3D;&#39; + value + &#39;;expires&#x3D;&#39; + oDate;</span><br><span class="line">                return this;</span><br><span class="line">            &#125;,</span><br><span class="line">            removeCookie: function (key) &#123;&#x2F;&#x2F;删</span><br><span class="line">                this.setCookie(key, &#39;&#39;, -1 );</span><br><span class="line">                return this;</span><br><span class="line">            &#125;,</span><br><span class="line">            getCookie: function (key, callback) &#123;&#x2F;&#x2F;查</span><br><span class="line">                </span><br><span class="line">                var allCookie &#x3D; document.cookie;</span><br><span class="line">                var cookieArr &#x3D; allCookie.split(&#39;; &#39;);</span><br><span class="line">                cookieArr.forEach(function (ele) &#123;</span><br><span class="line">                    var item &#x3D; ele.split(&#39;&#x3D;&#39;);</span><br><span class="line">                    if(item[0] &#x3D;&#x3D; key) &#123;</span><br><span class="line">                        callback?callback(item[1]):&#39;&#39;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                return this; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var dragFun &#x3D; &#123;</span><br><span class="line">            init: function () &#123;</span><br><span class="line">                &#x2F;&#x2F;入口函数</span><br><span class="line">                this.dom &#x3D; oDemo;</span><br><span class="line">                manageCookie.getCookie(&#39;position&#39;, function (data) &#123;</span><br><span class="line">                    if(data) &#123;</span><br><span class="line">                        var dataArr &#x3D; data.split(&#39;&amp;&#39;);</span><br><span class="line">                        oDemo.style.left &#x3D; dataArr[0] + &#39;px&#39;;</span><br><span class="line">                        oDemo.style.top &#x3D; dataArr[1] + &#39;px&#39;;</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;)</span><br><span class="line">                dragFun.bindEvent();</span><br><span class="line">            &#125;,</span><br><span class="line">            bindEvent: function() &#123;</span><br><span class="line">                &#x2F;&#x2F;绑定事件</span><br><span class="line">                this.dom.onmousedown &#x3D; this.oDemoDown.bind(this);</span><br><span class="line">            &#125;,</span><br><span class="line">            oDemoDown: function () &#123;</span><br><span class="line">                &#x2F;&#x2F;鼠标按下触发的函数</span><br><span class="line">                this.disX &#x3D; event.clientX - this.dom.offsetLeft;</span><br><span class="line">                this.disY &#x3D; event.clientY - this.dom.offsetTop;</span><br><span class="line">                document.onmousemove &#x3D; this.oDemoMove.bind(this);</span><br><span class="line">                document.onmouseup &#x3D; this.oDemoUp.bind(this);</span><br><span class="line">            &#125;,</span><br><span class="line">            oDemoMove: function () &#123;</span><br><span class="line">                &#x2F;&#x2F;鼠标移动</span><br><span class="line">                this.newLeft &#x3D; event.clientX - this.disX;</span><br><span class="line">                this.newTop &#x3D; event.clientY - this.disY;</span><br><span class="line">                this.dom.style.left &#x3D; this.newLeft + &#39;px&#39;;</span><br><span class="line">                this.dom.style.top &#x3D; this.newTop + &#39;px&#39;;</span><br><span class="line">            &#125;,</span><br><span class="line">            oDemoUp: function () &#123;</span><br><span class="line">                &#x2F;&#x2F;鼠标抬起</span><br><span class="line">                document.onmousemove &#x3D; null;</span><br><span class="line">                document.onmouseup &#x3D; null;</span><br><span class="line"></span><br><span class="line">                var positionStr &#x3D; this.newLeft + &#39;&amp;&#39; + this.newTop;</span><br><span class="line"></span><br><span class="line">                manageCookie.setCookie(&#39;position&#39;, positionStr, 3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dragFun.init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>简单拖拽封装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function drag (elem) &#123;</span><br><span class="line">    var disX,</span><br><span class="line">        disY;</span><br><span class="line">    elem.onmousedown &#x3D; function(e) &#123;</span><br><span class="line">        disX &#x3D; e.pageX - parseInt(div.style.left)</span><br><span class="line">        disY &#x3D; e.pageY - parseInt(div.style.top)</span><br><span class="line">        document.onmousemove &#x3D; function(e) &#123;</span><br><span class="line">            var event &#x3D; e|| window.event</span><br><span class="line">            div.style.left &#x3D; e.pageX - disX + &quot;px&quot;</span><br><span class="line">            div.style.top &#x3D; e.pageY - disY + &quot;px&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        document.onmouseup &#x3D; function() &#123;</span><br><span class="line">            div.onmousemove &#x3D; null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>getcomputedstyle和style的区别</title>
    <url>/2019/09/26/getcomputedstyle%E5%92%8Cstyle%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>S</p>
<h2 id="getomputedstyle-和-style-的区别？"><a href="#getomputedstyle-和-style-的区别？" class="headerlink" title="getomputedstyle 和 style 的区别？"></a>getomputedstyle 和 style 的区别？</h2><ul>
<li><p>getComputedStyle方法是只读的，只能获取样式，不能设置；而element.style能读写。</p>
</li>
<li><p>getComputedStyle方法获取的是最终应用在元素上的所有Css属性样式(即使没有css代码)，<br>而element.style只能获取元素style属性中的css样式。</p>
</li>
<li><p>getComputedStyle可以获取伪元素的样式。</p>
</li>
<li><p>兼容性：getComputedStyle方法在IE6~IE8是不支持的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>get和post请求的区别？</title>
    <url>/2019/09/07/get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<ul>
<li>get 和 post的请求区别？<span id="more"></span>
<ul>
<li>区别一：<ul>
<li>get重点是从服务器上获取资源</li>
<li>post重点是向服务器发送数据</li>
</ul>
</li>
<li>区别二：<ul>
<li>get传输数据通过url请求，以field（字段）=value的形式放在url后，用“？”连接，<br>多个请求数据间用“&amp;”连接，过程用户可见。</li>
<li>post传输数据放在请求体（request body）中发送给服务器，用户不可见。</li>
</ul>
</li>
<li>区别三：<ul>
<li>get传输数据大小有限制（根本原因是卢兰其地址栏对输入的url有最大长度限制，<br>超过会截断），但效率较高</li>
<li>post可以传输大量数据，所以上传文件用post方式</li>
</ul>
</li>
<li>区别四：<ul>
<li>get请求不安全，因为参数直接暴露在url上，并且会保存在浏览器的历史记录中，<br>不能用来传递敏感信息。</li>
<li>post较get安全性较高。</li>
</ul>
</li>
<li>区别五：<ul>
<li>get方式只能支持ASCII字符，向服务传的中文字符可能会乱码。</li>
<li>post支持标准字符集，可以正确传递中文字符。</li>
</ul>
</li>
<li>区别六：<ul>
<li>get在浏览器回退是无害的，而post会再次提交请求。</li>
</ul>
</li>
<li>区别七<ul>
<li>get请求会被浏览器主动cache（缓存），而post不会除非手动设置。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title>git commit提示Your branch is up-to-date with &#39;origin/master&#39;</title>
    <url>/2019/09/21/git-commit%E6%8F%90%E7%A4%BAYour-branch-is-up-to-date-with-origin-master/</url>
    <content><![CDATA[<h3 id="git-commit提示Your-branch-is-up-to-date-with-‘origin-master’"><a href="#git-commit提示Your-branch-is-up-to-date-with-‘origin-master’" class="headerlink" title="git commit提示Your branch is up-to-date with ‘origin/master’"></a>git commit提示Your branch is up-to-date with ‘origin/master’</h3><ul>
<li><p>新建一个分支</p>
<blockquote>
<p>git branch newbranch</p>
</blockquote>
</li>
<li><p>然后检查分支是否创建成功</p>
<blockquote>
<p>git branch</p>
</blockquote>
</li>
<li><p>切换到新的分支</p>
<blockquote>
<p>git checkout newbranch</p>
</blockquote>
</li>
<li><p>将改动提交到新的分支上</p>
<blockquote>
<p>git add .<br>git commit -m “0.0.1”</p>
</blockquote>
</li>
<li><p>然后可以检查是否成功</p>
<blockquote>
<p>git status</p>
</blockquote>
</li>
<li><p>然后切换到主分支</p>
<blockquote>
<p>git checkout master</p>
</blockquote>
</li>
<li><p>然后将新分支提交的改动合并到主分支上</p>
<blockquote>
<p>git merge newbanch</p>
</blockquote>
</li>
<li><p>push到仓库</p>
<blockquote>
<p>git push -u origin master</p>
</blockquote>
</li>
<li><p>最后还可以删除这个分支</p>
<blockquote>
<p>git branch -D newbranch</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript常用api合集</title>
    <url>/2020/07/17/javascript%E5%B8%B8%E7%94%A8api%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="一、节点"><a href="#一、节点" class="headerlink" title="一、节点"></a>一、节点</h2><h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.nodeName &#x2F;&#x2F;返回节点名称，只读</span><br><span class="line">Node.nodeType &#x2F;&#x2F;返回节点类型的常数值，只读</span><br><span class="line">Node.nodeValue &#x2F;&#x2F;返回Text或Comment节点的文本值，只读</span><br><span class="line">Node.textContent &#x2F;&#x2F;返回当前节点和它的所有后代节点的文本内容，可读写</span><br><span class="line">Node.baseURI &#x2F;&#x2F;返回当前网页的绝对路径</span><br><span class="line"></span><br><span class="line">Node.ownerDocument &#x2F;&#x2F;返回当前节点所在的顶层文档对象，即document</span><br><span class="line">Node.nextSibling &#x2F;&#x2F;返回紧跟在当前节点后面的第一个兄弟节点</span><br><span class="line">Node.previousSibling &#x2F;&#x2F;返回当前节点前面的、距离最近的一个兄弟节点</span><br><span class="line">Node.parentNode &#x2F;&#x2F;返回当前节点的父节点</span><br><span class="line">Node.parentElement &#x2F;&#x2F;返回当前节点的父Element节点</span><br><span class="line">Node.childNodes &#x2F;&#x2F;返回当前节点的所有子节点</span><br><span class="line">Node.firstChild &#x2F;&#x2F;返回当前节点的第一个子节点</span><br><span class="line">Node.lastChild &#x2F;&#x2F;返回当前节点的最后一个子节点</span><br><span class="line"></span><br><span class="line">Node.children &#x2F;&#x2F;返回当前节点的所有Element子节点</span><br><span class="line">Node.firstElementChild &#x2F;&#x2F;返回当前节点的第一个Element子节点</span><br><span class="line">Node.lastElementChild &#x2F;&#x2F;返回当前节点的最后一个Element子节点</span><br><span class="line">Node.childElementCount &#x2F;&#x2F;返回当前节点所有Element子节点的数目</span><br></pre></td></tr></table></figure>
<!--more-->
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.appendChild(node) &#x2F;&#x2F;向节点添加最后的子节点</span><br><span class="line">Node.hasChildNodes() &#x2F;&#x2F;返回布尔值，表示当前节点是否有子节点</span><br><span class="line">Node.cloneNode(true) &#x2F;&#x2F;默认为false(克隆节点),true(克隆节点及其属性，以及后代)</span><br><span class="line">Node.insertBefore(newNode,oldNode) &#x2F;&#x2F;在指定子节点前插入新的子节点</span><br><span class="line">Node.removeChild(node) &#x2F;&#x2F;删除节点，在要删除节点的父节点上操作</span><br><span class="line">Node.replaceChild(newChild,oldChild) &#x2F;&#x2F;替换节点</span><br><span class="line">Node.contains(node) &#x2F;&#x2F;返回一个布尔值，表示参数节点是否为当前节点的后代节点</span><br><span class="line">Node.compareDocumentPosition(node) &#x2F;&#x2F;返回一个7个比特位的二进制值，表示参数节点和当前节点的关系</span><br><span class="line">Node.isEqualNode(node) &#x2F;&#x2F;返回布尔值，用于检查两个节点是否想等，所谓的相等节点，指的的两个节点的类型、属性、子节点都相同</span><br><span class="line">Node.normalize() &#x2F;&#x2F;用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个</span><br><span class="line"></span><br><span class="line">ChildNode.remove()  &#x2F;&#x2F;用于删除当前节点</span><br><span class="line">ChildNode.before()  &#x2F;&#x2F;在ChildNode前插入元素节点或者文本节点</span><br><span class="line">ChildNode.after()  &#x2F;&#x2F;在ChildNode后插入元素或文本节点</span><br><span class="line">ChildNode.replaceWith()  &#x2F;&#x2F;替换该节点的父节点下的子节点，可以为文本或元素对象</span><br></pre></td></tr></table></figure>

<h3 id="Document节点"><a href="#Document节点" class="headerlink" title="Document节点"></a>Document节点</h3><h4 id="Document节点的属性"><a href="#Document节点的属性" class="headerlink" title="Document节点的属性"></a>Document节点的属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.doctype &#x2F;&#x2F;返回当前文档关联的文档类型定义(DTD)</span><br><span class="line">document.documentElement &#x2F;&#x2F;返回当前文档的根节点(html)</span><br><span class="line">document.defaultView &#x2F;&#x2F;返回document对象所在的window对象</span><br><span class="line">document.body &#x2F;&#x2F;返回当前文档的&lt;body&gt;节点</span><br><span class="line">document.head &#x2F;&#x2F;返回当前文档的&lt;head&gt;节点</span><br><span class="line">document.activeElement &#x2F;&#x2F;返回当前文档中获得焦点的那个元素</span><br><span class="line"></span><br><span class="line">document.links &#x2F;&#x2F;返回当前文档的所有a元素</span><br><span class="line">document.forms &#x2F;&#x2F;返回页面中所有表单元素</span><br><span class="line">document.images &#x2F;&#x2F;返回页面中所有图片元素</span><br><span class="line">document.embeds &#x2F;&#x2F;返回网页中所有嵌入对象</span><br><span class="line">document.scripts &#x2F;&#x2F;返回当前文档的所有脚本</span><br><span class="line">document.styleSheets &#x2F;&#x2F;返回当前网页的所有样式表</span><br><span class="line"></span><br><span class="line">document.documentURI &#x2F;&#x2F;表示当前文档的网址</span><br><span class="line">document.URI &#x2F;&#x2F;返回当前文档的网址</span><br><span class="line">document.domain &#x2F;&#x2F;返回当前文档的域名</span><br><span class="line">document.lastModified &#x2F;&#x2F;返回当前文档最后修改的时间戳</span><br><span class="line">document.location &#x2F;&#x2F;返回location对象，提供当前文档的URL信息</span><br><span class="line">document.referrer &#x2F;&#x2F;返回当前文档的访问来源</span><br><span class="line">document.title &#x2F;&#x2F;返回当前文档的标题</span><br><span class="line">document.characterSet &#x2F;&#x2F;属性返回渲染当前文档的字符集，比如UTF-8</span><br><span class="line">document.readyState &#x2F;&#x2F;返回当前文档的状态</span><br><span class="line">document.designMode &#x2F;&#x2F;控制当前文档是否可编辑，可读写</span><br><span class="line">document.compatMode &#x2F;&#x2F;返回浏览器处理文档的模式</span><br><span class="line">document.cookie &#x2F;&#x2F;用来操作Cookie</span><br></pre></td></tr></table></figure>

<h3 id="Document节点的方法"><a href="#Document节点的方法" class="headerlink" title="Document节点的方法"></a>Document节点的方法</h3><h4 id="读写方法"><a href="#读写方法" class="headerlink" title="读写方法"></a>读写方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.open() &#x2F;&#x2F;用于新建并打开一个文档</span><br><span class="line">document.close() &#x2F;&#x2F;关闭open方法所新建的文档</span><br><span class="line">document.write() &#x2F;&#x2F;用于向当前文档写入内容</span><br><span class="line">document.writeIn() &#x2F;&#x2F;用于向当前文档写入内容，尾部添加换行符</span><br></pre></td></tr></table></figure>

<h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.querySelector(selectors) &#x2F;&#x2F;接收一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点</span><br><span class="line">document.querySelectorAll(selectors) &#x2F;&#x2F;接收一个CSS选择器作为参数，返回所有匹配该选择器的元素节点</span><br><span class="line">document.getElementsByTagName(tagName) &#x2F;&#x2F;返回所有指定HTML标签的元素</span><br><span class="line">document.getElementsByClassName(className) &#x2F;&#x2F;返回包括了所有class名字符合指定条件的元素</span><br><span class="line">document.getElementsByName(name) &#x2F;&#x2F;用于选择拥有name属性的HTML元素(比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;object&gt;等)</span><br><span class="line">document.getElementById(id) &#x2F;&#x2F;返回匹配指定id属性的元素节点</span><br><span class="line">document.elementFromPoint(x,y) &#x2F;&#x2F;返回位于页面指定位置最上层的Element子节点</span><br></pre></td></tr></table></figure>

<h4 id="生成节点"><a href="#生成节点" class="headerlink" title="生成节点"></a>生成节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.createElement(tagName) &#x2F;&#x2F;用来生成HTML元素节点</span><br><span class="line">document.createTextNode(text) &#x2F;&#x2F;用来生成文本节点</span><br><span class="line">document.createAttribute(name) &#x2F;&#x2F;生成一个新的属性对象节点，并返回</span><br><span class="line">document.createDocumentFragment() &#x2F;&#x2F;生成一个DocumentFragment对象</span><br></pre></td></tr></table></figure>

<h4 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.createEvent(type) &#x2F;&#x2F;生成一个事件对象，该对象能被element.dispatchEvent()方法使用</span><br><span class="line">document.addEventListener(type,listener,capture) &#x2F;&#x2F;注册事件</span><br><span class="line">document.removeEventListener(type,listener,capture) &#x2F;&#x2F;注销事件</span><br><span class="line">document.dispatchEvent(event) &#x2F;&#x2F;触发事件</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.hasFocus() &#x2F;&#x2F;返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点</span><br><span class="line">document.adoptNode(externalNode) &#x2F;&#x2F;将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点</span><br><span class="line">document.importNode(externalNode,deep) &#x2F;&#x2F;从外部文档拷贝指定节点，插入当前文档</span><br></pre></td></tr></table></figure>

<h3 id="Element节点"><a href="#Element节点" class="headerlink" title="Element节点"></a>Element节点</h3><h4 id="Element节点的属性"><a href="#Element节点的属性" class="headerlink" title="Element节点的属性"></a>Element节点的属性</h4><h5 id="特性属性"><a href="#特性属性" class="headerlink" title="特性属性"></a>特性属性</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.attributes &#x2F;&#x2F;返回当前元素节点的所有属性节点</span><br><span class="line">Element.id &#x2F;&#x2F;返回指定元素的id属性，可读写</span><br><span class="line">Element.tagName &#x2F;&#x2F;返回指定元素的大写标签名</span><br><span class="line">Element.innerHTML &#x2F;&#x2F;返回该元素包含的HTML代码，可读写</span><br><span class="line">Element.outerHTML &#x2F;&#x2F;返回该元素节点的所有HTML代码，包括自身和所有子元素，可读写</span><br><span class="line">Element.className &#x2F;&#x2F;返回当前元素的class属性，可读写</span><br><span class="line">Element.classList &#x2F;&#x2F;返回当前元素节点的所有class集合</span><br><span class="line">Element.dataset &#x2F;&#x2F;返回元素节点中所有data-*属性</span><br></pre></td></tr></table></figure>

<h5 id="尺寸属性"><a href="#尺寸属性" class="headerlink" title="尺寸属性"></a>尺寸属性</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.clientHeight &#x2F;&#x2F;返回元素节点可见部分的高度</span><br><span class="line">Element.clientWidth &#x2F;&#x2F;返回元素节点可见部分的宽度</span><br><span class="line">Element.clientLeft &#x2F;&#x2F;返回元素节点左边框的宽度</span><br><span class="line">Element.clientTop &#x2F;&#x2F;返回元素节点顶部边框的宽度</span><br><span class="line"></span><br><span class="line">Element.scrollHeight &#x2F;&#x2F;返回元素节点的总高度</span><br><span class="line">Element.scrollWidth &#x2F;&#x2F;返回元素节点的总宽度</span><br><span class="line">Element.scrollLeft &#x2F;&#x2F;返回元素节点的水平滚动条向右滚动的像素数值，通过设置这个属性可以改变元素滚动的位置</span><br><span class="line">Element.scrollTop &#x2F;&#x2F;返回元素节点的垂直滚动向下滚动的像素数值</span><br><span class="line"></span><br><span class="line">Element.offsetHeight &#x2F;&#x2F;返回元素的垂直高度(包含border，padding)</span><br><span class="line">Element.offsetWidth &#x2F;&#x2F;返回元素的水平宽度(包含border，padding)</span><br><span class="line">Element.offsetLeft &#x2F;&#x2F;返回当前元素左上角相对于Element.offsetParent节点的垂直偏移</span><br><span class="line">Element.offsetTop &#x2F;&#x2F;返回水平位移</span><br><span class="line"></span><br><span class="line">Element.style &#x2F;&#x2F;返回元素节点的行内样式</span><br></pre></td></tr></table></figure>

<h5 id="节点相关属性"><a href="#节点相关属性" class="headerlink" title="节点相关属性"></a>节点相关属性</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.children &#x2F;&#x2F;包括当前元素节点的所有子元素</span><br><span class="line">Element.childElementCount &#x2F;&#x2F;返回当前元素节点包含的子HTML元素节点的个数</span><br><span class="line">Element.firstElementChild &#x2F;&#x2F;返回当前节点的第一个Element子节点</span><br><span class="line">Element.lastElementChild &#x2F;&#x2F;返回当前节点的最后一个Element子节点</span><br><span class="line">Element.nextElementSibling &#x2F;&#x2F;返回当前元素节点的下一个兄弟HTML元素节点</span><br><span class="line">Element.previousElementSibling &#x2F;&#x2F;返回当前元素节点的前一个兄弟HTML元素节点</span><br><span class="line">Element.offsetParent &#x2F;&#x2F;返回当前元素节点的最靠近、并且CSS的position属性不等于static的父元素</span><br></pre></td></tr></table></figure>

<h4 id="Element节点的方法"><a href="#Element节点的方法" class="headerlink" title="Element节点的方法"></a>Element节点的方法</h4><h5 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getBoundingClientRect() &#x2F;&#x2F;获取元素位置</span><br><span class="line">getClientRects() &#x2F;&#x2F;返回当前元素在页面上的矩形区域</span><br></pre></td></tr></table></figure>

<h5 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.getAttribute() &#x2F;&#x2F;读取指定属性</span><br><span class="line">Element.setAttribute() &#x2F;&#x2F;设置指定属性</span><br><span class="line">Element.hasAttribute() &#x2F;&#x2F;返回一个布尔值，表示当前元素节点是否有指定属性</span><br><span class="line">Element.removeAttribute() &#x2F;&#x2F;移除指定属性</span><br></pre></td></tr></table></figure>

<h5 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.querySelector() </span><br><span class="line">Element.querySelectorAll()</span><br><span class="line">Element.getElementByTagName()</span><br><span class="line">Element.getElementByClassName()</span><br></pre></td></tr></table></figure>

<h5 id="事件方法-1"><a href="#事件方法-1" class="headerlink" title="事件方法"></a>事件方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.addEventListener() &#x2F;&#x2F;添加事件的回调函数</span><br><span class="line">Element.removeEventListener() &#x2F;&#x2F;移除事件监听函数</span><br><span class="line">Element.dispatchEvent() &#x2F;&#x2F;触发事件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ie8</span><br><span class="line">Element.attachEvent(oneventName,listener)</span><br><span class="line">Element.detachEvent(oneventName,listener)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;event对象</span><br><span class="line">var event &#x3D; window.event||event</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;事件的目标节点</span><br><span class="line">var target &#x3D; event.target || event.srcElement</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;事件代理</span><br><span class="line">ul.addEventListener(&#39;click&#39;,function(event)&#123;</span><br><span class="line">    if(event.target.tagName.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;li&#39;)&#123;</span><br><span class="line">        console.log(event.target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.scrollIntoView()   &#x2F;&#x2F;滚动当前元素，进入浏览器的可见区域</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解析HTML字符串，然后将生成的节点插入DOM树的指定位置。</span><br><span class="line">Element.insertAdjacentHTML(where, htmlString); </span><br><span class="line">Element.insertAdjacentHTML(&#39;beforeBegin&#39;, htmlString); &#x2F;&#x2F; 在该元素前插入  </span><br><span class="line">Element.insertAdjacentHTML(&#39;afterBegin&#39;, htmlString); &#x2F;&#x2F; 在该元素第一个子元素前插入 </span><br><span class="line">Element.insertAdjacentHTML(&#39;beforeEnd&#39;, htmlString); &#x2F;&#x2F; 在该元素最后一个子元素后面插入 </span><br><span class="line">Element.insertAdjacentHTML(&#39;afterEnd&#39;, htmlString); &#x2F;&#x2F; 在该元素后插入</span><br><span class="line"></span><br><span class="line">Element.remove()  &#x2F;&#x2F;用于将当前元素节点从DOM中移除</span><br><span class="line">Element.focus()   &#x2F;&#x2F;用于将当前页面的焦点，转移到指定元素上</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二、CSS操作"><a href="#二、CSS操作" class="headerlink" title="二、CSS操作"></a>二、CSS操作</h2><h3 id="类名操作"><a href="#类名操作" class="headerlink" title="类名操作"></a>类名操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ie8以下</span><br><span class="line">Element.className  &#x2F;&#x2F;获取元素节点的类名</span><br><span class="line">Element.className +&#x3D; &#39; &#39; + newClassName  &#x2F;&#x2F;新增一个类名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否有某个类名</span><br><span class="line">function hasClass(element,className)&#123;</span><br><span class="line">  return new RegExp(className,&#39;gi&#39;).test(element.className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除class</span><br><span class="line">function removeClass(element,className)&#123;</span><br><span class="line">  element.className &#x3D; element.className.replace(new RegExp(&#39;(^|\\b)&#39; + className.split(&#39; &#39;).join(&#39;|&#39;) + &#39;(\\b|$)&#39;, &#39;gi&#39;),&#39;&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ie10 </span><br><span class="line">element.classList.add(className)  &#x2F;&#x2F;新增</span><br><span class="line">element.classList.remove(className)  &#x2F;&#x2F;删除</span><br><span class="line">element.classList.contains(className)  &#x2F;&#x2F;是否包含</span><br><span class="line">element.classList.toggle(className)  &#x2F;&#x2F;toggle class</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="style操作"><a href="#style操作" class="headerlink" title="style操作"></a>style操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.setAttribute(&#39;style&#39;,&#39;&#39;)</span><br><span class="line"></span><br><span class="line">element.style.backgroundColor &#x3D; &#39;red&#39;</span><br><span class="line"></span><br><span class="line">element.style.cssText &#x2F;&#x2F;用来读写或删除整个style属性</span><br><span class="line"></span><br><span class="line">element.style.setProperty(propertyName,value)  &#x2F;&#x2F;设置css属性</span><br><span class="line">element.style.getPropertyValue(property)  &#x2F;&#x2F;获取css属性</span><br><span class="line">element.style.removeProperty(property)  &#x2F;&#x2F;删除css属性</span><br><span class="line">操作非内联样式</span><br><span class="line">&#x2F;&#x2F;ie8</span><br><span class="line">element.currentStyle[attrName]</span><br><span class="line">&#x2F;&#x2F;ie9+</span><br><span class="line">window.getComputedStyle(el,null)[attrName] </span><br><span class="line">window.getComputedStyle(el,null).getPropertyValue(attrName)</span><br><span class="line">&#x2F;&#x2F;伪类</span><br><span class="line">window.getComputedStyle(el,&#39;:after&#39;)[attrName]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><h4 id="生成实例对象"><a href="#生成实例对象" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var o = new Object()
</code></pre>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><pre><code>Object.prototype //返回原型对象
</code></pre>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>Object.keys(o) //遍历对象的可枚举属性
Object.getOwnPropertyName(o) //遍历对象不可枚举的属性
</code></pre>
<h4 id="对象实例的方法"><a href="#对象实例的方法" class="headerlink" title="对象实例的方法"></a>对象实例的方法</h4><pre><code>valueOf() //返回当前对象对应的值
toString() //返回当前对象对应的字符串形式
toLocaleString() //返回当前对象对应的本地字符串形式
hasOwnProperty() //判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性
isPrototypeof() //判断当前对象是否为另一个对象的原型
propertyIsEnumerable() //判断某个属性是否可枚举
</code></pre>
<h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><h4 id="生成实例对象-1"><a href="#生成实例对象-1" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var a = new Array()
</code></pre>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><pre><code>a.length //长度
</code></pre>
<h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h4><pre><code>Array.isArray(a) //用来判断一个值是否为数组
</code></pre>
<h4 id="Array实例的方法"><a href="#Array实例的方法" class="headerlink" title="Array实例的方法"></a>Array实例的方法</h4><pre><code>a.valueof()   //返回数组本身
a.toString()  //返回数组的字符串形式
a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。
pop()   //用于删除数组的最后一个元素，并返回该元素
join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。
concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。
shift()  //用于删除数组的第一个元素，并返回该元素。
unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。
reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组
slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。
splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。
sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。
map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。
map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。
forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。
filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。
some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。
every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。
reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）
reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）
indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置
lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。
</code></pre>
<h3 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h3><h4 id="生成对象"><a href="#生成对象" class="headerlink" title="生成对象"></a>生成对象</h4><pre><code>var n = new Number()
</code></pre>
<h4 id="Number对象的属性"><a href="#Number对象的属性" class="headerlink" title="Number对象的属性"></a>Number对象的属性</h4><pre><code>Number.POSITIVE_INFINITY：正的无限，指向Infinity。
Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。
Number.NaN：表示非数值，指向NaN。
Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。
Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。
Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。
Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。
</code></pre>
<h4 id="Number对象实例的方法"><a href="#Number对象实例的方法" class="headerlink" title="Number对象实例的方法"></a>Number对象实例的方法</h4><pre><code>toString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。
toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。
toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。
toPrecision()  //用于将一个数转为指定位数的有效数字。
</code></pre>
<h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><h4 id="生成实例对象-2"><a href="#生成实例对象-2" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var s = new String()
</code></pre>
<h4 id="String对象的属性"><a href="#String对象的属性" class="headerlink" title="String对象的属性"></a>String对象的属性</h4><pre><code>s.length //返回字符串的长度
</code></pre>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><pre><code>s.chatAt(index)   //返回指定位置的字符
s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。
s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）
s.concat(s2)  //用于连接两个字符串
s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。
s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。
s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。
s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 
s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。
s.trim()  //用于去除字符串两端的空格，返回一个新字符串
s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。
s.toUpperCase()  //全部转为大写
s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。
s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。
s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。
s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。
s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。
</code></pre>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><pre><code>Math.E：常数e。
Math.LN2：2的自然对数。
Math.LN10：10的自然对数。
Math.LOG2E：以2为底的e的对数。
Math.LOG10E：以10为底的e的对数。
Math.PI：常数Pi。
Math.SQRT1_2：0.5的平方根。
Math.SQRT2：2的平方根。
</code></pre>
<h4 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h4><pre><code>Math.abs()：返回参数的绝对值  
Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。
Math.floor()：向下取整  
Math.max(n,n1,...)：可接受多个参数，返回最大值  
Math.min(n,n1,..)：可接受多个参数，返回最小值  
Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。
Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。
Math.log()：返回以e为底的自然对数值。
Math.exp()：返回e的指数，也就是常数e的参数次方。
Math.round()：四舍五入  
Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。
</code></pre>
<h4 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h4><pre><code>Math.sin()：返回参数的正弦  
Math.cos()：返回参数的余弦  
Math.tan()：返回参数的正切  
Math.asin()：返回参数的反正弦（弧度值）  
Math.acos()：返回参数的反余弦（弧度值）  
Math.atan()：返回参数的反正切（弧度值）
</code></pre>
<h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><pre><code>JSON.stringify()   
//用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。
//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。
//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。

JSON.parse()   //用于将JSON字符串转化成对象。
</code></pre>
<h3 id="console对象"><a href="#console对象" class="headerlink" title="console对象"></a>console对象</h3><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><pre><code>console.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。
console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。
console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。
console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；
console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈
console.table()  //可以将复合类型的数据转为表格显示。
console.count()  //用于计数，输出它被调用了多少次。
console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。
console.dirxml()  //用于以目录树的形式，显示DOM节点。
console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。

//这两个方法用于计时，可以算出一个操作所花费的准确时间。
console.time()
console.timeEnd()
//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。

console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。
console.profileEnd()  //用来结束正在运行的性能测试器。

console.group()
console.groupend()
//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。
console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。

console.trace()  //显示当前执行的代码在堆栈中的调用路径。
console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js严格模式</title>
    <url>/2019/08/21/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="使用严格模式"><a href="#使用严格模式" class="headerlink" title="使用严格模式"></a>使用严格模式</h2><ul>
<li>在脚本 <strong>顶层</strong> 中添加 ‘use strict’<span id="more"></span></li>
</ul>
<h2 id="为什么使用严格模式？"><a href="#为什么使用严格模式？" class="headerlink" title="为什么使用严格模式？"></a>为什么使用严格模式？</h2><ul>
<li><p>消除js语法的一些不合理、不严谨之处，减少一些怪异行为</p>
</li>
<li><p>提高编译器效率，增加运行速度</p>
</li>
<li><p>为未来新版的JavaScript做好铺垫</p>
</li>
</ul>
<h2 id="严格模式和正常模式比较："><a href="#严格模式和正常模式比较：" class="headerlink" title="严格模式和正常模式比较："></a>严格模式和正常模式比较：</h2><ul>
<li><p>严格模式下，不允许给为声明的变量赋值。</p>
</li>
<li><p>严格模式下不允许使用with</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!function () &#123;</span><br><span class="line">	&#39;use strict&#39;;</span><br><span class="line">	with(&#123; x: 1 &#125;) &#123;</span><br><span class="line">		console.log(x);  &#x2F;&#x2F;SyntaxError</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#x2F;&#x2F; !function()&#123;&#125;() 表示：解释器在解释语句时，如果以function开头，就会理解为函数声明，</span><br><span class="line">&#x2F;&#x2F;而前面加一个&quot;!&quot;可以让解释器理解为函数表达式，这样就可以立即调用了。</span><br></pre></td></tr></table></figure></li>
<li><p>严格模式下，eval变成了独立作用域</p>
</li>
<li><p>一般函数调用，this默认指向全局对象，在严格模式下，this指向undefined</p>
</li>
<li><p>严格模式下，对arguments对象有很多限制，如不能给arguments赋值，不再支持arguments.callee和arguments.caller</p>
</li>
<li><p>严格模式下，删除参数名、函数名会报错。非严格模式下返回false，静态失败（不报错也没效果）</p>
</li>
<li><p>严格模式下，给不可扩展（Object.preventExtensions(obj)）对象的新属性赋值会报错.<br>非严格模式下，静态失败。</p>
</li>
<li><p>严格模式下，修改不可写（Object.defineProperty(obj, ‘a’, {writable: false})）的属性报错。<br>非严格模式下，静态失败。</p>
</li>
<li><p>严格模式下，删除不可配置（Object.defineProperty(obj, ‘a’, {configurable: false})）的属性报错。<br>非严格模式下，静态失败。</p>
</li>
<li><p>严格模式下，给只读属性赋值会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!function()&#123;</span><br><span class="line">    &#39;use strict&#39;</span><br><span class="line">    var obj &#x3D; &#123;get x() &#123;return 12;&#125;&#125;</span><br><span class="line">    obj.x &#x3D; 5  &#x2F;&#x2F;TypeError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>严格模式下，禁止写八进制字面量。</p>
</li>
<li><p>严格模式下，对象的属性名重复设置会报错。非严格模式下，后者覆盖前者。</p>
</li>
<li><p>严格模式下，禁止设置五种基本类型的属性。（null.bbb = ‘xxx’ //TypeError）</p>
</li>
<li><p>严格模式下，不能使用一些保留的关键字（如static、puclic、private、protected、interface）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>异步加载js</title>
    <url>/2019/08/14/js%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%BA%BF%E5%92%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjs/</url>
    <content><![CDATA[<h2 id="js加载-浏览器加载-时间线"><a href="#js加载-浏览器加载-时间线" class="headerlink" title="js加载(浏览器加载)时间线"></a>js加载(浏览器加载)时间线</h2><pre><code>理论：它是根据js出生的那一刻开始记录的一系列浏览器按照顺序做的事，

就是加载顺序及一些优化
</code></pre>
 <span id="more"></span>

<ul>
<li><p>创建Document对象，开始解析web页面，这个阶段document.readyState = ‘loading’</p>
</li>
<li><p>遇见link外部css，创建线程 加载，并继续解析文档</p>
</li>
<li><p>遇见script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成</p>
</li>
</ul>
<p>并执行该脚本，然后继续解析文档</p>
<ul>
<li>遇见script外部js，并且设置了async、defer，浏览器创建线程 加载，并继续解析文档，对于</li>
</ul>
<p>async属性的脚本，加载完成后立即执行。（异步加载禁止使用document.write(),它会清除文档流）</p>
<ul>
<li><p>遇见img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档</p>
</li>
<li><p>文档解析完成，document.readyState = ‘interactive’</p>
</li>
<li><p>文档解析完成后，所有设置defer的脚本会按照顺序执行。（也禁止使用document.write()）</p>
</li>
<li><p>之后document对象触发DOMContentLoaded事件，标志程序执行从同步脚本执行阶段，转化为</p>
</li>
</ul>
<p>事件驱动阶段</p>
<ul>
<li>当所有async的脚本加载并执行后、img等加载完成后，document.readyState = ‘complete’,</li>
</ul>
<p>这是window对象触发load事件。</p>
<ul>
<li>…</li>
</ul>
<h2 id="异步加载js"><a href="#异步加载js" class="headerlink" title="异步加载js"></a>异步加载js</h2><pre><code>javascript 异步加载的三种方案:
</code></pre>
<ul>
<li>defer 异步加载，但要等到dom文档全部解析完成才会被执行，只有IE能用，可以将js代码写在</li>
</ul>
<p>script标签内部。</p>
<ul>
<li>async 异步加载，加载完就执行，async只能加载 外部脚本，不能把js写在script标签中，执行</li>
</ul>
<p>时也不会阻塞页面。</p>
<ul>
<li>动态创建 script，插入到dom中，加载完毕后callback。<br>简单实例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var script &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line"></span><br><span class="line">script.type &#x3D; &#39;text&#x2F;javascript&#39;</span><br><span class="line"></span><br><span class="line">script.src &#x3D; demo.js</span><br><span class="line"></span><br><span class="line">script.onload &#x3D; function() &#123; &#x2F;&#x2F;兼容性很好，除了IE</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.head.appendChild(script)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>动态加载函数封装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function asyncLoaded(url,callback)&#123;</span><br><span class="line">    var script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">&#x2F;&#x2F;  script.src &#x3D; url;   假如说网速非常好，直接执行完成了，后面就监听不到状态的改变了</span><br><span class="line">    if(script.readyState)&#123;</span><br><span class="line">        script.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">            if(script.readyState &#x3D;&#x3D; &quot;complete&quot; || script.readyState &#x3D;&#x3D;&quot;loaded&quot;)&#123;</span><br><span class="line">&#x2F;&#x2F;  执行某个函数</span><br><span class="line">                callback()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        script.onload &#x3D; function()&#123;</span><br><span class="line">&#x2F;&#x2F;  执行某个函数</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src &#x3D; url;    &#x2F;&#x2F;异步的过程</span><br><span class="line">    document.head.appendChild(script)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncLoaded(&#39;demo.js&#39;, function()&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>js引擎的预编译和执行</title>
    <url>/2019/08/13/js%E5%BC%95%E6%93%8E%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="var-的变量提升底层原理"><a href="#var-的变量提升底层原理" class="headerlink" title="var 的变量提升底层原理"></a>var 的变量提升底层原理</h2><pre><code>JavaScript引擎，不是逐条解释执行javascript代码，而是按照代码块一段段解释执行，
所谓代码块就是script标签分割的代码块。
</code></pre>
<span id="more"></span>
<pre><code>js引擎的工作方式分为：预编译和执行代码两个阶段。

1）常见的编译型语言编译阶段：词法分析（生成词法单元）——&gt;语法分析（抽象语法树）——&gt;(语义检查，代码优化)——&gt;代码生成

2）对于解释型语言来说，通过词法分析和语法分析得到抽象语法树之后就开始执行了，在JavaScript
解释器在构造语法树的时候，如果无法构造，就会报语法错误，并结束整个代码块的执行。
而在整个编译阶段，会把“一等公民”function和var创建的变量进行提升。（其中函数提升在变量
提成之前）

3）JavaScript语法采用的是词法作用域，也就是javascript的变量和函数作用域是在定义时
决定的，函数调用时决定的是执行期上下文和作用域链，所以js解释器只需要静态分析就能确定每个
变量、函数的作用域，这种作用域也称为静态作用域。
</code></pre>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ul>
<li><p>全局执行上下文：默认的上下文，任何不再函数内部的代码都在全局上下文中。它会执行两<br>件事：创建一个全局的window对象(浏览器的情况下)，并且设置this的值等于这个全局对象。<br>一个程序只会有一个全局执行上下文。</p>
</li>
<li><p>函数执行上下文：每当函数被调用时，都会为该函数创建一个新的上下文。</p>
</li>
<li><p>Eval函数执行上下文：执行在eval函数内部的代码也会有属于它自己的执行上下文。</p>
<p>  执行栈：JavaScript引擎会以栈的方式来处理多个执行期上下文其他语言叫“调用栈”，<br>  类似于数据结构的栈LIFO(后进先出)，用来存储代码运行时创建的所有执行上下文。<br>  栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。</p>
<p>  当JavaScript引擎第一次遇见脚本时，它会创建一个全局的执行上下文并且压入当前<br>  执行栈，每当引擎遇到一个函数调用，会为该函数创建一个新的执行上下文并压入栈的顶部。</p>
<p>  引擎会执行那些执行上下文位于栈顶的函数，当函数执行结束时，执行上下文从栈顶<br>  弹出，控制流程到达当前栈中的下一个上下文。</p>
<p>  当函数执行时，会创建一个成为 执行期上下文的内部对象。</p>
<p>  执行期上下文就是js代码被解析和执行时的运行环境，函数每次执行都会创建一个独一无二的执行上下文，所以多次调用会产生<br>  多个执行上下文，当函数执行完毕，所产生的执行上下文被销毁。</p>
<p>  执行上下文的生命周期包括三个阶段：</p>
<pre><code>  创建阶段-&gt;执行阶段-&gt;挥手阶段
  
</code></pre>
<p>  创建阶段会创建变量对象(Variable Object)，建立作用域链，确定this指向</p>
<pre><code>  1. 创建Scope chain
  2. 创建AO
  3. 设置this的值
</code></pre>
<p>  创建AO主要做了以下事情：</p>
<pre><code>  1. 创建AO对象
  2. 形参和变量声明存储到AO对象 //赋值为undefined
  3. 将形参和实参相统一
  4. 函数声明的函数名作为AO对象的key，函数体作为value
  
</code></pre>
<p>  执行阶段会完成变量赋值，函数引用，以及执行其他代码。</p>
</li>
<li><p>AO(Active Object) &amp; VO(Variable Object)的区别？</p>
<ul>
<li>VO：未进入执行上下文执行阶段之前，变量对象中的属性都不能访问。</li>
<li>AO：进入执行阶段之后，变量对象转变为活动对象，里面的属性都能访问了。</li>
<li>它们都是同一个对象，只是处于执行上下文的不同生命周期，而且只有处于<br>函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。</li>
</ul>
<p>  如果函数引用了外部变量的值，则JavaScript引擎会为改函数创建一个闭包体（closure），<br>  闭包体是一个完全封闭和独立的作用域，他不会在函数调用完毕后就被js引擎当作垃圾<br>  进行回收，闭包体可以长期存在。</p>
</li>
</ul>
<ul>
<li>执行上下文总结：<ul>
<li>单线程</li>
<li>同步执行，只有栈顶的上下文处于执行中，而其他上下文需要等待</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈，而且其他所有上下文环境<br>都可以直接访问全局上下文的属性</li>
<li>函数的执行上下文的个数没有限制</li>
<li>每次某个函数被调用，就会有新的执行上下文为其创建，即使是调用的自身函数，也是如此。</li>
</ul>
</li>
</ul>
<h2 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h2><pre><code>同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入Event Table
并注册函数。

当指定的事情完成时（例如定时器执行完毕，获取数据结束等），Event Table会将这个函数移入Event Queue

主线程内的任务执行完毕为空，会去Event Queue（事件队列）读取对应的函数，进入主线程执行。

上述过程不断重复，称为Event Loop（事件轮询）
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js继承的几种实现方式</title>
    <url>/2019/08/13/js%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="js继承的几种实现方式"><a href="#js继承的几种实现方式" class="headerlink" title="js继承的几种实现方式"></a>js继承的几种实现方式</h4><p>首先，我们需要定义一个父类：</p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个动物类</span><br><span class="line">function Animal (name) &#123;</span><br><span class="line">&#x2F;&#x2F;属性</span><br><span class="line">	this.name &#x3D; name || &#39;Animal&#39;;</span><br><span class="line">	&#x2F;&#x2F;实例方法</span><br><span class="line">	this.sleep &#x3D; function() &#123;</span><br><span class="line">	console.log(this.name + &#39;i&#39;m sleeping&#39;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;原型方法</span><br><span class="line">Animal.prototype.eat &#x3D; function(food) &#123;</span><br><span class="line">	console.log(this.name + &#39;i&#39;m eating&#39; + food)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>原型链继承</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Parent2 () &#123;</span><br><span class="line">	this.name &#x3D; &#39;parent2&#39;</span><br><span class="line">&#125;</span><br><span class="line">function Child2 () &#123;</span><br><span class="line">	this.sex &#x3D; &#39;male&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;第一种写法</span><br><span class="line">Child2.prototype &#x3D; new Parent2()</span><br><span class="line">&#x2F;&#x2F;第二种写法(创建一个新的Child2.prototype对象关联到Parent2.prototype)</span><br><span class="line">&#x2F;&#x2F;但是现在没有了Child2.prototype.constructor了</span><br><span class="line">&#x2F;&#x2F;Child2.prototype &#x3D; Object.create(Parent2.prototype)</span><br><span class="line">&#x2F;&#x2F;第三种写法（ES6） </span><br><span class="line">&#x2F;&#x2F;Object.setPrototypeOf(Child2.prototype, Parent.prototype)</span><br><span class="line">console.log(new Child2())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;缺点就是：实例化子类的时候无法给父类传递参数</span><br></pre></td></tr></table></figure></li>
<li><strong>构造函数继承</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js没有构造函数，但是一个普通函数，使用new调用的时候，它就会构造一个对象</span><br><span class="line">&#x2F;&#x2F;函数不是构造函数，准确来说是 带new的函数调用</span><br><span class="line">function Parent1 () &#123;</span><br><span class="line">	this.name &#x3D; &#39;parent1&#39;</span><br><span class="line">&#125;</span><br><span class="line">Parent1.prototype.say &#x3D; function()&#123;&#125;;</span><br><span class="line">function Child1() &#123;</span><br><span class="line">	Parent1.call(this)</span><br><span class="line">	this.sex &#x3D; &#39;male&#39;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Child1())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;缺点就是：不能继承原型链上的属性或方法</span><br></pre></td></tr></table></figure></li>
<li>实例继承</li>
<li>拷贝继承</li>
<li><strong>组合继承</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Cat(name) &#123;</span><br><span class="line">	Animal.call(this)</span><br><span class="line">	this.name &#x3D; name || &#39;tom&#39;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype &#x3D; new Animal();</span><br><span class="line">&#x2F;&#x2F;第二种写法：Cat.prototype &#x3D; Animal.prototype</span><br><span class="line">&#x2F;&#x2F;如果没有Cat.prototype &#x3D; new Animal()这一行，Cat.prototype.constructo</span><br><span class="line">是指向Cat的，加了这一行，Cat.prototype.constructor 指向了Animal，这显然</span><br><span class="line">会导致继承链的紊乱，因此必须手动纠正。</span><br><span class="line">Cat.prototype.constructor &#x3D; Cat;</span><br><span class="line">&#x2F;&#x2F;Cat.prototype &#x3D; Animal.prototype</span><br><span class="line">&#x2F;&#x2F; Text code</span><br><span class="line">var cat &#x3D; new Cat()</span><br><span class="line">console.log(cat.name)</span><br><span class="line">console.log(cat.sleep())</span><br><span class="line">console.log(cat instanceof Animal)	&#x2F;&#x2F;true</span><br><span class="line">console.log(cat instanceof Cat)	&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li>
<li><strong>寄生组合继承</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Cat(name) &#123;</span><br><span class="line">	Animal.call(this);</span><br><span class="line">	this.name &#x3D; name || &#39;Tom&#39;</span><br><span class="line">&#125;</span><br><span class="line">(function()&#123;</span><br><span class="line">	&#x2F;&#x2F; 创建一个没有实例的类</span><br><span class="line">	var Super &#x3D; function() &#123;</span><br><span class="line">	    Super.prototype &#x3D; Animal.prototype;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将实例作为子类的原型</span><br><span class="line">	Cat.prototype &#x3D; new Super();</span><br><span class="line">&#125;)();</span><br><span class="line">Cat.prototype.constructor &#x3D; Cat;</span><br><span class="line">&#x2F;&#x2F; Text Code</span><br><span class="line">var cat &#x3D; new Cat();</span><br><span class="line">console.log(cat.name)</span><br><span class="line">console.log(cat.sleep)</span><br><span class="line">console.log(cat instanceof Animal)		&#x2F;&#x2F;true</span><br><span class="line">console.log(cat instanceof Cat)		&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li>
<li><strong>extends继承</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用extends实现继承，必须添加super关键字定义子类的constructor，</span><br><span class="line">这里的super()相当于Animal.prototype.constructor.call(this)</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>new 的过程都干了什么</title>
    <url>/2019/08/13/new-%E7%9A%84%E8%BF%87%E7%A8%8B%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h4 id="new的过程"><a href="#new的过程" class="headerlink" title="new的过程"></a>new的过程</h4><span id="more"></span>
<pre><code>- 新生成一个对象
- 链接到原型（继承该函数的原型）
- 绑定this（将原型中的属性和方法加入到this引用的对象中）
- 返回新对象
</code></pre>
<p>自己实现一个new：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function create() &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个空的对象</span><br><span class="line">    let obj &#x3D; new Object()</span><br><span class="line">    &#x2F;&#x2F; 获得构造函数</span><br><span class="line">    let Con &#x3D; [].shift.call(arguments)</span><br><span class="line">    &#x2F;&#x2F; 设置新对象的__proto__属性指向构造函数的prototype属性</span><br><span class="line">    obj.__proto__ &#x3D; Con.prototype</span><br><span class="line">    &#x2F;&#x2F; 绑定 this，函数中this指向新实例对象。</span><br><span class="line">    let result &#x3D; Con.apply(obj, arguments)</span><br><span class="line">    &#x2F;&#x2F; 确保 new 出来的是个对象</span><br><span class="line">    return typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// 简洁版的new实现过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function newFunc(constructor)&#123;</span><br><span class="line">  &#x2F;&#x2F;第一步：创建一个空对象obj </span><br><span class="line">    var obj &#x3D; &#123;&#125;;</span><br><span class="line">   &#x2F;&#x2F;第二步：将构造函数 constructor的原型对象赋给obj的原型</span><br><span class="line">    obj.__proto__ &#x3D; constructor.prototype;</span><br><span class="line">  &#x2F;&#x2F;第三步：将构造函数 constructor中的this指向obj,并立即执行构造函数内部的操作</span><br><span class="line">    constructor.apply(obj);</span><br><span class="line">  &#x2F;&#x2F;第四步：返回这个对象</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>var、let、const区别</title>
    <url>/2019/07/29/var%E3%80%81let%E3%80%81const%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="JavaScript中var、let和const的区别？"><a href="#JavaScript中var、let和const的区别？" class="headerlink" title="JavaScript中var、let和const的区别？"></a>JavaScript中var、let和const的区别？</h2><span id="more"></span>
<pre><code>1. JavaScript有两种作用域：全局作用域和方法作用域，没有块级作用域。

2. var在全局声明为全局变量，在函数内声明就是局部变量。

3. let是ES6新增的一个命令，用来声明局部变量。

4. var存在变量提升，可以在变量声明之前使用，返回undefined。let存在暂时性死区，在变量声明之前
使用，会提示ReferenceError。

5. 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不
可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

6. let不允许在同一个作用域内重复声明同一个变量。

7. const 和 let 相同，声明也只在当前的块级作用域生效。同样也不会声明提升，
也存在暂时死区，只能在声明之后使用，且和 let 一样不得重复声明，不能重新赋值。

8. const 所不能改变的并不是值，而是变量指向的那个内存地址所保存的值不能变动，
对于简单类型（数值、字符串、布尔值），值就保存在变量所指向的内存地址中，
因此等同于常量。而对于复合类型（数组、对象），变量指向的内存地址，保
存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的
（即总指向一个固定的地址）。
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2019/11/17/webpack/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><pre><code>npm install --global webpack
</code></pre>
<h4 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h4><pre><code>npm init -y
npm install webpack webpack-cli -D
</code></pre>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是DOCTYPE及其作用？</title>
    <url>/2019/07/06/%E4%BB%80%E4%B9%88%E6%98%AFDOCTYPE%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="什么是DOCTYPE及其作用？"><a href="#什么是DOCTYPE及其作用？" class="headerlink" title="什么是DOCTYPE及其作用？"></a>什么是DOCTYPE及其作用？</h2><ul>
<li><p>DOCTYPE是document type（文档类型）的缩写。</p>
<span id="more"></span></li>
<li><p>写法：<!DOCTYPE html>(声明了浏览器就会进入标准模式，按照W3C标准渲染页面)</p>
</li>
<li><p>DOCTYPE的作用：</p>
<ul>
<li>DOCTYPE是用来声明文档类型和DTD规范的，校验文件和代码的合法性。</li>
<li>告诉浏览器通过哪种规范（文档类型，DTD）来解析文档。</li>
</ul>
</li>
<li><p>DTD（document type definition）文档类型定义是一系列的语法规则，用来定义XML<br>  或HTML的文件类型。浏览器会根据它来判断文档类型，决定使用哪种协议来解析，以及切换<br>  浏览器的模式。</p>
</li>
<li><p>浏览器模式</p>
<p>  为了能够很好的显示满足标准的页面，又能最大程度兼容不合法的HTML，浏览器厂商会提供两种<br>  浏览器模式。</p>
<ul>
<li>标准模式：根据W3C标准来渲染页面。</li>
<li>混杂模式（兼容模式、怪异模式）：浏览器采用更加宽松、向后兼容的方式来渲染页面。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>渲染机制类</category>
      </categories>
      <tags>
        <tag>渲染机制类</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是FOUC？如何避免？</title>
    <url>/2019/07/17/%E4%BB%80%E4%B9%88%E6%98%AFFOUC%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="什么是FOUC？如何避免？"><a href="#什么是FOUC？如何避免？" class="headerlink" title="什么是FOUC？如何避免？"></a>什么是FOUC？如何避免？</h2><span id="more"></span>
<h4 id="一、为什么会有白屏和FOUC呢？"><a href="#一、为什么会有白屏和FOUC呢？" class="headerlink" title="一、为什么会有白屏和FOUC呢？"></a>一、为什么会有白屏和FOUC呢？</h4><blockquote>
<p>浏览器再渲染的时候没有请求到或请求时间过长造成的，那么浏览器怎么应对的呢？</p>
<ul>
<li>白屏：CSS全部载入解析完成后渲染展示页面，如果没有加载完，就会出现白屏。</li>
<li>FOUC(Flash of Unstyled Content)无样式内容闪烁：用户定义样式表加载之前浏览器<br>使用默认样式显示文档，用户样式表加载渲染之后，再重新显示文档，造成页面闪烁。</li>
</ul>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><blockquote>
<ul>
<li>使用link标签将样式表放在顶部<head>标签中，防止白屏问题出现。</li>
<li>将JS放在<body>标签底部，原因如下：<ul>
<li>脚本会阻塞后面内容的呈现</li>
<li>脚本会阻塞其后组件的下载</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是事件代理，它的原理是什么？</title>
    <url>/2019/08/13/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%83%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="什么是事件代理，它的原理是什么？"><a href="#什么是事件代理，它的原理是什么？" class="headerlink" title="什么是事件代理，它的原理是什么？"></a>什么是事件代理，它的原理是什么？</h2><ul>
<li><p>事件代理：通俗来说就是将元素的事件委托给它的父级或者更外层元素处理</p>
</li>
<li><p>原理：利用事件冒泡机制实现</p>
</li>
<li><p>优点：</p>
<ul>
<li>只需将同类元素的事件委托给父级或者更外层的元素，不需要给所有元素都绑定事件</li>
<li>减少内容空间占用，提升性能</li>
<li>动态新增的元素无需重新绑定事件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>从浏览器输入网站最终页面渲染完成的全过程解析</title>
    <url>/2019/06/29/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E7%AB%99%E6%9C%80%E7%BB%88%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="从浏览器输入网站最终页面渲染完成，发生了什么？"><a href="#从浏览器输入网站最终页面渲染完成，发生了什么？" class="headerlink" title="从浏览器输入网站最终页面渲染完成，发生了什么？"></a>从浏览器输入网站最终页面渲染完成，发生了什么？</h2><span id="more"></span>
<ul>
<li><p>在浏览器输入URL（Uniform Resource Locator,统一资源定位符），也就是网址。</p>
<ul>
<li>网址分为三部分：举例 <code>https://www.zhihu.com/people/oliver-8-10/activities</code><ul>
<li>协议部分  <code>https</code></li>
<li>网络地址部分  <code>www.zhihu.com</code>(每个域名背后都有一个对应的IP地址，分为三种<br>局域网IP、公网IP、本机IP)</li>
<li>资源路径部分  <code>/people/oliver-8-10/activities</code></li>
</ul>
</li>
</ul>
</li>
<li><p>DNS（Domain Name System域名系统）解析: 将域名地址解析为ip地址</p>
<ul>
<li>查找浏览器本地缓存（格式化检查以及确认是哪种协议，默认为http协议）</li>
<li>查找系统缓存（本地host文件查找对应ip）</li>
<li>查找本地路由器缓存解析</li>
<li>查找网络服务商DNS缓存（也是先检查缓存，若没有或过期则到根域名服务商上查找<br>对应ip）</li>
</ul>
<p>  <strong>至于为什么一定要拿到ip，因为我们的tcp/ip协议只能识别ip</strong></p>
</li>
<li><p>根据IP地址与服务器建立联系（TCP连接，TCP三次握手）</p>
<p>  (客户端拿到ip地址之后，想要进行通信就要先和服务器取得联系，看对方在不在，通常<br>  是由三次握手来实现)</p>
<ul>
<li>第一次握手：建立连接时，客户端发送一个syn包（syn=1）到服务器，并进入SYN_SEND<br>状态，等待服务器确认。</li>
<li>第二次握手：服务器收到syn包之后，回复给客户端一个SYN+ACK报文段，然后服务器端<br>进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务器的SYN+ACK报文段之后，向服务器发送ACK报文段，发送之后<br>客户端和服务器都进入ESTABLISHED（已建立）状态，完成TCP三次握手。（第三次握手，是为了防止<br>已经失效的连接请求报文段突然传到服务端而产生错误。没有第三次的client的确认，server端<br>会一直等待，浪费资源）</li>
</ul>
</li>
<li><p>发送请求</p>
<ul>
<li>请求报文： HTTP协议的通信内容<ul>
<li>请求头</li>
<li>请求行 :请求方法、请求URL、请求HTTP协议及版本</li>
<li>请求主体</li>
</ul>
</li>
</ul>
</li>
<li><p>接受响应</p>
<ul>
<li>响应报文<ul>
<li>响应头</li>
<li>响应行</li>
<li>响应主体</li>
</ul>
</li>
</ul>
</li>
<li><p>数据传输完毕之后，要断开TCP连接，TCP四次挥手</p>
<ul>
<li>第一次分手：客户端向服务端发送一个FIN报文段，告诉服务端表示没有数据要发送了，<br>客户端进入FIN_WAIT_1状态。</li>
<li>第二次分手：服务端接受到客户端的FIN报文段，返回一个ACK报文段表示已经知道客户端<br>没有数据要发送了，服务端进入FIN_WAIT_2状态。</li>
<li>第三次分手：服务端向客户端发送一个FIN报文段，请求关闭连接，同时服务端进入CLOSE_WAIT<br>状态</li>
<li>第四次分手：客户端接受到服务端的FIN报文段，向服务端发送一个ACK报文段，然后客户<br>端进入TIME_WAIT状态，服务端接受ACK报文段后，关闭连接；过了一段时间后，客户端没有<br>收到回复，证明服务端已正常关闭，然后客户端也关闭连接。</li>
</ul>
</li>
<li><p>页面渲染</p>
<ul>
<li>浏览器根据服务端返回的HTML通过深度遍历解析成一个DOM树。</li>
<li>将CSS解析成一个CSS规则树。</li>
<li>根据DOM树和CSS规则树构建出一个Rendering树。</li>
<li>最后就是通过Rendering树，浏览器就知道每个节点和各个节点css的关系，再算出每个节点<br>再屏幕的具体位置，将内容从上而下的渲染出来。</li>
</ul>
</li>
<li><p>浏览器渲染流程</p>
<ul>
<li>浏览器的主线程：Browser进程<ul>
<li>负责下载资源</li>
<li>创建销毁renderer进程</li>
<li>负责将renderer进程生成的位图渲染到页面上</li>
<li>与用户交互</li>
</ul>
</li>
<li>浏览器内核：renderer进程<ul>
<li>js引擎线程<ul>
<li>由一个主线程和多个web worker线程组成，web worker线程不能操作dom</li>
</ul>
</li>
<li>GUI线程<ul>
<li>用于解析html生成DOM树，解析CSS生成CSSOM，布局layout、绘制paint，<br>回流和重绘依赖该线程。</li>
</ul>
</li>
<li>事件线程<ul>
<li>当事件触发时，该线程将事件的回调函数放入callback queue(任务队列)<br>中，等待js引擎处理</li>
</ul>
</li>
<li>定时触发线程<ul>
<li>setTimeout和setInterval由该线程来计时，计时结束，将回调函数放入任务队列。</li>
</ul>
</li>
<li>http请求线程<ul>
<li>每有一个http请求就开一个该线程，每当检测到状态编程就会产生一个状态<br>变更事件，如果这个事件都由对应的回调函数，将这个函数放入到任务队列。</li>
</ul>
</li>
<li>任务队列轮询线程<ul>
<li>用于轮询监听任务队列</li>
</ul>
</li>
</ul>
</li>
<li>事件<ul>
<li>DOMContentLoaded<ul>
<li>当初始的HTML文档被完全加载和解析完成(script脚本执行完，所属的script<br>脚本之前的样式表加载解析完成)之后，DOMContentLoaded事件被触发。</li>
</ul>
</li>
<li>onLoad<ul>
<li>所有资源加载完成触发window的onLoad事件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>null和undefined的区别</title>
    <url>/2019/08/13/null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h2><p><code>null表示空对象，即此处为一个空值</code><br>    <span id="more"></span><br>典型用法：</p>
<ul>
<li>作为函数的参数</li>
<li>作为对象原型链的终点</li>
</ul>
<p><code>undefined 表示缺少值，即此处应该有一个值，但是还没有赋值</code></p>
<p>典型用法：</p>
<ul>
<li>变量被声明，但还未赋值，为undefined</li>
<li>调用函数时，应该提供的参数没有提供，为undefined</li>
<li>对象没有赋值的属性，该属性的值为undefined</li>
<li>函数没有返回值时，默认返回undefined</li>
</ul>
<p><code>undefined 和 null转换为Boolean都会自动转换为false</code></p>
<p><code>Number(null) ——&gt; 0   null + 5 = 5 </code></p>
<p><code>Number(undefined) ——&gt; NaN   undefined + 5 = NaN </code></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的了解ES6吗？</title>
    <url>/2020/10/07/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3ES6%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="你真的了解ES6吗？"><a href="#你真的了解ES6吗？" class="headerlink" title="你真的了解ES6吗？"></a>你真的了解ES6吗？</h2><h3 id="下面的代码输出什么？"><a href="#下面的代码输出什么？" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line"></span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">       resolve(2)</span><br><span class="line">       console.log(3)</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">    reject(&#39;error&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">.then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 error 3</span><br><span class="line">&#x2F;&#x2F;要点分析：</span><br><span class="line">&#x2F;&#x2F; + promise 创建之后会立即执行</span><br><span class="line">&#x2F;&#x2F; + 状态一旦改变就不会在变，也就是reject与resolve只会执行其中一个</span><br><span class="line">&#x2F;&#x2F; + 异步队列的执行顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="下面的代码输出什么？-1"><a href="#下面的代码输出什么？-1" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const first &#x3D; () &#x3D;&gt; (new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(2);</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            console.log(3);</span><br><span class="line">            resolve(4);</span><br><span class="line">        &#125;, 0)</span><br><span class="line">        resolve(5);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(6);</span><br><span class="line">    p.then((arg) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then((arg) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(7);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 2 7 5 6 3</span><br><span class="line">&#x2F;&#x2F;要点解析：</span><br><span class="line">&#x2F;&#x2F; + promise创建立即执行，依次输出1 2</span><br><span class="line">&#x2F;&#x2F; + 执行同步任务，输出 7</span><br><span class="line">&#x2F;&#x2F; + 在执行上一步的时候已经将p.then 以及 first.then 加入到微任务执行队列，所以依次输出 5 6</span><br><span class="line">&#x2F;&#x2F; + 最后执行宏任务 setTimeout，输出 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="下面的代码输出什么？-2"><a href="#下面的代码输出什么？-2" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">.then(2)</span><br><span class="line">.then(Promise.resolve(3))</span><br><span class="line">.then(console.log)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 答案： 1</span><br><span class="line">&#x2F;&#x2F; + 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。</span><br><span class="line">&#x2F;&#x2F; + then方法接收的参数是函数！！！，而如果传递的并非是一个函数就会导致前一个Promise的结果穿透到下面。</span><br></pre></td></tr></table></figure>

<h3 id="const-和-Object-freeze-有什么区别？"><a href="#const-和-Object-freeze-有什么区别？" class="headerlink" title="const 和 Object.freeze 有什么区别？"></a>const 和 Object.freeze 有什么区别？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;const 声明一个常量，一旦声明，常量的值就不能改变，对于复杂的数据类型，比如对象是可以修改其属性的。const实际保证的不是变量的值，而是变量指向的内存地址所指向的数据不能改变</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Object.freeze适用于对象值，使得对象不可变，即不能改变对象属性，但是如果对象的属性值仍是复杂数据类型，那么是可以修改成功的。</span><br></pre></td></tr></table></figure>

<h3 id="for…in和for…of"><a href="#for…in和for…of" class="headerlink" title="for…in和for…of"></a>for…in和for…of</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;对于纯对象的遍历，for...in更合适</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: [],</span><br><span class="line">    c: function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">for( let key in obj) &#123;</span><br><span class="line">    console.log(key);&#x2F;&#x2F; a b c</span><br><span class="line">    console.log(obj[key]); &#x2F;&#x2F;1 [] function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对于数组遍历，如果不需要知道索引，for...of迭代更合适，还可以中断</span><br><span class="line">const arr &#x3D; [3, 5, 7];</span><br><span class="line">for(let i of arr)&#123;</span><br><span class="line">    console.log(i);&#x2F;&#x2F;3 5 7</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组遍历如果需要知道索引forEach()更合适</span><br><span class="line">arr.forEach((value, index) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(value);&#x2F;&#x2F;3 5 7</span><br><span class="line">    console.log(index);&#x2F;&#x2F;0 1 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;for...in对于数组遍历，会遍历得到索引值，可以通过数组索引取得对应得值，但是，for...in不仅可以枚举数组自身，还会枚举数组的原型(可通过arr.hasOwnProperty(i)去除)以及数组对象本身属性值。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;for...of可以迭代字符串</span><br><span class="line">let str &#x3D; &#39;foo&#39;</span><br><span class="line">for(let value of str) &#123;</span><br><span class="line">    console.log(value); &#x2F;&#x2F; &quot;f&quot; &quot;o&quot; &quot;o&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;for...of可以直接迭代arguments类数组对象</span><br><span class="line">(function()&#123;</span><br><span class="line">    for(let arg of arguments) &#123;</span><br><span class="line">        console.log(arg);&#x2F;&#x2F;1 2 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(1, 2, 3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;for...of 还可以迭代NodeList这类DOM集合</span><br><span class="line">let elements &#x3D; document.querySelectorAll(&#39;body&#39;);</span><br><span class="line">for(let element of elements) &#123;</span><br><span class="line">    console.log(element.tagName); &#x2F;&#x2F;&quot;BODY&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;for...of迭代Map</span><br><span class="line">let mapData &#x3D; new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]]);</span><br><span class="line">for(let [key, value] of mapData) &#123;</span><br><span class="line">    console.log(value); &#x2F;&#x2F;1 2 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;for...of迭代Set</span><br><span class="line">let setData &#x3D; new Set([1, 2, 3, 2, 1]);</span><br><span class="line">for(let value of setData) &#123;</span><br><span class="line">    console.log(value);&#x2F;&#x2F;1 2 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>元数据&lt;meta&gt;</title>
    <url>/2019/09/07/%E5%85%83%E6%95%B0%E6%8D%AE-meta/</url>
    <content><![CDATA[<h2 id="有哪些常见的meta标签？"><a href="#有哪些常见的meta标签？" class="headerlink" title="有哪些常见的meta标签？"></a>有哪些常见的meta标签？</h2><span id="more"></span>
<ul>
<li>指定文档编码<ul>
<li><code>&lt;meta charset = &quot;UTF-8&quot;&gt;</code></li>
</ul>
</li>
<li>name 属性<ul>
<li><code>1.&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;：在移动设备浏览器上，禁用缩放（zooming） 功能，用户只能滚动屏幕。</code></li>
<li><code>2.&lt;meta name=”description” content=””&gt;：告诉搜索引擎，当前页面的主要内容是xxx。</code></li>
<li><code>3.&lt;meta name=”keywords” content=””&gt;：告诉搜索引擎，当前页面的关键字。</code></li>
<li><code>4.&lt;meta name=”author” content=””&gt;：告诉搜索引擎，标注网站作者是谁。</code></li>
<li><code>5.&lt;meta name=”copyright” content=””&gt;：标注网站的版权信息。</code></li>
</ul>
</li>
<li>http-equiv 属性<ul>
<li><code>1.&lt;meta http-equiv=”Set-Cookie” content=”cookievalue=xxx;  expires=Friday,12-Jan-2001 18:18:18 GMT; path=/”&gt;:如果网页过期， 那么存盘的cookie将被删除。必须使用GMT的时间格式。</code></li>
<li><code>2.&lt;meta http-equiv=&#39;expires&#39; content=&#39;时间&#39; &gt;：用于设定网页的到期时间。  一旦网页过期，必须到服务器上重新传输。</code></li>
<li><code>3.&lt;meta http-equiv=”Refresh” content=”5;URL”&gt;：告诉浏览器在  【数字】秒后跳转到【一个网址】</code></li>
<li><code>4.&lt;meta http-equiv=”content-Type” content=”text/html; charset=utf-8″&gt;：  设定页面使用的字符集。</code></li>
<li><code>5.&lt;meta http-equiv=”Pragma” content=”no-cache”&gt;：禁止浏览器从本地   计算机的缓存中访问页面内容。访问者将无法脱机浏览。</code></li>
<li><code>6.&lt;meta http-equiv=”Window-target” content=”_top”&gt;：用来防止  别人在iframe(框架)里调用自己的页面，这也算是一个非常实用的属性。</code></li>
<li><code>7.&lt;meta http-equiv=&#39;X-UA-Compatible&#39; content=&#39;IE=edge,chrome=1&#39;&gt;   :强制浏览器按照特定的版本标准进行渲染。但不支持IE7及以下版本。如果是  ie浏览器就用最新的ie渲染，如果是双核浏览器就用chrome内核。</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>关于substring、substr和slice、splice的用法和区别</title>
    <url>/2019/06/06/%E5%85%B3%E4%BA%8Esubstring%E3%80%81substr%E5%92%8Cslice%E3%80%81splice%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="substring和substr"><a href="#substring和substr" class="headerlink" title="substring和substr"></a>substring和substr</h1><ul>
<li><strong>substring</strong> 和 <strong>substr</strong>都是针对字符串的，都是返回一个副本，而不是再原来字符串上直接操作的。<span id="more"></span>
<h4 id="关于substring（）"><a href="#关于substring（）" class="headerlink" title="关于substring（）"></a>关于substring（）</h4></li>
</ul>
<ul>
<li>substring（start, stop）表示从start开始到stop之间的新字符串，含头不含尾。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &#39;follish&#39;</span><br><span class="line">console.log(str.substring(1, 5)) &#x2F;&#x2F;&quot;olli&quot;</span><br><span class="line">console.log(str.substring(1, 5), str) &#x2F;&#x2F;&quot;olli follish&quot;</span><br></pre></td></tr></table></figure>
<!--more--></li>
<li>其中start是必填项，stop不填，表示从start处截取到字符串结尾，上代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;</span><br><span class="line">console.log(str.substring(1)) &#x2F;&#x2F;&quot;123456789&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果start比stop大，再方法执行前会先交换这两个参数，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substring(8,4))&#x2F;&#x2F;&quot;4567&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果start 和 stop相等，会返回一个空的字符串，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substring(6,6))&#x2F;&#x2F;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果 start 和 stop 为负数，则在方法执行之前会先将负数变为0，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substring(-2,6))&#x2F;&#x2F;&quot;012345&quot;</span><br><span class="line">console.log(str.substring(2,-6))&#x2F;&#x2F;&quot;01&quot;</span><br><span class="line">console.log(str.substring(-2,-6))&#x2F;&#x2F;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="关于substr（）"><a href="#关于substr（）" class="headerlink" title="关于substr（）"></a>关于substr（）</h4></li>
<li>substr(start, length)表示返回从start开始包含length长度的新字符串，包含start且不修改原字符串，如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substr(1,5))&#x2F;&#x2F;&quot;12345&quot; length为5</span><br><span class="line">console.log(str.substr(2,6),str)&#x2F;&#x2F;&quot;234567&quot; &quot;0123456789&quot;</span><br></pre></td></tr></table></figure></li>
<li>其中start是必填项，如果length不填，表示从start截取到字符串结尾，例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substr(1))&#x2F;&#x2F;&quot;123456789&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果 start 为负数，那么start = str.length + start ,例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substr(-1))&#x2F;&#x2F;&quot;9&quot;</span><br><span class="line">console.log(str.substr(-6,3))&#x2F;&#x2F;&quot;456&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果length的值为0或负数，则返回空字符串，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">console.log(str.substr(1,0))&#x2F;&#x2F;&quot;&quot;</span><br><span class="line">console.log(str.substr(-1,-1))&#x2F;&#x2F;&quot;&quot;</span><br><span class="line">console.log(str.substr(-1,0))&#x2F;&#x2F;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="关于slice"><a href="#关于slice" class="headerlink" title="关于slice()"></a>关于slice()</h4></li>
<li>重点声明一下，substring、substr只能操作字符串，splice只能操作数组，而最🐮🍺的就是<strong>slice</strong>既可操作数组又可以操作字符串。</li>
<li>slice(start, stop)表示截取从下标start到stop之间的元素，并返回新数组不改变原数组（字符串），类似与substring，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">    arr &#x3D; [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(str.slice(1,6))&#x2F;&#x2F;&quot;12345&quot;</span><br><span class="line">console.log(arr.slice(1,6))&#x2F;&#x2F;[1,2,3,4,5]</span><br></pre></td></tr></table></figure></li>
<li>start是必填项，如果stop不填，表示从start处截取到结尾，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">    arr &#x3D; [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(str.slice(1))&#x2F;&#x2F;&quot;123456789&quot;</span><br><span class="line">console.log(arr.slice(1))&#x2F;&#x2F;[1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></li>
<li>如果 start 比 stop 大，或者两者相等，则截取的内容为空，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">    arr &#x3D; [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(str.slice(3,3))&#x2F;&#x2F;&quot;&quot;</span><br><span class="line">console.log(arr.slice(3,3))&#x2F;&#x2F;[]</span><br><span class="line">console.log(str.slice(6,5))&#x2F;&#x2F;&quot;&quot;</span><br><span class="line">console.log(arr.slice(6,5))&#x2F;&#x2F;[]</span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>：如果start或者stop为负数，那么负数的选项从数组尾部开始算起，最后一个数字为-1，倒数第二个数字为-2，依次类推，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0123456789&quot;;</span><br><span class="line">console.log(str.slice(6,-1))&#x2F;&#x2F;&quot;678&quot;</span><br><span class="line">console.log(str.slice(-6,-1))&#x2F;&#x2F;&quot;45678&quot;</span><br><span class="line">console.log(str.slice(-6,8))&#x2F;&#x2F;&quot;4567&quot;</span><br></pre></td></tr></table></figure>
<h4 id="关于splice"><a href="#关于splice" class="headerlink" title="关于splice()"></a>关于splice()</h4></li>
<li>splice只能操作数组，splice(start, length, items)表示从下标start出截取length长度的元素后，在start处为原数组添加items，并返回截取的数组，splice会直接修改原数组：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(arr.splice(1,3,2,3,4))&#x2F;&#x2F;[1,2,3]</span><br><span class="line">console.log(arr);&#x2F;&#x2F;[0,2,3,4,4,5,6,7,8,9] 原数组被截取走了1,2,3，并加入了2,3,4</span><br></pre></td></tr></table></figure></li>
<li>其中start和length都是必填项，items为选填项，如果length为0或负数，则返回空数组，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(arr.splice(1,0,2,3,4))&#x2F;&#x2F;[]</span><br><span class="line">console.log(arr);&#x2F;&#x2F;[0,2,3,4,1,2,3,4,5,6,7,8,9] 直接在原数组下标0处并加入了2,3,4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(arr.splice(1,-9,2,3,4))&#x2F;&#x2F;[]</span><br><span class="line">console.log(arr);&#x2F;&#x2F;[0,2,3,4,1,2,3,4,5,6,7,8,9] 直接在原数组下标0处并加入了2,3,4</span><br></pre></td></tr></table></figure></li>
<li>如果start为负数，也是从右往左截取，最后一位为-1，倒数第二位为-2，以此类推，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [0,1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(arr.splice(-1,1,2,3,4))&#x2F;&#x2F;[9]</span><br><span class="line">console.log(arr);&#x2F;&#x2F;[0,1,2,3,4,5,6,7,8,2,3,4] 从右往左截取1位，也就是9，并加入2,3,4</span><br></pre></td></tr></table></figure>
<img src="http://vamknight.com/01.jpg" alt="寡姐最美"><br>【参考链接】：<a href="https://www.cnblogs.com/echolun/p/7646025.html">https://www.cnblogs.com/echolun/p/7646025.html</a></li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄漏</title>
    <url>/2019/10/11/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h2 id="造成内存泄漏的原因？"><a href="#造成内存泄漏的原因？" class="headerlink" title="造成内存泄漏的原因？"></a>造成内存泄漏的原因？</h2><ul>
<li>意外的全局变量<ul>
<li>无法被回收</li>
</ul>
</li>
<li>定时器<ul>
<li>未被正确关闭，导致所引用的外部变量无法被释放</li>
</ul>
</li>
<li>事件监听<ul>
<li>没有正确销毁</li>
</ul>
</li>
<li>闭包<ul>
<li>会导致父级中的变量无法被释放</li>
</ul>
</li>
<li>DOM引用<ul>
<li>DOM被删除时，内存中的引用未被正确清空</li>
</ul>
</li>
</ul>
<h2 id="如何查看内存变化情况？"><a href="#如何查看内存变化情况？" class="headerlink" title="如何查看内存变化情况？"></a>如何查看内存变化情况？</h2><ul>
<li>使用Chrome的Performance面板进行内存标记，可视化查看内存变化情况，找出异常点。</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全</title>
    <url>/2019/10/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><ul>
<li>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，<br>最终达到欺骗服务器执行恶意的SQL命令</li>
</ul>
<h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ul>
<li>xss：跨站脚本攻击(Cross Site Scripting),攻击者通过注入非法的html标签<br>或者JavaScript代码，从而当用户浏览该网页时，控制用户浏览器。</li>
<li>xss主要分为三类：<ul>
<li>DOM xss<ul>
<li>DOM即文本对象模型，DOM通常代表在html、xhtml和xml中的对象，使用DOM<br>可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器<br>解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端<br>的事情。</li>
</ul>
</li>
<li>反射型 xss<ul>
<li>反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请<br>求时，XSS代码出现在URL中 ，最后输入提交到服务器，服务器解析后在响应内容<br>中出现这段XSS代码，最后浏览器解析执行。</li>
</ul>
</li>
<li>存储型 xss<ul>
<li>存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS<br>和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。<br>允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS<br>代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中<br>最典型的例子就是留言板。</li>
</ul>
</li>
</ul>
</li>
<li>主要影响：<ul>
<li>利用虚假输入表单骗取用户个人信息</li>
<li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或者图片</li>
</ul>
</li>
<li>防御措施：<ul>
<li>设置httpOnly：在cookie中设置HttpOnly属性后，js脚本将无法读取到cookie的信息。</li>
<li>输入检查，对于用户输入进行格式检查。<ul>
<li>移除用户上传的DOM属性，如onerror事件等。</li>
<li>移除用户上传的style节点、script节点、iframe节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><ul>
<li><p>csrf：跨站请求伪造(Cross-Site Request Forgeries)，冒充用户发起请求，完成<br>一些违背用户意愿的事情。</p>
</li>
<li><p>防御措施</p>
<ul>
<li>Token验证：<ul>
<li>第一步：后端随机产生一个token，把这个token保存在session状态中，同时<br>后端把token交给前端页面；</li>
<li>第二步：前端页面提交请求时，把token加入到请求数据或者头信息中，一起<br>传给后端；</li>
<li>后端验证前端传来的token与session是否一致，一致则合法，否则非法请求。</li>
</ul>
</li>
<li>Referer check：请求来源验证，但是不能保证100%有效，因为服务器并不是什么<br>时候都能取到Referer，而且低版本浏览器存在伪造Referer的风险。</li>
<li>验证码：强制用户必须和应用进行交互，完成最终请求，但用户体验比较差。</li>
</ul>
</li>
</ul>
<h4 id="clickjacking"><a href="#clickjacking" class="headerlink" title="clickjacking"></a>clickjacking</h4><ul>
<li><p>clickjacking: 点击劫持，利用透明的按钮或连接做成陷阱，覆盖在web页面之上，然后<br>诱使用户在不知的情况下，点击那个链接访问内容的一种攻击手段。又称为界面伪装。</p>
</li>
<li><p>大概有两种方式：</p>
<ul>
<li>攻击者使用一个透明iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，<br>此时用将在不知情的情况下点击透明的iframe页面。</li>
<li>攻击者使用一张图片覆盖在网页，遮挡网页原有的位置含义。</li>
</ul>
</li>
<li><p>防御措施：</p>
<ul>
<li>X-FRAME-OPTIONS 响应头是用来给浏览器指示允许一个页面可否在<code>&lt;frame&gt;</code>,<br><code>&lt;iframe&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记。网站可以使用此功能，来确保自己网站<br>内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。</li>
</ul>
</li>
</ul>
<h5 id="控制台注入代码"><a href="#控制台注入代码" class="headerlink" title="控制台注入代码"></a>控制台注入代码</h5>]]></content>
      <categories>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>同步和异步的区别，怎么异步加载javascript</title>
    <url>/2019/08/13/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjavascript/</url>
    <content><![CDATA[<h2 id="同步和异步的区别，怎么异步加载javascript"><a href="#同步和异步的区别，怎么异步加载javascript" class="headerlink" title="同步和异步的区别，怎么异步加载javascript?"></a>同步和异步的区别，怎么异步加载javascript?</h2><ul>
<li><p>同步模式<br>  同步模式，又称阻塞模式，javascript在默认情况下是会阻塞加载的，当前面的 </p>
<p>  javascript 请求没有处理和执行完时，会阻止浏览器的后续处理</p>
</li>
<li><p>异步模式<br>  异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理</p>
</li>
<li><p>异步加载JavaScript</p>
<ul>
<li>动态添加script标签</li>
<li>defer</li>
<li>async</li>
</ul>
<p>  defer属性和async都是属于 script 标签上面的属性，两者都能实现 JavaScript 的</p>
<p>  异步加载。不同之处在于：async 在异步加载完成的时候就马上开始执行了，defer 会等到</p>
<p>   html 加载完毕之后再执行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串去重</title>
    <url>/2019/08/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<h2 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h2><h4 id="for遍历"><a href="#for遍历" class="headerlink" title="for遍历"></a>for遍历</h4><span id="more"></span>
<pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var flag;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        flag = 1;
        var newLen = newStr.length;
        for(var j=0; j&lt;newLen; j++)&#123;
            if(str[i] == newStr[j])&#123;
                flag = 0;
                break;
            &#125;
        &#125;
        if(flag)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr; 
&#125;
</code></pre>
<h4 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法"></a>indexOf方法</h4><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(newStr.indexOf(str[i])==-1)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h4 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h4><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(newStr.search(str[i])==-1)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h4 id="对象属性法"><a href="#对象属性法" class="headerlink" title="对象属性法"></a>对象属性法</h4><pre><code>function removeRepeatStr(str)&#123;
    var obj = &#123;&#125;;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(!obj[str[i]])&#123;
            newStr = newStr + str[i];
            obj[str[i]] = 1;//注意，这里的1是给对象属性赋值，这个值可以任意取。意思是把每个遍历的字符作为对象属性并赋值保存，保证该属性的唯一性
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>常见设计模式</title>
    <url>/2019/09/27/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h3><ul>
<li><p>单例模式</p>
</li>
<li><p>构造函数模式</p>
</li>
<li><p>建造者模式</p>
</li>
<li><p>工厂模式</p>
</li>
<li><p>代理模式</p>
</li>
<li><p>命令模式</p>
</li>
<li><p>观察者模式</p>
</li>
<li><p>适配器模式</p>
</li>
<li><p>职责链模式</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序</title>
    <url>/2019/10/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><h4 id="文件主要目录及文件作用"><a href="#文件主要目录及文件作用" class="headerlink" title="文件主要目录及文件作用"></a>文件主要目录及文件作用</h4> <span id="more"></span>
<ul>
<li>component 组件文件夹<ul>
<li>navBar 底部组件<ul>
<li>navBar.js 底部组件的js代码</li>
<li>navBar.json 底部组件的配置文件</li>
<li>navBar.wxml 底部组件的html代码</li>
<li>navBar.wxss 底部组件的css代码</li>
</ul>
</li>
</ul>
</li>
<li>pages 页面文件夹<ul>
<li>index 首页<ul>
<li>index.js 首页的js代码</li>
<li>index.json 首页的配置文件</li>
<li>index.wxml 首页的html代码</li>
<li>index.wxss 首页的css代码</li>
</ul>
</li>
</ul>
</li>
<li>public 图片文件夹</li>
<li>utils 工具文件夹<ul>
<li>api.js 控制api的文件</li>
<li>md5.js 工具：MD5加密文件</li>
<li>timestamp.js 工具：事件戳文件</li>
</ul>
</li>
<li>app.json 设置全局的基础数据等</li>
<li>app.wxss 公共样式，可通过import导入更多</li>
<li>project.config.json 项目配置文件</li>
</ul>
<h4 id="微信小程序生命周期"><a href="#微信小程序生命周期" class="headerlink" title="微信小程序生命周期"></a>微信小程序生命周期</h4><ul>
<li>onLoad(): 页面加载时触发，一个页面只会调用一次，可以在onLoad中获取打开当前页面<br>所调用的query参数。</li>
<li>onShow(): 页面显示/切入前台时触发，每次打开页面都会调用一次。</li>
<li>onReady(): 页面初次渲染完成时触发，一个页面只会调用一次。</li>
<li>onHide(): 页面隐藏/切入后台时触发，当navigateTo或底部tab切换时调用。</li>
<li>onUnload(): 页面卸载时触发。</li>
</ul>
<h4 id="app-json是对当前小程序的全局配置，讲述三个配置各个项的含义"><a href="#app-json是对当前小程序的全局配置，讲述三个配置各个项的含义" class="headerlink" title="app.json是对当前小程序的全局配置，讲述三个配置各个项的含义?"></a>app.json是对当前小程序的全局配置，讲述三个配置各个项的含义?</h4><ul>
<li>pages字段：用于描述当前小程序所有页面路径，为了让微信客户端知道当前小程序页面<br>定义在那个目录。</li>
<li>window字段：小程序所有页面的顶部背景颜色，文字颜色定义等。</li>
<li>tab字段：小程序全局顶部tab或底部tab。</li>
</ul>
<h4 id="小程序的wxss和css有哪些不一样的地方？"><a href="#小程序的wxss和css有哪些不一样的地方？" class="headerlink" title="小程序的wxss和css有哪些不一样的地方？"></a>小程序的wxss和css有哪些不一样的地方？</h4><ul>
<li>新像素单位rpx</li>
<li>样式可直接使用import导入</li>
</ul>
<h4 id="小程序wxml和标准的html的异同？"><a href="#小程序wxml和标准的html的异同？" class="headerlink" title="小程序wxml和标准的html的异同？"></a>小程序wxml和标准的html的异同？</h4><p>都是用来描述页面的结构，都是由标签、属性等构成。</p>
<ul>
<li>标签名字不一样，且小程序标签更少，单一标签更多。</li>
<li>多了一些wx:if这样的属性和双大括号这样的表达式。</li>
<li>wxml只能在微信小程序开发者工具中预览，html可以在浏览器内预览。</li>
<li>组件封装不同，wxml对组件进行了重新封装。</li>
<li>小程序运行在JS Core内，没有DOM树和window对象，小程序无法使用window对象和document<br>对象。</li>
</ul>
<h4 id="小程序wxss和css的异同？"><a href="#小程序wxss和css的异同？" class="headerlink" title="小程序wxss和css的异同？"></a>小程序wxss和css的异同？</h4><p>都是用来描述页面的样子</p>
<ul>
<li>wxss具有css大部分的特性，也做了一些扩充和修改。</li>
<li>wxss新增了尺寸单位，wxss在底层支持新的尺寸单位rpx。</li>
<li>wxss仅支持部分css选择器。</li>
<li>wxss提供全局样式和局部样式。</li>
</ul>
<h4 id="小程序页面间有哪些传递数据的方法？"><a href="#小程序页面间有哪些传递数据的方法？" class="headerlink" title="小程序页面间有哪些传递数据的方法？"></a>小程序页面间有哪些传递数据的方法？</h4><ul>
<li>使用全局变量实现数据传递</li>
<li>页面跳转或重定向时，使用url带参数传递数据</li>
<li>使用组件模板template传递参数</li>
<li>使用数据库传递数据</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>手写JS代码</title>
    <url>/2019/07/17/%E6%89%8B%E5%86%99JS%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="手写防抖（Debouncing）和节流（Throttling）"><a href="#手写防抖（Debouncing）和节流（Throttling）" class="headerlink" title="手写防抖（Debouncing）和节流（Throttling）"></a>手写防抖（Debouncing）和节流（Throttling）</h2><h3 id="防抖（Debouncing）实现"><a href="#防抖（Debouncing）实现" class="headerlink" title="防抖（Debouncing）实现"></a>防抖（Debouncing）实现</h3><ul>
<li>典型例子：限制<code>鼠标连击</code>触发、<code>监听用户输入</code>。<blockquote>
<p><strong>解释</strong>：当一次事件发生后，事件处理器要等一定阀值的时间，如果这段时间过去后，再也没有事件发生，就处理最后一次发生的事件。如果还差<code>0.01</code>秒到达指定事件，这是又有一次事件触发，那么之前的等待作废，需要重新再次等待指定时间。</p>
</blockquote>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;防抖动函数</span><br><span class="line">function debounce(fn, wait &#x3D; 50, immediate) &#123;</span><br><span class="line"></span><br><span class="line">	let timer;</span><br><span class="line">	</span><br><span class="line">	return function() &#123;</span><br><span class="line">	</span><br><span class="line">		if (immediate) &#123;</span><br><span class="line">		</span><br><span class="line">		fn.apply(this, arguments)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (timer) clearTimeout(timer)</span><br><span class="line">		</span><br><span class="line">		timer &#x3D; setTimeout() &#x3D;&gt; &#123;</span><br><span class="line">		</span><br><span class="line">			fn.apply(this, arguments)</span><br><span class="line">			</span><br><span class="line">		&#125;,wait)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="节流（Throttling）实现"><a href="#节流（Throttling）实现" class="headerlink" title="节流（Throttling）实现"></a>节流（Throttling）实现</h4><blockquote>
<p><strong>解释</strong>：可以理解为事件再一个管道中传输，加上这个节流阀之后，事件的流速就会减慢，节流可以将一个函数的调用频率限制再一定阀值内，例如 1s ，那么 1s 内这个函数一定不会被调用两次。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;简单的节流函数</span><br><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">	let prev &#x3D; new Date();</span><br><span class="line">	return function() &#123; 	</span><br><span class="line">	    const args &#x3D; arguments;   </span><br><span class="line">		const now &#x3D; new Date();</span><br><span class="line">		if (now - prev &gt; wait) &#123;</span><br><span class="line">			fn.apply(this, args);</span><br><span class="line">			prev &#x3D; new Date();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="手写一个JS深拷贝"><a href="#手写一个JS深拷贝" class="headerlink" title="手写一个JS深拷贝"></a>手写一个JS深拷贝</h4><ul>
<li>著名乞丐版<blockquote>
<p>var newObj = JSON.parse ( JSON.stringify ( someObj ) );</p>
</blockquote>
</li>
<li>面试够用版<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">	if (typeof obj &#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class="line">		&#x2F;&#x2F;复杂数据类型</span><br><span class="line">		var result &#x3D; obj.constructor &#x3D;&#x3D; Array ? [] : &#123;&#125;;</span><br><span class="line">		for (let i in obj) &#123;</span><br><span class="line">			result[i] &#x3D; typeof obj[i] &#x3D;&#x3D; &quot;object&quot; ? deepCopy(obj[i] : obj[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	&#x2F;&#x2F;简单数据类型</span><br><span class="line">		var result &#x3D; obj</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="手写一个Promise"><a href="#手写一个Promise" class="headerlink" title="手写一个Promise"></a>手写一个Promise</h4></li>
<li>三种状态 <code>pending | fulfilled(resolved) | rejected</code></li>
<li>当处于 <code>pending</code> 状态的时候，可以转移到 <code>fulfilled(resolved)</code>或者<code>rejected</code>状态</li>
<li>当处于<code>fulfilled(resolved)</code>状态或者<code>rejected</code>状态时候，就不可变。</li>
<li>必须有一个<code>then</code>的异步执行方法，<code>then</code>接受两个参数<code>onFulfilled、onRejected</code></li>
</ul>
<p><strong>基础版</strong> 代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myPromise(constructor)&#123;</span><br><span class="line">    let self&#x3D;this;</span><br><span class="line">    self.status&#x3D;&quot;pending&quot; &#x2F;&#x2F;定义状态改变前的初始状态</span><br><span class="line">    self.value&#x3D;undefined;&#x2F;&#x2F;定义状态为resolved的时候的状态</span><br><span class="line">    self.reason&#x3D;undefined;&#x2F;&#x2F;定义状态为rejected的时候的状态</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        &#x2F;&#x2F;两个&#x3D;&#x3D;&#x3D;&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status&#x3D;&#x3D;&#x3D;&quot;pending&quot;)&#123;</span><br><span class="line">          self.value&#x3D;value;</span><br><span class="line">          self.status&#x3D;&quot;resolved&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        &#x2F;&#x2F;两个&#x3D;&#x3D;&#x3D;&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status&#x3D;&#x3D;&#x3D;&quot;pending&quot;)&#123;</span><br><span class="line">          self.reason&#x3D;reason;</span><br><span class="line">          self.status&#x3D;&quot;rejected&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;捕获构造异常</span><br><span class="line">    try&#123;</span><br><span class="line">       constructor(resolve,reject);</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">       reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同时再myPromise的原型上定义链式调用的then方法：</span><br><span class="line"></span><br><span class="line">myPromise.prototype.then&#x3D;function(onFullfilled,onRejected)&#123;</span><br><span class="line">   let self&#x3D;this;</span><br><span class="line">   switch(self.status)&#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现-instanceof"><a href="#实现-instanceof" class="headerlink" title="实现 instanceof"></a>实现 instanceof</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function instanceof (left, right) &#123;</span><br><span class="line">	let proto &#x3D; left.__proto__;</span><br><span class="line">	let prototype &#x3D; right.prototype</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		if (proto &#x3D;&#x3D;&#x3D; null) return false</span><br><span class="line">		if (proto &#x3D;&#x3D;&#x3D; prototype) return true</span><br><span class="line">		proto &#x3D; proto.__proto__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="js函数柯里化"><a href="#js函数柯里化" class="headerlink" title="js函数柯里化"></a>js函数柯里化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;求和</span><br><span class="line">let add &#x3D; function (a, b, c) &#123;</span><br><span class="line">	return a + b +c</span><br><span class="line">&#125;</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">	&#x2F;&#x2F;闭包</span><br><span class="line">	&#x2F;&#x2F;缓存除函数fn之外的所有参数</span><br><span class="line">	let args &#x3D; Array.prototype.slice.call(arguments, 1)</span><br><span class="line">	return function() &#123;</span><br><span class="line">		&#x2F;&#x2F;连接已经缓存的老的参数和新传入的参数（就是把每次传入的参数都先保存下来，但是并不执行）</span><br><span class="line">		let newArgs &#x3D; args.concat(Array.from(arguments))</span><br><span class="line">		if (newArgs.length &lt; fn.length) &#123;</span><br><span class="line">			return curry.call(this, fn, ...newArgs)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">		&#x2F;&#x2F;调用</span><br><span class="line">		return fn.apply(this, newArgs)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let f &#x3D; curry(add)</span><br><span class="line">console.log(&#39;柯里化&#39;,f(1)(2)(3))</span><br><span class="line">console.log(&#39;柯里化&#39;,f(1, 2)(3))</span><br><span class="line">console.log(&#39;柯里化&#39;,f(1, 2, 3))</span><br></pre></td></tr></table></figure>
<h4 id="原生js封装ajax"><a href="#原生js封装ajax" class="headerlink" title="原生js封装ajax"></a>原生js封装ajax</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ajax(options) &#123;</span><br><span class="line">	var xhr &#x3D; null;</span><br><span class="line">	var params &#x3D; formsParams(options, data);</span><br><span class="line">	&#x2F;&#x2F;创建对象</span><br><span class="line">	if (window.XMLHttpRequest()) &#123;</span><br><span class="line">		xhr &#x3D; new XMLHttpRequest()</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		xhr &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;连接</span><br><span class="line">	if (options.type &#x3D;&#x3D;&#x3D; &quot;GET&quot;) &#123;</span><br><span class="line">		xhr.open(options.type, options.url + &quot;?&quot; +params, options.async);</span><br><span class="line">		xhr.send(null)</span><br><span class="line">	&#125; else if (options.type &#x3D;&#x3D;&#x3D; &quot;POST&quot;) &#123;</span><br><span class="line">		xhr.open(options.type, options.url, options.async);</span><br><span class="line">		xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;);</span><br><span class="line">		xhr.send(params);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;判断状态</span><br><span class="line">	xhr.onreadystateChange &#x3D; function() &#123;</span><br><span class="line">		if (xhr.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D;&#x3D;200) &#123;</span><br><span class="line">			options.success(xhr.responseText);</span><br><span class="line">		&#125;</span><br><span class="line">	function formParams(data) &#123;</span><br><span class="line">		var arr &#x3D; [];</span><br><span class="line">		for (var prop in data) &#123;</span><br><span class="line">			arr.push(prop + &quot;&#x3D;&quot; + data[prop]);</span><br><span class="line">		&#125;</span><br><span class="line">		return arr.join(&quot;&amp;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">ajax(&#123;</span><br><span class="line">	url: &quot;time.php&quot;,</span><br><span class="line">	type: &quot;POST&quot;,</span><br><span class="line">	async: true,</span><br><span class="line">	data: &#123;</span><br><span class="line">		name: &quot;Tom&quot;,</span><br><span class="line">		age: 18</span><br><span class="line">	&#125;,</span><br><span class="line">	success: function(data) &#123;</span><br><span class="line">		console.log(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>简化版：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 1. 创建连接 **&#x2F;</span><br><span class="line">var xhr &#x3D; null;</span><br><span class="line">xhr &#x3D; new XMLHttpRequest()</span><br><span class="line">&#x2F;** 2. 连接服务器 **&#x2F;</span><br><span class="line">xhr.open(&#39;get&#39;, url, true)</span><br><span class="line">&#x2F;** 3. 发送请求 **&#x2F;</span><br><span class="line">xhr.send(null);</span><br><span class="line">&#x2F;** 4. 接受请求 **&#x2F;</span><br><span class="line">xhr.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">	if(xhr.readyState &#x3D;&#x3D; 4)&#123;</span><br><span class="line">		if(xhr.status &#x3D;&#x3D; 200)&#123;</span><br><span class="line">			success(xhr.responseText);</span><br><span class="line">		&#125; else &#123; </span><br><span class="line">			&#x2F;** false **&#x2F;</span><br><span class="line">			fail &amp;&amp; fail(xhr.status);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化版封装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function get(url, callback) &#123;</span><br><span class="line">    var oReq &#x3D; new XMLHttpRequest()</span><br><span class="line">    oReq.onload &#x3D; function() &#123;</span><br><span class="line">        callback(oReq.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">    oReq.open(&quot;get&quot;, url, true)</span><br><span class="line">    oReq.send()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get(&#39;data.json&#39;, function(data) &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="手写jsonp"><a href="#手写jsonp" class="headerlink" title="手写jsonp"></a>手写jsonp</h4><p>跨域通信的几种方式：jsonp、hash、postMessage、webSocket、CORS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function (window,document) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    var jsonp &#x3D; function (url,data,callback) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1.将传入的data数据转化为url字符串形式</span><br><span class="line">        &#x2F;&#x2F; &#123;id:1,name:&#39;zhangsan&#39;&#125; &#x3D;&gt; id&#x3D;1&amp;name&#x3D;zhangsan</span><br><span class="line">        var dataString &#x3D; url.indexof(&#39;?&#39;) &#x3D;&#x3D; -1? &#39;?&#39;: &#39;&amp;&#39;;</span><br><span class="line">        for(var key in data)&#123;</span><br><span class="line">            dataString +&#x3D; key + &#39;&#x3D;&#39; + data[key] + &#39;&amp;&#39;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2 处理url中的回调函数</span><br><span class="line">        &#x2F;&#x2F; cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span><br><span class="line">        var cbFuncName &#x3D; &#39;my_json_cb_&#39; + Math.random().toString().replace(&#39;.&#39;,&#39;&#39;);</span><br><span class="line">        dataString +&#x3D; &#39;callback&#x3D;&#39; + cbFuncName;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.创建一个script标签并插入到页面中</span><br><span class="line">        var scriptEle &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">        scriptEle.src &#x3D; url + dataString;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.挂载回调函数</span><br><span class="line">        window[cbFuncName] &#x3D; function (data) &#123;</span><br><span class="line">            callback(data);</span><br><span class="line">            &#x2F;&#x2F; 处理完回调函数的数据之后，删除jsonp的script标签</span><br><span class="line">            document.body.removeChild(scriptEle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5.append到页面中</span><br><span class="line">        document.body.appendChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用</span><br><span class="line">    window.$jsonp &#x3D; jsonp;</span><br><span class="line"></span><br><span class="line">&#125;)(window,document)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>简化版JSONP</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var script &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line"> script.type &#x3D; &#39;text&#x2F;javascript&#39;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;传参一个回调函数名给后端，方便后端返回时执行这个前端定义的回调函数</span><br><span class="line"> script.src &#x3D; &#39;http:&#x2F;&#x2F;www.xxx.com:8080&#x2F;login?user&#x3D;admin&amp;callback&#x3D;handleCallback&#39;</span><br><span class="line"> document.body.appendChild(script)</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;回调执行函数</span><br><span class="line"> function handleCallbak(res) &#123;</span><br><span class="line">     alert(JSOn.stringify(res))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现一个new操作符"><a href="#实现一个new操作符" class="headerlink" title="实现一个new操作符"></a>实现一个new操作符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function New(func) &#123;</span><br><span class="line">    var res &#x3D; &#123;&#125;;</span><br><span class="line">    if (func.prototype !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        res.__proto__ &#x3D; func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    var ret &#x3D; func.apply(res, Array.prototype.slice.call(arguments, 1));</span><br><span class="line">    if ((typeof ret &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof ret &#x3D;&#x3D;&#x3D; &quot;function&quot;) &amp;&amp; ret !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; New(A, 1, 2);</span><br><span class="line">&#x2F;&#x2F; equals to</span><br><span class="line">var obj1 &#x3D; new A(1, 2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 简洁版的new实现过程</span><br><span class="line"></span><br><span class="line">function newFunc(constructor)&#123;</span><br><span class="line">      &#x2F;&#x2F;第一步：创建一个空对象obj </span><br><span class="line">        var obj &#x3D; &#123;&#125;;</span><br><span class="line">       &#x2F;&#x2F;第二步：将构造函数 constructor的原型对象赋给obj的原型</span><br><span class="line">        obj.__proto__ &#x3D; constructor.prototype;</span><br><span class="line">      &#x2F;&#x2F;第三步：将构造函数 constructor中的this指向obj,并立即执行构造函数内部的操作</span><br><span class="line">        constructor.apply(obj);</span><br><span class="line">      &#x2F;&#x2F;第四步：返回这个对象</span><br><span class="line">        return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现call"><a href="#实现call" class="headerlink" title="实现call"></a>实现call</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.call2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;改变this指向，将目标函数作为这个对象的属性</span><br><span class="line">    var context &#x3D; context || window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;利用arguments类数组对象实现参数不定长</span><br><span class="line">    var args &#x3D; [];</span><br><span class="line">    for(var i &#x3D; 1, len &#x3D; arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&#39;arguments[&#39; + i + &#39;]&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将不定长的参数传递给函数</span><br><span class="line">    var result &#x3D; eval(&#39;context.fn(&#39; + args +&#39;)&#39;);</span><br><span class="line">    &#x2F;&#x2F; obj.fn(...args)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不能增加对象的属性，所以结尾要删除delete</span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现apply"><a href="#实现apply" class="headerlink" title="实现apply"></a>实现apply</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.apply2 &#x3D; function (context, arr) &#123;</span><br><span class="line">    var context &#x3D; Object(context) || window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result &#x3D; context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        var args &#x3D; [];</span><br><span class="line">        for (var i &#x3D; 0, len &#x3D; arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&#39;arr[&#39; + i + &#39;]&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        result &#x3D; eval(&#39;context.fn(&#39; + args + &#39;)&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class="line">    var fbound &#x3D; function () &#123;</span><br><span class="line">        self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line">    &#125;</span><br><span class="line">    fNOP.prototype &#x3D; this.prototype;</span><br><span class="line">    fbound.prototype &#x3D; new fNOP();</span><br><span class="line">    return fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>掘金面经笔记</title>
    <url>/2019/09/13/%E6%8E%98%E9%87%91%E9%9D%A2%E7%BB%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="如何监听未处理的异常"><a href="#如何监听未处理的异常" class="headerlink" title="如何监听未处理的异常"></a>如何监听未处理的异常</h3><span id="more"></span>
<ul>
<li>try…catch<ul>
<li>无法捕捉到语法错误，只能捕捉运行时错误</li>
<li>可以拿到出错的信息(出错的文件，行号，列号)</li>
</ul>
</li>
<li>window.onerror<ul>
<li>由于try…catch只能捕获块里面的错误，全局的一些错误可以用window.onerror来捕获</li>
</ul>
</li>
</ul>
<h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3><ul>
<li>http是一种一种广泛使用的网络协议，是一个客户端和服务器请求和应答的标准。</li>
<li>http工作在TCP协议的80端口，https工作在TCP协议的443端口</li>
<li>http协议运行在TCP协议之上，所有的传输内容都是明文，https运行在SSL/TLS之上，<br>SSL/TLS运行在TCP之上，所有的传输内容都是经过加密的。</li>
<li>https是以安全为目标的http通道，是http的安全版。是http加上SSL层对传输的信息和url做了一些加密处理，更加安全</li>
</ul>
<h3 id="为什么https不会被截取信息"><a href="#为什么https不会被截取信息" class="headerlink" title="为什么https不会被截取信息"></a>为什么https不会被截取信息</h3><ul>
<li>完成TCP三次同步握手</li>
<li>客户端验证服务器数字证书，通过，进入步骤3 </li>
<li>DH算法协商对称加密算法的密钥、hash算法的密钥</li>
<li>SSL安全加密隧道协商完成</li>
<li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；<br>用协商的hash算法进行数据完整性保护，保证数据不被篡改</li>
</ul>
<h3 id="浏览器如何缓存"><a href="#浏览器如何缓存" class="headerlink" title="浏览器如何缓存"></a>浏览器如何缓存</h3><ul>
<li>html meta标签控制缓存<ul>
<li><code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cahce&quot;&gt;</code> //告诉浏览器当前页面不被缓存</li>
</ul>
</li>
<li>http头信息控制缓存<ul>
<li>Expires ——&gt; 过期时间</li>
<li>Cache-Control 响应头信息(no-cache、no-store、max-age、public)</li>
</ul>
</li>
</ul>
<h3 id="TCP协议如何保证传输的可靠性"><a href="#TCP协议如何保证传输的可靠性" class="headerlink" title="TCP协议如何保证传输的可靠性"></a>TCP协议如何保证传输的可靠性</h3><ul>
<li>校验和</li>
<li>确认应答 + 序列号</li>
<li>超时重传</li>
<li>流浪控制</li>
<li>拥塞控制</li>
<li>TCP的连接管理</li>
<li>滑动窗口</li>
</ul>
<h3 id="UDP-amp-TCP-的区别"><a href="#UDP-amp-TCP-的区别" class="headerlink" title="UDP &amp; TCP 的区别"></a>UDP &amp; TCP 的区别</h3><ul>
<li><p>相同点：</p>
<ul>
<li>UDP协议 和 TCP协议 都是运输层协议</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li>UDP特点：<ul>
<li>无连接 —— 知道对端的IP和端口号就直接进行传输，不需要建立连接</li>
<li>不可靠 —— 没有确认机制，没有重传机制，即使因为网络故障无法发送到<br>对方，UDP协议也不会给应用层返回任何错误信息</li>
<li>面向数据报</li>
<li>传输速 度块</li>
</ul>
</li>
<li>TCP特点：<ul>
<li>面向连接，在客户端和服务器进行交换数据前，必须先在双方之间建立一个<br>TCP连接</li>
<li>可靠传输，具有确认应答机制、超时重传机制、拥塞控制、流量控制、<br>滑动窗口机制、延迟应答等。</li>
<li>面向字节流</li>
</ul>
</li>
</ul>
</li>
<li><p>UDP的响应速度优于TCP，安全性和数据可靠性不如TCP</p>
</li>
<li><p>UDP一般用在网络负担非常重，但对响应速度要求高，数据类型都是短消息的情况下</p>
</li>
</ul>
<h3 id="样式导入方式及优先级？"><a href="#样式导入方式及优先级？" class="headerlink" title="样式导入方式及优先级？"></a>样式导入方式及优先级？</h3><ul>
<li>引入方式<ul>
<li>行内样式</li>
<li>内联式</li>
<li>外链式</li>
<li>导入式: @import url(reset.css)</li>
</ul>
</li>
<li>各种方式的优先级<ul>
<li>行内样式 &gt; 外链式 &gt; 内联式 &gt; @import导入式</li>
</ul>
</li>
</ul>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC(block formatting context)翻译为“块级格式化上下文”，它会生成独立的渲染区域<br>(不影响外面的元素，同时也不受外部元素的影响)，它有一下规则：</p>
<ul>
<li>内部的box会在垂直方向上一个接一个的放置。</li>
<li>内部box在垂直方向上的距离由margin决定，同属一个BFC内的相邻box会发生margin重叠。</li>
<li>BFC的区域不会与float box发生重叠。</li>
<li>计算BFC的高度时，浮动元素也参与计算(清除浮动)</li>
</ul>
<p>触发BFC的条件：</p>
<ul>
<li>float属性不为none</li>
<li>position为absolute或者fixed</li>
<li>display为inline-block、table-cell、table-caption、flex、inline-flex</li>
<li>overflow不为visible</li>
</ul>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之排序</title>
    <url>/2019/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h4 id="五大算法"><a href="#五大算法" class="headerlink" title="五大算法"></a>五大算法</h4><ul>
<li><p>贪心算法</p>
</li>
<li><p>分治算法</p>
</li>
<li><p>动态规划</p>
</li>
<li><p>回溯法</p>
</li>
<li><p>分支限界法</p>
</li>
</ul>
<span id="more"></span>

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bubleSort(arr) &#123;</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    for (let outer &#x3D; len ; outer &gt;&#x3D; 2; outer--) &#123;</span><br><span class="line">        for(let inner &#x3D; 0; inner &lt;&#x3D;outer - 1; inner++) &#123;</span><br><span class="line">            if(arr[inner] &gt; arr[inner + 1]) &#123;</span><br><span class="line">                [arr[inner],arr[inner+1]] &#x3D; [arr[inner+1],arr[inner]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function selectSort(arr) &#123;</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    for(let i &#x3D; 0 ;i &lt; len - 1; i++) &#123;</span><br><span class="line">        for(let j &#x3D; i ; j&lt;len; j++) &#123;</span><br><span class="line">            if(arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                [arr[i],arr[j]] &#x3D; [arr[j],arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function insertSort(arr) &#123;</span><br><span class="line">    for(let i &#x3D; 1; i &lt; arr.length; i++) &#123;  &#x2F;&#x2F;外循环从1开始，默认arr[0]是有序段</span><br><span class="line">        for(let j &#x3D; i; j &gt; 0; j--) &#123;  &#x2F;&#x2F;j &#x3D; i,将arr[j]依次插入有序段中</span><br><span class="line">            if(arr[j] &lt; arr[j-1]) &#123;</span><br><span class="line">                [arr[j],arr[j-1]] &#x3D; [arr[j-1],arr[j]];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    if(arr.length &lt;&#x3D; 1) &#123;</span><br><span class="line">        return arr;  &#x2F;&#x2F;递归出口</span><br><span class="line">    &#125;</span><br><span class="line">    var left &#x3D; [],</span><br><span class="line">        right &#x3D; [],</span><br><span class="line">        current &#x3D; arr.splice(0,1); </span><br><span class="line">    for(let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if(arr[i] &lt; current) &#123;</span><br><span class="line">            left.push(arr[i])  &#x2F;&#x2F;放在左边</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(arr[i]) &#x2F;&#x2F;放在右边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return quickSort(left).concat(current,quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建列表类</span><br><span class="line">function ArrayList() &#123;</span><br><span class="line">    this.array &#x3D; []</span><br><span class="line">    &#x2F;&#x2F;方法</span><br><span class="line">    &#x2F;&#x2F;插入方法</span><br><span class="line">    ArrayList.prototype.insert &#x3D; function(item)&#123;</span><br><span class="line">        this.array.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;toString 方便测试</span><br><span class="line">    ArrayList.prototype.toString &#x3D; function()&#123;</span><br><span class="line">        return this.array.join(&#39;-&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--var arr &#x3D; new ArrayList()--&gt;</span><br><span class="line">&lt;!--arr.insert(1)--&gt;</span><br><span class="line">&lt;!--arr.insert(2)--&gt;</span><br><span class="line">&lt;!--arr.insert(3)--&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现排序算法</span><br><span class="line">&#x2F;&#x2F;冒泡排序</span><br><span class="line">ArrayList.prototype.bubbleSort &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.获取数组的长度</span><br><span class="line">    var length &#x3D; this.array.length</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2.反向循环, 因此次数越来越少</span><br><span class="line">    for (var i &#x3D; length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 3.根据i的次数, 比较循环到i位置</span><br><span class="line">        for (var j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 4.如果j位置比j+1位置的数据大, 那么就交换</span><br><span class="line">            if (this.array[j] &gt; this.array[j+1]) &#123;</span><br><span class="line">                &#x2F;&#x2F; 交换</span><br><span class="line">                this.swap(j, j+1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList.prototype.swap &#x3D; function (m, n) &#123;</span><br><span class="line">    var temp &#x3D; this.array[m]</span><br><span class="line">    this.array[m] &#x3D; this.array[n]</span><br><span class="line">    this.array[n] &#x3D; temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;选择排序</span><br><span class="line">ArrayList.prototype.selectionSort &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.获取数组的长度</span><br><span class="line">    var length &#x3D; this.array.length</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span><br><span class="line">    for (var i &#x3D; 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 3.内层循环: 从i+1位置开始, 和后面的内容比较</span><br><span class="line">        var min &#x3D; i</span><br><span class="line">        for (var j &#x3D; min + 1; j &lt; length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 4.如果i位置的数据大于j位置的数据, 那么记录最小的位置</span><br><span class="line">            if (this.array[min] &gt; this.array[j]) &#123;</span><br><span class="line">                min &#x3D; j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 5.交换min和i位置的数据</span><br><span class="line">        this.swap(min, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;插入排序</span><br><span class="line">ArrayList.prototype.insertionSort &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.获取数组的长度</span><br><span class="line">    var length &#x3D; this.array.length</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span><br><span class="line">    for (var i &#x3D; 1; i &lt; length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 3.记录选出的元素, 放在变量temp中</span><br><span class="line">        var j &#x3D; i</span><br><span class="line">        var temp &#x3D; this.array[i]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span><br><span class="line">        while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) &#123;</span><br><span class="line">            this.array[j] &#x3D; this.array[j-1]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5.将选出的j位置, 放入temp元素</span><br><span class="line">        this.array[j] &#x3D; temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;希尔排序</span><br><span class="line">ArrayList.prototype.shellSort &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.获取数组的长度</span><br><span class="line">    var length &#x3D; this.array.length</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2.根据长度计算增量</span><br><span class="line">    var gap &#x3D; Math.floor(length &#x2F; 2)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3.增量不断变量小, 大于0就继续排序</span><br><span class="line">    while (gap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 4.实现插入排序</span><br><span class="line">        for (var i &#x3D; gap; i &lt; length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 4.1.保存临时变量</span><br><span class="line">            var j &#x3D; i</span><br><span class="line">            var temp &#x3D; this.array[i]</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 4.2.插入排序的内层循环</span><br><span class="line">            while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) &#123;</span><br><span class="line">                this.array[j] &#x3D; this.array[j - gap]</span><br><span class="line">                j -&#x3D; gap</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 4.3.将选出的j位置设置为temp</span><br><span class="line">            this.array[j] &#x3D; temp</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F; 5.重新计算新的间隔</span><br><span class="line">        gap &#x3D; Math.floor(gap &#x2F; 2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;快速排序</span><br><span class="line"> &#x2F;&#x2F; 选择枢纽</span><br><span class="line"> ArrayList.prototype.median &#x3D; function (left, right) &#123;</span><br><span class="line">     &#x2F;&#x2F; 1.求出中间的位置</span><br><span class="line">     var center &#x3D; Math.floor((left + right) &#x2F; 2)</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; 2.判断并且进行交换</span><br><span class="line">     if (this.array[left] &gt; this.array[center]) &#123;</span><br><span class="line">         this.swap(left, center)</span><br><span class="line">     &#125;</span><br><span class="line">     if (this.array[center] &gt; this.array[right]) &#123;</span><br><span class="line">         this.swap(center, right)</span><br><span class="line">     &#125;</span><br><span class="line">     if (this.array[left] &gt; this.array[right]) &#123;</span><br><span class="line">         this.swap(left, right)</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; 3.巧妙的操作: 将center移动到right - 1的位置.</span><br><span class="line">     this.swap(center, right - 1)</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; 4.返回pivot</span><br><span class="line">     return this.array[right - 1]</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 快速排序实现</span><br><span class="line"> ArrayList.prototype.quickSort &#x3D; function () &#123;</span><br><span class="line">     this.quickSortRec(0, this.array.length - 1)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ArrayList.prototype.quickSortRec &#x3D; function (left, right) &#123;</span><br><span class="line">     &#x2F;&#x2F; 0.递归结束条件</span><br><span class="line">     if (left &gt;&#x3D; right) return</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; 1.获取枢纽</span><br><span class="line">     var pivot &#x3D; this.median(left, right)</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; 2.开始进行交换</span><br><span class="line">     &#x2F;&#x2F; 2.1.记录左边开始位置和右边开始位置</span><br><span class="line">     var i &#x3D; left</span><br><span class="line">     var j &#x3D; right - 1</span><br><span class="line">     &#x2F;&#x2F; 2.2.循环查找位置</span><br><span class="line">     while (true) &#123;</span><br><span class="line">         while (this.array[++i] &lt; pivot) &#123; &#125;</span><br><span class="line">         while (this.array[--j] &gt; pivot) &#123; &#125;</span><br><span class="line">         if (i &lt; j) &#123;</span><br><span class="line">               &#x2F;&#x2F; 2.3.交换两个数值</span><br><span class="line">             this.swap(i, j)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F; 2.4.当i&lt;j的时候(一定不会&#x3D;, 看下面解释中的序号3), 停止循环因为两边已经找到了相同的位置</span><br><span class="line">             break</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; 3.将枢纽放在正确的位置</span><br><span class="line">     this.swap(i, right - 1)</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; 4.递归调用左边</span><br><span class="line">     this.quickSortRec(left, i - 1)</span><br><span class="line">     this.quickSortRec(i + 1, right)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 封装ArrayList</span><br><span class="line"> function ArrayList() &#123;</span><br><span class="line">     this.array &#x3D; []</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.insert &#x3D; function (item) &#123;</span><br><span class="line">         this.array.push(item)</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.toString &#x3D; function () &#123;</span><br><span class="line">         return this.array.join()</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.bubbleSort &#x3D; function () &#123;</span><br><span class="line">         &#x2F;&#x2F; 1.获取数组的长度</span><br><span class="line">         var length &#x3D; this.array.length</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 2.反向循环, 因此次数越来越少</span><br><span class="line">         for (var i &#x3D; length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">             &#x2F;&#x2F; 3.根据i的次数, 比较循环到i位置</span><br><span class="line">             for (var j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">                 &#x2F;&#x2F; 4.如果j位置比j+1位置的数据大, 那么就交换</span><br><span class="line">                 if (this.array[j] &gt; this.array[j+1]) &#123;</span><br><span class="line">                     &#x2F;&#x2F; 交换</span><br><span class="line">                     this.swap(j, j+1)</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.selectionSort &#x3D; function () &#123;</span><br><span class="line">         &#x2F;&#x2F; 1.获取数组的长度</span><br><span class="line">         var length &#x3D; this.array.length</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span><br><span class="line">         for (var i &#x3D; 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">             &#x2F;&#x2F; 3.内层循环: 从i+1位置开始, 和后面的内容比较</span><br><span class="line">             var min &#x3D; i</span><br><span class="line">             for (var j &#x3D; min + 1; j &lt; length; j++) &#123;</span><br><span class="line">                 &#x2F;&#x2F; 4.如果i位置的数据大于j位置的数据, 记录最小的位置</span><br><span class="line">                 if (this.array[min] &gt; this.array[j]) &#123;</span><br><span class="line">                     min &#x3D; j</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             this.swap(min, i)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.insertionSort &#x3D; function () &#123;</span><br><span class="line">         &#x2F;&#x2F; 1.获取数组的长度</span><br><span class="line">         var length &#x3D; this.array.length</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span><br><span class="line">         for (var i &#x3D; 1; i &lt; length; i++) &#123;</span><br><span class="line">             &#x2F;&#x2F; 3.记录选出的元素, 放在变量temp中</span><br><span class="line">             var j &#x3D; i</span><br><span class="line">             var temp &#x3D; this.array[i]</span><br><span class="line"> </span><br><span class="line">             &#x2F;&#x2F; 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span><br><span class="line">             while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) &#123;</span><br><span class="line">                 this.array[j] &#x3D; this.array[j-1]</span><br><span class="line">                 j--</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             &#x2F;&#x2F; 5.将选出的j位置, 放入temp元素</span><br><span class="line">             this.array[j] &#x3D; temp</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.shellSort &#x3D; function () &#123;</span><br><span class="line">         &#x2F;&#x2F; 1.获取数组的长度</span><br><span class="line">         var length &#x3D; this.array.length</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 2.根据长度计算增量</span><br><span class="line">         var gap &#x3D; Math.floor(length &#x2F; 2)</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 3.增量不断变量小, 大于0就继续排序</span><br><span class="line">         while (gap &gt; 0) &#123;</span><br><span class="line">             &#x2F;&#x2F; 4.实现插入排序</span><br><span class="line">             for (var i &#x3D; gap; i &lt; length; i++) &#123;</span><br><span class="line">                 &#x2F;&#x2F; 4.1.保存临时变量</span><br><span class="line">                 var j &#x3D; i</span><br><span class="line">                 var temp &#x3D; this.array[i]</span><br><span class="line"> </span><br><span class="line">                 &#x2F;&#x2F; 4.2.插入排序的内存循环</span><br><span class="line">                 while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) &#123;</span><br><span class="line">                     this.array[j] &#x3D; this.array[j - gap]</span><br><span class="line">                     j -&#x3D; gap</span><br><span class="line">                 &#125;</span><br><span class="line"> </span><br><span class="line">                 &#x2F;&#x2F; 4.3.将选出的j位置设置为temp</span><br><span class="line">                 this.array[j] &#x3D; temp</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             &#x2F;&#x2F; 5.重新计算新的间隔</span><br><span class="line">             gap &#x3D; Math.floor(gap &#x2F; 2)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.swap &#x3D; function (m, n) &#123;</span><br><span class="line">         var temp &#x3D; this.array[m]</span><br><span class="line">         this.array[m] &#x3D; this.array[n]</span><br><span class="line">         this.array[n] &#x3D; temp</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; 选择枢纽</span><br><span class="line">     ArrayList.prototype.median &#x3D; function (left, right) &#123;</span><br><span class="line">         &#x2F;&#x2F; 1.求出中间的位置</span><br><span class="line">         var center &#x3D; Math.floor((left + right) &#x2F; 2)</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 2.判断并且进行交换</span><br><span class="line">         if (this.array[left] &gt; this.array[center]) &#123;</span><br><span class="line">             this.swap(left, center)</span><br><span class="line">         &#125;</span><br><span class="line">         if (this.array[center] &gt; this.array[right]) &#123;</span><br><span class="line">             this.swap(center, right)</span><br><span class="line">         &#125;</span><br><span class="line">         if (this.array[left] &gt; this.array[right]) &#123;</span><br><span class="line">             this.swap(left, right)</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 3.巧妙的操作: 将center移动到right - 1的位置.</span><br><span class="line">         this.swap(center, right - 1)</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 4.返回pivot</span><br><span class="line">         return this.array[right - 1]</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; 快速排序实现</span><br><span class="line">     ArrayList.prototype.quickSort &#x3D; function () &#123;</span><br><span class="line">         this.quickSortRec(0, this.array.length - 1)</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     ArrayList.prototype.quickSortRec &#x3D; function (left, right) &#123;</span><br><span class="line">         &#x2F;&#x2F; 0.递归结束条件</span><br><span class="line">         if (left &gt;&#x3D; right) return</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 1.获取枢纽</span><br><span class="line">         var pivot &#x3D; this.median(left, right)</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 2.开始进行交换</span><br><span class="line">         var i &#x3D; left</span><br><span class="line">         var j &#x3D; right - 1</span><br><span class="line">         while (true) &#123;</span><br><span class="line">             while (this.array[++i] &lt; pivot) &#123; &#125;</span><br><span class="line">             while (this.array[--j] &gt; pivot) &#123; &#125;</span><br><span class="line">             if (i &lt; j) &#123;</span><br><span class="line">                 this.swap(i, j)</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 break</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 3.将枢纽放在正确的位置</span><br><span class="line">         this.swap(i, right - 1)</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 4.递归调用左边</span><br><span class="line">         this.quickSortRec(left, i - 1)</span><br><span class="line">         this.quickSortRec(i + 1, right)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据结构与算法</title>
    <url>/2019/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="什么是数据结构与算法？"><a href="#什么是数据结构与算法？" class="headerlink" title="什么是数据结构与算法？"></a>什么是数据结构与算法？</h2><ul>
<li>数据结构就是在计算机中，存储和组织数据的方式。<span id="more"></span>
<ul>
<li>常见的数据结构：<img src="http://vamknight.com/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<!--more--></li>
</ul>
</li>
<li>算法（Algorithm）的定义：<ul>
<li>算法就是解决问题的方法/步骤，数据结构的实现离不开算法。<ul>
<li>一个有限指令集，每条指令的描述不依赖于语言</li>
<li>接受一些输入（有些情况不需要输入）</li>
<li>产生输出</li>
<li>一定在有限步骤之后终止</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之哈希表</title>
    <url>/2019/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建HashTable构造函数</span><br><span class="line">function HashTable() &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义属性</span><br><span class="line">    this.storage &#x3D; []</span><br><span class="line">    this.count &#x3D; 0</span><br><span class="line">    this.limit &#x3D; 8</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义相关方法</span><br><span class="line">    &#x2F;&#x2F; 判断是否是质数</span><br><span class="line">    HashTable.prototype.isPrime &#x3D; function (num) &#123;</span><br><span class="line">        var temp &#x3D; parseInt(Math.sqrt(num))</span><br><span class="line">        &#x2F;&#x2F; 2.循环判断</span><br><span class="line">        for (var i &#x3D; 2; i &lt;&#x3D; temp; i++) &#123;</span><br><span class="line">            if (num % i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取质数</span><br><span class="line">    HashTable.prototype.getPrime &#x3D; function (num) &#123;</span><br><span class="line">        while (!isPrime(num)) &#123;</span><br><span class="line">            num++</span><br><span class="line">        &#125;</span><br><span class="line">        return num</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希函数</span><br><span class="line">    HashTable.prototype.hashFunc &#x3D; function(str, max) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.初始化hashCode的值</span><br><span class="line">        var hashCode &#x3D; 0</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.霍纳算法, 来计算hashCode的数值</span><br><span class="line">        for (var i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class="line">            hashCode &#x3D; 37 * hashCode + str.charCodeAt(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.取模运算</span><br><span class="line">        hashCode &#x3D; hashCode % max</span><br><span class="line">        return hashCode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 插入数据方法</span><br><span class="line">    HashTable.prototype.put &#x3D; function (key, value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.获取key对应的index</span><br><span class="line">        var index &#x3D; this.hashFunc(key, this.limit)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.取出数组(也可以使用链表)</span><br><span class="line">        &#x2F;&#x2F; 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ]  [ [k,v] ] ]</span><br><span class="line">        var bucket &#x3D; this.storage[index]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.判断这个数组是否存在</span><br><span class="line">        if (bucket &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">            &#x2F;&#x2F; 3.1创建桶</span><br><span class="line">            bucket &#x3D; []</span><br><span class="line">            this.storage[index] &#x3D; bucket</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.判断是新增还是修改原来的值.</span><br><span class="line">        var override &#x3D; false</span><br><span class="line">        for (var i &#x3D; 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            var tuple &#x3D; bucket[i]</span><br><span class="line">            if (tuple[0] &#x3D;&#x3D;&#x3D; key) &#123;</span><br><span class="line">                tuple[1] &#x3D; value</span><br><span class="line">                override &#x3D; true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5.如果是新增, 前一步没有覆盖</span><br><span class="line">        if (!override) &#123;</span><br><span class="line">            bucket.push([key, value])</span><br><span class="line">            this.count++</span><br><span class="line"></span><br><span class="line">            if (this.count &gt; this.limit * 0.75) &#123;</span><br><span class="line">                var primeNum &#x3D; this.getPrime(this.limit * 2)</span><br><span class="line">                this.resize(primeNum)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取存放的数据</span><br><span class="line">    HashTable.prototype.get &#x3D; function (key) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.获取key对应的index</span><br><span class="line">        var index &#x3D; this.hashFunc(key, this.limit)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.获取对应的bucket</span><br><span class="line">        var bucket &#x3D; this.storage[index]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.如果bucket为null, 那么说明这个位置没有数据</span><br><span class="line">        if (bucket &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.有bucket, 判断是否有对应的key</span><br><span class="line">        for (var i &#x3D; 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            var tuple &#x3D; bucket[i]</span><br><span class="line">            if (tuple[0] &#x3D;&#x3D;&#x3D; key) &#123;</span><br><span class="line">                return tuple[1]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5.没有找到, return null</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 删除数据</span><br><span class="line">    HashTable.prototype.remove &#x3D; function (key) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.获取key对应的index</span><br><span class="line">        var index &#x3D; this.hashFunc(key, this.limit)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.获取对应的bucket</span><br><span class="line">        var bucket &#x3D; this.storage[index]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.判断同是否为null, 为null则说明没有对应的数据</span><br><span class="line">        if (bucket &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.遍历bucket, 寻找对应的数据</span><br><span class="line">        for (var i &#x3D; 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            var tuple &#x3D; bucket[i]</span><br><span class="line">            if (tuple[0] &#x3D;&#x3D;&#x3D; key) &#123;</span><br><span class="line">                bucket.splice(i, 1)</span><br><span class="line">                this.count--</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 缩小数组的容量</span><br><span class="line">                if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;</span><br><span class="line">                    var primeNum &#x3D; this.getPrime(Math.floor(this.limit &#x2F; 2))</span><br><span class="line">                    this.resize(primeNum)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return tuple[1]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5.来到该位置, 说明没有对应的数据, 那么返回null</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; isEmpty方法</span><br><span class="line">    HashTable.prototype.isEmpty &#x3D; function () &#123;</span><br><span class="line">        return this.count &#x3D;&#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; size方法</span><br><span class="line">    HashTable.prototype.size &#x3D; function () &#123;</span><br><span class="line">        return this.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表扩容</span><br><span class="line">    HashTable.prototype.resize &#x3D; function (newLimit) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.保存旧的数组内容</span><br><span class="line">        var oldStorage &#x3D; this.storage</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.重置属性</span><br><span class="line">        this.limit &#x3D; newLimit</span><br><span class="line">        this.count &#x3D; 0</span><br><span class="line">        this.storage &#x3D; []</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中</span><br><span class="line">        oldStorage.forEach(function (bucket) &#123;</span><br><span class="line">            &#x2F;&#x2F; 1.bucket为null, 说明这里面没有数据</span><br><span class="line">            if (bucket &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 2.bucket中有数据, 那么将里面的数据重新哈希化插入</span><br><span class="line">            for (var i &#x3D; 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">                var tuple &#x3D; bucket[i]</span><br><span class="line">                this.put(tuple[0], tuple[1])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li><p>什么是链表？</p>
<ul>
<li>链表的元素在内存中不必是连续的空间，链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。<span id="more"></span></li>
</ul>
</li>
<li><p>相对于数组，链表都有哪些优势？</p>
<ul>
<li>内存空间不是比是连续的. 可以充分利用计算机的内存. 实现灵活的内存动态管理。</li>
<li>链表不必在创建时就确定大小, 并且大小可以无限的延伸下去。</li>
<li>链表在插入和删除数据时, 时间复杂度可以达到O(1). 相对数组效率高很多。</li>
</ul>
</li>
<li><p>相对于数组，链表都有哪些缺点？</p>
<ul>
<li>链表访问任何一个位置的元素时, 都需要从头开始访问.(无法跳过第一个元素访问任何一个元素)。</li>
<li>无法通过下标直接访问元素, 需要从头一个个访问, 直到找到对应的问题。<!--more--></li>
</ul>
</li>
<li><p>链表的数据结构：</p>
<img src="http://vamknight.com/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png"></li>
<li><p>链表有哪些常见操作？</p>
<ul>
<li>append(element)：向列表尾部添加一个新的项</li>
<li>insert(position, element)：向列表的特定位置插入一个新的项。</li>
<li>update(position, element): 修改某一个位置上的元素。</li>
<li>remove(element)：从列表中移除一项。</li>
<li>indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。</li>
</ul>
<p>  // 链表中的属性<br>  this.length = 0<br>  this.head = null</p>
<p>  // 链表尾部追加元素方法<br>  LinkedList.prototype.append = function (element) {</p>
<pre><code>  // 1.根据新元素创建节点
  var newNode = new Node(element)

  // 2.判断原来链表是否为空
  if (this.head === null) &#123; /
</code></pre>
<ul>
<li><p>removeAt(position)：从列表的特定位置移除一项。<br>this.next = null<br>}<br>/ 链表尾空</p>
<pre><code>  this.head = newNode
</code></pre>
<p>  } else { // 链表不为空</p>
<pre><code>  // 2.1.定义变量, 保存当前找到的节点
  var current = this.head
  while (current.next) &#123;
      current = current.next
  &#125;

  // 2.2.找到最后一项, 将其next赋值为node
  current.next = newNode
</code></pre>
<p>  }</p>
<p>  // 3.链表长度增加1<br>  this.length++<br>}</p>
</li>
</ul>
<p>  // 链表的toString方法<br>  LinkedList.prototype.toString = function () {</p>
<pre><code>  // 1.定义两个变量
  var current = this.head
  var listString = &quot;&quot;

  // 2.循环获取链表中所有的元素
  while (current) &#123;
      listString += &quot;,&quot; + current.element
      current = current.next
  &#125;

  // 3.返回最终结果
  return listString.slice(1)
</code></pre>
<p>  }</p>
<p>  // 根据下标删除元素<br>  LinkedList.prototype.insert = function (position, element) {</p>
<pre><code>  // 1.检测越界问题: 越界插入失败
  if (position &lt; 0 || position &gt; this.length) return false

  // 2.定义变量, 保存信息
  var newNode = new Node(element)
  var current = this.head
  var previous = null
  index = 0

  // 3.判断是否列表是否在第一个位置插入
  if (position == 0) &#123;
      newNode.next = current
      this.head = newNode
  &#125; else &#123;
      while (index++ &lt; position) &#123;
          previous = current
          current = current.next
      &#125;

      newNode.next = current
      previous.next = newNode
  &#125;

  // 4.length+1
  this.length++

  return true
</code></pre>
<p>  }</p>
<p>  //update方法<br>  LinkedList.prototype.update = function (position, newData) {</p>
<pre><code>  if (position &lt; 0 || position &gt;= this.length) return  null
  
  var current = this.head
  var index = 0
  while (index++ &lt; position) &#123;
      current = current.next
  &#125;
  current.data = newData
  return true
</code></pre>
<p>  }</p>
<p>  // 根据位置移除节点<br>  LinkedList.prototype.removeAt = function (position) {</p>
<pre><code>  // 1.检测越界问题: 越界移除失败, 返回null
  if (position &lt; 0 || position &gt;= this.length) return null

  // 2.定义变量, 保存信息
  var current = this.head
  var previous = null
  var index = 0

  // 3.判断是否是移除第一项
  if (position === 0) &#123;
      this.head = current.next
  &#125; else &#123;
      while (index++ &lt; position) &#123;
          previous = current
          current = current.next
      &#125;

      previous.next = current.next
  &#125;

  // 4.length-1
  this.length--

  // 5.返回移除的数据
  return current.element
</code></pre>
<p>  }</p>
<p>  // 根据元素获取链表中的位置<br>  LinkedList.prototype.indexOf = function (element) {</p>
<pre><code>  // 1.定义变量, 保存信息
  var current = this.head
  index = 0

  // 2.找到元素所在的位置
  while (current) &#123;
      if (current.element === element) &#123;
          return index
      &#125;
      index++
      current = current.next
  &#125;

  // 3.来到这个位置, 说明没有找到, 则返回-1
  return -1
</code></pre>
<p>  }</p>
<p>  // 根据元素删除信息<br>  LinkedList.prototype.remove = function (element) {</p>
<pre><code>  var index = this.indexOf(element)
  return this.removeAt(index)
</code></pre>
<p>  }</p>
<p>  // 判断链表是否为空<br>  LinkedList.prototype.isEmpty = function () {</p>
<pre><code>  return this.length == 0
</code></pre>
<p>  }</p>
<p>  // 获取链表的长度<br>  LinkedList.prototype.size = function () {</p>
<pre><code>  return this.length
</code></pre>
<p>  }</p>
<p>  // 获取第一个节点<br>  LinkedList.prototype.getFirst = function () {</p>
<pre><code>  return this.head.element
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 以上操作的都是单向链表，下面来认识一下双向链表。</span><br><span class="line">- 单向链表的缺点：</span><br><span class="line">    + 只能从头遍历到尾，也就是链表的相连的过程是单向的，实现的原理是上一个链表中有一个指向下一个的引用。</span><br><span class="line">    + 我们可以轻松的到达下一个节点，但是回到上一个节点是很难的，只能从头遍历。</span><br><span class="line">    + 但是，实际开发中，经常会遇到回到上一个节点的情况。</span><br><span class="line">- 双向链表：</span><br><span class="line">    + 既可以从头遍历到尾，又可以从尾遍历到头。</span><br><span class="line">    + 也就是链表相连的过程是双向的。</span><br><span class="line">    + 实现的原理就是既有先前连接的引用，也有一个向后连接的引用。</span><br><span class="line">    + 双向链表可以有效的解决单向链表的问题。</span><br><span class="line">- 双向链表的一些缺点：</span><br><span class="line">    + 每次在插入或删除某一个节点时，需要处理四个引用，实现起来比较复杂。</span><br><span class="line">    + 相对于单向链表占用的内存更大一些。</span><br><span class="line">    </span><br><span class="line">- 双向链表的结构图：</span><br><span class="line">&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;vamknight.com&#x2F;%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png&quot;&gt;</span><br><span class="line"></span><br><span class="line">- 双向链表的特点：</span><br><span class="line">    + 可以使用一个head和一个tail分别指向头部和尾部的节点。</span><br><span class="line">    + 每个节点都是由三部分组成：前一个节点的指针（prev）、保存的元素（item）、后一个节点的指针（next）。</span><br><span class="line">    + 双向链表的第一个节点的prev是null。</span><br><span class="line">    + 双向链表的最后一个节点的next是null。</span><br><span class="line"></span><br><span class="line">- 双向链表都有哪些常见操作？</span><br><span class="line">    + append(element)：向列表尾部添加一个新的项</span><br><span class="line">    </span><br><span class="line">    + insert(position, element)：向列表的特定位置插入一个新的项。</span><br><span class="line">    </span><br><span class="line">    + update(position, element): 修改某一个位置上的元素。</span><br><span class="line">    </span><br><span class="line">    + get(position): 获取对应位置的元素。</span><br><span class="line">    </span><br><span class="line">    + remove(element)：从列表中移除一项。</span><br><span class="line">    </span><br><span class="line">    + indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。</span><br><span class="line">    </span><br><span class="line">    + removeAt(position)：从列表的特定位置移除一项。</span><br><span class="line">    </span><br><span class="line">    + isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。</span><br><span class="line">    </span><br><span class="line">    + size()：返回链表包含的元素个数。与数组的length属性类似。</span><br><span class="line">    </span><br><span class="line">    + toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。</span><br><span class="line">    </span><br><span class="line">    + forwardString(): 返回正向遍历的节点字符串形式。</span><br><span class="line">    </span><br><span class="line">    + backwardString(): 返回反向遍历的节点字符串形式。</span><br><span class="line"></span><br><span class="line">- 双向链表常见方法的封装：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// 创建双向链表的构造函数<br>function DoublyLinkedList() {<br>  // 创建节点构造函数<br>  function Node(element) {</p>
<pre><code>  this.element = element
  this.next = null
  this.prev = null // 新添加的
</code></pre>
<p>  }</p>
<p>  // 定义属性<br>  this.length = 0<br>  this.head = null<br>  this.tail = null // 新添加的</p>
<p>  // 定义相关操作方法<br>  // 在尾部追加数据<br>  DoublyLinkedList.prototype.append = function (element) {</p>
<pre><code>  // 1.根据元素创建节点
  var newNode = new Node(element)

  // 2.判断列表是否为空列表
  if (this.head == null) &#123;
      this.head = newNode
      this.tail = newNode
  &#125; else &#123;
      this.tail.next = newNode
      newNode.prev = this.tail
      this.tail = newNode
  &#125;

  // 3.length+1
  this.length++
</code></pre>
<p>  }</p>
<p>  // 在任意位置插入数据<br>  DoublyLinkedList.prototype.insert = function (position, element) {</p>
<pre><code>  // 1.判断越界的问题
  if (position &lt; 0 || position &gt; this.length) return false

  // 2.创建新的节点
  var newNode = new Node(element)

  // 3.判断插入的位置
  if (position === 0) &#123; // 在第一个位置插入数据
      // 判断链表是否为空
      if (this.head == null) &#123;
          this.head = newNode
          this.tail = newNode
      &#125; else &#123;
          this.head.prev = newNode
          newNode.next = this.head
          this.head = newNode
      &#125;
  &#125; else if (position === this.length) &#123; // 插入到最后的情况
      // 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么?
      this.tail.next = newNode
      newNode.prev = this.tail
      this.tail = newNode
  &#125; else &#123; // 在中间位置插入数据
      // 定义属性
      var index = 0
      var current = this.head
      var previous = null

      // 查找正确的位置
      while (index++ &lt; position) &#123;
          previous = current
          current = current.next
      &#125;

      // 交换节点的指向顺序
      newNode.next = current
      newNode.prev = previous
      current.prev = newNode
      previous.next = newNode
  &#125;

  // 4.length+1
  this.length++

  return true
</code></pre>
<p>  }</p>
<p>  // 根据位置删除对应的元素<br>  DoublyLinkedList.prototype.removeAt = function (position) {</p>
<pre><code>  // 1.判断越界的问题
  if (position &lt; 0 || position &gt;= this.length) return null

  // 2.判断移除的位置
  var current = this.head
  if (position === 0) &#123;
      if (this.length == 1) &#123;
          this.head = null
          this.tail = null
      &#125; else &#123;
          this.head = this.head.next
          this.head.prev = null
      &#125;
  &#125; else if (position === this.length -1) &#123;
      current = this.tail
      this.tail = this.tail.prev
      this.tail.next = null
  &#125; else &#123;
      var index = 0
      var previous = null

      while (index++ &lt; position) &#123;
          previous = current
          current = current.next
      &#125;

      previous.next = current.next
      current.next.prev = previous
  &#125;

  // 3.length-1
  this.length--

  return current.element
</code></pre>
<p>  }</p>
<p>  // 根据元素获取在链表中的位置<br>  DoublyLinkedList.prototype.indexOf = function (element) {</p>
<pre><code>  // 1.定义变量保存信息
  var current = this.head
  var index = 0

  // 2.查找正确的信息
  while (current) &#123;
      if (current.element === element) &#123;
          return index
      &#125;
      index++
      current = current.next
  &#125;

  // 3.来到这个位置, 说明没有找到, 则返回-1
  return -1
</code></pre>
<p>  }</p>
<p>  // 根据元素删除<br>  DoublyLinkedList.prototype.remove = function (element) {</p>
<pre><code>  var index = this.indexOf(element)
  return this.removeAt(index)
</code></pre>
<p>  }</p>
<p>  // 判断是否为空<br>  DoublyLinkedList.prototype.isEmpty = function () {</p>
<pre><code>  return this.length === 0
</code></pre>
<p>  }</p>
<p>  // 获取链表长度<br>  DoublyLinkedList.prototype.size = function () {</p>
<pre><code>  return this.length
</code></pre>
<p>  }</p>
<p>  // 获取第一个元素<br>  DoublyLinkedList.prototype.getHead = function () {</p>
<pre><code>  return this.head.element
</code></pre>
<p>  }</p>
<p>  // 获取最后一个元素<br>  DoublyLinkedList.prototype.getTail = function () {</p>
<pre><code>  return this.tail.element
</code></pre>
<p>  }</p>
<p>  // 遍历方法的实现<br>  // 正向遍历的方法<br>  DoublyLinkedList.prototype.forwardString = function () {</p>
<pre><code>  var current = this.head
  var forwardStr = &quot;&quot;

  while (current) &#123;
      forwardStr += &quot;,&quot; + current.element
      current = current.next
  &#125;

  return forwardStr.slice(1)
</code></pre>
<p>  }</p>
<p>  // 反向遍历的方法<br>  DoublyLinkedList.prototype.reverseString = function () {</p>
<pre><code>  var current = this.tail
  var reverseStr = &quot;&quot;

  while (current) &#123;
      reverseStr += &quot;,&quot; + current.element
      current = current.prev
  &#125;

  return reverseStr.slice(1)
</code></pre>
<p>  }</p>
<p>  // 实现toString方法<br>  DoublyLinkedList.prototype.toString = function () {</p>
<pre><code>  return this.forwardString()
</code></pre>
<p>  }<br>}<br>~~~</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>队列（Queue）</title>
    <url>/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89/</url>
    <content><![CDATA[<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><span id="more"></span>
<ul>
<li><p>队列是一种受限的线性表，先进先出（FIFO First In First Out）。</p>
<ul>
<li>它只允许在表的前端（front）进行删除操作</li>
<li>在表的后端（rear）进行插入操作<!--more--></li>
</ul>
</li>
<li><p>常见应用场景：</p>
<ul>
<li>队列主要用在和时间有关的地方，特别是操作系统中，队列是实现多任务的重要机制。</li>
<li>消息机制可以通过队列来实现，进程调度也是使用队列来实现。<img src="https://raw.githubusercontent.com/foolishmax/static/master/blogPic/%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></li>
</ul>
</li>
<li><p>队列有哪些常见的操作呢？</p>
<ul>
<li>enqueue(element): 向队列尾部添加一个（或多个）新的项。</li>
<li>dequeue(): 移除队列的第一项，并返回被移除的元素。</li>
<li>front(): 返回队列中第一个元素，队列不做任何改动。</li>
<li>isEmpty(): 如果队列中不包含任何元素，返回true，否则返回false。</li>
<li>size(): 返回队列包含的元素个数，与数组length类似。</li>
<li>toString(): 将队列中的内容，转成字符串形式。</li>
</ul>
</li>
<li><p>队列常见操作的封装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;封装队列</span><br><span class="line">function Queue() &#123;</span><br><span class="line">    &#x2F;&#x2F;属性</span><br><span class="line">    this.items &#x3D; []</span><br><span class="line">    &#x2F;&#x2F;将元素加入到队列中</span><br><span class="line">    Queue.prototype.enqueue &#x3D; function(element) &#123;</span><br><span class="line">        this.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从队列中删除前端元素</span><br><span class="line">    Queue.prototype.dequeue &#x3D; function() &#123;</span><br><span class="line">        return this.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查看前端的元素</span><br><span class="line">    Queue.prototype.front &#x3D; function() &#123;</span><br><span class="line">        return this.items[0]</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查看队列是否为空</span><br><span class="line">    Queue.prototype.isEmpty &#x3D; function() &#123;</span><br><span class="line">        return this.items.length &#x3D;&#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查看队列中元素的个数</span><br><span class="line">    Queue.prototype.size &#x3D; function() &#123;</span><br><span class="line">        return this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;toString方法</span><br><span class="line">    Queue.prototype.toString &#x3D; function() &#123;</span><br><span class="line">        var resultString &#x3D; &#39;&#39;</span><br><span class="line">        for (var i &#x3D; 0; i&lt; this.items.length; i++) &#123;</span><br><span class="line">            resultString +&#x3D; this.items[i] + &#39; &#39;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用队列函数</span><br><span class="line">var queue &#x3D; new Queue()</span><br><span class="line">queue.enqueue(20)</span><br><span class="line">alert(queue)</span><br></pre></td></tr></table></figure></li>
<li><p>面试题： 击鼓传花</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;面试题: 击鼓传花</span><br><span class="line">function passGame(nameList, num) &#123;</span><br><span class="line">    &#x2F;&#x2F;创建一个队列结构</span><br><span class="line">    var queue &#x3D; new Queue()</span><br><span class="line">    &#x2F;&#x2F;将所有人加入到队列中</span><br><span class="line">    for(var i &#x3D; 0; i &lt; nameList.length; i++) &#123;</span><br><span class="line">        queue.enqueue(nameList[i])</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;开始数数字</span><br><span class="line">    while (queue.size() &gt; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F;不是num重新加入队列末尾</span><br><span class="line">        &#x2F;&#x2F;是num从队列中删除</span><br><span class="line">        for (var i &#x3D; 0; i&lt; num - 1; i++) &#123;</span><br><span class="line">            queue.enqueue(queue.dequeue())</span><br><span class="line">        &#125;</span><br><span class="line">        queue.dequeue()</span><br><span class="line">    &#125;</span><br><span class="line">    return queque.front()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>封装优先队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;封装优先级队列</span><br><span class="line">function PriorityQueue() &#123;</span><br><span class="line">    &#x2F;&#x2F;内部创建一个构造类</span><br><span class="line">    function QueueElement(element, priority) &#123;</span><br><span class="line">        this.element &#x3D; element</span><br><span class="line">        this.priority &#x3D; priority</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;属性</span><br><span class="line">    this.items &#x3D; []</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;实现队列元素的插入</span><br><span class="line">    PriorityQueue.prototype.enqueue &#x3D; function(element, priority) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建QueueElement对象</span><br><span class="line">        var queueElement &#x3D; new QueueElement(element, priority)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;判断为队列是否为空</span><br><span class="line">        if (this.items.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            this.items.push(queueElement)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var added &#x3D; false</span><br><span class="line">            for (var i &#x3D; 0; i &lt; this.items.length; i++) &#123;</span><br><span class="line">                if (queueElement.priority &lt; this.items[i].priority) &#123;</span><br><span class="line">                    this.items.splice(i, 0, queueElement)</span><br><span class="line">                    added &#x3D; true</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!added) &#123;</span><br><span class="line">                this.items.push(queueElement)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#x2F;&#x2F;从队列中删除前端元素</span><br><span class="line">    PriorityQueue.prototype.dequeue &#x3D; function() &#123;</span><br><span class="line">        return this.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查看前端的元素</span><br><span class="line">    PriorityQueue.prototype.front &#x3D; function() &#123;</span><br><span class="line">        return this.items[0]</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查看队列是否为空</span><br><span class="line">    PriorityQueue.prototype.isEmpty &#x3D; function() &#123;</span><br><span class="line">        return this.items.length &#x3D;&#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查看队列中元素的个数</span><br><span class="line">    PriorityQueue.prototype.size &#x3D; function() &#123;</span><br><span class="line">        return this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;toString方法</span><br><span class="line">    PriorityQueue.prototype.toString &#x3D; function() &#123;</span><br><span class="line">        var resultString &#x3D; &#39;&#39;</span><br><span class="line">        for (var i &#x3D; 0; i&lt; this.items.length; i++) &#123;</span><br><span class="line">            resultString +&#x3D; this.items[i].element + &#39;-&#39; + this.items[i].priority + &#39; &#39;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试代码</span><br><span class="line">var pq &#x3D; new PriorityQueue()</span><br><span class="line">pq.enqueue(&#39;a&#39;,10)</span><br><span class="line">pq.enqueue(&#39;b&#39;,100)</span><br><span class="line">pq.enqueue(&#39;c&#39;,50)</span><br><span class="line">alert(pq)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2019/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><span id="more"></span>
<ul>
<li>集合通常是由一组无序的，不能重复的元素构成。可以看成是一种特殊的数组，特殊之处在于里<br>面的元素没有顺序就意味着不能通过下标值进行访问，不能重复意味着相同的对象在同一个集合中只能存<br>在一份。<!-- more --></li>
<li>集合都有哪些常见的操作方法呢？<ul>
<li>add(value)：向集合添加一个新的项。</li>
<li>remove(value)：从集合移除一个值。</li>
<li>has(value)：如果值在集合中，返回true，否则返回false。</li>
<li>clear()：移除集合中的所有项。</li>
<li>size()：返回集合所包含元素的数量。与数组的length属性类似。</li>
<li>values()：返回一个包含集合中所有值的数组。</li>
</ul>
</li>
<li>集合之间都有哪些操作呢？<ul>
<li>并集：对于两个给定的集合，返回一个包含两个集合中所有元素的新集合。</li>
<li>交集：对于两个给定的集合，返回一个包含两个集合中公有元素的新集合。</li>
<li>差集：对于两个给定的集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的新集合。</li>
<li>子集：验证一个给定集合是否是另一个集合的子集。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/foolishmax/static/master/blogPic/%E9%9B%86%E5%90%88%E5%85%B3%E7%B3%BB.png">
    
    
- 集合封装的完整代码：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 封装集合的构造函数</span><br><span class="line">function Set() &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用一个对象来保存集合的元素</span><br><span class="line">    this.items &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 集合的操作方法</span><br><span class="line">    &#x2F;&#x2F; 判断集合中是否有某个元素</span><br><span class="line">    Set.prototype.has &#x3D; function (value) &#123;</span><br><span class="line">        return this.items.hasOwnProperty(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 向集合中添加元素</span><br><span class="line">    Set.prototype.add &#x3D; function (value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.判断集合中是否已经包含了该元素</span><br><span class="line">        if (this.has(value)) return false</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.将元素添加到集合中</span><br><span class="line">        this.items[value] &#x3D; value</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 从集合中删除某个元素</span><br><span class="line">    Set.prototype.remove &#x3D; function (value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.判断集合中是否包含该元素</span><br><span class="line">        if (!this.has(value)) return false</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.包含该元素, 那么将元素删除</span><br><span class="line">        delete this.items[value]</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 清空集合中所有的元素</span><br><span class="line">    Set.prototype.clear &#x3D; function () &#123;</span><br><span class="line">        this.items &#x3D; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取集合的大小</span><br><span class="line">    Set.prototype.size &#x3D; function () &#123;</span><br><span class="line">        return Object.keys(this.items).length</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">        考虑兼容性问题, 使用下面的代码</span><br><span class="line">        var count &#x3D; 0</span><br><span class="line">        for (var value in this.items) &#123;</span><br><span class="line">            if (this.items.hasOwnProperty(value)) &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count</span><br><span class="line">        *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取集合中所有的值</span><br><span class="line">    Set.prototype.values &#x3D; function () &#123;</span><br><span class="line">        return Object.keys(this.items)</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">        考虑兼容性问题, 使用下面的代码</span><br><span class="line">        var keys &#x3D; []</span><br><span class="line">        for (var value in this.items) &#123;</span><br><span class="line">            keys.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">        return keys</span><br><span class="line">        *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;集合之间的操作</span><br><span class="line">    &#x2F;&#x2F;并集</span><br><span class="line">    Set.prototype.union &#x3D; function (otherSet) &#123;</span><br><span class="line">        &#x2F;&#x2F;this:集合对象A</span><br><span class="line">        &#x2F;&#x2F;otherSet:集合对象B</span><br><span class="line">        &#x2F;&#x2F;1.创建新的集合</span><br><span class="line">        var unionSet &#x3D; new Set()</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;2.将A集合中所有的元素添加到新集合中</span><br><span class="line">        var values &#x3D; this.values()</span><br><span class="line">        for(var i &#x3D; 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            unionSet.add(values[i])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;3.取出B集合中的元素，判断是否需要添加到新集合</span><br><span class="line">        values &#x3D; otherSet.values()</span><br><span class="line">        for(var i &#x3D; 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            unionSet.add(values[i])</span><br><span class="line">        &#125;</span><br><span class="line">        return unionSet</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;交集</span><br><span class="line">        Set.prototype.intersection &#x3D; function (otherSet) &#123;</span><br><span class="line">            var intersectionSet &#x3D; new Set()</span><br><span class="line">            var values &#x3D; this.values()</span><br><span class="line">            &#x2F;&#x2F;取出A集合一个个元素，判断是否同时存在于B中，存在B中，则添加到新集合中</span><br><span class="line">            for (var i &#x3D; 0; i &lt; values.length; i++) &#123;</span><br><span class="line">                var item &#x3D; values[i]</span><br><span class="line">                if (otherSet.has(item)) &#123;</span><br><span class="line">                    intersectionSet.add(item)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return intersectionSet</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;差集</span><br><span class="line">    Set.prototype.difference &#x3D; function (otherSet) &#123;</span><br><span class="line">        var differenceSet &#x3D; new Set()</span><br><span class="line">        var values &#x3D; this.values()</span><br><span class="line">        &#x2F;&#x2F;取出A集合一个个元素，判断是否同时存在于B中，不存在B中，则添加到新集合中</span><br><span class="line">        for (var i &#x3D; 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            var item &#x3D; values[i]</span><br><span class="line">            if (!otherSet.has(item)) &#123;</span><br><span class="line">                differenceSet.add(item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return differenceSet</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 子集</span><br><span class="line">    Set.prototype.subset &#x3D; function (otherSet) &#123;</span><br><span class="line">        var values &#x3D; this.values()</span><br><span class="line">        for (var i &#x3D; 0; i &lt; values.length; i++) &#123;</span><br><span class="line">            var item &#x3D; values[i]</span><br><span class="line">            if (!otherSet.has(item)) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组去重的6种方法</title>
    <url>/2019/06/18/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>终于，石墨烯的PPT完成了一小部分，感觉自己高中的化学都白学了，什么sp²杂化轨道全忘完了，回来继续学习我的前端学习之旅。<br>今天来总结一下，前端高频面试题，数组去重！！！</p>
<h2 id="1-直接遍历法"><a href="#1-直接遍历法" class="headerlink" title="1.直接遍历法"></a>1.直接遍历法</h2><span id="more"></span>
<ul>
<li>利用JavaScript的<code>indexOf</code>方法，新建一个数组 newArr，<br>用这个数组去判断旧数组中的每一个数是否等于-1,如果是，说明该数在新数组中不存在，则将其添加进新数组，遍历完后就能将数组去重并保存至新建的数组中。<!--more-->
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var newArr &#x3D; []</span><br><span class="line">    for (var i &#x3D; 0;i &lt; arr.length;i++) &#123;</span><br><span class="line">        if (newArr.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            newArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique(arr))</span><br><span class="line"></span><br><span class="line">----------------------------------------------------</span><br><span class="line"></span><br><span class="line">原型链：</span><br><span class="line"></span><br><span class="line">Array.prototype.unique &#x3D; function() &#123;</span><br><span class="line">    var arr &#x3D; []</span><br><span class="line">    for(var i &#x3D; 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        if (arr.indexOf(this[i]) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            arr.push(this[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(arr.unique())</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-reduce-函数"><a href="#2-reduce-函数" class="headerlink" title="2.reduce 函数"></a>2.reduce 函数</h2><ul>
<li>使用数组的<code>reduce</code>方法结合<code>indexOf</code>两个方法实现数组去重，<br>来自MDN的解释：reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数<br>(升序执行)，将其结果汇总为单个返回值。<br>mozilla 官方对 reduce 的解释是 arr.reduce(callback[, initialValue])<br>方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。简单点讲就是<br>对数组中的每一个数作用一个函数，这个回调函数就是第一个参数 callback ,第二个参数是传<br>入的初始值，不传则使用数组中的第一个元素，注意在没有初始值的空数组上调用 reduce 将报错。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function unique2(arr) &#123;</span><br><span class="line">    return arr.reduce (function(prev, next) &#123;</span><br><span class="line">        if(prev.indexOf(next) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            prev.push(next)</span><br><span class="line">        &#125;</span><br><span class="line">        return prev</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique2(arr))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-相邻比较"><a href="#3-相邻比较" class="headerlink" title="3.相邻比较"></a>3.相邻比较</h2><ul>
<li>利用数组的 sort() 函数，这个函数原本是对数组进行排序的，但在这里我们不用它进行排序，<br>而只是让它将重复的元素聚拢起来，接着我们比较相邻的两个数，如果相等，则跳过；如果不相等，<br>我们就将其添加进新数组里，这样得到的数组就是去重后的数组。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function unique3(arr)&#123;</span><br><span class="line">  var newArr &#x3D; [arr[0]];</span><br><span class="line">  arr.sort();</span><br><span class="line">  for(var i&#x3D;1;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(arr[i] !&#x3D;&#x3D; arr[i-1])&#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique3(arr))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-下标指针遍历（不太理解）"><a href="#4-下标指针遍历（不太理解）" class="headerlink" title="4.下标指针遍历（不太理解）"></a>4.下标指针遍历（不太理解）</h2><ul>
<li>利用数组的下标指针，来确定是否是相同的元素，如果是的话，就让其指针递增跳过，然后不断把不重复的数组保存至新数组中。<br>代码嵌套了两层循环，分别有 i 和 j 两指针，其中 j 总是比 i 大 1，通过判断数组中这个数<br>与它后面的数是否相等，如果相等，则说明这个数重复了，我们便将指针 i 和 j 继续往后运行，<br>然后用 j = ++i 保持 j 比 i 大 1。最后一直把不重复的指针 i 对应的元素添加进数组。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function unique4()&#123;</span><br><span class="line">  var newArr &#x3D; [];</span><br><span class="line">  for(var i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    for(var j&#x3D;i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">      if(arr[i] &#x3D;&#x3D;&#x3D; arr[j])&#123;</span><br><span class="line">        j &#x3D; ++i;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    newArr.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique4(arr))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-临时对象存储"><a href="#5-临时对象存储" class="headerlink" title="5.临时对象存储"></a>5.临时对象存储</h2><ul>
<li>借用一个临时对象来存储数组元素，判断数组中的元素是否在对象中，如果不存在，就将该数添加进数组，并在临时对象中做标记。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function unique5(arr)&#123;</span><br><span class="line">  var newArr &#x3D; [];</span><br><span class="line">  var temp &#x3D; &#123;&#125;;</span><br><span class="line">  for(var i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(!temp[arr[i]])&#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">      temp[arr[i]] &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique5(arr))</span><br></pre></td></tr></table></figure>

<h2 id="6-简单粗暴法"><a href="#6-简单粗暴法" class="headerlink" title="6.简单粗暴法"></a>6.简单粗暴法</h2><ul>
<li>利用 ES6 中的 Set 集合里元素唯一的特性，先将数组转换为集合，这样里面的元素就是唯一的了，再用 Array.from 方法将集合转回数组返回。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function unique6(arr)&#123;</span><br><span class="line">  &#x2F;&#x2F;return Array.from(new Set(arr));</span><br><span class="line">  </span><br><span class="line">  return [...new Set(arr)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1, 2, 3, 3, 2, undefined, undefined]</span><br><span class="line">console.log(unique6(arr))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>日期</title>
    <url>/2019/07/18/%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><span id="more"></span>
<pre><code>Date.now()  //获取当前时间毫秒数
var dt = new Date() //构造一个实例对象
dt.getTime()    //获取毫秒数
dt.getFullYear() //年
dt.getMonth()   //月（0-11）
dt.getDate()    //日 （0-31）
dt.getHours()   //小时（0-23）
dt.getMinutes() //分钟（0-59）
dt.getSeconds() //秒（0-59）
dt.getDay()     //星期几（0-6）
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%EF%BC%88Stack%EF%BC%89/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><span id="more"></span>
<ul>
<li><p>我们知道数组是一种线性结构，可以在数组的任意位置插入或删除数据。但有些时候，我们为了实现某种功能，必须对这种 任意性 加以限制，而我们的栈和队列就是比较常见的 <strong>受限的线性结构</strong>。</p>
</li>
<li><p>栈是一种<strong>先进后出</strong>或**后进先出(LIFO Last In First Out)**的数据结构，栈内的元素只能通过列表的一端访问，这一端称为栈顶，因为<br>数据只能在栈顶添加或删除，所以只要数据的保存满足“先进后出或后进先出”的原理，都优先考虑使用栈。</p>
</li>
<li><p>栈的结构示意图：</p>
<img src="https://raw.githubusercontent.com/foolishmax/static/master/blogPic/%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<!--more--></li>
<li><p>栈常见有哪些操作？</p>
</li>
</ul>
<ul>
<li>push（element）：添加一个新元素到栈顶位置。</li>
<li>pop（）：移除栈顶的元素，同时返回被移除的元素。</li>
<li>peek（）：返回栈顶的元素，不对栈做任何修改。</li>
<li>isEmpty（）：如果栈里没有任何元素返回true，否则返回false。</li>
<li>size（）：返回栈里的元素个数，类似数组中的length。</li>
<li>toString（）：将栈结构的内容以字符形式返回。</li>
</ul>
<ul>
<li>栈常见操作的封装：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Stack() &#123;</span><br><span class="line">    this.items &#x3D; []</span><br><span class="line">    &#x2F;&#x2F;将元素压入栈</span><br><span class="line">    Stack.prototype.push &#x3D; function(element) &#123;</span><br><span class="line">        this.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从栈中移除元素</span><br><span class="line">    Stack.prototype.pop &#x3D; function() &#123;</span><br><span class="line">        return this.items.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查看栈顶元素</span><br><span class="line">    Stack.prototype.peek &#x3D; function() &#123;</span><br><span class="line">        return this.items[this.items.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断栈是否为空</span><br><span class="line">    Stack.prototype.isEmpty &#x3D; function() &#123;</span><br><span class="line">        return this.items.length &#x3D;&#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断栈中元素个数</span><br><span class="line">    Stack.prototype.size &#x3D; function() &#123;</span><br><span class="line">        return this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;toString方法</span><br><span class="line">    Stack.prototype.toString &#x3D; function() &#123;</span><br><span class="line">        var resultString &#x3D; &#39;&#39;</span><br><span class="line">        for (var i &#x3D; 0; i&lt; this.items.length; i++) &#123;</span><br><span class="line">            resultString +&#x3D; this.items[i] + &#39; &#39;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;栈的使用</span><br><span class="line">var s &#x3D; new Stack()</span><br><span class="line">s.push(23)</span><br><span class="line">alert(s)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;函数十进制转为二进制</span><br><span class="line">function dec2bin(decNumber) &#123;</span><br><span class="line">    &#x2F;&#x2F;定义栈对象</span><br><span class="line">    var stack &#x3D; new Stack()</span><br><span class="line">    while (decNumber &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取余数放入栈中</span><br><span class="line">        stack.push(decNumber % 2)</span><br><span class="line">        &#x2F;&#x2F;获取除后的结果,作为下次操作的对象</span><br><span class="line">        decNumber &#x3D; Math.floor(decNumber &#x2F; 2)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从栈中取出0和1</span><br><span class="line">    var binaryString &#x3D; &#39;&#39;</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        binaryString +&#x3D; stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    return binaryString</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用函数</span><br><span class="line">alert(dec2bin(100))</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>本地存储</title>
    <url>/2019/09/30/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<ul>
<li><p>客户端的本地存储：</p>
<ul>
<li><p>localStorage</p>
<span id="more"></span>
<ul>
<li>生命周期永久生效，除非手动删除，否则关闭页面也会存在</li>
<li>可以在同一浏览器多窗口共享</li>
<li>以键值对的形式存储使用</li>
<li>方法：<ul>
<li>存储数据：localStorage.setItem(key, value)</li>
<li>获取数据：localStorage.getItem(key)</li>
<li>删除数据：localStorage.removeItem(key)</li>
<li>删除所有数据：localStorage.clear()</li>
</ul>
</li>
</ul>
</li>
<li><p>sessionStorage </p>
<ul>
<li>声明周期为关闭浏览器窗口</li>
<li>在同一个窗口中数据可以共享</li>
<li>以键值对的形式存储</li>
<li>方法：<ul>
<li>存储数据：sessionStorage.setItem(key, value)</li>
<li>获取数据：sessionStorage.getItem(key)</li>
<li>删除数据：sessionStorage.removeItem(key)</li>
<li>删除所有数据：sessionStorage.clear()</li>
</ul>
  <a href='https://www.cnblogs.com/pengc/p/8714475.html'>localStorage和sessionStorage</a>  <a href='https://www.cnblogs.com/8023-CHD/p/11067141.html'>cookie和session</a></li>
</ul>
</li>
<li><p>IndexDB 离线存储，当网络断开，可以从浏览器中读取数据，用来做一些离线应用</p>
</li>
<li><p>Cookie </p>
<ul>
<li>包含字段<ul>
<li>name: cookie名称</li>
<li>value: 值</li>
<li>domain: cookie生效的域名</li>
<li>path: cookie生效的路径</li>
<li>expires/max-age: cookie过期时间</li>
<li>size: 大小</li>
<li>HttpOnly: 用户端不可更改</li>
</ul>
</li>
<li>存储用户信息，通过在客户端记录信息确定用户身份，最大为4kb</li>
<li>会话Cookie，若不设置过期时间，表示这个cookie的生命周期为浏览器会话期间，浏览器<br>关闭，cookie就消失，会话cookie会保存在内存中而不是硬盘上。</li>
<li>持久Cookie，若设置了过期时间，浏览器会把cookie保存在硬盘上，关闭浏览器仍然有效直到<br>超过设定的过期时间。</li>
<li>cookie数据始终在同源的http请求中携带(即使不需要)，即会在浏览器和服务器之间来回传递。</li>
<li>Cookie具有不可跨域名性，例如浏览器访问百度不会带上谷歌的cookie</li>
</ul>
</li>
</ul>
</li>
<li><p>服务端的存储：</p>
<ul>
<li>Session<ul>
<li>Session 服务器端一种记录客户端状态的机制</li>
<li>cookie数据存放在客户的浏览器上，session将数据存放在服务器端</li>
<li>Session相对Cookie来说比较安全，别人可以分析本地存放的cookie进行cookie欺骗</li>
<li>Session会在一定时间内保存在服务器上，访问量较多的时候会比较占用服务器的性能，<br>考虑到减轻服务器性能方面的时候，应当使用cookie</li>
<li>可以将登陆等重要信息保存在session，其他信息放在cookie中</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>本地存储</category>
      </categories>
      <tags>
        <tag>本地存储</tag>
      </tags>
  </entry>
  <entry>
    <title>比较Vue和React？</title>
    <url>/2019/06/30/%E6%AF%94%E8%BE%83Vue%E5%92%8CReact%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="比较Vue和React的相同点和不同点？"><a href="#比较Vue和React的相同点和不同点？" class="headerlink" title="比较Vue和React的相同点和不同点？"></a>比较Vue和React的相同点和不同点？</h2><span id="more"></span>
<ul>
<li>相同点<ul>
<li>都有组件化开发和Virtual DOM</li>
<li>都支持props进行父子组件间的数据通信</li>
<li>都支持数据驱动视图，不直接操作真实DOM，状态数据更新页面则自动更新</li>
<li>都支持服务端渲染</li>
<li>都支持原生应用的开发方案，React有React Native，Vue有Weex<!--more--></li>
</ul>
</li>
<li>不同点<ul>
<li>数据绑定： Vue实现了数据的双向绑定，React数据流动是单向的</li>
<li>React推荐的组件写法为JSX，也就是把HTML和CSS全部写进Javascript中，即“all in js”<br>Vue推荐的组件写法是webpack+vue-loader的单文件组件格式，即html、css、js写在同一个<br>文件</li>
<li>state对象在react应用中不可变，需要使用setState方法更新状态；在vue中state对象不是<br>必须的，数据由data属性在vue对象中管理</li>
<li>virtual DOM不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树，<br>而对于React而言，每当应用的状态被改变时，全部组件都会重新渲染，所以react会需要<br>shouldComponentUpdate这个生命周期函数方法进行控制。</li>
<li>React严格上只针对MVC的view层，Vue则是MVVM模式。</li>
</ul>
</li>
</ul>
<h2 id="前端框架使用Vue还是React？清晰比较两者差异"><a href="#前端框架使用Vue还是React？清晰比较两者差异" class="headerlink" title="前端框架使用Vue还是React？清晰比较两者差异"></a>前端框架使用Vue还是React？清晰比较两者差异</h2><h4 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h4><ul>
<li>vue<ul>
<li>vue由尤雨溪开发，独立团队维护，大部分子项目交给团队成员打理，Vue核心库依然<br>主要由尤雨溪亲自维护。</li>
</ul>
</li>
<li>react<ul>
<li>React起源于Facebook的内部项目，在建设instagram(图片分享)的时候，为了处理<br>数据流且考虑性能方面的问题，因该公司对市场上所有框架都不满意，就决定自己写一套，<br>用来架构Instagram的网站。并在2013年5月开源。</li>
</ul>
</li>
</ul>
<h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><ul>
<li>vue<ul>
<li>vue是一款渐进式框架，采用自底向上增量开发的设计。在声明式渲染(视图模板引擎)<br>的基础上，通过添加组件系统(component)、客户端路由(vue-router)、状态管理(vuex)<br>来构建一个完整的框架。</li>
</ul>
</li>
<li>react<ul>
<li>react主张函数式编程，所以推崇纯组件，数据不可变，单向数据流，</li>
</ul>
</li>
</ul>
<h4 id="编写语法"><a href="#编写语法" class="headerlink" title="编写语法"></a>编写语法</h4><ul>
<li>vue<ul>
<li>vue推荐的做法是webpack + vue-loader的单文件格式，vue保留了html、css、js<br>分离的写法，数据绑定使用mustache风格，样式直接使用css，在<code>&lt;style&gt;</code>标签提供<br>了一个可选的scoped属性，用开控制css仅对当前组件生效还是全局生效。</li>
</ul>
</li>
<li>react<ul>
<li>react推荐的做法是JSX + inline style，也就是把HTML和CSS全都写进JavaScript<br>中，即“all in js”，react没有模板，直接就是一个渲染函数，返回一个虚拟DOM树，<br>在render()编写的JSX语法最终会被编译成原生JavaScript。</li>
</ul>
</li>
</ul>
<h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><ul>
<li>vue<ul>
<li>vue提供了CLI脚手架，可以帮助我们非常容易地构建项目，全局安装后用vue create<br>命令创建新项目，可以让用户自定义选择需要安装的模板。</li>
</ul>
</li>
<li>react<ul>
<li>react提供了create-react-app，但只提供一个构建单页面应用的默认选项。</li>
</ul>
</li>
</ul>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><ul>
<li>vue<ul>
<li>vue实现双向数据绑定，view的变化能实时让model改变，而model的变化也能实时<br>更新到view</li>
<li>vue采用数据劫持 + 发布-订阅模式，通过Object.defineProperty对数据进行操作，<br>为数据动态添加getter和setter方法，当获取数据的时候会触发对应的getter方法，<br>当设置数据的时候会触发对应的setter方法，从而进一步触发vm的watcher方法，然后<br>对数据进行更改，vm则进一步触发视图更新操作。</li>
</ul>
</li>
<li>react<ul>
<li>react是单向数据流，react中属性是不允许更改的，状态是允许更改的。react中组件<br>不允许通过this.state这种方法直接更改组件的状态。自身设置的状态，可以通过setState<br>进行更改。</li>
<li>setState是异步的，导致获取dom可能拿到的还是之前的内容，所以需要在setState<br>第二个参数(回调函数)中获取更新后的内容。</li>
</ul>
</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul>
<li>vue<ul>
<li>vue中每个组件内部自动实现了shouldComponentUpdate的优化，在vue中里面由于<br>依赖追踪系统的存在，当任意数据变动的时候，Vue的每一个组件都能精确的知道自己是<br>否需要重绘。而在react中需要我们手动去优化其性能，但s是当数据特别多的时候vue中<br>的watcher也会特别多，从而造成页面卡顿，所以一般大西瓜项目会倾向于react。</li>
</ul>
</li>
<li>react<ul>
<li>当props或state发生改变的时候会触发shouldComponentUpdate生命周期函数，它<br>是用来控制组件是否被重新渲染的，如果它返回true，则执行render函数，更新组件；<br>如果它返回false，则不会触发重新渲染的过程。</li>
<li>如果希望更新之前和之前的状态进行一个对比，这个时候需要重写shouldCompnentUpdate<br>来避免不必要的dom操作，对比当前的props或state和更新后的nextProps或nextState，<br>返回true时，组件更新；返回false，不更新，节省性能。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue、React</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器是怎么对HTML5的离线存储资源进行管理和加载的？</title>
    <url>/2019/10/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%B9HTML5%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E5%92%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="浏览器是怎么对HTML5的离线存储资源进行管理和加载的？"><a href="#浏览器是怎么对HTML5的离线存储资源进行管理和加载的？" class="headerlink" title="浏览器是怎么对HTML5的离线存储资源进行管理和加载的？"></a>浏览器是怎么对HTML5的离线存储资源进行管理和加载的？</h2><ul>
<li><p>在线的情况下：浏览器发现html头部有manifest属性，会请求manifest文件，如果是<br>第一次访问app，浏览器会根据manifest文件的内容下载相应的资源并进行离线缓存。如果<br>已经离线存储了，浏览器会使用离线的资源加载页面，然后浏览器会比对新的manifest文件<br>与旧的manifest文件，如果文件没有发生改变，就不要做任何操作，如果文件改变，就会重新<br>下载文件中的资源并进行离线存储。</p>
</li>
<li><p>离线的情况下：浏览器就直接使用离线存储的资源。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的reflow和repaint</title>
    <url>/2019/07/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84reflow%E5%92%8Crepaint/</url>
    <content><![CDATA[<h2 id="浏览器的reflow和repaint"><a href="#浏览器的reflow和repaint" class="headerlink" title="浏览器的reflow和repaint"></a>浏览器的reflow和repaint</h2><span id="more"></span>
<ul>
<li>reflow（回流||重排）：当浏览器上某一个位置的布局发生了改变，浏览器会重新从根部开始计算该节点的</li>
</ul>
<p>布局。比如：向页面中添加、删除某一元素等，dom节点的宽高位置改变，只要这些操作影响了</p>
<p>页面的元素位置或大小的变化，都会引起reflow。</p>
<ul>
<li>repaint（重绘）：如果只改变页面元素的颜色、字体等不影响布局的属性时，浏览器会进行repaint。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由上可见，相比repaint操作，reflow的耗时要更多。只要是动态的对页面进行修改，浏览器的reflow</span><br><span class="line"></span><br><span class="line">和repaint的操作就不可避免，我们要做的就是尽可能的减少浏览器的reflow和repaint的次数。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>深度封装typeof判断</title>
    <url>/2019/08/04/%E6%B7%B1%E5%BA%A6%E5%B0%81%E8%A3%85typeof%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h2 id="深度封装typeof判断"><a href="#深度封装typeof判断" class="headerlink" title="深度封装typeof判断"></a>深度封装typeof判断</h2><span id="more"></span>
<pre><code>function myTypeof(val) &#123;
    var type = typeof(val)
    var res = &#123;
        &#39;[object Object]&#39; : &#39;object&#39;,
        &#39;[object Array]&#39; : &#39;array&#39;,
        &#39;[object Number]&#39; : &#39;object number&#39;,
        &#39;[object String]&#39; : &#39;object string&#39;,
        &#39;[object Boolean]&#39; : &#39;object boolean&#39;
    &#125;
    if (val === null) &#123;
        return &#39;null&#39;
    &#125; else if (type == &#39;object&#39;) &#123;
        var str = Object.prototype.toString.call(val)
        return res[str]
    &#125; else &#123;
        return type
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝、浅拷贝</title>
    <url>/2019/07/29/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h2><span id="more"></span>
<pre><code>浅拷贝：只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。

深拷贝：会创造一个一模一样的对象，新旧对象不共享内存，修改新对象不会影响原对象。

浅拷贝实现：
    1.自定义函数
    function shallowCopy (initialObj) &#123;
        var obj = &#123;&#125;
        for (var prop in initialObj) &#123;
            if (initialObj.hasOwnProperty(prop)) &#123;
                obj[prop] = initialObj[prop]
            &#125;
        &#125;
        return obj
    &#125;
    
    2.ES6 的Object.assign()  //目标对象只有一层的时候，就是深拷贝
    let newObj = Object.assign(&#123;&#125;, obj)
    
    3.ES6 的对象扩展（当数组或对象只有一层的时候，扩展运算符就相当于深拷贝）
    let newObj = &#123;...obj&#125;
    
深拷贝实现
    1.JSON.stringify 和 JSON.parse
    let newObj = JSON.parse(JSON.stringify(obj))
    
    2.lodash函数库的_.cloneDeep方法
    var _ = require(&#39;lodash&#39;)
    var newObj = _.cloneDeep(obj)
    
    3.slice方法实现数组深拷贝
    let arr1 = [1,2,3,4]
    let arr2 = arr1.slice(0)
    arr1[0] = 5
    console.log(arr1) //[5,2,3,4]
    console.log(arr2) //[1,2,3,4]
    
    4.concat实现数据深拷贝
    let arr1 = [1,2,3,4]
    let arr2 = arr1.concat()
    arr1[0] = 5
    console.log(arr1) //[5,1,2,3]
    console.log(arr2) //[1,2,3,4]
    
    5.自己封装
    function deepClone(obj) &#123;
        let objClone = Array.isArray(obj) ? [] : &#123;&#125;;
        if (obj &amp;&amp; typeof obj === &quot;object&quot;) &#123;
            // for...in 会把继承的属性一起遍历
            for (let key in obj) &#123;
                // 判断是不是自有属性，而不是继承属性
                if (obj.hasOwnProperty(key)) &#123;
                    //判断ojb子元素是否为对象或数组，如果是，递归复制
                    if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123;
                        objClone[key] = this.deepClone(obj[key]);
                    &#125; else &#123;
                        //如果不是，简单复制
                        objClone[key] = obj[key];
                    &#125;
                &#125;
            &#125;
        &#125;
        return objClone;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客学习知识总结-1</title>
    <url>/2019/07/06/%E7%89%9B%E5%AE%A2%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-1/</url>
    <content><![CDATA[<h2 id="牛客学习知识总结"><a href="#牛客学习知识总结" class="headerlink" title="牛客学习知识总结"></a>牛客学习知识总结</h2><span id="more"></span>
<ul>
<li><p>超链接</p>
<ul>
<li>a标签的href的属性值是url，里面必须包含协议，没有协议就会解析成相对路径。</li>
</ul>
</li>
<li><p>HTTP状态码分类：</p>
<ul>
<li>1** 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2** 成功，操作被成功接受并处理。<ul>
<li>200 服务端成功处理了请求并返回内容</li>
</ul>
</li>
<li>3** 重定向，需要进一步的操作以完成请求<ul>
<li>301 永久重定向</li>
<li>302 临时重定向</li>
<li>304 资源未被修改，返回一个304状态吗然后从本地缓存中加载请求的资源</li>
</ul>
</li>
<li>4** 客户端错误，请求包含语法错误或无法完成请求。<ul>
<li>404 （页面丢失）未找到资源</li>
<li>403 服务器拒绝请求</li>
<li>408 （请求超时） 服务器等候请求时发生超时</li>
</ul>
</li>
<li>5** 服务器错误，服务器在处理请求的过程中发生错误<ul>
<li>503 服务器暂时不可用</li>
<li>504 服务器内部错误<!--more--></li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP协议的特征：</p>
<ul>
<li>C/S(客户端/服务器)模式：只要客户端和服务器知道如何处理数据内容，任何类型的数据<br>都可以通过HTTP来发送，客户端和服务器指定合适的MIME-type内容类型。</li>
<li>简单快速</li>
<li>灵活</li>
<li>无连接：限制每次连接只处理一个请求，收到客户的应答后即断开连接，可以节省传输时间。</li>
<li>无状态：对于事物处理没有记忆能力，意味着如果后续处理需要前面的信息，则必须重传，<br>这样就会导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就会很快。</li>
</ul>
</li>
<li><p>get 和 post的请求区别？</p>
<ul>
<li>区别一：<ul>
<li>get重点是从服务器上获取资源</li>
<li>post重点是向服务器发送数据</li>
</ul>
</li>
<li>区别二：<ul>
<li>get传输数据通过url请求，以field（字段）=value的形式放在url后，用“？”连接，<br>多个请求数据间用“&amp;”连接，过程用户可见。</li>
<li>post传输数据放在请求体（request body）中发送给服务器，用户不可见。</li>
</ul>
</li>
<li>区别三：<ul>
<li>get传输数据大小有限制，但效率较高</li>
<li>post可以传输大量数据，所以上传文件用post方式</li>
</ul>
</li>
<li>区别四：<ul>
<li>get请求不安全，因为参数直接暴露在url上，不能用来传递敏感信息。</li>
<li>post较get安全性较高。</li>
</ul>
</li>
<li>区别五：<ul>
<li>get方式只能支持ASCII字符，向服务传的中文字符可能会乱码。</li>
<li>post支持标准字符集，可以正确传递中文字符。</li>
</ul>
</li>
<li>区别六：<ul>
<li>get在浏览器回退是无害的，而post会再次提交请求。</li>
</ul>
</li>
<li>区别七<ul>
<li>get请求会被浏览器主动cache（缓存），而post不会除非手动设置。</li>
</ul>
</li>
</ul>
</li>
<li><p>iframe有哪些缺点？</p>
<ul>
<li>iframe会阻塞主页面的onload事件</li>
<li>通过oIframe.contentWindow寻找子window对象</li>
<li>通过window.parent寻找父级窗体</li>
<li>通过window.top寻找顶级窗体</li>
<li>window.location.hash 解决父页面向子页面传值</li>
<li>window.name 解决子页面向父页面传值</li>
<li>不利于SEO，搜索引擎的检索程序无法解读这种页面（百度spider不收录，浏览器对iframe框架的兼容问题）</li>
<li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>
<li>如果需要使用iframe，最好通过javascript动态给iframe添加src属性值。</li>
</ul>
</li>
<li><p>xhtml和html有什么区别？</p>
<ul>
<li>性能方面 <ul>
<li>XHTML兼容性好，兼容各大浏览器、手机以及PDA，使浏览器可以快速正确编译网页</li>
</ul>
</li>
<li>书写习惯方面<ul>
<li>HTML标签不区分大小写，XHTML所有标签必须小写</li>
<li>XHTML必须成双成对</li>
<li>HTML对标签顺序要求不严格，XHTML标签顺序必须正确</li>
<li>等等</li>
</ul>
</li>
</ul>
</li>
<li><p>html和xml的区别？</p>
<ul>
<li>xml被设计用来传输和存储数据，其焦点是数据的内容</li>
<li>html被设计用来显示数据，其焦点是数据的外观</li>
<li>html旨在显示信息，而xml旨在传输信息</li>
<li>xml在定义标记时区分大小写，而html不区分大小写</li>
</ul>
</li>
<li><p>link和@import的区别：</p>
</li>
</ul>
<p><strong>两者都是外部引用CSS的方式，但有一定的区别</strong></p>
<pre><code>+ link是XHTML标签，除了加载CSS外，还可以加载其他文件；@import只能加载CSS。

+ 解析到link时，页面会同步加载Css；@import在页面加载完后加载Css。

+ link是XHTML标签，无兼容问题；@import是在**CSS2.1**之后提出的，只有再IE5以上才能识别。

+ link可以js动态引入，@import不行

+ @import的最佳写法： @import url(style.css),其他写法：@import &#39;style.css&#39;、
@import &quot;style.css&quot;、@import url(&#39;style.css&#39;)、@import url(&quot;style.css&quot;)
</code></pre>
<ul>
<li>viewport</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,minimum-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;no&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; width            设置viewport宽度，为一个正整数，或字符串‘device-width’</span><br><span class="line">  &#x2F;&#x2F; device-width     设备宽度</span><br><span class="line">  &#x2F;&#x2F; height           设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置</span><br><span class="line">  &#x2F;&#x2F; initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数</span><br><span class="line">  &#x2F;&#x2F; minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数</span><br><span class="line">  &#x2F;&#x2F; maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数</span><br><span class="line">  &#x2F;&#x2F; user-scalable    是否允许手动缩放</span><br></pre></td></tr></table></figure>

<ul>
<li><p>单行文本溢出省略号</p>
<p>  overflow: hidden;</p>
<p>  text-overflow:ellipsis;</p>
<p>  white-space: nowrap;</p>
</li>
<li><p>多行文本溢出省略号</p>
<p>  display: -webkit-box;</p>
<p>  -webkit-box-orient: vertical;</p>
<p>  -webkit-line-clamp: 3;</p>
<p>  overflow: hidden;</p>
</li>
<li><p>换行标签</p>
<p>  word-wrap: break-word</p>
</li>
</ul>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title>简书面经笔记（一）</title>
    <url>/2019/07/28/%E7%AE%80%E4%B9%A6%E9%9D%A2%E7%BB%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前端面经笔记-一"><a href="#前端面经笔记-一" class="headerlink" title="前端面经笔记(一)"></a>前端面经笔记(一)</h2><span id="more"></span>
<h4 id="如何判断一个对象是否为数组"><a href="#如何判断一个对象是否为数组" class="headerlink" title="如何判断一个对象是否为数组"></a>如何判断一个对象是否为数组</h4><pre><code>1. Array.prototype.isPrototypeOf(obj)方法，判断Array.prototype是不是在obj的原型链中，
如果在，则返回true，否则返回false。

2. obj instanceof Array

3. Object.prototype.toString.call(obj); //(===&quot;[object Array]&quot;)

4.Array.isArray(obj)
</code></pre>
<h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><pre><code>1.macro-task(宏任务)：包括整体代码script、setTimeout、setInterval
2.micro-task(微任务)：Promise.then、process.nextTick

    
</code></pre>
<h4 id="Http的持久连接和管线化"><a href="#Http的持久连接和管线化" class="headerlink" title="Http的持久连接和管线化"></a>Http的持久连接和管线化</h4><pre><code>1. 什么是持久连接？
    HTTP1.1规定了默认保持持久连接，数据传输完成也保持TCP连接不断开，等待同域名下
    继续使用这个通道传输数据,在一个TCP连接上传输多个HTTP请求和响应。
    
    持久连接避免了重新建立连接，大大减少了建立和关闭连接的消耗和延迟，HTTP的连接是建立
    在TCP协议之上的，建立一条TCP连接需要三次握手，TCP连接关闭需要四次挥手，这些都需要时间。
    
2. 什么是管线化？
    持久连接：
        请求1 ——&gt; 响应1 ——&gt; 请求2 ——&gt; 响应2
    管线化：
        请求1 ——&gt; 请求2 ——&gt; 响应1 ——&gt; 响应2
        
    管线化机制需要通过持久化连接完成。
    
    持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后，
    才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。
    实现并行发送请求。
    
    只有GET和HEAD请求可以进行管线化，而POST有所限制。
    
    初次建立连接不应启动管线机制，因为对方服务器不一定支持HTTP1.1版本的协议。
    
</code></pre>
<h4 id="为什么利用多个域名来存储网站资源会更有效？"><a href="#为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="为什么利用多个域名来存储网站资源会更有效？"></a>为什么利用多个域名来存储网站资源会更有效？</h4><pre><code>1.CDN 是构建在网络之上的内容分发网络，可以使用户就近获取资源，减低网络拥塞，提高用户
访问的响应效率以及命中率。

2.突破浏览器的并发限制，同一时间针对同一域名下的请求有一定的数量限制，超过限定数目
的请求会被阻塞。

3.节约cookie带宽

4.减少主域名的连接数，优化页面响应速度

5.防止不必要的安全问题
</code></pre>
<h4 id="CSS权重（156进制）"><a href="#CSS权重（156进制）" class="headerlink" title="CSS权重（156进制）"></a>CSS权重（156进制）</h4><pre><code>1. ！import  权值：infinite 无穷大

2. 内联样式， 权值1000

3. ID选择器， 权值： 100

4. 类、伪类、属性选择器， 权值： 10

5.标签、伪元素选择器， 权值： 1

6.通配符选择器 *，子选择器 &gt;,相邻选择器 +，权值： 0

权值相等，后来居上
</code></pre>
<h4 id="html5的新特性"><a href="#html5的新特性" class="headerlink" title="html5的新特性"></a>html5的新特性</h4><pre><code>1. 添加了video、radio标签
2. 添加了canvas画布和svg渲染矢量图片
3. 添加了一些语义化的标签 header、footer、main、section...
4. input的type值新添加了很多属性（email，search，color，number...）
5. 添加了地理位置定位功能 Geolocation API
6. 添加了web Storage存储功能，localStorage和sessionStorage
7. 使用html5，通过创建cache manifest文件，可以轻松地创建web应用的离线版本
8. web worker创造多线程环境，是运行在后台的javaScript。
9。 服务端推送（EventSource用于接受服务端发送事件通知）
</code></pre>
<h4 id="CSS3新添加的特性？"><a href="#CSS3新添加的特性？" class="headerlink" title="CSS3新添加的特性？"></a>CSS3新添加的特性？</h4><pre><code>1. 媒体查询
2. transform，transition，translate，scale，rotate等相关动画效果
3. box-shadow，text-shadow等特效
4. CSS3 @font-face规则，可以引入任意字体
5. CSS3 @keyframes规则，创建动画(配合animation使用)
6. 2D、3D转化
7. 添加了border-radius、border-image、column-count、resize、box-sizing
、outline-offset等属性
</code></pre>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><pre><code>基本数据类型：Null、Undefined、String、Boolean、Number
ES6：Symbol
ES10：Bigint（可以突破安全整数限制，安全的存储和操作最大整数之外的整数，不会损失精度）
</code></pre>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>简单说一下原型链</title>
    <url>/2019/07/16/%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="简单说下原型链"><a href="#简单说下原型链" class="headerlink" title="简单说下原型链"></a>简单说下原型链</h2><span id="more"></span>
<ul>
<li><p>原型链是由原型对象组成的，每个对象都有__proto__属性，指向了创建该对象的构造函数的<br>原型，__proto__将对象连接起来组成了原型链。</p>
</li>
<li><p>原型链：用来实现继承和共享属性的有限对象链。</p>
</li>
<li><p>每个对象都有__proto__（隐式原型）属性，指向创建该对象的构造函数的原型。其实<br>这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能<br>访问到，所以使用 <em>proto</em> 来访问。</p>
</li>
<li><p>对象的隐式原型等于对象的构造函数的显式原型：obj.<strong>proto</strong> === Object.prototype</p>
</li>
<li><p>访问属性的时候，js引擎会调用内部的默认。。。。。。[[Get]]操作，[[Get]]操作首先会检查对象本身是否包含这个属性<br>如果对象没有这个属性，则对象可以通过__proto__来寻找不属于该对象的属性，<strong>proto</strong><br>将对象和原型连接起来形成原型链</p>
</li>
<li><p>Function.prototype 和 Object.prototype是两个特殊的对象，他们由引擎创建。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>说一下浏览器的缓存机制</title>
    <url>/2019/07/10/%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><span id="more"></span>
<pre><code>缓存可以简单高效的提高性能优化，对于一个数据请求来说，分为网络请求、后端处理、浏览器
响应三个步骤，浏览器缓存可以优化网络请求和响应部分。比如：直接换用缓存而不发起请求，
或者发起请求但后端存储的数据和前端一致，就没有必要将数据回传，这样就减少的响应数据，
使得缓存文件可以重复利用，减少带宽，减低网络负荷。
</code></pre>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><pre><code>网络请求会先从缓存位置上面查找缓存，如果都没有命中，才会去请求网络资源，从缓存位置
分为四种，并且各自有优先级：
- Service Worker
- Memory Cache
- Disk Cache
- Push Cache
</code></pre>
<h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Service Worker 是运行在浏览器背后的独立线程，一般可以用<br>来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为<br>Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。<br>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、<br>如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册<br> Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问<br> 的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，<br> 否则就去请求数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数<br> 获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级<br> 去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显<br> 示我们是从 Service Worker 中获取的内容。</p>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面<br>上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，<br>可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就<br>被释放了。</p>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之<br> Memory Cache 胜在容量和存储时效性上。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会<br>根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源<br>已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不<br>会再次去请求数据。</p>
<h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种<br>缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，<br>并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中<br>的缓存指令。</p>
<p><code>如果以上四种缓存都没有命中的话，只能发起网络请求来获取资源了。 为了性能上的考虑，大部分接口都应该选择好缓存策略， 浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置HTTP Header来实现的。</code></p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><pre><code>强缓存：不会向服务器发送请求，直接从缓存中读取资源，可以通过HTTP Header实现：Expires
和Cache-Control。
+ Expires：缓存过期时间，用来指定资源到期的时间，是服务端的具体的时间点，结合Last-modified
使用，Expires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

+ Cache-Control：和多个指令配合使用，实现资源缓存。

+ Expires和Cache-Control同时存在，Cache-Control优先级高于Expires。
</code></pre>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><pre><code>协商缓存就是强缓存失效后，浏览器携带缓存表示向服务器发起请求，由服务器根据缓存表示决定
是否使用缓存的过程，主要有以下两种情况：
+ 协商缓存生效，返回304和Not Modified

+ 协商缓存失效，返回200和请求结果。

+ 协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。

+ ETag是服务器响应请求时，返回当前资源文件的一个唯一标识（有服务器生成），只要资源有变化
，ETag就会重新生成。
</code></pre>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><pre><code>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用
缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和
Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，
那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；
生效则返回304，继续使用缓存
</code></pre>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对闭包的理解？</title>
    <url>/2019/07/17/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="说说你对闭包的理解？"><a href="#说说你对闭包的理解？" class="headerlink" title="说说你对闭包的理解？"></a>说说你对闭包的理解？</h2><span id="more"></span>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ul>
<li><p>函数可以记住并访问所在的词法作用域，就产生了闭包。或简单理解为：定义在一个函数内部的<br>函数，内部函数持有外部函数内变量或参数的引用。</p>
</li>
<li><p>内部函数被保存在全局，内部函数依赖外部函数，外部函数参数和变量不会被垃圾回收机制回收，<br>这些变量会始终存在于内存中。</p>
</li>
</ul>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译<br>阶段由编译器完成，将代码编译成可执行代码，这个阶段作用域规则会确定。执行阶段由js<br>引擎完成，主要任务是执行可执行代码，执行期上下文在这个阶段创建。</li>
<li>编译器<ul>
<li>语法分析</li>
<li>词法分析</li>
<li>可执行代码生成</li>
<li>作用域规则确定</li>
<li>…</li>
</ul>
</li>
<li>js引擎<ul>
<li>执行上下文</li>
<li>代码执行</li>
<li>垃圾回收</li>
<li>…</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    var a &#x3D; 2</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">    return bar</span><br><span class="line">&#125;</span><br><span class="line">var baz &#x3D; foo()</span><br><span class="line">baz() &#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;也可以是作为参数传递给外部函数</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a &#x3D; 2</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    baz(bar)</span><br><span class="line">&#125;</span><br><span class="line">function baz(fn) &#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;也可以间接的分配给全局变量</span><br><span class="line">var fn</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a &#x3D; 2</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    fn &#x3D; bar</span><br><span class="line">&#125;</span><br><span class="line">function baz() &#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">baz()</span><br></pre></td></tr></table></figure>

<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li><p>可以读取函数内部的变量</p>
</li>
<li><p>柯里化</p>
</li>
<li><p>封装对象的私有属性和私有方法（收敛权限）,例如模块实例</p>
</li>
<li><p>模块的两个特征：</p>
<ul>
<li>为了创建一个内部作用域而调用了一个包装函数</li>
<li>包装函数必须至少一个对内部函数的引用，这样就会创建涵盖整个函数内部作用域的闭包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; (function CoolModule()&#123;</span><br><span class="line">    var something &#x3D; &quot;cool&quot;</span><br><span class="line">    var another &#x3D; [1, 2, 3]</span><br><span class="line">    </span><br><span class="line">    function doSomething() &#123;</span><br><span class="line">        console.log(something)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function doAnother() &#123;</span><br><span class="line">        console.log(another.join(&#39;!&#39;))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">foo.doSomething()   &#x2F;&#x2F;cool</span><br><span class="line">foo.doAnother()     &#x2F;&#x2F;1!2!3</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>避免污染全局变量</p>
</li>
</ul>
<h4 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h4><ul>
<li>会增大内存使用量，容易造成内存泄漏。</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>在退出函数前，将不使用的局部变量全部删除。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2019/06/29/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%AE%83/</url>
    <content><![CDATA[<h2 id="什么是跨域？解决跨域的方法有哪些"><a href="#什么是跨域？解决跨域的方法有哪些" class="headerlink" title="什么是跨域？解决跨域的方法有哪些?"></a>什么是跨域？解决跨域的方法有哪些?</h2><span id="more"></span>
<ul>
<li><p>同源策略</p>
<ul>
<li>是一种浏览器的安全策略</li>
<li>协议、域名、端口号必须完全一致</li>
<li>不同源的客户端脚本在没有明确的授权的情况下，不能读取对方的资源</li>
</ul>
</li>
<li><p>跨域</p>
<ul>
<li>指一个域下的文档或脚本尝试去请求另一个域下的资源。</li>
</ul>
</li>
</ul>
<!-- more -->

<ul>
<li><p>解决跨域</p>
<ul>
<li>jsonp</li>
<li>postMessage 跨域</li>
<li>WebSocket 协议跨域</li>
<li>CORS（跨域资源共享，服务端设置Access-Control-Allow-Origin，前端无需设置，<br>若要带cookie请求，前后端都要设置）</li>
<li>nginx 反向代理接口跨域</li>
<li>document.domain(两个页面通过js强制设置document.domain为基础主域，针对基础域名相同的情况)</li>
<li>window.name + iframe</li>
<li>location.hash + iframe</li>
<li>…</li>
</ul>
</li>
<li><p>实现jsonp跨域</p>
<ul>
<li>通常为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一台独立域名<br>的服务器上，在html页面中再通过响应的标签从不同域名加载静态资源。jsonp就是利用此<br>原理，动态创建script，再请求一个带参网址实现跨域通信</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var script &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">    script.type &#x3D; &#39;text&#x2F;javascript&#39;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;传参一个回调函数名给后端，方便后端返回时执行这个前端定义的回调函数</span><br><span class="line">    script.src &#x3D; &#39;http:&#x2F;&#x2F;www.xxx.com:8080&#x2F;login?user&#x3D;admin&amp;callback&#x3D;handleCallback&#39;</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;回调执行函数</span><br><span class="line">    function handleCallbak(res) &#123;</span><br><span class="line">        alert(JSOn.stringify(res))</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖（Debouncing）和节流（Throttling）实现</title>
    <url>/2019/06/11/%E9%98%B2%E6%8A%96%EF%BC%88Debouncing%EF%BC%89%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%88Throttling%EF%BC%89%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="手写防抖（Debouncing）和节流（Throttling）"><a href="#手写防抖（Debouncing）和节流（Throttling）" class="headerlink" title="手写防抖（Debouncing）和节流（Throttling）"></a>手写防抖（Debouncing）和节流（Throttling）</h2><h3 id="防抖（Debouncing）实现"><a href="#防抖（Debouncing）实现" class="headerlink" title="防抖（Debouncing）实现"></a>防抖（Debouncing）实现</h3><ul>
<li>典型例子：限制<code>鼠标连击</code>触发、<code>监听用户输入</code>。<blockquote>
<p><strong>解释</strong>：当一次事件发生后，事件处理器要等一定阀值的时间，如果这段时间过去后，<br>再也没有事件发生，就处理最后一次发生的事件。如果还差<code>0.01</code>秒到达指定事件，这是又有一次<br>事件触发，那么之前的等待作废，需要重新再次等待指定时间。</p>
</blockquote>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;防抖动函数</span><br><span class="line">function debounce(fn, wait &#x3D; 50, immediate) &#123;</span><br><span class="line"></span><br><span class="line">	let timer;</span><br><span class="line">	</span><br><span class="line">	return function() &#123;</span><br><span class="line">	</span><br><span class="line">		if (immediate) &#123;</span><br><span class="line">		</span><br><span class="line">		fn.apply(this, arguments)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (timer) clearTimeout(timer)</span><br><span class="line">		</span><br><span class="line">		timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">		</span><br><span class="line">			fn.apply(this, arguments)</span><br><span class="line">			</span><br><span class="line">		&#125;,wait)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--more--></li>
</ul>
<h4 id="节流（Throttling）实现"><a href="#节流（Throttling）实现" class="headerlink" title="节流（Throttling）实现"></a>节流（Throttling）实现</h4><blockquote>
<p><strong>解释</strong>：可以理解为事件再一个管道中传输，加上这个节流阀之后，事件的流速就会减慢，<br>节流可以将一个函数的调用频率限制再一定阀值内，例如 1s ，那么 1s 内这个函数一定不会被调用两次。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;简单的节流函数</span><br><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">	let prev &#x3D; new Date();</span><br><span class="line">	return function() &#123; 	</span><br><span class="line">	    const args &#x3D; arguments;   </span><br><span class="line">		const now &#x3D; new Date();</span><br><span class="line">		if (now - prev &gt; wait) &#123;</span><br><span class="line">			fn.apply(this, args);</span><br><span class="line">			prev &#x3D; new Date();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://psytn65m0.bkt.clouddn.com/01.jpg"  height="270" width="180"></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>阻止冒泡以及默认事件</title>
    <url>/2019/07/29/%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E4%BB%A5%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="如何阻止冒泡"><a href="#如何阻止冒泡" class="headerlink" title="如何阻止冒泡?"></a>如何阻止冒泡?</h2><span id="more"></span>
<pre><code>W3C的方法e.stopPropagation(),IE使用e.cancelBubble = true;

封装：
    //阻止冒泡行为
    function stopBubble(e) &#123;
        //如果提供了事件对象，则这是一个非IE浏览器
        if (e &amp;&amp; e.stopPropagation) e.stopPropagation()
        //IE的方法
        else window.event.cancelBubble = true
    &#125;
    
</code></pre>
<h2 id="如何阻止默认事件？"><a href="#如何阻止默认事件？" class="headerlink" title="如何阻止默认事件？"></a>如何阻止默认事件？</h2><pre><code>W3C的方法是e.preventDefault(),IE使用e.returnValue = false

封装：
    //阻止浏览器的默认行为
    function stopDefault (e) &#123;
        if (e &amp;&amp; e.preventDefault) e.preventDefault()
        //IE中阻止默认事件的方法
        else window.event.returnValue = false
        return false
    &#125;
</code></pre>
<h2 id="补充：事件绑定的封装"><a href="#补充：事件绑定的封装" class="headerlink" title="补充：事件绑定的封装"></a>补充：事件绑定的封装</h2><pre><code>function addEvent(element,type,handle) &#123;
    if(element.addEventListener)&#123;
        element.addEventListener(type,handle,false);
    &#125;else if(element.attachEvent)&#123;
        element.attachEvent(&#39;on&#39;+type,function () &#123;
            handle.call(element);
        &#125;)
    &#125;else &#123;
        element[&#39;on&#39;+type] = handle;
    &#125;
&#125;
</code></pre>
<h2 id="JS如何设置获取盒子模型对应的宽和高？"><a href="#JS如何设置获取盒子模型对应的宽和高？" class="headerlink" title="JS如何设置获取盒子模型对应的宽和高？"></a>JS如何设置获取盒子模型对应的宽和高？</h2><ul>
<li><p>dom.style.width/height</p>
</li>
<li><p>dom.currentStyle.width/height (ie支持)</p>
</li>
<li><p>window.getComputedStyle(dom).width/height</p>
</li>
<li><p>dom.getBoundingClientRect().width/height</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>面试居中问题</title>
    <url>/2019/07/29/%E9%9D%A2%E8%AF%95%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>##如何居中一个元素？</p>
<h4 id="行级元素水平居中-单行文本水平居中"><a href="#行级元素水平居中-单行文本水平居中" class="headerlink" title="行级元素水平居中(单行文本水平居中)"></a>行级元素水平居中(单行文本水平居中)</h4><pre><code>text-align: center;
</code></pre>
<span id="more"></span>
<h4 id="块级元素水平居中"><a href="#块级元素水平居中" class="headerlink" title="块级元素水平居中"></a>块级元素水平居中</h4><pre><code>1.宽度固定，自身设置  margin: 0 auto;
2.宽度不固定： 父元素设置 text-align: center;
             自身设置：display: inline-block;
</code></pre>
<h4 id="行级元素垂直居中-单行文本垂直居中"><a href="#行级元素垂直居中-单行文本垂直居中" class="headerlink" title="行级元素垂直居中(单行文本垂直居中)"></a>行级元素垂直居中(单行文本垂直居中)</h4><pre><code>line-height: height;
</code></pre>
<h4 id="行级元素垂直居中-多行文本垂直居中"><a href="#行级元素垂直居中-多行文本垂直居中" class="headerlink" title="行级元素垂直居中(多行文本垂直居中)"></a>行级元素垂直居中(多行文本垂直居中)</h4><pre><code>1.父元素设置 display: table; //table是块状元素成为一个块级表格
2.子元素设置 display: table-cell;  //子元素设置成表格单元格
           vertical-align: middle; //使表格内容垂直居中显示
</code></pre>
<h4 id="实现元素的水平垂直居中"><a href="#实现元素的水平垂直居中" class="headerlink" title="实现元素的水平垂直居中"></a>实现元素的水平垂直居中</h4><pre><code>方法一： margin: auto;

    父元素：position: relative;
           width: 300px;
           height: 300px;
           border: 1px solid red;
           
    子元素：position: absolute;
           width: 100px;
           height: 100px;
           margin: auto;
           top: 0;
           left: 0;
           right: 0;
           bottom: 0;
           
方法二： 负margin法
    .box &#123;
            width: 400px;
            height: 200px;
            position: relative;
            background: red;
        &#125;
    .content &#123;
        width: 200px;
        height: 100px;
        position: absolute;
        top: 50%;
        left: 50%;
        
        &lt;!--margin-left: -100px;//宽高已知--&gt;
        &lt;!--margin-top: -50px;--&gt;
        
        transform: translate(-50%, -50%);//宽高未知
        background: green;
    &#125;
    
方法三： flex布局
    .box &#123;
        width: 400px;
        height: 200px;
        background: red;
        display: flex;
        justify-content: center;    //控制水平方向的居中
        align-items: center;    //控制垂直方向的居中
    &#125;
    .content &#123;
        width: 200px;
        height: 100px;
        background: green;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>打乱数组</title>
    <url>/2019/08/07/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h2><span id="more"></span>
<pre><code>1. 常见的sort打乱数组的方法

function shuffle(arr) &#123;
   return arr.sort (function () &#123;
        return Math.random() - 0.5
    &#125;)
&#125;
var arr = [1,2,3,4,5,6,7]
shuffle(arr)

更加简洁的ES6写法

function shuffle(arr) &#123;
    return arr.sort(() =&gt; Math.random() - 0.5)
&#125;

但是这种写法有问题，并不能真正地随机打乱数组，经过大量的实验发现
每个元素仍然有很大的几率出现在它原来的位置附近。

2.洗牌算法
    从最后一个数据开始往前，每次随机一个位置，将两者的位置进行交换，直到数组交换完毕。


ES6实现：

function shuffle(arr) &#123;
    let i =  arr.length;
    while(i) &#123;
        let j = Math.floor(Math.random() * i--);
        [arr[j], arr[i]] = [arr[i], arr[j]];
    &#125;
    return arr
&#125;

var arr = [1,2,3,4,5,6,7]
shuffle(arr)
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题分享——作用域</title>
    <url>/2019/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num1 &#x3D; 55;</span><br><span class="line">var num2 &#x3D; 66;</span><br><span class="line"></span><br><span class="line">function f1 (num, num1) &#123;</span><br><span class="line">    &#x2F;&#x2F;形参num, num1相当于在函数内进行了一下声明：</span><br><span class="line">    &#x2F;&#x2F;var num</span><br><span class="line">    &#x2F;&#x2F;var num1</span><br><span class="line">    num &#x3D; 100;</span><br><span class="line">    num1 &#x3D; 100;</span><br><span class="line">    num2 &#x3D; 100; &#x2F;&#x2F;相当于在全局内进行了声明</span><br><span class="line">    console.log(num); &#x2F;&#x2F;100</span><br><span class="line">    console.log(num1); &#x2F;&#x2F;100</span><br><span class="line">    console.log(num2); &#x2F;&#x2F;100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(num1, num2);&#x2F;&#x2F;num1 &#x3D; 55; num2 &#x3D; 66;</span><br><span class="line">console.log(num1); &#x2F;&#x2F;55</span><br><span class="line">console.log(num2); &#x2F;&#x2F;100</span><br><span class="line">console.log(num); &#x2F;&#x2F;报错</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">55</span><br><span class="line">100</span><br><span class="line">Uncaught ReferenceError: num is not defined</span><br></pre></td></tr></table></figure>

<h4 id="创建10个标签，点击的时候弹出来对面的下标序号"><a href="#创建10个标签，点击的时候弹出来对面的下标序号" class="headerlink" title="创建10个标签，点击的时候弹出来对面的下标序号"></a>创建10个<a>标签，点击的时候弹出来对面的下标序号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    (function(i)&#123;</span><br><span class="line">        var a &#x3D; document.createElement(&#39;a&#39;)</span><br><span class="line">        a.innerHTML &#x3D; i + &#39;&lt;br&gt;&#39;</span><br><span class="line">        a.addEventListener(&#39;click&#39;, function(e) &#123;</span><br><span class="line">            e.preventDefault()</span><br><span class="line">            alert(i)</span><br><span class="line">        &#125;)</span><br><span class="line">        document.body.appendChild(a)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="闭包实际应用中主要用于封装变量，收敛权限"><a href="#闭包实际应用中主要用于封装变量，收敛权限" class="headerlink" title="闭包实际应用中主要用于封装变量，收敛权限"></a>闭包实际应用中主要用于封装变量，收敛权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isFirstLoad() &#123;</span><br><span class="line">    var _list &#x3D; []</span><br><span class="line">    return function (val) &#123;</span><br><span class="line">        if (_list.indexOf &gt;&#x3D; 0) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _list.push(val)</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">var firstLoad &#x3D; isFirstLoad()</span><br><span class="line">firstLoad(10)   &#x2F;&#x2F;true</span><br><span class="line">firstLoad(10)   &#x2F;&#x2F;false</span><br><span class="line">firstLoad(20)   &#x2F;&#x2F;true</span><br><span class="line">firstLoad(20)   &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>值类型和引用类型的传递</title>
    <url>/2019/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="值类型和引用类型的传递"><a href="#值类型和引用类型的传递" class="headerlink" title="值类型和引用类型的传递"></a>值类型和引用类型的传递</h2><span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age, salary) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.salary &#x3D; salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f1(person) &#123;</span><br><span class="line">    person.name &#x3D; &quot;ls&quot;;</span><br><span class="line">    person &#x3D; new Person(&quot;aa&quot;, 18, 10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new Person(&quot;zs&quot;, 18, 1000);</span><br><span class="line">console.log(p.name); &#x2F;&#x2F;zs</span><br><span class="line">f1(p);</span><br><span class="line">console.log(p.name); &#x2F;&#x2F;ls</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题分享——冒泡排序</title>
    <url>/2019/06/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="JS冒泡排序详解"><a href="#JS冒泡排序详解" class="headerlink" title="JS冒泡排序详解"></a>JS冒泡排序详解</h2><span id="more"></span>
<ul>
<li>说明：<ul>
<li>时间复杂度指的是一个算法执行所消耗的时间。—— O（n*n）</li>
<li>空间复杂度指执行一个程序所需内存的大小。—— O（1）</li>
<li>稳定性，如果a = b,a在b的前面，排序后a仍然在b的前面。——（稳定）</li>
<li>不稳定性，如果a = b,a在b的前面，排序后可能会交换位置。<!--more--></li>
</ul>
</li>
<li>原理：<ul>
<li>依次比较相邻的两个值，如果后面的比前面的小，则将小的元素排到前面。依照这个规则<br>进行多次并且递减的迭代，直到顺序正确。</li>
</ul>
</li>
<li>冒泡排序的写法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sortArr (arr) &#123;</span><br><span class="line">    for (i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        for (j &#x3D; 0; j &lt;arr.length - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                var temp &#x3D; arr[j]</span><br><span class="line">                arr[j] &#x3D; arr[j + 1]</span><br><span class="line">                arr[j + 1] &#x3D; temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [2, 5, 6, 3, 3, 2, 9, 4]</span><br><span class="line">console.log(sortArr(arr))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题分享——反转数组</title>
    <url>/2019/06/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="JS基础：反转数组"><a href="#JS基础：反转数组" class="headerlink" title="JS基础：反转数组"></a>JS基础：反转数组</h2><span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">for (var i &#x3D; 0; i &lt; arr.length &#x2F; 2; i++) &#123;</span><br><span class="line">    var temp &#x3D; arr[i]</span><br><span class="line">    arr[i] &#x3D; arr[arr.length - 1 - i]</span><br><span class="line">    arr[arr.length - 1 - i] &#x3D; temp</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;JS反转函数：reverse()</span><br><span class="line">arr.reverse()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题——封装函数驼峰命名</title>
    <url>/2019/06/22/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<h2 id="封装函数使字符串以驼峰式命名"><a href="#封装函数使字符串以驼峰式命名" class="headerlink" title="封装函数使字符串以驼峰式命名"></a>封装函数使字符串以驼峰式命名</h2><ul>
<li>已知字符串foo = ‘get-element-by-id’,写一个函数将其转换为驼峰式命名“getElementById”<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;详细过程分析：</span><br><span class="line">var foo &#x3D; &#39;get-element-by-id&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据某个字符进行分割</span><br><span class="line">var arr &#x3D; foo.split(&#39;-&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;分割成四个片段保存在数组内</span><br><span class="line">console.log(arr) &#x2F;&#x2F; (4) [&quot;get&quot;, &quot;element&quot;, &quot;by&quot;, &quot;id&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将下标为1的数组元素第一个字符元素转为大写</span><br><span class="line">console.log(arr[1].charAt(0).toUpperCase()) &#x2F;&#x2F;E</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;截取后面字符元素</span><br><span class="line">console.log(arr[1].substr(1, arr[1].length - 1)) &#x2F;&#x2F;lement</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历</span><br><span class="line">for(var i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] &#x3D; arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1)</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr) &#x2F;&#x2F;(4) [&quot;get&quot;, &quot;Element&quot;, &quot;By&quot;, &quot;Id&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据某一个字符将数组转换为字符串</span><br><span class="line">console.log(arr.join(&#39;&#39;));</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;封装</span><br><span class="line">function toString(foo) &#123;</span><br><span class="line">    var arr &#x3D; foo.split(&#39;-&#39;);</span><br><span class="line">    </span><br><span class="line">    for(var i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] &#x3D; arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return arr.join(&#39;&#39;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(toString(&#39;get-element-by-id&#39;))</span><br></pre></td></tr></table></figure>
<p>把the-first-name变成theFirstName</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;-(\w)&#x2F;g</span><br><span class="line">var str &#x3D; &quot;the-first-name&quot;</span><br><span class="line">console.log(str.replace(reg, function($, $1)&#123;</span><br><span class="line">    return $1.toUpperCase()</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>把aabb换成bbaa</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;(\w)\1(\w)\2&#x2F;g;</span><br><span class="line">var str &#x3D; &quot;aabb&quot;;</span><br><span class="line">&#x2F;&#x2F; console.log(str.replace(reg,&quot;$2$2$1$1&quot;));&#x2F;&#x2F;&quot;bbaa&quot;</span><br><span class="line">console.log(str.replace(reg,function($,$1,$2)&#123;</span><br><span class="line">  return $2+$2+$1+$1;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>正则简单的去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;aaaabbbbbccccc&quot;;</span><br><span class="line">var reg &#x3D; &#x2F;(\w)\1*&#x2F;g;</span><br><span class="line">console.log.replace(reg,&quot;$1&quot;));&#x2F;&#x2F;abc</span><br></pre></td></tr></table></figure>
<pre><code>       把&quot;1000000000&quot;变成&quot;100.000.000&quot;这种写法，把后面往前面查，三位加个点
       <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;100000000&quot;;</span><br><span class="line">var reg &#x3D; &#x2F;(?&#x3D;(\B)(\d&#123;3&#125;)+$)&#x2F;g;</span><br><span class="line">console.log(str.replace(reg,&quot;.&quot;))&#x2F;&#x2F;&quot;100.000.000&quot;</span><br><span class="line">||</span><br><span class="line">string.replace(&#x2F;\B(?&#x3D;(\d&#123;3&#125;)+(?!\d))&#x2F;g, &quot;.&quot;) &#x2F;&#x2F;先行断言?&#x3D;,后行断言(?!\d)</span><br><span class="line">||</span><br><span class="line">(25435345.22).toLocaleString(str(&#39;en-US&#39;)</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑转移测试文章</title>
    <url>/2021/03/28/%E5%87%A1%E4%BA%8B%E9%A2%84%E5%88%99%E7%AB%8B%EF%BC%8C%E4%B8%8D%E9%A2%84%E5%88%99%E5%BA%9F/</url>
    <content><![CDATA[<h3 id="凡事预则立，不预则废"><a href="#凡事预则立，不预则废" class="headerlink" title="凡事预则立，不预则废"></a>凡事预则立，不预则废</h3><p>凡事预则立，不预则废</p>
]]></content>
  </entry>
</search>
