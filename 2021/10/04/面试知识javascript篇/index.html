<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>面试知识javascript篇 - foolishmax</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="foolishmax"><meta name="msapplication-TileImage" content="/images/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="foolishmax"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="[toc] 从浏览器地址栏输入 url 到显示页面的步骤"><meta property="og:type" content="blog"><meta property="og:title" content="面试知识javascript篇"><meta property="og:url" content="https://github.com/foolishmax/2021/10/04/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86javascript%E7%AF%87/"><meta property="og:site_name" content="foolishmax"><meta property="og:description" content="[toc] 从浏览器地址栏输入 url 到显示页面的步骤"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70"><meta property="og:image" content="https://github.com/images/md_img/defer_async.jpg"><meta property="og:image" content="https://github.com/images/md_img/sso.jpg"><meta property="og:image" content="https://github.com/images/md_img/koa1.jpg"><meta property="og:image" content="https://github.com/images/md_img/koa2.jpg"><meta property="article:published_time" content="2021-10-04T13:54:55.000Z"><meta property="article:modified_time" content="2023-04-26T07:40:52.115Z"><meta property="article:author" content="foolishmax"><meta property="article:tag" content="面经"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/foolishmax/2021/10/04/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86javascript%E7%AF%87/"},"headline":"面试知识javascript篇","image":["https://github.com/images/md_img/defer_async.jpg","https://github.com/images/md_img/sso.jpg","https://github.com/images/md_img/koa1.jpg","https://github.com/images/md_img/koa2.jpg"],"datePublished":"2021-10-04T13:54:55.000Z","dateModified":"2023-04-26T07:40:52.115Z","author":{"@type":"Person","name":"foolishmax"},"publisher":{"@type":"Organization","name":"foolishmax","logo":{"@type":"ImageObject","url":"https://github.com/images/favicon.svg"}},"description":"[toc] 从浏览器地址栏输入 url 到显示页面的步骤"}</script><link rel="canonical" href="https://github.com/foolishmax/2021/10/04/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86javascript%E7%AF%87/"><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="foolishmax" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/favicon.svg" alt="foolishmax" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">档案</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/foolishmax"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="detail column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-04T13:54:55.000Z" title="10/4/2021, 9:54:55 PM">2021-10-04</time>发表</span><span class="level-item"><time dateTime="2023-04-26T07:40:52.115Z" title="4/26/2023, 3:40:52 PM">2023-04-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span><span class="level-item">1 小时读完 (大约13461个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">面试知识javascript篇</h1><div class="content"><p>[toc]</p>
<h2 id="从浏览器地址栏输入-url-到显示页面的步骤"><a href="#从浏览器地址栏输入-url-到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入 url 到显示页面的步骤"></a>从浏览器地址栏输入 url 到显示页面的步骤</h2><span id="more"></span>

<pre><code>* 先检查搜索关键字是否符合url规则，然后将其组装成完成url进行访问
* 检查缓存，浏览器检查本地强缓存是否可用，如果命中强缓存就直接从缓存中返回资源
  - 根据http header中的expires、cache-control来判断是否命中强缓存
* DNS解析，如果未命中强缓存，则向服务器发起请求，通过递归查询和迭代查询解析域名来获取对应IP地址
  - 浏览器IP缓存
  - 操作系统IP缓存
  - 本地hosts文件
  - 路由器缓存
  - 本地DNS服务器以递归方式进行查询缓存记录
  - 若没有缓存记录就向根DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器，
  本地DNS服务器把对应关系暂存在缓存中（以便下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。
* 客户端发送HTTP请求
* 建立TCP连接，三次握手
* 发起http请求
* 负载均衡：服务端网关收到http请求后，可能会进行一系列负载均衡处理，通过反向代理分配给对应集群中的服务器去执行
* 服务端返回响应：服务端收到请求后，根据请求头中缓存标识（If-Modified-Since/If-None-Match）来判断缓存是否生效，
生效返回304状态码，未命中缓存返回200状态码和标识（Last-Modified/Etag）
* 浏览器接收到http响应后，根据connection: keep-alive判断保持连接或者四次挥手断开TCP连接
* 浏览器缓存响应头中缓存标识字段（Last-Modified/Etag）
* 解析HTML文档，此时document.readystate为loading
* 构建DOM树，浏览器从上到下解析html文档生成DOM节点树
* 构建CSSOM树，浏览器解析遇到样式进行异步下载，构建CSSOM树（不会阻塞DOM树构建，但是会阻塞渲染，防止css规则不断变化）
* 构建渲染树，根据DOM节点树和CSSOM树构建渲染树Render
* 遇到图片异步下载，遇到不带async和defer的script时，阻塞html的解析并下载且执行
* 带async的script标签，不会中断html解析并行下载脚本，下载完成后中断html解析并执行脚本，优先级高于defer,但是无序
* 带defer的script标签，不会中断html解析并行下载脚本，当浏览器解析完html时，DOMContentLoaded事件即将触发时执行脚本
* 文档解析完成，document.readystate变为interactive,触发DOMContentLoaded事件
* 等待图片加载或所有异步脚本加载执行完成，document.readystate变为complete,window触发load事件
* 布局Layout，根据Render树计算每个节点在屏幕上的位置布局
* 绘制Paint，绘制节点到屏幕上，涉及到构建图层树、绘制列表、光栅化（合成线程）和显示等。
</code></pre>
<p>其他：<br>dns-prefetch:<br>前端网络性能优化的一种措施，提前解析之后可能遇到的域名，使解析结果缓存到系统缓存中，缩短 DNS 解析时间，进而提高网站的访问速度</p>
<p>dns-prefetch 原理：<br>浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP(运行商)DNS 缓存-&gt;根域名服务器-&gt;顶级域名服务器-&gt;主域名服务器</p>
<p>dns-prefetch 将解析后的 IP 缓存放在系统缓存中<br>dns-prefetch 与 preconnect 预连接提示配对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com/&quot; crossorigin&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://fonts.gstatic.com/&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>Note：如果页面需要建立与许多第三方域的连接，则将它们预先连接会适得其反。 preconnect 提示最好仅用于最关键的连接。对于其他的，只需使用 <link rel="dns-prefetch"> 即可节省第一步的时间 DNS 查找。</p>
<p>扩展：<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3NDY4NDgyOQ==&mid=2247491757&idx=1&sn=a956c6c62c98e2d5ee71c8ed8d3a3eb8&chksm=cecfa85ff9b82149a3e50e81789b29cc0923745cf8a8f7713619aa2499753a3de760f24e6f93&scene=132#wechat_redirect">收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？</a></p>
<h2 id="你知道哪些前端攻击？该如何预防？"><a href="#你知道哪些前端攻击？该如何预防？" class="headerlink" title="你知道哪些前端攻击？该如何预防？"></a>你知道哪些前端攻击？该如何预防？</h2><ul>
<li><p>xss</p>
<ul>
<li>Cross Site Script 跨站脚本攻击</li>
<li>手段：将 js 代码插入到网页内容中，渲染时执行 js 代码</li>
<li>预防：特殊字符替换（前端或后端）</li>
<li>输入检查，对于用户输入进行格式检查。</li>
</ul>
</li>
<li><p>csrf</p>
<ul>
<li><p>Cross Site Request Forgery 跨站请求伪造</p>
</li>
<li><p>手段：诱导用户去访问另一个网站的接口，伪造请求</p>
</li>
<li><p>预防：严格的跨域限制 + 验证码机制</p>
</li>
<li><p>csrf 详细过程</p>
<ul>
<li>用户登录 A 网站，有了 A 网站的 cookie</li>
<li>诱导用户到 B 网站，并发起 A 网站的请求</li>
<li>A 网站的 API 发现有 cookie，认为是用户自己操作的</li>
</ul>
</li>
<li><p>csrf 预防手段</p>
<ul>
<li>严格的跨域请求限制，如判断 referer（请求来源）</li>
<li>为 cookie 设置 SameSite，禁止跨域传递 cookie<ul>
<li>Chrome 51 开始，浏览器的 Cookie 新增加了一个 SameSite 属性，用来防止 CSRF 攻击 和用户追踪（第三方恶意获取 cookie），限制第三方 Cookie，从而减少安全风险。</li>
</ul>
</li>
<li>关键接口使用短信验证码</li>
<li>token 验证</li>
</ul>
</li>
</ul>
</li>
<li><p>点击劫持</p>
<ul>
<li>click jacing</li>
<li>手段：诱导界面上蒙一个透明 iframe，诱导用户点击</li>
<li>预防：让 iframe 不能跨域加载<ul>
<li>X-FRAME-OPTIONS 响应头是用来给浏览器指示允许一个页面可否在<code>&lt;frame&gt;</code>,<br><code>&lt;iframe&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记。网站可以使用此功能，来确保自己网站<br>内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。</li>
</ul>
</li>
</ul>
</li>
<li><p>DDos</p>
<ul>
<li>Distribute denial-of-service 分布式拒绝服务</li>
<li>手段：分布式的、大规模的流量访问，使服务器瘫痪</li>
<li>预防：软件层不好做，需硬件预防（如阿里云 WAF）</li>
</ul>
</li>
<li><p>SQL 注入</p>
<ul>
<li>手段：提交内容时写入 SQL 语句，破环数据库</li>
<li>预防：处理输入的内容，替换特殊字符</li>
</ul>
</li>
</ul>
<h2 id="性能优化（空间换时间）"><a href="#性能优化（空间换时间）" class="headerlink" title="性能优化（空间换时间）"></a>性能优化（空间换时间）</h2><ul>
<li><p>性能优化原则</p>
<ul>
<li>多使用内存、缓存</li>
<li>减少 CUP 计算，减少网络加载耗时</li>
<li>适用于所有编程的性能优化-空间换时间</li>
</ul>
</li>
<li><p>减少资源体积：压缩代码</p>
</li>
<li><p>减少访问次数：合并代码，SSR 服务器渲染，缓存，精灵图</p>
<ul>
<li>缓存（webpack contenthash）<ul>
<li>静态资源加 hash 后缀，根据文件内容计算 hash</li>
<li>文件内容不变，则 hash 不变则 url 不变</li>
<li>url 和文件不变，则会自动触发 http 的缓存机制，返回 304</li>
</ul>
</li>
<li>SSR<ul>
<li>服务器端渲染：将网页和数据一起加载，一起渲染</li>
<li>非 SSR（前后端分离）：先加载网页，后加载数据，再渲染数据</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS 预解析</p>
</li>
<li><p>减少 cookie 大小，http 请求会携带 cookie</p>
</li>
<li><p>使用 http2 头部压缩</p>
</li>
<li><p>避免重定向：当页面发生了重定向，就会延迟整个 HTML 文档的传输。在 HTML 文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。</p>
</li>
<li><p>渲染优化</p>
<ul>
<li>css 放在 head，js 放在 body 最下面</li>
<li>尽早开始执行 js，用 DOMContentLoaded 触发</li>
<li>懒加载（图片懒加载-IntersectionObserver，下滑更多等）</li>
<li>对 DOM 查询进行缓存</li>
<li>减少 DOM 数量，大数据量分页、虚拟列表</li>
<li>合并频繁的 DOM 操作,document.createDocumentFragment()，减少 dom 操作次数</li>
<li>节流 throttle、防抖 debounce</li>
<li>使用 loading 图，提高用户视觉体验</li>
<li>使用 GPU 加速：使用 transform、opacity，要慎用低端机 GPU 差，占用较多内存，因此是否开启硬件加速，要用测试结果决定</li>
<li>使用 requestAnimationFrame 来实现视觉变化</li>
</ul>
</li>
<li><p>三方资源</p>
<ul>
<li>第三方资源、库使用 CDN</li>
<li>压缩图片体积，减少图片大小</li>
<li>图片使用 webp 格式，减少图片体积</li>
<li>preload 预先加载 css 文件或者字体文件、js 文件等<ul>
<li>浏览器需要先把 html 页面加载回来，才能知道下一步去加载那些 js、css 或字体文件，中间时间就被浪费掉了</li>
<li>可以在等待 html 响应的同时把重要的静态资源文件也加载回来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="你对闭包了解多少？"><a href="#你对闭包了解多少？" class="headerlink" title="你对闭包了解多少？"></a>你对闭包了解多少？</h2><pre><code>解释一下作用域链是如何产生的
解释一下js执行山下文的创建、执行过程
解释一下闭包所产生的变量放在哪里
</code></pre>
<ul>
<li>闭包的定义：闭包就是能够读取其他函数内部变量的函数。</li>
<li>闭包的底层实现原理</li>
<li>js 执行上下文：</li>
<li><img src="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70" alt="image"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">js运行三部曲</span><br><span class="line">1.语法分析</span><br><span class="line">2.预编译</span><br><span class="line">3.解释执行</span><br><span class="line"></span><br><span class="line">js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。</span><br><span class="line">预编译的环境需要个环境，这个环境就是执行上下文。</span><br><span class="line"></span><br><span class="line">js执行上下文分为三种：</span><br><span class="line">1.全局执行上下文：代码开始执行时首先进入的环境</span><br><span class="line">2.函数执行上下文：函数调用时，会开始执行函数中的代码</span><br><span class="line">3.eval执行上下文：不建议使用</span><br><span class="line"></span><br><span class="line">执行上下文的周期，分为两个阶段</span><br><span class="line">1.创建阶段</span><br><span class="line">    创建词法环境</span><br><span class="line">    生成变量对象VO，建立作用域链</span><br><span class="line">    确认this指向，并绑定this</span><br><span class="line">2.执行阶段</span><br><span class="line">    进行变量赋值，函数引用以及执行代码</span><br><span class="line"></span><br><span class="line">预编译发生在函数执行前，预编译四部曲：</span><br><span class="line">1.创建AO对象</span><br><span class="line">2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined</span><br><span class="line">3.将形参和实参相统一</span><br><span class="line">4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）</span><br><span class="line">5.最后程序输出变量值的时候，就是从AO对象中拿</span><br><span class="line">（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，</span><br><span class="line">就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包）</span><br></pre></td></tr></table></figure>

<h2 id="js-的执行机制"><a href="#js-的执行机制" class="headerlink" title="js 的执行机制"></a>js 的执行机制</h2><p>js 是单线程的，处理 js 任务只能一个一个顺序执行，js 中把任务分为了同步任务和异步任务，<br>同步任务进入主线程先执行，异步任务进入 Event Table 并注册函数，指定事情完成后，Event Table 就会将函数移入到事件队列 Event Queque 中，等待主线程任务执行完毕，就会从事件队列中取出对应事件进入主线程执行。</p>
<p>macro-task（宏任务）：包括整体代码 script、setTimeout、setInterval、IO 操作、UI 交互、postMessage 等<br>micro-task（微任务）：Promise.then、process.nextTick、MutationObserve 等<br>微任务先于宏任务先执行（除了 script）执行过程不同任务进入不同的 event queue</p>
<p>js 先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，遇到宏任务放到宏任务事件队列中。</p>
<p>然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，<br>等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，<br>执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，<br>就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，<br>以此类推。</p>
<h2 id="简单说下原型链"><a href="#简单说下原型链" class="headerlink" title="简单说下原型链"></a>简单说下原型链</h2><ul>
<li><p>原型链是由原型对象组成的，每个对象都有<strong>proto</strong>属性，指向了创建该对象的构造函数的<br>原型，<strong>proto</strong>将对象连接起来组成了原型链。</p>
</li>
<li><p>原型链：用来实现继承和共享属性的有限对象链。</p>
</li>
<li><p>每个对象都有<strong>proto</strong>（隐式原型）属性，指向创建该对象的构造函数的原型。其实<br>这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能<br>访问到，所以使用 <em>proto</em> 来访问。</p>
</li>
<li><p>对象的隐式原型等于对象的构造函数的显式原型：obj.<strong>proto</strong> === Object.prototype</p>
</li>
<li><p>访问属性的时候，js 引擎会调用内部的默认[[Get]]操作，[[Get]]操作首先会检查对象本身是否包含这个属性<br>如果对象没有这个属性，则对象可以通过<strong>proto</strong>来寻找不属于该对象的属性，<strong>proto</strong><br>将对象和原型连接起来形成原型链</p>
</li>
<li><p>Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎创建。</p>
</li>
</ul>
<h2 id="defer-和-async-有什么区别？"><a href="#defer-和-async-有什么区别？" class="headerlink" title="defer 和 async 有什么区别？"></a>defer 和 async 有什么区别？</h2><ul>
<li>区别 <img src="/images/md_img/defer_async.jpg" alt="区别"></li>
</ul>
<h2 id="如何监听未处理的异常"><a href="#如何监听未处理的异常" class="headerlink" title="如何监听未处理的异常"></a>如何监听未处理的异常</h2><ul>
<li>try…catch<ul>
<li>无法捕捉到语法错误，只能捕捉运行时错误</li>
<li>可以拿到出错的信息(出错的文件，行号，列号)</li>
</ul>
</li>
<li>window.onerror<ul>
<li>由于 try…catch 只能捕获块里面的错误，全局的一些错误可以用 window.onerror</li>
</ul>
</li>
<li>window.addEventListener(‘error’,callback):捕获资源错误</li>
<li>window.addEventListener(‘unhandledrejection’,callback):捕获 promise 类型错误</li>
<li>vue.config.errorHandler: vue 错误</li>
<li>componentDidCatch：错误边界函数</li>
</ul>
<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><ul>
<li><p>客户端的本地存储：</p>
<ul>
<li>localStorage - 生命周期永久生效，除非手动删除，否则关闭页面也会存在 - 可以在同一浏览器多窗口共享 - 以键值对的形式存储使用</li>
<li>方法：</li>
</ul>
<ul>
<li>存储数据：localStorage.setItem(key, value)</li>
<li>获取数据：localStorage.getItem(key)</li>
<li>删除数据：localStorage.removeItem(key)</li>
<li>删除所有数据：localStorage.clear()</li>
</ul>
<ul>
<li><p>sessionStorage</p>
<ul>
<li><p>声明周期为关闭浏览器窗口</p>
</li>
<li><p>在同一个窗口中数据可以共享</p>
</li>
<li><p>以键值对的形式存储</p>
</li>
<li><p>方法：</p>
<ul>
<li>存储数据：sessionStorage.setItem(key, value)</li>
<li>获取数据：sessionStorage.getItem(key)</li>
<li>删除数据：sessionStorage.removeItem(key)</li>
<li>删除所有数据：sessionStorage.clear()</li>
</ul>
<p><a target="_blank" rel="noopener" href='https://www.cnblogs.com/pengc/p/8714475.html'>localStorage 和 sessionStorage</a></p>
<p><a target="_blank" rel="noopener" href='https://www.cnblogs.com/8023-CHD/p/11067141.html'>cookie 和 session</a></p>
</li>
</ul>
</li>
<li><p>IndexDB 离线存储，当网络断开，可以从浏览器中读取数据，用来做一些离线应用</p>
</li>
<li><p>Cookie</p>
<ul>
<li>包含字段<ul>
<li>name: cookie 名称</li>
<li>value: 值</li>
<li>domain: cookie 生效的域名</li>
<li>path: cookie 生效的路径</li>
<li>expires/max-age: cookie 过期时间</li>
<li>size: 大小</li>
<li>HttpOnly: 用户端不可更改</li>
</ul>
</li>
<li>存储用户信息，通过在客户端记录信息确定用户身份，最大为 4kb</li>
<li>会话 Cookie，若不设置过期时间，表示这个 cookie 的生命周期为浏览器会话期间，浏览器<br>关闭，cookie 就消失，会话 cookie 会保存在内存中而不是硬盘上。</li>
<li>持久 Cookie，若设置了过期时间，浏览器会把 cookie 保存在硬盘上，关闭浏览器仍然有效直到<br>超过设定的过期时间。</li>
<li>cookie 数据始终在同源的 http 请求中携带(即使不需要)，即会在浏览器和服务器之间来回传递。</li>
<li>Cookie 具有不可跨域名性，例如浏览器访问百度不会带上谷歌的 cookie</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>监测是否支持 web Storage<ul>
<li>1.通过 window.sessionStorage,window.localStorage 判断浏览器是否支持</li>
<li>2.通过 try{}catch{} 执行一下 storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。</li>
</ul>
</li>
</ul>
<ul>
<li>服务端的存储：<ul>
<li>Session<ul>
<li>Session 服务器端一种记录客户端状态的机制</li>
<li>cookie 数据存放在客户的浏览器上，session 将数据存放在服务器端</li>
<li>Session 相对 Cookie 来说比较安全，别人可以分析本地存放的 cookie 进行 cookie 欺骗</li>
<li>Session 会在一定时间内保存在服务器上，访问量较多的时候会比较占用服务器的性能，<br>考虑到减轻服务器性能方面的时候，应当使用 cookie</li>
<li>可以将登陆等重要信息保存在 session，其他信息放在 cookie 中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="localStorage-超过最大限制（5M）怎么处理？"><a href="#localStorage-超过最大限制（5M）怎么处理？" class="headerlink" title="localStorage 超过最大限制（5M）怎么处理？"></a>localStorage 超过最大限制（5M）怎么处理？</h2><ul>
<li><p>localstorage 一般最大容量为 5M，意思是每个域名（假如为 a.com）下最大 localstorage 容量为 5M，我们可以通过 iframe 创建 b.com 域框架用于存储 a.com 剩下的数据，然后通过 postMessage 读写数据。</p>
<ul>
<li>通常对于不同页面的脚本，只有在同源策略下才能通信，但是 window.postMessage(message,targetOrigin)方法提供了一种受控机制来规避此限制。</li>
<li>而且 localStorage 本身定位也不是大数据量的存储方案</li>
</ul>
</li>
<li><p>浏览器提供了大数据量的本地存储的方案：IndexedDB</p>
<ul>
<li>一般存储数据大小在 250M 以上</li>
<li>可以使用 localforage 插件（yarn add localforage），api 基本和 localStorage 类似，学习成本低</li>
</ul>
</li>
</ul>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul>
<li>cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据 cookie 追踪用户在不同页面的访问信息。</li>
<li>cookie 特点<ul>
<li>1.大小限制，cookie 大小限制在 4KB 以内</li>
<li>2.宽带限制，cookie 数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。</li>
<li>3.安全风险，cookie 会频繁的在网络中传送，不加密的情况下是有安全风险的。</li>
<li>4.操作复杂<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name: string, value: string) &#123;</span><br><span class="line">    const exp = new Date();</span><br><span class="line">    //过期时间设置为一天</span><br><span class="line">    exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000);</span><br><span class="line">    document.cookie = `$&#123;name&#125;=$&#123;escape(value);expires=$&#123;exp.toString()&#125;&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="fetch-和-axios"><a href="#fetch-和-axios" class="headerlink" title="fetch 和 axios"></a>fetch 和 axios</h2><pre><code>fetch取消发送
1.创建一个AbortController实例
2.该实例具有signal属性
3.将signal传递给fetch option
4.调用AbortController的abort属性来取消所有使用该信号的fetch

axios取消发送
1.const cancelToken = axios.CancelToken
2.const source = CancelToken.source()
3.axios.get(&#39;/xxx&#39;,&#123;cancelToken: source.token&#125;)
</code></pre>
<h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><ul>
<li>箭头函数中的 this 是在定义函数的时候绑定的（继承自父执行上下文中的 this），而不是执行函数时绑定。</li>
<li>箭头函数没有 this，所以不能用作构造函数。</li>
</ul>
<h2 id="Map-和-Set-两种新的数据结构的区别？"><a href="#Map-和-Set-两种新的数据结构的区别？" class="headerlink" title="Map 和 Set 两种新的数据结构的区别？"></a>Map 和 Set 两种新的数据结构的区别？</h2><ul>
<li><p>Map 类似 Object 是一种键值对集合，区别在于 Map 的键不仅限于字符串，其他各种类型的值都可以作为 Map 的键</p>
</li>
<li><p>Set 是类似数组的一种数据结构，不同点在于 Set 中没有重复的值</p>
</li>
</ul>
<h2 id="js-的-new-操作符都做了些什么？"><a href="#js-的-new-操作符都做了些什么？" class="headerlink" title="js 的 new 操作符都做了些什么？"></a>js 的 new 操作符都做了些什么？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个空的js对象&#123;&#125;</span><br><span class="line">2. 将空对象的隐式原型__proto__指向构造函数的原型</span><br><span class="line">3. 将空对象作为构造函数的上下文（改变this指向）</span><br><span class="line">4. 对构造函数返回值做判断</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line">function newFn(fn, ...args) &#123;</span><br><span class="line">  const obj = Object.create(fn.prototype);</span><br><span class="line">  const result = fn.apply(obj, args);</span><br><span class="line">  return typeof result === &#x27;object&#x27; &amp;&amp; result !== null ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = newFn(Person, &#x27;Jerome&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;p.name :&gt;&gt; &#x27;, p.name); // p.name :&gt;&gt;  Jerome</span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">在new的时候，会对构造函数的返回值做一些判断</span><br><span class="line">1. 如果返回值是基础类型数据，则忽略返回值</span><br><span class="line">2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效</span><br></pre></td></tr></table></figure>

<h2 id="es6-新特性"><a href="#es6-新特性" class="headerlink" title="es6 新特性"></a>es6 新特性</h2><pre><code>1.let和const
2.模版字符串
3.箭头函数
4.函数可以设置默认参数值
5.扩展运算符
6.对象和数组的解构
7.class
</code></pre>
<h2 id="图片懒加载原理"><a href="#图片懒加载原理" class="headerlink" title="图片懒加载原理"></a>图片懒加载原理</h2><ul>
<li>浏览器是否发起请求是根据<img />标签的 src 属性</li>
<li>所以懒加载的关键是：在图片没有进入可视区域时，先不给<img />的 src 属性赋值，等到图片进入可是区域再给 data-src -&gt; src 赋值。</li>
<li>// 方法一：offsetTop - scrollTop &lt;= 视口高度</li>
<li>// 方法二：getBoundingClientRect().top &lt;= 视口高度 screenHeight</li>
<li>// 方法三：IntersectionObserver</li>
</ul>
<h2 id="为什么-try-catch-不能捕获到-promise-的错误？"><a href="#为什么-try-catch-不能捕获到-promise-的错误？" class="headerlink" title="为什么 try/catch 不能捕获到 promise 的错误？"></a>为什么 try/catch 不能捕获到 promise 的错误？</h2><ul>
<li><p>try-catch 主要用于捕获同步函数的异常，如果 try 里面的异步方法出现了异常，此时 catch 是无法捕获到异常的。ES6 中 Promise 对象的实例提供了 catch() 方法，表示异步捕获异常。</p>
</li>
<li><p>原因：当异步函数抛出异常时，对于宏任务而言，执行函数时已经将该函数推入栈，此时并不在 try-catch 所在的栈，所以 try-catch 并不能捕获到错误。对于微任务而言，比如 promise，promise 的构造函数的异常只能被自带的 reject 也就是.catch 函数捕获到。</p>
</li>
</ul>
<h2 id="requestIdleCallback-和-requestAnimationFrame-有什么区别？"><a href="#requestIdleCallback-和-requestAnimationFrame-有什么区别？" class="headerlink" title="requestIdleCallback 和 requestAnimationFrame 有什么区别？"></a>requestIdleCallback 和 requestAnimationFrame 有什么区别？</h2><pre><code>requestIdleCallback(callback, timeout):
· 低优先级
· 兼容性不好
· 执行时机：浏览器空闲时被调用
· 指定timeout，回调任务就会被放进事件循环队列，强制执行，但是会影响性能

requestAnimationFrame(callback):
· 高优先级
· 执行时机：下次重绘前执行传入的回调函数

- 补充
  - 两者都是宏任务(其实也算不上，重要的是执行时机)
</code></pre>
<h2 id="如何阻止冒泡"><a href="#如何阻止冒泡" class="headerlink" title="如何阻止冒泡?"></a>如何阻止冒泡?</h2><pre><code>W3C的方法e.stopPropagation(),IE使用e.cancelBubble = true;

封装：
    //阻止冒泡行为
    function stopBubble(e) &#123;
        //如果提供了事件对象，则这是一个非IE浏览器
        if (e &amp;&amp; e.stopPropagation) e.stopPropagation()
        //IE的方法
        else window.event.cancelBubble = true
    &#125;
</code></pre>
<h2 id="如何阻止默认事件？"><a href="#如何阻止默认事件？" class="headerlink" title="如何阻止默认事件？"></a>如何阻止默认事件？</h2><pre><code>W3C的方法是e.preventDefault(),IE使用e.returnValue = false

封装：
    //阻止浏览器的默认行为
    function stopDefault (e) &#123;
        if (e &amp;&amp; e.preventDefault) e.preventDefault()
        //IE中阻止默认事件的方法
        else window.event.returnValue = false
        return false
    &#125;
</code></pre>
<h2 id="补充：事件绑定的封装"><a href="#补充：事件绑定的封装" class="headerlink" title="补充：事件绑定的封装"></a>补充：事件绑定的封装</h2><pre><code>function addEvent(element,type,handle) &#123;
    if(element.addEventListener)&#123;
        element.addEventListener(type,handle,false);
    &#125;else if(element.attachEvent)&#123;
        element.attachEvent(&#39;on&#39;+type,function () &#123;
            handle.call(element);
        &#125;)
    &#125;else &#123;
        element[&#39;on&#39;+type] = handle;
    &#125;
&#125;
</code></pre>
<h2 id="如何判断一个对象是否为数组"><a href="#如何判断一个对象是否为数组" class="headerlink" title="如何判断一个对象是否为数组"></a>如何判断一个对象是否为数组</h2><pre><code>1. Array.prototype.isPrototypeOf(obj)方法，判断Array.prototype是不是在obj的原型链中，
如果在，则返回true，否则返回false。

2. obj instanceof Array

3. Object.prototype.toString.call(obj); //(===&quot;[object Array]&quot;)

4.Array.isArray(obj)
</code></pre>
<h2 id="Http-的持久连接和管线化"><a href="#Http-的持久连接和管线化" class="headerlink" title="Http 的持久连接和管线化"></a>Http 的持久连接和管线化</h2><pre><code>1. 什么是持久连接？
    HTTP1.1规定了默认保持持久连接，数据传输完成也保持TCP连接不断开，等待同域名下
    继续使用这个通道传输数据,在一个TCP连接上传输多个HTTP请求和响应。

    持久连接避免了重新建立连接，大大减少了建立和关闭连接的消耗和延迟，HTTP的连接是建立
    在TCP协议之上的，建立一条TCP连接需要三次握手，TCP连接关闭需要四次挥手，这些都需要时间。

2. 什么是管线化？
    持久连接：
        请求1 ——&gt; 响应1 ——&gt; 请求2 ——&gt; 响应2
    管线化：
        请求1 ——&gt; 请求2 ——&gt; 响应1 ——&gt; 响应2

    管线化机制需要通过持久化连接完成。

    持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后，
    才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。
    实现并行发送请求。

    只有GET和HEAD请求可以进行管线化，而POST有所限制。

    初次建立连接不应启动管线机制，因为对方服务器不一定支持HTTP1.1版本的协议。
</code></pre>
<h2 id="为什么利用多个域名来存储网站资源会更有效？"><a href="#为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="为什么利用多个域名来存储网站资源会更有效？"></a>为什么利用多个域名来存储网站资源会更有效？</h2><pre><code>1.CDN 是构建在网络之上的内容分发网络，可以使用户就近获取资源，减低网络拥塞，提高用户
访问的响应效率以及命中率。

2.突破浏览器的并发限制，同一时间针对同一域名下的请求有一定的数量限制，超过限定数目
的请求会被阻塞。

3.节约cookie带宽

4.减少主域名的连接数，优化页面响应速度

5.防止不必要的安全问题
</code></pre>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><pre><code>基本数据类型：Null、Undefined、String、Boolean、Number
ES6：Symbol
ES10：Bigint（可以突破安全整数限制，安全的存储和操作最大整数之外的整数，不会损失精度）
</code></pre>
<h2 id="牛客学习"><a href="#牛客学习" class="headerlink" title="牛客学习"></a>牛客学习</h2><ul>
<li><p>超链接</p>
<ul>
<li>a 标签的 href 的属性值是 url，里面必须包含协议，没有协议就会解析成相对路径。</li>
</ul>
</li>
<li><p>HTTP 状态码分类：</p>
<ul>
<li>1** 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2** 成功，操作被成功接受并处理。<ul>
<li>200 服务端成功处理了请求并返回内容</li>
</ul>
</li>
<li>3** 重定向，需要进一步的操作以完成请求<ul>
<li>301 永久重定向</li>
<li>302 临时重定向</li>
<li>304 资源未被修改，返回一个 304 状态吗然后从本地缓存中加载请求的资源</li>
</ul>
</li>
<li>4** 客户端错误，请求包含语法错误或无法完成请求。<ul>
<li>404 （页面丢失）未找到资源</li>
<li>403 服务器拒绝请求</li>
<li>408 （请求超时） 服务器等候请求时发生超时</li>
</ul>
</li>
<li>5** 服务器错误，服务器在处理请求的过程中发生错误<ul>
<li>503 服务器暂时不可用</li>
<li>504 服务器内部错误</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP 协议的特征：</p>
<ul>
<li>C/S(客户端/服务器)模式：只要客户端和服务器知道如何处理数据内容，任何类型的数据<br>都可以通过 HTTP 来发送，客户端和服务器指定合适的 MIME-type 内容类型。</li>
<li>简单快速</li>
<li>灵活</li>
<li>无连接：限制每次连接只处理一个请求，收到客户的应答后即断开连接，可以节省传输时间。</li>
<li>无状态：对于事物处理没有记忆能力，意味着如果后续处理需要前面的信息，则必须重传，<br>这样就会导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就会很快。</li>
</ul>
</li>
<li><p>get 和 post 的请求区别？</p>
<ul>
<li>区别一：<ul>
<li>get 重点是从服务器上获取资源</li>
<li>post 重点是向服务器发送数据</li>
</ul>
</li>
<li>区别二：<ul>
<li>get 传输数据通过 url 请求，以 field（字段）=value 的形式放在 url 后，用“？”连接，<br>多个请求数据间用“&amp;”连接，过程用户可见。</li>
<li>post 传输数据放在请求体（request body）中发送给服务器，用户不可见。</li>
</ul>
</li>
<li>区别三：<ul>
<li>get 传输数据大小有限制，但效率较高</li>
<li>post 可以传输大量数据，所以上传文件用 post 方式</li>
</ul>
</li>
<li>区别四：<ul>
<li>get 请求不安全，因为参数直接暴露在 url 上，不能用来传递敏感信息。</li>
<li>post 较 get 安全性较高。</li>
</ul>
</li>
<li>区别五：<ul>
<li>get 方式只能支持 ASCII 字符，向服务传的中文字符可能会乱码。</li>
<li>post 支持标准字符集，可以正确传递中文字符。</li>
</ul>
</li>
<li>区别六：<ul>
<li>get 在浏览器回退是无害的，而 post 会再次提交请求。</li>
</ul>
</li>
<li>区别七<ul>
<li>get 请求会被浏览器主动 cache（缓存），而 post 不会除非手动设置。</li>
</ul>
</li>
</ul>
</li>
<li><p>iframe 有哪些缺点？</p>
<ul>
<li><p>iframe 会阻塞主页面的 onload 事件</p>
</li>
<li><p>通过 oIframe.contentWindow 寻找子 window 对象</p>
</li>
<li><p>通过 window.parent 寻找父级窗体</p>
</li>
<li><p>通过 window.top 寻找顶级窗体</p>
</li>
<li><p>window.location.hash 解决父页面向子页面传值</p>
</li>
<li><p>window.name 解决子页面向父页面传值</p>
</li>
<li><p>不利于 SEO，搜索引擎的检索程序无法解读这种页面（百度 spider 不收录，浏览器对 iframe 框架的兼容问题）</p>
</li>
<li><p>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</p>
</li>
<li><p>如果需要使用 iframe，最好通过 javascript 动态给 iframe 添加 src 属性值。</p>
</li>
</ul>
</li>
<li><p>xhtml 和 html 有什么区别？</p>
<ul>
<li><p>性能方面</p>
<ul>
<li>XHTML 兼容性好，兼容各大浏览器、手机以及 PDA，使浏览器可以快速正确编译网页</li>
</ul>
</li>
<li><p>书写习惯方面</p>
<ul>
<li><p>HTML 标签不区分大小写，XHTML 所有标签必须小写</p>
</li>
<li><p>XHTML 必须成双成对</p>
</li>
<li><p>HTML 对标签顺序要求不严格，XHTML 标签顺序必须正确</p>
</li>
<li><p>等等</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>html 和 xml 的区别？</p>
<ul>
<li><p>xml 被设计用来传输和存储数据，其焦点是数据的内容</p>
</li>
<li><p>html 被设计用来显示数据，其焦点是数据的外观</p>
</li>
<li><p>html 旨在显示信息，而 xml 旨在传输信息</p>
</li>
<li><p>xml 在定义标记时区分大小写，而 html 不区分大小写</p>
</li>
</ul>
</li>
<li><p>link 和@import 的区别：<br><strong>两者都是外部引用 CSS 的方式，但有一定的区别</strong></p>
<pre><code>+ link是XHTML标签，除了加载CSS外，还可以加载其他文件；@import只能加载CSS。

+ 解析到link时，页面会同步加载Css；@import在页面加载完后加载Css。

+ link是XHTML标签，无兼容问题；@import是在**CSS2.1**之后提出的，只有再IE5以上才能识别。

+ link可以js动态引入，@import不行

+ @import的最佳写法： @import url(style.css),其他写法：@import &#39;style.css&#39;、
@import &quot;style.css&quot;、@import url(&#39;style.css&#39;)、@import url(&quot;style.css&quot;)
</code></pre>
</li>
<li><p>viewport</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>// width 设置 viewport 宽度，为一个正整数，或字符串‘device-width’<br>// device-width 设备宽度<br>// height 设置 viewport 高度，一般设置了宽度，会自动解析出高度，可以不用设置<br>// initial-scale 默认缩放比例（初始缩放比例），为一个数字，可以带小数<br>// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数<br>// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数<br>// user-scalable 是否允许手动缩放</p>
<ul>
<li><p>单行文本溢出省略号</p>
<p>overflow: hidden;</p>
<p>text-overflow:ellipsis;</p>
<p>white-space: nowrap;</p>
</li>
<li><p>多行文本溢出省略号</p>
<p>display: -webkit-box;</p>
<p>-webkit-box-orient: vertical;</p>
<p>-webkit-line-clamp: 3;</p>
<p>overflow: hidden;</p>
</li>
<li><p>换行标签</p>
<p>word-wrap: break-word</p>
</li>
</ul>
<h2 id="浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？"><a href="#浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？" class="headerlink" title="浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？"></a>浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？</h2><ul>
<li><p>在线的情况下：浏览器发现 html 头部有 manifest 属性，会请求 manifest 文件，如果是<br>第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并进行离线缓存。如果<br>已经离线存储了，浏览器会使用离线的资源加载页面，然后浏览器会比对新的 manifest 文件<br>与旧的 manifest 文件，如果文件没有发生改变，就不要做任何操作，如果文件改变，就会重新<br>下载文件中的资源并进行离线存储。</p>
</li>
<li><p>离线的情况下：浏览器就直接使用离线存储的资源。</p>
</li>
</ul>
<h2 id="如何清除-token"><a href="#如何清除-token" class="headerlink" title="如何清除 token"></a>如何清除 token</h2><ul>
<li><p>浏览器关闭会出发 <strong>beforeunload</strong> ，<strong>unload</strong> 这两个事件。</p>
</li>
<li><p>浏览器刷新也会触发，还会触发<strong>load</strong>事件</p>
</li>
<li><p>方案一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onbeforeunload = function () &#123;</span><br><span class="line">    localStorage.removeItem(&quot;token&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点： 刷新也会清空 token</p>
</li>
<li><p>方案二</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.onunload = function() &#123;</span><br><span class="line">    localStorage.setItem(&quot;lastTime&quot;,new Date().getTime())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">    let lastTime = localStorage.getItem(&quot;lastTime&quot;);</span><br><span class="line">    const interval = 3 * 1000;</span><br><span class="line">    // 如果时间间隔大于3s，则清除token</span><br><span class="line">    if (!lastTime || new Date().getTime() - lastTime &gt; interval) &#123;</span><br><span class="line">        localStorage.remove(&quot;token&quot;);</span><br><span class="line">        console.log(&quot;remove token&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;time is less than not remove token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>补充<br>可以使用 sessionStorage 代替 localStorage 来存储 token，当关闭浏览器时会自动清除 token，sessionStorage 不是持久化的本地存储，而是会话级别的存储，而 localStorage 是持久化的本地存储，除非主动删除数据，否则数据是不会过期的。</p>
</li>
</ul>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举个例子：</span></span><br><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;^13.4.6&quot;</span>, <span class="comment">// 只锁定主版本号 major</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;~13.4.6&quot;</span>, <span class="comment">// 锁定主版本号和次版本号 major + minor</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;13.4.6&quot;</span>,  <span class="comment">// 锁定版本</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;*&quot;</span>,       <span class="comment">// 最新版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// major: 13, minor: 4, patch: 6</span></span><br><span class="line"></span><br><span class="line">$ npm info jquery <span class="comment">// 查看 jquery 信息</span></span><br><span class="line">$ npm view jquery versions <span class="comment">// 查看 jquery 所有版本</span></span><br><span class="line">$ npm list | grep gulp <span class="comment">// 过滤 gulp</span></span><br><span class="line">$ npm outdated <span class="comment">// 查看过期版本</span></span><br><span class="line">$ npm update <span class="comment">//更新版本</span></span><br><span class="line">$ npm cache clean --force <span class="comment">// 清楚缓存</span></span><br><span class="line">$ npm ls <span class="comment">// 查看项目引用了哪些包</span></span><br><span class="line">$ npm unpublish --force <span class="comment">// 从npm卸载包</span></span><br><span class="line"><span class="comment">// 执行顺序</span></span><br><span class="line">$ npm run script1 &amp; npm run script2 <span class="comment">//并行执行</span></span><br><span class="line">$ npm run script1 &amp;&amp; npm run script2 <span class="comment">// 继发执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cross-env: 运行跨平台设置和使用环境变量的脚本</span></span><br><span class="line"><span class="comment">// cross-env可以设置NODE_ENV环境变量，process.env.NODE_ENV === &#x27;production&#x27;</span></span><br><span class="line">$ npm install --save-dev cross-env</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;scripts&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">$ npm config get registry <span class="comment">// 查看当前源</span></span><br><span class="line">$ npm config set registry <span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org //切换镜像源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// npx</span></span><br><span class="line"><span class="comment">// --no-install: 让npx强制使用本地模块，不下载远程模块，如果本地不存在，就会报错</span></span><br><span class="line">$ npx --no-install http-server</span><br><span class="line"><span class="comment">// --ignore-existing: 忽略本地的同名模块，强制安装远程模块</span></span><br><span class="line">$ npx --ignore-existing http-server</span><br></pre></td></tr></table></figure>

<h2 id="URI-和-URL-有什么区别？"><a href="#URI-和-URL-有什么区别？" class="headerlink" title="URI 和 URL 有什么区别？"></a>URI 和 URL 有什么区别？</h2><ul>
<li><p>URL(Uniform Resource Identifier): 统一资源定位符</p>
<ul>
<li>如：<a target="_blank" rel="noopener" href="https://upos-sz-staticks3.bilivideo.com/cmaskboss/164203142_30_1.jpg">https://upos-sz-staticks3.bilivideo.com/cmaskboss/164203142_30_1.jpg</a></li>
</ul>
</li>
<li><p>URI(Uniform Resource Locator): 统一资源标识符</p>
<ul>
<li>如：164203142_30_1.jpg</li>
</ul>
</li>
<li><p>URN(Uniform Resource Name): 统一资源名称</p>
<ul>
<li>如：urn:isbn:9787115318893 (国际标准图书编号)，类似身份证</li>
</ul>
</li>
<li><p>URL 是 URI 的子集</p>
</li>
</ul>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><pre><code>Date.now()  //获取当前时间毫秒数
var dt = new Date() //构造一个实例对象
dt.getTime()    //获取毫秒数
dt.getFullYear() //年
dt.getMonth()   //月（0-11）
dt.getDate()    //日 （0-31）
dt.getHours()   //小时（0-23）
dt.getMinutes() //分钟（0-59）
dt.getSeconds() //秒（0-59）
dt.getDay()     //星期几（0-6）
</code></pre>
<h2 id="浏览器如何缓存"><a href="#浏览器如何缓存" class="headerlink" title="浏览器如何缓存"></a>浏览器如何缓存</h2><ul>
<li>html meta 标签控制缓存<ul>
<li><code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cahce&quot;&gt;</code> //告诉浏览器当前页面不被缓存</li>
</ul>
</li>
<li>http 头信息控制缓存<ul>
<li>Expires ——&gt; 过期时间</li>
<li>Cache-Control 响应头信息(no-cache、no-store、max-age、public)</li>
</ul>
</li>
</ul>
<h2 id="Chrome-打开一个页面需要启动多少线程？分别有哪些线程？"><a href="#Chrome-打开一个页面需要启动多少线程？分别有哪些线程？" class="headerlink" title="Chrome 打开一个页面需要启动多少线程？分别有哪些线程？"></a>Chrome 打开一个页面需要启动多少线程？分别有哪些线程？</h2><pre><code>最新Chrome浏览器包括：一个浏览器(Browser)主进程、一个GPU进程、一个网络(NetWork)
进程、多个渲染进程和多个插件进程
</code></pre>
<ul>
<li><p>进程：</p>
<ul>
<li><p>浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。</p>
</li>
<li><p>渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，<br>排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个<br>Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
</li>
<li><p>GPU 进程：Chrome 刚开始的时候是没有 GPU 进程的，而 GPU 使用的使用初衷是为了实现<br>3D CSS 效果，之后随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 称为<br>浏览器普遍的需求，最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
</li>
<li><p>网络进程：主要负责网页的网络资源加载，之前是作为一个模块运行在浏览器进程里面<br>的，最近才独立出来，称为一个单独的进程。</p>
</li>
<li><p>插件进程：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以<br>保证插件进程崩溃不会对浏览器和页面造成影响。</p>
</li>
</ul>
</li>
<li><p>线程：</p>
<ul>
<li>js 线程</li>
<li>UI 渲染线程</li>
<li>事件线程</li>
<li>定时器触发线程</li>
<li>http 请求线程</li>
<li>插件线程</li>
</ul>
</li>
</ul>
<h2 id="js-请说说写一个拖拽组件的思路及注意事项"><a href="#js-请说说写一个拖拽组件的思路及注意事项" class="headerlink" title="[js] 请说说写一个拖拽组件的思路及注意事项?"></a>[js] 请说说写一个拖拽组件的思路及注意事项?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先，其实拖拽效果的思路是很简单的。主要就是三个步骤：</span><br><span class="line"></span><br><span class="line">1.onmousedown的时候，启动可拖拽事件，记录被拖拽元素的原始坐标参数。</span><br><span class="line"></span><br><span class="line">2.onmousemove的时候，实时记录鼠标移动的距离，结合被拖拽元素第一阶段的坐标参数，计算并设置新的坐标值。</span><br><span class="line"></span><br><span class="line">3.onmouseup的时候，关闭可拖拽事件，记录新的坐标值。</span><br><span class="line"></span><br><span class="line">注意：这里主要是通过绝对定位的top和left来确定元素的位置的，因此被拖拽元素的css一定要设置绝对定位。</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li><p>箭头函数的特点</p>
<ol>
<li>没有 arguments</li>
<li>无法通过 apply、call、bind 改变 this</li>
<li>某些箭头函数代码难以阅读</li>
</ol>
</li>
</ul>
<h2 id="for…in-和-for…of-有什么区别"><a href="#for…in-和-for…of-有什么区别" class="headerlink" title="for…in 和 for…of 有什么区别"></a>for…in 和 for…of 有什么区别</h2><ul>
<li><p>key 和 value</p>
<ol>
<li>for…in 遍历得到 key</li>
<li>for…of 遍历得到 value</li>
</ol>
</li>
<li><p>适用于不同的数据类型</p>
<ol>
<li>遍历对象： for…in 可以，for…of 不可以</li>
<li>遍历 Map、Set：for…of 可以，for…in 不可以</li>
<li>遍历 generator：for…of 可以，for…in 不可以</li>
</ol>
</li>
<li><p>可枚举 vs 可迭代</p>
<ol>
<li>for…in 用于可枚举（Object.getOwnPropertyDescriptors(obj)）数据，如对象、数组、字符串</li>
<li>for…of 用于可迭代(arr[Symbol.iterator])数据，如数组、字符串、Map、Set</li>
</ol>
</li>
</ul>
<h2 id="for-await…of-有什么作用？"><a href="#for-await…of-有什么作用？" class="headerlink" title="for await…of 有什么作用？"></a>for await…of 有什么作用？</h2><ul>
<li>for await…of 用于遍历多个 Promise</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPromise</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="title function_">createPromise</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> p2 = <span class="title function_">createPromise</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="keyword">const</span> p3 = <span class="title function_">createPromise</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> list = [p1, p2, p3];</span><br><span class="line">  <span class="keyword">const</span> list2 = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ---------------同时调用----------------</span></span><br><span class="line">  <span class="comment">// 方式一</span></span><br><span class="line">  <span class="comment">// const res1 = await p1;</span></span><br><span class="line">  <span class="comment">// console.log(res1);</span></span><br><span class="line">  <span class="comment">// const res2 = await p2;</span></span><br><span class="line">  <span class="comment">// console.log(res2);</span></span><br><span class="line">  <span class="comment">// const res3 = await p3;</span></span><br><span class="line">  <span class="comment">// console.log(res3);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方式二</span></span><br><span class="line">  <span class="comment">// Promise.all(list).then((res) =&gt; console.log(res));</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方式三</span></span><br><span class="line">  <span class="comment">// for await (let res of list) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(res);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// -----------------逐步调用---------------</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> list2) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">createPromise</span>(value);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="JS-严格模式有什么特点？"><a href="#JS-严格模式有什么特点？" class="headerlink" title="JS 严格模式有什么特点？"></a>JS 严格模式有什么特点？</h2><ul>
<li>特点（’use strict’）<ol>
<li>全局变量必须先声明</li>
<li>禁止使用 with</li>
<li>this 指向 undefined 而不是 window</li>
<li>函数参数不能重名</li>
<li>eval 有单独作用域，不推荐使用</li>
</ol>
</li>
</ul>
<h2 id="HTTP-跨域请求时为什么发送-options-请求？"><a href="#HTTP-跨域请求时为什么发送-options-请求？" class="headerlink" title="HTTP 跨域请求时为什么发送 options 请求？"></a>HTTP 跨域请求时为什么发送 options 请求？</h2><blockquote>
<p>options 请求是对 CORS 跨域请求之间的一次预检查，获取服务器是否允许本次请求，检查成功才会正式发起请求，是浏览器自行处理的</p>
</blockquote>
<h2 id="JS-内存泄漏如何检测？场景有哪些？"><a href="#JS-内存泄漏如何检测？场景有哪些？" class="headerlink" title="JS 内存泄漏如何检测？场景有哪些？"></a>JS 内存泄漏如何检测？场景有哪些？</h2><ul>
<li><p>垃圾回收 GC</p>
<ol>
<li>引用计数</li>
<li>标记清除</li>
</ol>
</li>
<li><p>场景</p>
<ol>
<li>意外的全局变量</li>
<li>遗忘的定时器</li>
<li>使用不当的闭包</li>
<li>遗漏的 DOM 元素</li>
<li>网络回调</li>
</ol>
</li>
<li><p>内存泄漏属于非预期的，闭包是主动行为，闭包非内存泄漏</p>
</li>
<li><p>可以使用 chrome devtools 的 performance 和 memory 工具类检测 js 内存</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dasusu/p/12200176.html">参考</a></p>
</li>
</ul>
<h2 id="vdom-真的很快吗？"><a href="#vdom-真的很快吗？" class="headerlink" title="vdom 真的很快吗？"></a>vdom 真的很快吗？</h2><ul>
<li><p>js 直接操作 dom 才是最快的，vdom 并不快</p>
</li>
<li><p>但是 vdom 是最合适“数据驱动视图”的技术方案</p>
</li>
</ul>
<h2 id="遍历数组，for-和-forEach-哪个快？"><a href="#遍历数组，for-和-forEach-哪个快？" class="headerlink" title="遍历数组，for 和 forEach 哪个快？"></a>遍历数组，for 和 forEach 哪个快？</h2><ul>
<li><p>时间复杂度都是 O(n)</p>
</li>
<li><p>结论：</p>
<ol>
<li>for 更快</li>
<li>forEach 每次都要创建一个函数来调用，而 for 不会创建函数</li>
<li>函数需要独立的作用域，会有额外的开销</li>
</ol>
</li>
</ul>
<h2 id="请描述-JS-Bridge-的原理"><a href="#请描述-JS-Bridge-的原理" class="headerlink" title="请描述 JS Bridge 的原理"></a>请描述 JS Bridge 的原理</h2><ul>
<li><p>什么是 JS Bridge？</p>
<ul>
<li>js 无法直接调用 native API</li>
<li>需要通过一些特定的“格式”来调用</li>
<li>这些“格式”就统称 JS-Bridge，例如微信 JSSDK</li>
</ul>
</li>
<li><p>JS Bridge 的常见实现方式</p>
<ul>
<li>注册全局 API</li>
<li>URL Scheme</li>
</ul>
</li>
</ul>
<h2 id="移动端-H5-click-有-300ms-延迟，如何解决？"><a href="#移动端-H5-click-有-300ms-延迟，如何解决？" class="headerlink" title="移动端 H5 click 有 300ms 延迟，如何解决？"></a>移动端 H5 click 有 300ms 延迟，如何解决？</h2><ul>
<li><p>背景：double tap to zoom</p>
</li>
<li><p>初期解决方案 FastClick</p>
<ul>
<li>监听 touchend 事件(touchstart touchend 会先于 click 触发)</li>
<li>使用自定义 DOM 事件模拟一个 click 事件</li>
<li>把默认的 click 事件(300ms 之后触发)禁止掉</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;load&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">FastClick</span>.<span class="title function_">attach</span>(<span class="variable language_">document</span>.<span class="property">body</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>现代浏览器的改进（width=device-width）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;id=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="网络请求中，token-和-cookie-有什么区别？"><a href="#网络请求中，token-和-cookie-有什么区别？" class="headerlink" title="网络请求中，token 和 cookie 有什么区别？"></a>网络请求中，token 和 cookie 有什么区别？</h2><ul>
<li><p>cookie</p>
<ul>
<li>http 无状态，每次请求都要带 cookie，以帮助识别身份</li>
<li>服务端也可以向客户端 set-cookie，cookie 大小限制 4kb</li>
<li>默认有跨域限制：不可跨域共享、传递 cookie</li>
</ul>
</li>
<li><p>token vs cookie</p>
<ul>
<li>cookie 是 http 规范，而 token 是自定义传递</li>
<li>cookie 会默认被浏览器存储，而 token 需自己存储</li>
<li>token 默认没有跨域限制</li>
</ul>
</li>
<li><p>JWT(JSON Web Token)</p>
<ul>
<li>前端发起登录，后端验证成功之后，返回一个加密的 token</li>
<li>前端自行存储这个 token（其中包含了用户信息，加密了）</li>
<li>以后访问服务端的接口，都带着这个 token，作为用户信息</li>
</ul>
</li>
</ul>
<h2 id="Session-和-JWT-哪个更好？"><a href="#Session-和-JWT-哪个更好？" class="headerlink" title="Session 和 JWT 哪个更好？"></a>Session 和 JWT 哪个更好？</h2><ul>
<li><p>session</p>
<ul>
<li>优点<ul>
<li>原理简单，易于学习</li>
<li>用户信息存储在服务端，可以快速封禁某个用户</li>
</ul>
</li>
<li>缺点<ul>
<li>占用服务端内存，硬件成本高</li>
<li>多进程，多服务器时，不好同步-需要使用第三方缓存，如 redis</li>
<li>默认有跨域限制</li>
</ul>
</li>
</ul>
</li>
<li><p>JWT</p>
<ul>
<li>优点<ul>
<li>不占用服务器内存</li>
<li>多进程、多服务器不受影响</li>
<li>没有跨域限制</li>
</ul>
</li>
<li>缺点<ul>
<li>用户信息存储在客户端，无法快速封禁某用户</li>
<li>万一服务器密钥被泄漏，则用户信息全部丢失</li>
<li>token 体积一般大于 cookie，会增加请求的数据量</li>
</ul>
</li>
</ul>
</li>
<li><p>答案</p>
<ul>
<li>如有严格管理用户信息的需求（保密、快速封禁），推荐 session</li>
<li>如没有特殊要求，则使用 JWT</li>
</ul>
</li>
</ul>
<h2 id="如何实现-SSO-单点登录？"><a href="#如何实现-SSO-单点登录？" class="headerlink" title="如何实现 SSO 单点登录？"></a>如何实现 SSO 单点登录？</h2><ul>
<li><p>基于 cookie（主域名相同）</p>
<ul>
<li>cookie 默认不可跨域共享，但有些情况下可设置共享</li>
<li>主域名相同，如<a target="_blank" rel="noopener" href="http://www.baidu.com,image.baidu.com/">www.baidu.com,image.baidu.com</a></li>
<li>设置 cookie domain 为主域名，即可共享 cookie</li>
</ul>
</li>
<li><p>SSO（主域名不相同，cookie 无法共享）</p>
<ul>
<li><img src="/images/md_img/sso.jpg" alt="sso"></li>
</ul>
</li>
</ul>
<h2 id="Map-和-WeakMap-的区别和应用场景？"><a href="#Map-和-WeakMap-的区别和应用场景？" class="headerlink" title="Map 和 WeakMap 的区别和应用场景？"></a>Map 和 WeakMap 的区别和应用场景？</h2><ul>
<li><p>Map：</p>
<ul>
<li>key 可以是任意数据类型</li>
<li>key 是强引用，只要键不释放，就会一直占着内存不会被 GC</li>
<li>能轻易转化为数据（扩展运算符），weakmap 做不到</li>
</ul>
</li>
<li><p>WeakMap:</p>
<ul>
<li>key 只能是非 null 的对象引用</li>
<li>key 是弱引用，没有其他引用存在时会被 GC</li>
<li>key 随时会被回收，所以 key 不可枚举，没有 size 等属性</li>
</ul>
</li>
<li><p>Map 场景：</p>
<ul>
<li>频繁的读写和查询</li>
<li>键值复杂的情况</li>
</ul>
</li>
</ul>
<h2 id="重绘-repaint-重排-reflow（回流）-有什么区别？"><a href="#重绘-repaint-重排-reflow（回流）-有什么区别？" class="headerlink" title="重绘 repaint 重排 reflow（回流） 有什么区别？"></a>重绘 repaint 重排 reflow（回流） 有什么区别？</h2><ul>
<li><p>重绘 repaint</p>
<ul>
<li>元素外观改变，如颜色、背景色</li>
<li>但元素的尺寸、定位不变，不会影响到其他元素的位置</li>
</ul>
</li>
<li><p>重排 relfow</p>
<ul>
<li>重新计算尺寸和布局，可能会影响其他元素的位置</li>
<li>如元素高度增加，可能会使相邻元素位置下移</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li>重排比重绘影响更大，消耗更大</li>
<li>所以，要尽量避免无意义的重排</li>
</ul>
</li>
<li><p>减少重排的方法</p>
<ul>
<li>集中修改样式，或直接切换 css、class</li>
<li>修改之前先设置 display: none,脱离文档流</li>
<li>使用 BFC 特性，不影响其他元素位置</li>
<li>频发触发（resize、scroll）使用节流和防抖</li>
<li>使用 createDocumentFragment 批量操作 DOM</li>
<li>优化动画，使用 CSS3 和 requestAnimationFrame</li>
</ul>
</li>
</ul>
<h2 id="如何实现网页多标签通讯？"><a href="#如何实现网页多标签通讯？" class="headerlink" title="如何实现网页多标签通讯？"></a>如何实现网页多标签通讯？</h2><ul>
<li><p>使用 WebSocket</p>
<ul>
<li>无跨域限制</li>
<li>需要服务端支持，成本高</li>
</ul>
</li>
<li><p>localStorage（跨域不共享）</p>
<ul>
<li>同域的 A 和 B 两个页面</li>
<li>A 页面设置 localStorage</li>
<li>B 页面可监听到 localStorage 值的修改</li>
</ul>
</li>
<li><p>SharedWorker(必须同域)</p>
<ul>
<li>SharedWorker 是 WebWorker 的一种</li>
<li>WebWorker 可开启子进程执行 JS，但不能操作 DOM</li>
<li>SharedWorker 可单独开启一个进程，用于同域页面通讯</li>
</ul>
</li>
</ul>
<h2 id="网页和-iframe-如何通讯？"><a href="#网页和-iframe-如何通讯？" class="headerlink" title="网页和 iframe 如何通讯？"></a>网页和 iframe 如何通讯？</h2><ul>
<li>使用 postMessage 通讯</li>
<li>注意跨域的限制和判断</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父传子</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">iframe1</span>.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"><span class="comment">// 子传父</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"><span class="comment">// 接收</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">origin</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="请描述-koa2-洋葱圈模型？"><a href="#请描述-koa2-洋葱圈模型？" class="headerlink" title="请描述 koa2 洋葱圈模型？"></a>请描述 koa2 洋葱圈模型？</h2><ul>
<li><p>koa2</p>
<ul>
<li>一个简约、流行的 nodejs 框架</li>
<li>通过中间件组织代码</li>
<li>多个中间件以“洋葱圈模型”执行</li>
</ul>
</li>
<li><p>代码执行过程</p>
<ul>
<li><img src="/images/md_img/koa1.jpg" alt="koa1"></li>
</ul>
</li>
<li><p>洋葱圈模型(类似捕获冒泡)</p>
<ul>
<li><img src="/images/md_img/koa2.jpg" alt="koa2"></li>
</ul>
</li>
</ul>
<h2 id="H5-页面如何进行首屏优化？"><a href="#H5-页面如何进行首屏优化？" class="headerlink" title="H5 页面如何进行首屏优化？"></a>H5 页面如何进行首屏优化？</h2><ul>
<li><p>路由懒加载</p>
<ul>
<li>适用于 SPA</li>
<li>路由拆分，优先保证首页加载</li>
</ul>
</li>
<li><p>服务端渲染 SSR</p>
<ul>
<li>传统前后端分离（SPA）渲染页面的过程复杂</li>
<li>SSR 渲染页面过程简单，所有性能好</li>
<li>如果是纯 H5 页面，SSR 是性能优化的终极方案</li>
</ul>
</li>
<li><p>App 预取</p>
<ul>
<li>如果 H5 在 App WebView 中展示，可使用 App 预取</li>
<li>用户访问列表页面时，App 预加载文章首屏内容</li>
<li>用户进入 H5 页面，直接从 App 中获取内容，瞬间展示首屏</li>
</ul>
</li>
<li><p>分页</p>
<ul>
<li>针对列表页</li>
<li>默认只展示第一页内容</li>
<li>上滑加载更多</li>
</ul>
</li>
<li><p>图片懒加载 lazyload</p>
<ul>
<li>针对详情页</li>
<li>默认只展示文本内容，然后出发图片懒加载</li>
<li>注意：提前设置图片尺寸，尽量只重绘不重排</li>
</ul>
</li>
<li><p>Hybrid</p>
<ul>
<li>提前将 HTML、JS、CSS 下载到 App 内部</li>
<li>在 App webview 中使用 file：// 协议加载页面文件</li>
<li>再用 Ajax 获取内容并展示（也结合 App 预取）</li>
</ul>
</li>
</ul>
<h2 id="后端一次性返回-10w-条数据，你该如何渲染？"><a href="#后端一次性返回-10w-条数据，你该如何渲染？" class="headerlink" title="后端一次性返回 10w 条数据，你该如何渲染？"></a>后端一次性返回 10w 条数据，你该如何渲染？</h2><ul>
<li><p>设计不合理，后端调整(分页)</p>
</li>
<li><p>自定义中间层</p>
<ul>
<li>自定义 nodejs 中间层，获取并拆分这 10w 条数据</li>
<li>前端对接 nodejs 中间层，而不是服务端</li>
<li>成本比较高</li>
</ul>
</li>
<li><p>虚拟列表</p>
<ul>
<li>只渲染可视区域</li>
</ul>
</li>
</ul>
<h2 id="如果一个-H5-很慢，你该如何排查性能问题？"><a href="#如果一个-H5-很慢，你该如何排查性能问题？" class="headerlink" title="如果一个 H5 很慢，你该如何排查性能问题？"></a>如果一个 H5 很慢，你该如何排查性能问题？</h2><ul>
<li><p>前端性能指标</p>
<ul>
<li>First Paint（FP）</li>
<li>First ContentFul Paint（FCP）</li>
<li>DomContentLoaded（DCL）</li>
<li>Largest Contentful Paint（LCP）</li>
<li>Load（L）</li>
</ul>
</li>
<li><p>Chrome devtools</p>
<ul>
<li>Performance 可查看上述性能指标，并有网页快照</li>
<li>Network 可以查看各个资源的加载时间</li>
</ul>
</li>
<li><p>lighthouse（第三方性能评测工具）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// terminal</span></span><br><span class="line">lighthouse <span class="attr">https</span>:<span class="comment">//www.imooc.com/ --view --preset=desktop</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过以上工具来判读是加载慢还是渲染慢</p>
<ul>
<li>加载慢<ul>
<li>优化服务端硬件配置，使用 CDN</li>
<li>路由懒加载，大组件异步加载-减少主包的体积</li>
<li>优化 http 缓存策略</li>
</ul>
</li>
<li>渲染慢<ul>
<li>优化服务端接口（如 ajax 获取数据慢）</li>
<li>优化全段组件内部逻辑</li>
<li>服务端渲染 SSR</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="BOM-API"><a href="#BOM-API" class="headerlink" title="BOM API"></a>BOM API</h2><ul>
<li>navigator</li>
<li>screen</li>
<li>location</li>
<li>history</li>
</ul>
<h2 id="为何要将-css-文件放在-head-标签中呢？"><a href="#为何要将-css-文件放在-head-标签中呢？" class="headerlink" title="为何要将 css 文件放在 head 标签中呢？"></a>为何要将 css 文件放在 head 标签中呢？</h2><ul>
<li>css 放在 body 标签尾部时，DOMTree 构建完成之后便开始构建 RenderTree，并计算布局渲染网页，等加载解析完 css 之后，开始构建 CSSOMTree，并和 DOMTree 重新构建 RenderTree，重新计算布局渲染网页</li>
<li>css 放在 head 中，先加载 css，之后解析 css 构建 CSSOMTree，同时构建 DOMTree，CSSOMTree 和 DOMTree 都构建完成之后开始构建 Render Tree，计算布局网页</li>
<li>两者对比，css 放在 head 中比放在 body 标签尾部少了一次构建 RenderTree，一次计算布局和一次渲染网页，因此性能会更好，并且 css 放在 body 标签尾部会在网页中短暂出现裸奔的 html，不利于用户体验</li>
</ul>
<h2 id="为什么建议把-script-标签放在-body-最后？"><a href="#为什么建议把-script-标签放在-body-最后？" class="headerlink" title="为什么建议把 script 标签放在 body 最后？"></a>为什么建议把 script 标签放在 body 最后？</h2><ul>
<li>js 的下载和执行会阻塞 DOMTree 的构建，即会中断 DOMTree 的更新，所以如果把 script 标签放在首屏范围内的 HTML 代码中会截断首屏的内容。</li>
<li>普通 script 标签放在 body 底部，做与不做 async 或者 defer 处理都不会影响首屏时间，但是会影响 DomContentLoad 和 load 的时间，进而影响依赖他们的代码的执行的开始时间</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 页面的全部资源加载完成后才会执行，包括图片、视频等</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// DOM 渲染完成后即可执行，此时图片、视频可能还没有加载完</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="ES6-新增的声明方式"><a href="#ES6-新增的声明方式" class="headerlink" title="ES6 新增的声明方式"></a>ES6 新增的声明方式</h2><ul>
<li>let、const<ul>
<li>不属于顶层对象 window</li>
<li>不允许重复声明</li>
<li>不存在变量提升</li>
<li>暂时性死区（不能在变量声明之前去使用）</li>
<li>块级作用域</li>
</ul>
</li>
</ul>
<h2 id="如何给所有-async-函数添加-try-catch？"><a href="#如何给所有-async-函数添加-try-catch？" class="headerlink" title="如何给所有 async 函数添加 try/catch？"></a>如何给所有 async 函数添加 try/catch？</h2><p>babel 插件：</p>
<ol>
<li><p>借助 AST 抽象语法树，遍历查找代码中的 await 关键字<br>· 词法分析、语法分析生成 AST 抽象语法树</p>
</li>
<li><p>找到 await 节点后，从父路径中查找声明的 async 函数，获取该函数的 body（函数中包含的代码）</p>
</li>
<li><p>创建 try/catch 语句，将原来的 async 的 body 放入其中<br>· 通过 bebel-template 插件以字符串形式的代码构建 AST 树节点，生成 try/catch 节点</p>
</li>
<li><p>最后将 try/catch 语句替换 async 的 body</p>
</li>
</ol>
<p>全局捕获 Promise 类型错误：</p>
<ol>
<li>window.addEventListener(‘unhandledrejection’, callback)</li>
</ol>
<h2 id="async-await-和-promise-的区别？"><a href="#async-await-和-promise-的区别？" class="headerlink" title="async/await 和 promise 的区别？"></a>async/await 和 promise 的区别？</h2><ul>
<li><p>promise 的出现是为了解决传统 callback 函数导致的<strong>回调地狱</strong>问题，但是它本身的语法造成纵向的回调链，遇到复杂的业务场景语法也不美观。</p>
</li>
<li><p>async await 可以说是改良版的 promise，或者说是 promise 的语法糖，可以让异步代码同步化，语法更加美观。</p>
</li>
<li><p>async/await 本质也是 Generator 函数的语法糖，使得异步操作更加方便。就是 Generator 函数（*）的替换为 async、yield 替换为 await</p>
<ul>
<li>Generator 需要调用 next 执行，而 async 函数内置执行器，函数调用后自动执行</li>
<li>async/await = Generator 函数 + 内置自动执行器</li>
</ul>
</li>
</ul>
<h2 id="Object-create-proto-propertiesObject-、new-Object-和-有什么区别？"><a href="#Object-create-proto-propertiesObject-、new-Object-和-有什么区别？" class="headerlink" title="Object.create(proto, propertiesObject)、new Object()和{}有什么区别？"></a>Object.create(proto, propertiesObject)、new Object()和{}有什么区别？</h2><ol>
<li>{}创建对象时，不会调用构造函数，js 引擎会创建一个空对象，然后改变 this 指向新创建的对象</li>
<li>new 则需要经历：<br>2.1 先创建空对象<br>2.2 设置原型链，设置新对象的 constructor 属性为构造函数的名称，设置新对象的<strong>proto</strong>指向构造函数的 prototype 对象<br>2.3 调用新对象并调整 this 指向新对象<br>2.4 最后如果返回值为非 null 对象直接返回该返回值，否则返回新对象</li>
<li>Object.create 方法支持两个参数，第一个参数作为新创建对象的原型，第二个为可选参数作为新创建对象的属性</li>
<li>{}字面量创建对象的性能比 new 和 Object.create 要好</li>
<li>{} 和 new 所创建的对象继承 Object 原型链的属性和方法，Object.create 通过第一个参数指定原型，可以通过 Object.create(Object.prototype)</li>
<li>Object.create(null)创建的对象没有任何属性和方法</li>
</ol>
<h2 id="document-ready-和-window-onload-的区别"><a href="#document-ready-和-window-onload-的区别" class="headerlink" title="document.ready 和 window.onload 的区别?"></a>document.ready 和 window.onload 的区别?</h2><ol>
<li>document.ready 表示 dom 文档解析完成，但是不包含异步脚本和图片等的加载,onload 需要所有文件都加载完成</li>
<li>ready 可以执行多次，onload 只会后者覆盖前者</li>
<li>ready 快于 onload</li>
</ol>
<h2 id="为什么-setTimeout-有最小-4ms-延迟？"><a href="#为什么-setTimeout-有最小-4ms-延迟？" class="headerlink" title="为什么 setTimeout 有最小 4ms 延迟？"></a>为什么 setTimeout 有最小 4ms 延迟？</h2><blockquote>
<p>原因在于如果浏览器允许 0ms，会导致 javascript 引擎过度循环，因为浏览器本身也是建立在 event loop 之上的，如果 js 引擎通过 0ms timer 不断的唤起系统，那么 event loop 就会阻塞，导致 CPU spining（快速旋转），有个故事就是英特尔团队发现 chrome 不正常的电量消耗，就是因为 0ms timer 导致 CPU spining，后果就是计算机没办法进入低功耗模式，所以耗电特别快。后来 chrome 将 timer 的时间间隔做了限制为 1ms。</p>
</blockquote>
<blockquote>
<p>不同浏览器的最低延迟不一样，比如 chrome 的最低时延是 1ms，而如果 timer 嵌套层级很多，那么最低是 4ms，具体嵌套层级的阈值不同浏览器也不一致，HTML Standard 规定是 &gt;5, chrome 是 &gt;=5;</p>
</blockquote>
<h2 id="如果判断是-PC-端还是移动端"><a href="#如果判断是-PC-端还是移动端" class="headerlink" title="如果判断是 PC 端还是移动端"></a>如果判断是 PC 端还是移动端</h2><ul>
<li>屏幕宽度：window.screen、window.innerWidth</li>
<li>屏幕方向：window.orientation pc 端为 undefined</li>
<li>navigator.userAgent 正则去匹配</li>
</ul>
<h2 id="常见移动端适配方案？"><a href="#常见移动端适配方案？" class="headerlink" title="常见移动端适配方案？"></a>常见移动端适配方案？</h2><ul>
<li>媒体查询@media<ul>
<li>分别为不同屏幕尺寸的移动设备编写不同尺寸的 css 属性</li>
</ul>
</li>
<li>rem 适配方案<ul>
<li>使用 flexible 阿里早期开源的移动端适配解决方案</li>
<li>postcss-pxtorem 插件实现 px 到 rem 的转换</li>
</ul>
</li>
<li>viewport 适配方案<ul>
<li>设置 meta 标签</li>
<li>使用 postcss-px-to-viewport 插件将 px 自动转换为 vw</li>
<li>可以通过插件的 ignoring 特性标注不需要转换的属性</li>
</ul>
</li>
</ul>
<p>缺点：就是转换的时候如不能完全整除就会产生像素差</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/05/react%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">React深入浅出知识链路</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/05/jquery%E5%AD%A6%E4%B9%A0/"><span class="level-item">jQuery学习</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "dvbU6cs8mO4tpam28kfkNFaI-gzGzoHsz",
            appKey: "tfoqOv7jT6pDSo3Abm9K4Jok",
            
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/avatar.jpeg" alt="foolishmax"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">foolishmax</p><p class="is-size-6 is-block">Web Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#从浏览器地址栏输入-url-到显示页面的步骤"><span class="level-left"><span class="level-item">1</span><span class="level-item">从浏览器地址栏输入 url 到显示页面的步骤</span></span></a></li><li><a class="level is-mobile" href="#你知道哪些前端攻击？该如何预防？"><span class="level-left"><span class="level-item">2</span><span class="level-item">你知道哪些前端攻击？该如何预防？</span></span></a></li><li><a class="level is-mobile" href="#性能优化（空间换时间）"><span class="level-left"><span class="level-item">3</span><span class="level-item">性能优化（空间换时间）</span></span></a></li><li><a class="level is-mobile" href="#你对闭包了解多少？"><span class="level-left"><span class="level-item">4</span><span class="level-item">你对闭包了解多少？</span></span></a></li><li><a class="level is-mobile" href="#js-的执行机制"><span class="level-left"><span class="level-item">5</span><span class="level-item">js 的执行机制</span></span></a></li><li><a class="level is-mobile" href="#简单说下原型链"><span class="level-left"><span class="level-item">6</span><span class="level-item">简单说下原型链</span></span></a></li><li><a class="level is-mobile" href="#defer-和-async-有什么区别？"><span class="level-left"><span class="level-item">7</span><span class="level-item">defer 和 async 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#如何监听未处理的异常"><span class="level-left"><span class="level-item">8</span><span class="level-item">如何监听未处理的异常</span></span></a></li><li><a class="level is-mobile" href="#本地存储"><span class="level-left"><span class="level-item">9</span><span class="level-item">本地存储</span></span></a></li><li><a class="level is-mobile" href="#localStorage-超过最大限制（5M）怎么处理？"><span class="level-left"><span class="level-item">10</span><span class="level-item">localStorage 超过最大限制（5M）怎么处理？</span></span></a></li><li><a class="level is-mobile" href="#cookie"><span class="level-left"><span class="level-item">11</span><span class="level-item">cookie</span></span></a></li><li><a class="level is-mobile" href="#fetch-和-axios"><span class="level-left"><span class="level-item">12</span><span class="level-item">fetch 和 axios</span></span></a></li><li><a class="level is-mobile" href="#箭头函数中的-this"><span class="level-left"><span class="level-item">13</span><span class="level-item">箭头函数中的 this</span></span></a></li><li><a class="level is-mobile" href="#Map-和-Set-两种新的数据结构的区别？"><span class="level-left"><span class="level-item">14</span><span class="level-item">Map 和 Set 两种新的数据结构的区别？</span></span></a></li><li><a class="level is-mobile" href="#js-的-new-操作符都做了些什么？"><span class="level-left"><span class="level-item">15</span><span class="level-item">js 的 new 操作符都做了些什么？</span></span></a></li><li><a class="level is-mobile" href="#es6-新特性"><span class="level-left"><span class="level-item">16</span><span class="level-item">es6 新特性</span></span></a></li><li><a class="level is-mobile" href="#图片懒加载原理"><span class="level-left"><span class="level-item">17</span><span class="level-item">图片懒加载原理</span></span></a></li><li><a class="level is-mobile" href="#为什么-try-catch-不能捕获到-promise-的错误？"><span class="level-left"><span class="level-item">18</span><span class="level-item">为什么 try/catch 不能捕获到 promise 的错误？</span></span></a></li><li><a class="level is-mobile" href="#requestIdleCallback-和-requestAnimationFrame-有什么区别？"><span class="level-left"><span class="level-item">19</span><span class="level-item">requestIdleCallback 和 requestAnimationFrame 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#如何阻止冒泡"><span class="level-left"><span class="level-item">20</span><span class="level-item">如何阻止冒泡?</span></span></a></li><li><a class="level is-mobile" href="#如何阻止默认事件？"><span class="level-left"><span class="level-item">21</span><span class="level-item">如何阻止默认事件？</span></span></a></li><li><a class="level is-mobile" href="#补充：事件绑定的封装"><span class="level-left"><span class="level-item">22</span><span class="level-item">补充：事件绑定的封装</span></span></a></li><li><a class="level is-mobile" href="#如何判断一个对象是否为数组"><span class="level-left"><span class="level-item">23</span><span class="level-item">如何判断一个对象是否为数组</span></span></a></li><li><a class="level is-mobile" href="#Http-的持久连接和管线化"><span class="level-left"><span class="level-item">24</span><span class="level-item">Http 的持久连接和管线化</span></span></a></li><li><a class="level is-mobile" href="#为什么利用多个域名来存储网站资源会更有效？"><span class="level-left"><span class="level-item">25</span><span class="level-item">为什么利用多个域名来存储网站资源会更有效？</span></span></a></li><li><a class="level is-mobile" href="#基本数据类型"><span class="level-left"><span class="level-item">26</span><span class="level-item">基本数据类型</span></span></a></li><li><a class="level is-mobile" href="#牛客学习"><span class="level-left"><span class="level-item">27</span><span class="level-item">牛客学习</span></span></a></li><li><a class="level is-mobile" href="#浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？"><span class="level-left"><span class="level-item">28</span><span class="level-item">浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？</span></span></a></li><li><a class="level is-mobile" href="#如何清除-token"><span class="level-left"><span class="level-item">29</span><span class="level-item">如何清除 token</span></span></a></li><li><a class="level is-mobile" href="#npm"><span class="level-left"><span class="level-item">30</span><span class="level-item">npm</span></span></a></li><li><a class="level is-mobile" href="#URI-和-URL-有什么区别？"><span class="level-left"><span class="level-item">31</span><span class="level-item">URI 和 URL 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#日期"><span class="level-left"><span class="level-item">32</span><span class="level-item">日期</span></span></a></li><li><a class="level is-mobile" href="#浏览器如何缓存"><span class="level-left"><span class="level-item">33</span><span class="level-item">浏览器如何缓存</span></span></a></li><li><a class="level is-mobile" href="#Chrome-打开一个页面需要启动多少线程？分别有哪些线程？"><span class="level-left"><span class="level-item">34</span><span class="level-item">Chrome 打开一个页面需要启动多少线程？分别有哪些线程？</span></span></a></li><li><a class="level is-mobile" href="#js-请说说写一个拖拽组件的思路及注意事项"><span class="level-left"><span class="level-item">35</span><span class="level-item">[js] 请说说写一个拖拽组件的思路及注意事项?</span></span></a></li><li><a class="level is-mobile" href="#箭头函数"><span class="level-left"><span class="level-item">36</span><span class="level-item">箭头函数</span></span></a></li><li><a class="level is-mobile" href="#for…in-和-for…of-有什么区别"><span class="level-left"><span class="level-item">37</span><span class="level-item">for…in 和 for…of 有什么区别</span></span></a></li><li><a class="level is-mobile" href="#for-await…of-有什么作用？"><span class="level-left"><span class="level-item">38</span><span class="level-item">for await…of 有什么作用？</span></span></a></li><li><a class="level is-mobile" href="#JS-严格模式有什么特点？"><span class="level-left"><span class="level-item">39</span><span class="level-item">JS 严格模式有什么特点？</span></span></a></li><li><a class="level is-mobile" href="#HTTP-跨域请求时为什么发送-options-请求？"><span class="level-left"><span class="level-item">40</span><span class="level-item">HTTP 跨域请求时为什么发送 options 请求？</span></span></a></li><li><a class="level is-mobile" href="#JS-内存泄漏如何检测？场景有哪些？"><span class="level-left"><span class="level-item">41</span><span class="level-item">JS 内存泄漏如何检测？场景有哪些？</span></span></a></li><li><a class="level is-mobile" href="#vdom-真的很快吗？"><span class="level-left"><span class="level-item">42</span><span class="level-item">vdom 真的很快吗？</span></span></a></li><li><a class="level is-mobile" href="#遍历数组，for-和-forEach-哪个快？"><span class="level-left"><span class="level-item">43</span><span class="level-item">遍历数组，for 和 forEach 哪个快？</span></span></a></li><li><a class="level is-mobile" href="#请描述-JS-Bridge-的原理"><span class="level-left"><span class="level-item">44</span><span class="level-item">请描述 JS Bridge 的原理</span></span></a></li><li><a class="level is-mobile" href="#移动端-H5-click-有-300ms-延迟，如何解决？"><span class="level-left"><span class="level-item">45</span><span class="level-item">移动端 H5 click 有 300ms 延迟，如何解决？</span></span></a></li><li><a class="level is-mobile" href="#网络请求中，token-和-cookie-有什么区别？"><span class="level-left"><span class="level-item">46</span><span class="level-item">网络请求中，token 和 cookie 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#Session-和-JWT-哪个更好？"><span class="level-left"><span class="level-item">47</span><span class="level-item">Session 和 JWT 哪个更好？</span></span></a></li><li><a class="level is-mobile" href="#如何实现-SSO-单点登录？"><span class="level-left"><span class="level-item">48</span><span class="level-item">如何实现 SSO 单点登录？</span></span></a></li><li><a class="level is-mobile" href="#Map-和-WeakMap-的区别和应用场景？"><span class="level-left"><span class="level-item">49</span><span class="level-item">Map 和 WeakMap 的区别和应用场景？</span></span></a></li><li><a class="level is-mobile" href="#重绘-repaint-重排-reflow（回流）-有什么区别？"><span class="level-left"><span class="level-item">50</span><span class="level-item">重绘 repaint 重排 reflow（回流） 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#如何实现网页多标签通讯？"><span class="level-left"><span class="level-item">51</span><span class="level-item">如何实现网页多标签通讯？</span></span></a></li><li><a class="level is-mobile" href="#网页和-iframe-如何通讯？"><span class="level-left"><span class="level-item">52</span><span class="level-item">网页和 iframe 如何通讯？</span></span></a></li><li><a class="level is-mobile" href="#请描述-koa2-洋葱圈模型？"><span class="level-left"><span class="level-item">53</span><span class="level-item">请描述 koa2 洋葱圈模型？</span></span></a></li><li><a class="level is-mobile" href="#H5-页面如何进行首屏优化？"><span class="level-left"><span class="level-item">54</span><span class="level-item">H5 页面如何进行首屏优化？</span></span></a></li><li><a class="level is-mobile" href="#后端一次性返回-10w-条数据，你该如何渲染？"><span class="level-left"><span class="level-item">55</span><span class="level-item">后端一次性返回 10w 条数据，你该如何渲染？</span></span></a></li><li><a class="level is-mobile" href="#如果一个-H5-很慢，你该如何排查性能问题？"><span class="level-left"><span class="level-item">56</span><span class="level-item">如果一个 H5 很慢，你该如何排查性能问题？</span></span></a></li><li><a class="level is-mobile" href="#BOM-API"><span class="level-left"><span class="level-item">57</span><span class="level-item">BOM API</span></span></a></li><li><a class="level is-mobile" href="#为何要将-css-文件放在-head-标签中呢？"><span class="level-left"><span class="level-item">58</span><span class="level-item">为何要将 css 文件放在 head 标签中呢？</span></span></a></li><li><a class="level is-mobile" href="#为什么建议把-script-标签放在-body-最后？"><span class="level-left"><span class="level-item">59</span><span class="level-item">为什么建议把 script 标签放在 body 最后？</span></span></a></li><li><a class="level is-mobile" href="#ES6-新增的声明方式"><span class="level-left"><span class="level-item">60</span><span class="level-item">ES6 新增的声明方式</span></span></a></li><li><a class="level is-mobile" href="#如何给所有-async-函数添加-try-catch？"><span class="level-left"><span class="level-item">61</span><span class="level-item">如何给所有 async 函数添加 try/catch？</span></span></a></li><li><a class="level is-mobile" href="#async-await-和-promise-的区别？"><span class="level-left"><span class="level-item">62</span><span class="level-item">async/await 和 promise 的区别？</span></span></a></li><li><a class="level is-mobile" href="#Object-create-proto-propertiesObject-、new-Object-和-有什么区别？"><span class="level-left"><span class="level-item">63</span><span class="level-item">Object.create(proto, propertiesObject)、new Object()和{}有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#document-ready-和-window-onload-的区别"><span class="level-left"><span class="level-item">64</span><span class="level-item">document.ready 和 window.onload 的区别?</span></span></a></li><li><a class="level is-mobile" href="#为什么-setTimeout-有最小-4ms-延迟？"><span class="level-left"><span class="level-item">65</span><span class="level-item">为什么 setTimeout 有最小 4ms 延迟？</span></span></a></li><li><a class="level is-mobile" href="#如果判断是-PC-端还是移动端"><span class="level-left"><span class="level-item">66</span><span class="level-item">如果判断是 PC 端还是移动端</span></span></a></li><li><a class="level is-mobile" href="#常见移动端适配方案？"><span class="level-left"><span class="level-item">67</span><span class="level-item">常见移动端适配方案？</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/favicon.svg" alt="foolishmax" height="28"></a><p class="is-size-7"><span>&copy; 2023 foolishmax</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>