<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>面试题目总结 - foolishmax</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="foolishmax"><meta name="msapplication-TileImage" content="/images/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="foolishmax"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="[toc] 从浏览器地址栏输入 url 到显示页面的步骤"><meta property="og:type" content="blog"><meta property="og:title" content="面试题目总结"><meta property="og:url" content="https://github.com/foolishmax/2021/10/04/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86javascript%E7%AF%87/"><meta property="og:site_name" content="foolishmax"><meta property="og:description" content="[toc] 从浏览器地址栏输入 url 到显示页面的步骤"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70"><meta property="og:image" content="https://github.com/images/md_img/lazyload.webp"><meta property="og:image" content="https://github.com/images/md_img/sso.jpg"><meta property="og:image" content="https://github.com/images/md_img/defer_async.jpg"><meta property="og:image" content="https://github.com/images/md_img/koa1.jpg"><meta property="og:image" content="https://github.com/images/md_img/koa2.jpg"><meta property="article:published_time" content="2021-10-04T13:54:55.000Z"><meta property="article:modified_time" content="2023-03-28T04:53:01.796Z"><meta property="article:author" content="foolishmax"><meta property="article:tag" content="面经"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/foolishmax/2021/10/04/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86javascript%E7%AF%87/"},"headline":"面试题目总结","image":["https://github.com/images/md_img/lazyload.webp","https://github.com/images/md_img/sso.jpg","https://github.com/images/md_img/defer_async.jpg","https://github.com/images/md_img/koa1.jpg","https://github.com/images/md_img/koa2.jpg"],"datePublished":"2021-10-04T13:54:55.000Z","dateModified":"2023-03-28T04:53:01.796Z","author":{"@type":"Person","name":"foolishmax"},"publisher":{"@type":"Organization","name":"foolishmax","logo":{"@type":"ImageObject","url":"https://github.com/images/favicon.svg"}},"description":"[toc] 从浏览器地址栏输入 url 到显示页面的步骤"}</script><link rel="canonical" href="https://github.com/foolishmax/2021/10/04/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86javascript%E7%AF%87/"><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="foolishmax" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/favicon.svg" alt="foolishmax" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">档案</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/foolishmax"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="detail column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-04T13:54:55.000Z" title="10/4/2021, 9:54:55 PM">2021-10-04</time>发表</span><span class="level-item"><time dateTime="2023-03-28T04:53:01.796Z" title="3/28/2023, 12:53:01 PM">2023-03-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span><span class="level-item">2 小时读完 (大约17284个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">面试题目总结</h1><div class="content"><p>[toc]</p>
<h2 id="从浏览器地址栏输入-url-到显示页面的步骤"><a href="#从浏览器地址栏输入-url-到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入 url 到显示页面的步骤"></a>从浏览器地址栏输入 url 到显示页面的步骤</h2><span id="more"></span>

<pre><code>* 先检查搜索关键字是否符合url规则，然后将其组装成完成url进行访问
* 检查缓存，浏览器检查本地强缓存是否可用，如果命中强缓存就直接从缓存中返回资源
* DNS解析，如果未命中强缓存，则向服务器发起请求，通过递归查询和迭代查询解析域名来获取对应IP地址
  - 浏览器IP缓存
  - 操作系统IP缓存
  - 本地hosts文件
  - 路由器缓存
  - DNS根服务器
  - 本地DNS服务器以递归方式进行查询缓存记录
  - 若没有缓存记录就向根DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器，
  本地DNS服务器把对应关系暂存在缓存中（以便下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。
* 客户端发送HTTP请求
* 建立TCP连接，三次握手
* 发起http请求
* 负载均衡：服务端网管收到http请求后，可能会进行一系列负载均衡处理，通过反向代理分配给对应集群中的服务器去执行
* 服务端返回响应：服务端收到请求后，根据请求头中缓存标识来判断缓存是否生效，生效返回304状态码，未命中缓存返回200状态码
* 浏览器接收到http响应后，根据connection: keep-alive判断保持连接或者四次挥手断开TCP连接
* 浏览器缓存响应头中缓存标识字段
* 解析HTML文档，此时document.readystate为loading
* 构建DOM树，浏览器从上到下解析html文档生成DOM节点树
* 构建CSSOM树，浏览器解析遇到样式进行异步下载，构建CSSOM树（不会阻塞DOM树构建，但是会阻塞渲染，防止css规则不断变化）
* 构建渲染树，根据DOM节点树和CSSOM树构建渲染树Render
* 遇到图片异步下载，遇到不带async和defer的script时，阻塞html的解析并下载且执行
* 带async的script标签，不会中断html解析并行下载脚本，下载完成后中断html解析并执行脚本，优先级高于defer
* 带defer的script标签，不会中断html解析并行下载脚本，当浏览器解析完html时，DOMContentLoaded事件即将触发时执行脚本
* 文档解析完成，document.readystate变为interactive,触发DOMContentLoaded事件
* 等待图片加载或所有异步脚本加载执行完成，document.readystate变为complete,window触发load事件
* 布局Layout，根据Render树计算每个节点在屏幕上的位置布局
* 绘制Paint，绘制节点到屏幕上，涉及到构建图层树、绘制列表、光栅化（合成线程）和显示等。
</code></pre>
<p>其他：<br>dns-prefetch:<br>前端网络性能优化的一种措施，提前解析之后可能遇到的域名，使解析结果缓存到系统缓存中，缩短 DNS 解析时间，进而提高网站的访问速度</p>
<p>dns-prefetch 原理：<br>浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP(运行商)DNS 缓存-&gt;根域名服务器-&gt;顶级域名服务器-&gt;主域名服务器</p>
<p>dns-prefetch 将解析后的 IP 缓存放在系统缓存中<br>dns-prefetch 与 preconnect 预连接提示配对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com/&quot; crossorigin&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://fonts.gstatic.com/&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>Note：如果页面需要建立与许多第三方域的连接，则将它们预先连接会适得其反。 preconnect 提示最好仅用于最关键的连接。对于其他的，只需使用 <link rel="dns-prefetch"> 即可节省第一步的时间 DNS 查找。</p>
<p>扩展：<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3NDY4NDgyOQ==&mid=2247491757&idx=1&sn=a956c6c62c98e2d5ee71c8ed8d3a3eb8&chksm=cecfa85ff9b82149a3e50e81789b29cc0923745cf8a8f7713619aa2499753a3de760f24e6f93&scene=132#wechat_redirect">收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？</a></p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul>
<li>cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据 cookie 追踪用户在不同页面的访问信息。</li>
<li>cookie 特点<ul>
<li>1.大小限制，cookie 大小限制在 4KB 以内</li>
<li>2.宽带限制，cookie 数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。</li>
<li>3.安全风险，cookie 会频繁的在网络中传送，不加密的情况下是有安全风险的。</li>
<li>4.操作复杂<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name: string, value: string) &#123;</span><br><span class="line">    const exp = new Date();</span><br><span class="line">    //过期时间设置为一天</span><br><span class="line">    exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000);</span><br><span class="line">    document.cookie = `$&#123;name&#125;=$&#123;escape(value);expires=$&#123;exp.toString()&#125;&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="localStorage-会话存储-和-sessionStorage-本地存储"><a href="#localStorage-会话存储-和-sessionStorage-本地存储" class="headerlink" title="localStorage 会话存储 和 sessionStorage 本地存储"></a>localStorage 会话存储 和 sessionStorage 本地存储</h2><ul>
<li>1.存储容量大</li>
<li>2.零宽带，仅存储在本地，不会和服务器发生任何交互行为，不存在网络宽带占用问题。</li>
<li>3.编程接口，提供一套丰富的接口，操作数据更加方便。</li>
<li>4.独立的存储空间，不会造成数据的混乱。</li>
</ul>
<ul>
<li><p>主要区别在于数据存储的 <code>时间范围</code>和<code>页面范围</code></p>
<ul>
<li>sessionStorage: 数据只存储到窗口或标签关闭时，只在当前窗口的当前标签内可见,5M 左右，不同浏览器不同大小。</li>
<li>localStorage: 数据会一直存在除非手动清除，数据可被同源(协议、域名、端口号一致)的每个窗口或标签共享,5M 左右，不同浏览器不同大小。</li>
</ul>
</li>
<li><p>监测是否支持 web Storage</p>
<ul>
<li>1.通过 window.sessionStorage,window.localStorage 判断浏览器是否支持</li>
<li>2.通过 try{}catch{} 执行一下 storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。</li>
</ul>
</li>
</ul>
<h2 id="html5-的几种存储形式"><a href="#html5-的几种存储形式" class="headerlink" title="html5 的几种存储形式"></a>html5 的几种存储形式</h2><ul>
<li>1.本地存储 localStorage,sessionStorage</li>
<li>2.离线缓存 application cache</li>
<li><ol start="3">
<li>indexedDb,webSQL</li>
</ol>
</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.负载均衡、CDN加速、设置缓存、</span><br><span class="line">2.业务逻辑优化</span><br><span class="line">3.代码程序优化（组件按需加载、图片懒加载，代码压缩）</span><br><span class="line">4.避免重绘回流</span><br><span class="line">重绘：页面元素的样式改变不会影响它在文档流中的位置时发生重绘</span><br><span class="line">回流：DOM尺寸大小结构发生变化时</span><br><span class="line">回流一定会导致重绘</span><br><span class="line">如何避免：</span><br><span class="line">1.避免频繁操作dom，通过创建document.createDocumentFragment()一次性插入需要操作的dom</span><br><span class="line">2.具有复杂动画的Dom元素使用绝对定位，使其脱离文档流</span><br><span class="line">3.合并对于Dom中style样式的操作</span><br><span class="line">4.避免使用css表达式 calc()</span><br></pre></td></tr></table></figure>

<h2 id="fetch-和-axios"><a href="#fetch-和-axios" class="headerlink" title="fetch 和 axios"></a>fetch 和 axios</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch取消发送</span><br><span class="line">1.创建一个AbortController实例</span><br><span class="line">2.该实例具有signal属性</span><br><span class="line">3.将signal传递给fetch option</span><br><span class="line">4.调用AbortController的abort属性来取消所有使用该信号的fetch</span><br><span class="line"></span><br><span class="line">axios取消发送</span><br><span class="line">1.const cancelToken = axios.CancelToken</span><br><span class="line">2.const source = CancelToken.source()</span><br><span class="line">3.axios.get(&#x27;/xxx&#x27;,&#123;cancelToken: source.token&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在作用域的创建阶段（预编译阶段），会生成js的变量对象（VO对象）供js引擎去访问。</span><br><span class="line">1.创建ao对象</span><br><span class="line">2.找形参和变量声明，作为ao对象的属性名，值为undefined</span><br><span class="line">3.实参和形参相统一</span><br><span class="line">4.找函数声明，如果名字和变量相同则覆盖变量声明</span><br><span class="line">5.解释执行</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.箭头函数中的this是在定义函数的时候绑定的（继承自父执行上下文中的this），而不是执行函数时绑定。</span><br><span class="line">2.箭头函数没有this，所以不能用作构造函数。</span><br></pre></td></tr></table></figure>

<h2 id="Map-和-Set-两种新的数据结构的区别？"><a href="#Map-和-Set-两种新的数据结构的区别？" class="headerlink" title="Map 和 Set 两种新的数据结构的区别？"></a>Map 和 Set 两种新的数据结构的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Map类似Object是一种键值对集合，区别在于Map的键不仅限于字符串，其他各种类型的值都可以作为Map的键</span><br><span class="line"></span><br><span class="line">2.Set是类似数组的一种数据结构，不点在于Set中没有重复的值</span><br></pre></td></tr></table></figure>

<h2 id="你对闭包了解多少？"><a href="#你对闭包了解多少？" class="headerlink" title="你对闭包了解多少？"></a>你对闭包了解多少？</h2><pre><code>解释一下作用域链是如何产生的
解释一下js执行山下文的创建、执行过程
解释一下闭包所产生的变量放在哪里
</code></pre>
<ul>
<li>闭包的定义：闭包就是能够读取其他函数内部变量的函数。</li>
<li>闭包的底层实现原理</li>
<li>js 执行上下文：</li>
<li><img src="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70" alt="image"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">js运行三部曲</span><br><span class="line">1.语法分析</span><br><span class="line">2.预编译</span><br><span class="line">3.解释执行</span><br><span class="line"></span><br><span class="line">js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。</span><br><span class="line">预编译的环境需要个环境，这个环境就是执行上下文。</span><br><span class="line"></span><br><span class="line">js执行上下文分为三种：</span><br><span class="line">1.全局执行上下文：代码开始执行时首先进入的环境</span><br><span class="line">2.函数执行上下文：函数调用时，会开始执行函数中的代码</span><br><span class="line">3.eval执行上下文：不建议使用</span><br><span class="line"></span><br><span class="line">执行上下文的周期，分为两个阶段</span><br><span class="line">1.创建阶段</span><br><span class="line">    创建词法环境</span><br><span class="line">    生成变量对象VO，建立作用域链</span><br><span class="line">    确认this指向，并绑定this</span><br><span class="line">2.执行阶段</span><br><span class="line">    进行变量赋值，函数引用以及执行代码</span><br><span class="line"></span><br><span class="line">预编译发生在函数执行前，预编译四部曲：</span><br><span class="line">1.创建AO对象</span><br><span class="line">2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined</span><br><span class="line">3.将形参和实参相统一</span><br><span class="line">4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）</span><br><span class="line">5.最后程序输出变量值的时候，就是从AO对象中拿</span><br><span class="line">（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，</span><br><span class="line">就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包）</span><br></pre></td></tr></table></figure>

<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student.__proto__ === Student.prototype</span><br><span class="line">1.每个函数function都由一个prototype，即显式原型。是在定义函数的时候自动添加的，默认是一个空的Object对象</span><br><span class="line">2.每个引用类型都有一个__proto__,即隐式原型。是创建对象时自动添加的，默认值为构造函数的prototype属性值</span><br><span class="line">实例对象的隐式原型 等于 对应构造函数或类的显式原型</span><br><span class="line">能直接操作显式原型，不能直接操作隐式原型</span><br></pre></td></tr></table></figure>

<h2 id="简单说下原型链"><a href="#简单说下原型链" class="headerlink" title="简单说下原型链"></a>简单说下原型链</h2><ul>
<li><p>原型链是由原型对象组成的，每个对象都有<strong>proto</strong>属性，指向了创建该对象的构造函数的<br>原型，<strong>proto</strong>将对象连接起来组成了原型链。</p>
</li>
<li><p>原型链：用来实现继承和共享属性的有限对象链。</p>
</li>
<li><p>每个对象都有<strong>proto</strong>（隐式原型）属性，指向创建该对象的构造函数的原型。其实<br>这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能<br>访问到，所以使用 <em>proto</em> 来访问。</p>
</li>
<li><p>对象的隐式原型等于对象的构造函数的显式原型：obj.<strong>proto</strong> === Object.prototype</p>
</li>
<li><p>访问属性的时候，js 引擎会调用内部的默认。。。。。。[[Get]]操作，[[Get]]操作首先会检查对象本身是否包含这个属性<br>如果对象没有这个属性，则对象可以通过<strong>proto</strong>来寻找不属于该对象的属性，<strong>proto</strong><br>将对象和原型连接起来形成原型链</p>
</li>
<li><p>Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎创建。</p>
</li>
</ul>
<h2 id="js-的-new-操作符都做了些什么？"><a href="#js-的-new-操作符都做了些什么？" class="headerlink" title="js 的 new 操作符都做了些什么？"></a>js 的 new 操作符都做了些什么？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个空的js对象&#123;&#125;</span><br><span class="line">2. 将空对象的隐式原型__proto__指向构造函数的原型</span><br><span class="line">3. 将空对象作为构造函数的上下文（改变this指向）</span><br><span class="line">4. 对构造函数返回值做判断</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line">function create(fn, ...args) &#123;</span><br><span class="line">    let obj = Object.create(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    // obj.__proto__ = fn.prototype;</span><br><span class="line">    Object.setPrototypeOf(obj, fn.prototype);</span><br><span class="line"></span><br><span class="line">    let result = fn.apply(obj, args);</span><br><span class="line"></span><br><span class="line">    return result instanceof Object ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">在new的时候，会对构造函数的返回值做一些判断</span><br><span class="line">1. 如果返回值是基础类型数据，则忽略返回值</span><br><span class="line">2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效</span><br></pre></td></tr></table></figure>

<h2 id="什么是会话-cookie-什么是持久-cookie"><a href="#什么是会话-cookie-什么是持久-cookie" class="headerlink" title="什么是会话 cookie,什么是持久 cookie?"></a>什么是会话 cookie,什么是持久 cookie?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie是服务器返回的，指定了expire（有效期）的是持久cookie,没有指定的是会话cookie</span><br></pre></td></tr></table></figure>

<h2 id="es6-新特性"><a href="#es6-新特性" class="headerlink" title="es6 新特性"></a>es6 新特性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.let和const</span><br><span class="line">2.模版字符串</span><br><span class="line">3.箭头函数</span><br><span class="line">4.函数可以设置默认参数值</span><br><span class="line">5.扩展运算符</span><br><span class="line">6.对象和数组的解构</span><br><span class="line">7.class</span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载原理"><a href="#图片懒加载原理" class="headerlink" title="图片懒加载原理"></a>图片懒加载原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器是否发起请求是根据&lt;img /&gt;标签的src属性</span><br><span class="line">2. 所以懒加载的关键是：在图片没有进入可视区域时，</span><br><span class="line">先不给&lt;img /&gt;的src属性赋值，等到图片进入可是区域再给data-src -&gt; src赋值。</span><br><span class="line"></span><br><span class="line">当图片底边距离页面的偏移（图片高度+图片距离顶部偏移高度）</span><br><span class="line">小于等于</span><br><span class="line">浏览器底边距离页面顶部高度（浏览器一屏高度 + 滚动区域）</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="/images/md_img/lazyload.webp" alt="图片懒加载"></li>
</ul>
<h2 id="AMD-和-CMD-的区别"><a href="#AMD-和-CMD-的区别" class="headerlink" title="AMD 和 CMD 的区别"></a>AMD 和 CMD 的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">共同点：</span><br><span class="line">1.两者都是框架在推广过程中对模块定义的规范产出</span><br><span class="line">2.都是异步加载模块</span><br><span class="line">不同点：</span><br><span class="line">1.AMD是RequireJs在推广过程中对模块定义的规范产出，CMD是SeaJs在推广过程中对模块定义的规范化产出</span><br><span class="line">2.AMD推崇依赖前置，CMD推崇依赖就近</span><br><span class="line">3.AMD的应用体验好，因为模块提前执行了，CMD性能好，因为只有用户需要的时候才执行</span><br></pre></td></tr></table></figure>

<h2 id="如何实现-js-倒计时的纠偏？"><a href="#如何实现-js-倒计时的纠偏？" class="headerlink" title="如何实现 js 倒计时的纠偏？"></a>如何实现 js 倒计时的纠偏？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 第一种通过前端定时向服务端发送请求获取最新的时间差，以此来校准倒计时时间。</span><br><span class="line">2. 通过前端根据偏差时间来自动调整下次间隔的时间来实现，首先以setTimeout递归的方式来实现倒计时，</span><br><span class="line">通过一个变量记录倒计时的秒数，根据秒数和间隔时间计算出此时无偏差时应该显示的时间，</span><br><span class="line">然后拿当前真实时间与这个时间相减，就可以得到时间的偏差大小，因此在设置下一个定时器的时候，</span><br><span class="line">间隔时间减去这个偏差大小就可以纠正时间误差。</span><br></pre></td></tr></table></figure>

<h2 id="js-的执行机制"><a href="#js-的执行机制" class="headerlink" title="js 的执行机制"></a>js 的执行机制</h2><p>js 是单线程的，处理 js 任务只能一个一个顺序执行，js 中把任务分为了同步任务和异步任务，<br>同步任务进入主线程先执行，异步任务进入 Event Table 并注册函数，指定事情完成后，Event Table 就会将函数移入到事件队列 Event Queque 中，等待主线程任务执行完毕，<br>就会从事件队列中取出对应事件进入主线程执行。</p>
<p>macro-task（宏任务）：包括整体代码 script、setTimeout、setInterval、IO 操作、UI 交互、postMessage 等<br>micro-task（微任务）：Promise.then、process.nextTick、MutationObserve 等<br>微任务先于宏任务先执行（除了 script）执行过程不同任务进入不同的 event queue</p>
<p>js 先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，遇到宏任务放到宏任务事件队列中。</p>
<p>然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，<br>等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，<br>执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，<br>就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，<br>以此类推。</p>
<h2 id="V8-垃圾回收机制"><a href="#V8-垃圾回收机制" class="headerlink" title="V8 垃圾回收机制"></a>V8 垃圾回收机制</h2><p>垃圾收集器会定期（周期性）的找出那些不再继续使用的变量，释放其内存，因为开销比较大，所以会按照固定的时间间隔周期性的执行</p>
<p>最常用的两种方法：标记清除（常用）和引用计数</p>
<p>标记清除：变量进入作用域，进行标记，离开作用域进行清除回收</p>
<p>引用计数：就是跟踪记录每个值被引用的次数，引用一次加 1，删除减 1，引用计数为 0 时，进行回收，（循环引用可能会导致内存泄漏）</p>
<p>常见的内存泄漏原因：<br>全局变量过多引起内存泄漏<br>闭包<br>dom 事件未清除<br>循环引用</p>
<ul>
<li><p>V8 会把堆分为新生代和老生代</p>
</li>
<li><p>新生代（副垃圾回收器）</p>
<ul>
<li>存放生存时间短的对象</li>
<li>通常只支持 1 ～ 8M 的容量</li>
<li>分为对象区和空闲区<ul>
<li>对对象区域中的垃圾做标记，标记完成进入垃圾清理阶段，把存活的对象复制到空闲区域，把这些对象有序的排列起来</li>
<li>完成复制后，对象区和空闲区进行角色翻转</li>
</ul>
</li>
</ul>
</li>
<li><p>老生代（主垃圾回收器）</p>
<ul>
<li>对象存放生存时间久</li>
<li>对象占用空间大</li>
</ul>
</li>
<li><p>副垃圾回收器采用对象晋升策略：移动那些经过两次垃圾回收依然还存活的对象到老生代中</p>
</li>
</ul>
<p>V8 实现了精准式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p>
<p>新生代算法<br>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。<br>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。<br>在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。<br>新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动。<br>算法会检查 From 空间中存活的对象并复制到 To 空间中，如果失活的对象就会销毁。<br>当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p>
<p>老生代算法<br>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是 标记清除算法 和 标记压缩算法。<br>在将算法前，先来说下什么情况下对象会出现在老生代空间中：<br>● 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间。<br>● To 空间的对象占比大于 25%。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</p>
<p>以下情况会启动 标记清除算法：<br>● 某一空间没有分块的时候<br>● 空间中对象超过一定限制<br>● 空间不能保证新生代中的对象移动时</p>
<p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动 压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清除不需要的内存。</p>
<h2 id="如何阻止冒泡"><a href="#如何阻止冒泡" class="headerlink" title="如何阻止冒泡?"></a>如何阻止冒泡?</h2><pre><code>W3C的方法e.stopPropagation(),IE使用e.cancelBubble = true;

封装：
    //阻止冒泡行为
    function stopBubble(e) &#123;
        //如果提供了事件对象，则这是一个非IE浏览器
        if (e &amp;&amp; e.stopPropagation) e.stopPropagation()
        //IE的方法
        else window.event.cancelBubble = true
    &#125;
</code></pre>
<h2 id="如何阻止默认事件？"><a href="#如何阻止默认事件？" class="headerlink" title="如何阻止默认事件？"></a>如何阻止默认事件？</h2><pre><code>W3C的方法是e.preventDefault(),IE使用e.returnValue = false

封装：
    //阻止浏览器的默认行为
    function stopDefault (e) &#123;
        if (e &amp;&amp; e.preventDefault) e.preventDefault()
        //IE中阻止默认事件的方法
        else window.event.returnValue = false
        return false
    &#125;
</code></pre>
<h2 id="补充：事件绑定的封装"><a href="#补充：事件绑定的封装" class="headerlink" title="补充：事件绑定的封装"></a>补充：事件绑定的封装</h2><pre><code>function addEvent(element,type,handle) &#123;
    if(element.addEventListener)&#123;
        element.addEventListener(type,handle,false);
    &#125;else if(element.attachEvent)&#123;
        element.attachEvent(&#39;on&#39;+type,function () &#123;
            handle.call(element);
        &#125;)
    &#125;else &#123;
        element[&#39;on&#39;+type] = handle;
    &#125;
&#125;
</code></pre>
<h2 id="如何判断一个对象是否为数组"><a href="#如何判断一个对象是否为数组" class="headerlink" title="如何判断一个对象是否为数组"></a>如何判断一个对象是否为数组</h2><pre><code>1. Array.prototype.isPrototypeOf(obj)方法，判断Array.prototype是不是在obj的原型链中，
如果在，则返回true，否则返回false。

2. obj instanceof Array

3. Object.prototype.toString.call(obj); //(===&quot;[object Array]&quot;)

4.Array.isArray(obj)
</code></pre>
<h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><pre><code>1.macro-task(宏任务)：包括整体代码script、setTimeout、setInterval
2.micro-task(微任务)：Promise.then、process.nextTick
</code></pre>
<h2 id="Http-的持久连接和管线化"><a href="#Http-的持久连接和管线化" class="headerlink" title="Http 的持久连接和管线化"></a>Http 的持久连接和管线化</h2><pre><code>1. 什么是持久连接？
    HTTP1.1规定了默认保持持久连接，数据传输完成也保持TCP连接不断开，等待同域名下
    继续使用这个通道传输数据,在一个TCP连接上传输多个HTTP请求和响应。

    持久连接避免了重新建立连接，大大减少了建立和关闭连接的消耗和延迟，HTTP的连接是建立
    在TCP协议之上的，建立一条TCP连接需要三次握手，TCP连接关闭需要四次挥手，这些都需要时间。

2. 什么是管线化？
    持久连接：
        请求1 ——&gt; 响应1 ——&gt; 请求2 ——&gt; 响应2
    管线化：
        请求1 ——&gt; 请求2 ——&gt; 响应1 ——&gt; 响应2

    管线化机制需要通过持久化连接完成。

    持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后，
    才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。
    实现并行发送请求。

    只有GET和HEAD请求可以进行管线化，而POST有所限制。

    初次建立连接不应启动管线机制，因为对方服务器不一定支持HTTP1.1版本的协议。
</code></pre>
<h2 id="为什么利用多个域名来存储网站资源会更有效？"><a href="#为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="为什么利用多个域名来存储网站资源会更有效？"></a>为什么利用多个域名来存储网站资源会更有效？</h2><pre><code>1.CDN 是构建在网络之上的内容分发网络，可以使用户就近获取资源，减低网络拥塞，提高用户
访问的响应效率以及命中率。

2.突破浏览器的并发限制，同一时间针对同一域名下的请求有一定的数量限制，超过限定数目
的请求会被阻塞。

3.节约cookie带宽

4.减少主域名的连接数，优化页面响应速度

5.防止不必要的安全问题
</code></pre>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><pre><code>基本数据类型：Null、Undefined、String、Boolean、Number
ES6：Symbol
ES10：Bigint（可以突破安全整数限制，安全的存储和操作最大整数之外的整数，不会损失精度）
</code></pre>
<h2 id="牛客学习"><a href="#牛客学习" class="headerlink" title="牛客学习"></a>牛客学习</h2><ul>
<li><p>超链接</p>
<ul>
<li>a 标签的 href 的属性值是 url，里面必须包含协议，没有协议就会解析成相对路径。</li>
</ul>
</li>
<li><p>HTTP 状态码分类：</p>
<ul>
<li>1** 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2** 成功，操作被成功接受并处理。<ul>
<li>200 服务端成功处理了请求并返回内容</li>
</ul>
</li>
<li>3** 重定向，需要进一步的操作以完成请求<ul>
<li>301 永久重定向</li>
<li>302 临时重定向</li>
<li>304 资源未被修改，返回一个 304 状态吗然后从本地缓存中加载请求的资源</li>
</ul>
</li>
<li>4** 客户端错误，请求包含语法错误或无法完成请求。<ul>
<li>404 （页面丢失）未找到资源</li>
<li>403 服务器拒绝请求</li>
<li>408 （请求超时） 服务器等候请求时发生超时</li>
</ul>
</li>
<li>5** 服务器错误，服务器在处理请求的过程中发生错误 + 503 服务器暂时不可用 + 504 服务器内部错误<!--more--></li>
</ul>
</li>
<li><p>HTTP 协议的特征：</p>
<ul>
<li>C/S(客户端/服务器)模式：只要客户端和服务器知道如何处理数据内容，任何类型的数据<br>都可以通过 HTTP 来发送，客户端和服务器指定合适的 MIME-type 内容类型。</li>
<li>简单快速</li>
<li>灵活</li>
<li>无连接：限制每次连接只处理一个请求，收到客户的应答后即断开连接，可以节省传输时间。</li>
<li>无状态：对于事物处理没有记忆能力，意味着如果后续处理需要前面的信息，则必须重传，<br>这样就会导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就会很快。</li>
</ul>
</li>
<li><p>get 和 post 的请求区别？</p>
<ul>
<li>区别一：<ul>
<li>get 重点是从服务器上获取资源</li>
<li>post 重点是向服务器发送数据</li>
</ul>
</li>
<li>区别二：<ul>
<li>get 传输数据通过 url 请求，以 field（字段）=value 的形式放在 url 后，用“？”连接，<br>多个请求数据间用“&amp;”连接，过程用户可见。</li>
<li>post 传输数据放在请求体（request body）中发送给服务器，用户不可见。</li>
</ul>
</li>
<li>区别三：<ul>
<li>get 传输数据大小有限制，但效率较高</li>
<li>post 可以传输大量数据，所以上传文件用 post 方式</li>
</ul>
</li>
<li>区别四：<ul>
<li>get 请求不安全，因为参数直接暴露在 url 上，不能用来传递敏感信息。</li>
<li>post 较 get 安全性较高。</li>
</ul>
</li>
<li>区别五：<ul>
<li>get 方式只能支持 ASCII 字符，向服务传的中文字符可能会乱码。</li>
<li>post 支持标准字符集，可以正确传递中文字符。</li>
</ul>
</li>
<li>区别六：<ul>
<li>get 在浏览器回退是无害的，而 post 会再次提交请求。</li>
</ul>
</li>
<li>区别七<ul>
<li>get 请求会被浏览器主动 cache（缓存），而 post 不会除非手动设置。</li>
</ul>
</li>
</ul>
</li>
<li><p>iframe 有哪些缺点？</p>
<ul>
<li><p>iframe 会阻塞主页面的 onload 事件</p>
</li>
<li><p>通过 oIframe.contentWindow 寻找子 window 对象</p>
</li>
<li><p>通过 window.parent 寻找父级窗体</p>
</li>
<li><p>通过 window.top 寻找顶级窗体</p>
</li>
<li><p>window.location.hash 解决父页面向子页面传值</p>
</li>
<li><p>window.name 解决子页面向父页面传值</p>
</li>
<li><p>不利于 SEO，搜索引擎的检索程序无法解读这种页面（百度 spider 不收录，浏览器对 iframe 框架的兼容问题）</p>
</li>
<li><p>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</p>
</li>
<li><p>如果需要使用 iframe，最好通过 javascript 动态给 iframe 添加 src 属性值。</p>
</li>
</ul>
</li>
<li><p>xhtml 和 html 有什么区别？</p>
<ul>
<li><p>性能方面</p>
<ul>
<li>XHTML 兼容性好，兼容各大浏览器、手机以及 PDA，使浏览器可以快速正确编译网页</li>
</ul>
</li>
<li><p>书写习惯方面</p>
<ul>
<li><p>HTML 标签不区分大小写，XHTML 所有标签必须小写</p>
</li>
<li><p>XHTML 必须成双成对</p>
</li>
<li><p>HTML 对标签顺序要求不严格，XHTML 标签顺序必须正确</p>
</li>
<li><p>等等</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>html 和 xml 的区别？</p>
<ul>
<li><p>xml 被设计用来传输和存储数据，其焦点是数据的内容</p>
</li>
<li><p>html 被设计用来显示数据，其焦点是数据的外观</p>
</li>
<li><p>html 旨在显示信息，而 xml 旨在传输信息</p>
</li>
<li><p>xml 在定义标记时区分大小写，而 html 不区分大小写</p>
</li>
</ul>
</li>
<li><p>link 和@import 的区别：<br><strong>两者都是外部引用 CSS 的方式，但有一定的区别</strong></p>
<pre><code>+ link是XHTML标签，除了加载CSS外，还可以加载其他文件；@import只能加载CSS。

+ 解析到link时，页面会同步加载Css；@import在页面加载完后加载Css。

+ link是XHTML标签，无兼容问题；@import是在**CSS2.1**之后提出的，只有再IE5以上才能识别。

+ link可以js动态引入，@import不行

+ @import的最佳写法： @import url(style.css),其他写法：@import &#39;style.css&#39;、
@import &quot;style.css&quot;、@import url(&#39;style.css&#39;)、@import url(&quot;style.css&quot;)
</code></pre>
</li>
<li><p>viewport</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>// width 设置 viewport 宽度，为一个正整数，或字符串‘device-width’<br>// device-width 设备宽度<br>// height 设置 viewport 高度，一般设置了宽度，会自动解析出高度，可以不用设置<br>// initial-scale 默认缩放比例（初始缩放比例），为一个数字，可以带小数<br>// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数<br>// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数<br>// user-scalable 是否允许手动缩放</p>
<ul>
<li><p>单行文本溢出省略号</p>
<p>overflow: hidden;</p>
<p>text-overflow:ellipsis;</p>
<p>white-space: nowrap;</p>
</li>
<li><p>多行文本溢出省略号</p>
<p>display: -webkit-box;</p>
<p>-webkit-box-orient: vertical;</p>
<p>-webkit-line-clamp: 3;</p>
<p>overflow: hidden;</p>
</li>
<li><p>换行标签</p>
<p>word-wrap: break-word</p>
</li>
</ul>
<h2 id="深度封装-typeof-判断"><a href="#深度封装-typeof-判断" class="headerlink" title="深度封装 typeof 判断"></a>深度封装 typeof 判断</h2><pre><code>function myTypeof(val) &#123;
    var type = typeof(val)
    var res = &#123;
        &#39;[object Object]&#39; : &#39;object&#39;,
        &#39;[object Array]&#39; : &#39;array&#39;,
        &#39;[object Number]&#39; : &#39;object number&#39;,
        &#39;[object String]&#39; : &#39;object string&#39;,
        &#39;[object Boolean]&#39; : &#39;object boolean&#39;
    &#125;
    if (val === null) &#123;
        return &#39;null&#39;
    &#125; else if (type == &#39;object&#39;) &#123;
        var str = Object.prototype.toString.call(val)
        return res[str]
    &#125; else &#123;
        return type
    &#125;
&#125;
</code></pre>
<h2 id="浏览器的-reflow-和-repaint"><a href="#浏览器的-reflow-和-repaint" class="headerlink" title="浏览器的 reflow 和 repaint"></a>浏览器的 reflow 和 repaint</h2><ul>
<li>reflow（回流||重排）：当浏览器上某一个位置的布局发生了改变，浏览器会重新从根部开始计算该节点的</li>
</ul>
<p>布局。比如：向页面中添加、删除某一元素等，dom 节点的宽高位置改变，只要这些操作影响了</p>
<p>页面的元素位置或大小的变化，都会引起 reflow。</p>
<ul>
<li>repaint（重绘）：如果只改变页面元素的颜色、字体等不影响布局的属性时，浏览器会进行 repaint。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由上可见，相比repaint操作，reflow的耗时要更多。只要是动态的对页面进行修改，浏览器的reflow</span><br><span class="line"></span><br><span class="line">和repaint的操作就不可避免，我们要做的就是尽可能的减少浏览器的reflow和repaint的次数。</span><br></pre></td></tr></table></figure>

<h2 id="浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？"><a href="#浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？" class="headerlink" title="浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？"></a>浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？</h2><ul>
<li><p>在线的情况下：浏览器发现 html 头部有 manifest 属性，会请求 manifest 文件，如果是<br>第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并进行离线缓存。如果<br>已经离线存储了，浏览器会使用离线的资源加载页面，然后浏览器会比对新的 manifest 文件<br>与旧的 manifest 文件，如果文件没有发生改变，就不要做任何操作，如果文件改变，就会重新<br>下载文件中的资源并进行离线存储。</p>
</li>
<li><p>离线的情况下：浏览器就直接使用离线存储的资源。</p>
</li>
</ul>
<h2 id="如何清除-token"><a href="#如何清除-token" class="headerlink" title="如何清除 token"></a>如何清除 token</h2><ul>
<li><p>浏览器关闭会出发 <strong>beforeunload</strong> ，<strong>unload</strong> 这两个事件。</p>
</li>
<li><p>浏览器刷新也会触发，还会触发<strong>load</strong>事件</p>
</li>
<li><p>方案一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onbeforeunload = function () &#123;</span><br><span class="line">    localStorage.removeItem(&quot;token&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点： 刷新也会清空 token</p>
</li>
<li><p>方案二</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.onunload = function() &#123;</span><br><span class="line">    localStorage.setItem(&quot;lastTime&quot;,new Date().getTime())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">    let lastTime = localStorage.getItem(&quot;lastTime&quot;);</span><br><span class="line">    const interval = 3 * 1000;</span><br><span class="line">    // 如果时间间隔大于3s，则清除token</span><br><span class="line">    if (!lastTime || new Date().getTime() - lastTime &gt; interval) &#123;</span><br><span class="line">        localStorage.remove(&quot;token&quot;);</span><br><span class="line">        console.log(&quot;remove token&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;time is less than not remove token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>补充<br>可以使用 sessionStorage 代替 localStorage 来存储 token，当关闭浏览器时会自动清除 token，sessionStorage 不是持久化的本地存储，而是会话级别的存储，而 localStorage 是持久化的本地存储，除非主动删除数据，否则数据是不会过期的。</p>
</li>
</ul>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><!--more-->

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举个例子：</span></span><br><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;^13.4.6&quot;</span>, <span class="comment">// 只锁定主版本号 major</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;~13.4.6&quot;</span>, <span class="comment">// 锁定主版本号和次版本号 major + minor</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;13.4.6&quot;</span>,  <span class="comment">// 锁定版本</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;*&quot;</span>,       <span class="comment">// 最新版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// major: 13, minor: 4, patch: 6</span></span><br><span class="line"></span><br><span class="line">$ npm info jquery <span class="comment">// 查看 jquery 信息</span></span><br><span class="line">$ npm view jquery versions <span class="comment">// 查看 jquery 所有版本</span></span><br><span class="line">$ npm list | grep gulp <span class="comment">// 过滤 gulp</span></span><br><span class="line">$ npm outdated <span class="comment">// 查看过期版本</span></span><br><span class="line">$ npm update <span class="comment">//更新版本</span></span><br><span class="line">$ npm cache clean --force <span class="comment">// 清楚缓存</span></span><br><span class="line">$ npm ls <span class="comment">// 查看项目引用了哪些包</span></span><br><span class="line">$ npm unpublish --force <span class="comment">// 从npm卸载包</span></span><br><span class="line"><span class="comment">// 执行顺序</span></span><br><span class="line">$ npm run script1 &amp; npm run script2 <span class="comment">//并行执行</span></span><br><span class="line">$ npm run script1 &amp;&amp; npm run script2 <span class="comment">// 继发执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cross-env: 运行跨平台设置和使用环境变量的脚本</span></span><br><span class="line"><span class="comment">// cross-env可以设置NODE_ENV环境变量，process.env.NODE_ENV === &#x27;production&#x27;</span></span><br><span class="line">$ npm install --save-dev cross-env</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;scripts&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">$ npm config get registry <span class="comment">// 查看当前源</span></span><br><span class="line">$ npm config set registry <span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org //切换镜像源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// npx</span></span><br><span class="line"><span class="comment">// --no-install: 让npx强制使用本地模块，不下载远程模块，如果本地不存在，就会报错</span></span><br><span class="line">$ npx --no-install http-server</span><br><span class="line"><span class="comment">// --ignore-existing: 忽略本地的同名模块，强制安装远程模块</span></span><br><span class="line">$ npx --ignore-existing http-server</span><br></pre></td></tr></table></figure>

<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><ul>
<li><p>客户端的本地存储：</p>
<ul>
<li><p>localStorage - 生命周期永久生效，除非手动删除，否则关闭页面也会存在 - 可以在同一浏览器多窗口共享 - 以键值对的形式存储使用 - 方法： + 存储数据：localStorage.setItem(key, value) + 获取数据：localStorage.getItem(key) + 删除数据：localStorage.removeItem(key) + 删除所有数据：localStorage.clear()</p>
</li>
<li><p>sessionStorage</p>
<ul>
<li><p>声明周期为关闭浏览器窗口</p>
</li>
<li><p>在同一个窗口中数据可以共享</p>
</li>
<li><p>以键值对的形式存储</p>
</li>
<li><p>方法：</p>
<ul>
<li>存储数据：sessionStorage.setItem(key, value)</li>
<li>获取数据：sessionStorage.getItem(key)</li>
<li>删除数据：sessionStorage.removeItem(key)</li>
<li>删除所有数据：sessionStorage.clear()</li>
</ul>
<p><a target="_blank" rel="noopener" href='https://www.cnblogs.com/pengc/p/8714475.html'>localStorage 和 sessionStorage</a></p>
<p><a target="_blank" rel="noopener" href='https://www.cnblogs.com/8023-CHD/p/11067141.html'>cookie 和 session</a></p>
</li>
</ul>
</li>
<li><p>IndexDB 离线存储，当网络断开，可以从浏览器中读取数据，用来做一些离线应用</p>
</li>
<li><p>Cookie</p>
<ul>
<li>包含字段<ul>
<li>name: cookie 名称</li>
<li>value: 值</li>
<li>domain: cookie 生效的域名</li>
<li>path: cookie 生效的路径</li>
<li>expires/max-age: cookie 过期时间</li>
<li>size: 大小</li>
<li>HttpOnly: 用户端不可更改</li>
</ul>
</li>
<li>存储用户信息，通过在客户端记录信息确定用户身份，最大为 4kb</li>
<li>会话 Cookie，若不设置过期时间，表示这个 cookie 的生命周期为浏览器会话期间，浏览器<br>关闭，cookie 就消失，会话 cookie 会保存在内存中而不是硬盘上。</li>
<li>持久 Cookie，若设置了过期时间，浏览器会把 cookie 保存在硬盘上，关闭浏览器仍然有效直到<br>超过设定的过期时间。</li>
<li>cookie 数据始终在同源的 http 请求中携带(即使不需要)，即会在浏览器和服务器之间来回传递。</li>
<li>Cookie 具有不可跨域名性，例如浏览器访问百度不会带上谷歌的 cookie</li>
</ul>
</li>
</ul>
</li>
<li><p>服务端的存储：</p>
<ul>
<li>Session<ul>
<li>Session 服务器端一种记录客户端状态的机制</li>
<li>cookie 数据存放在客户的浏览器上，session 将数据存放在服务器端</li>
<li>Session 相对 Cookie 来说比较安全，别人可以分析本地存放的 cookie 进行 cookie 欺骗</li>
<li>Session 会在一定时间内保存在服务器上，访问量较多的时候会比较占用服务器的性能，<br>考虑到减轻服务器性能方面的时候，应当使用 cookie</li>
<li>可以将登陆等重要信息保存在 session，其他信息放在 cookie 中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="localStorage-超过最大限制（5M）怎么处理？"><a href="#localStorage-超过最大限制（5M）怎么处理？" class="headerlink" title="localStorage 超过最大限制（5M）怎么处理？"></a>localStorage 超过最大限制（5M）怎么处理？</h2><ul>
<li><p>localstorage 一般最大容量为 5M，意思是每个域名（假如为 a.com）下最大 localstorage 容量为 5M，我们可以通过 iframe 创建 b.com 域框架用于存储 a.com 剩下的数据，然后通过 postMessage 读写数据。</p>
<ul>
<li>通常对于不同页面的脚本，只有在同源策略下才能通信，但是 window.postMessage(message,targetOrigin)方法提供了一种受控机制来规避次限制。</li>
<li>而且 localStorage 本身定位也不是大数据量的存储方案</li>
</ul>
</li>
<li><p>浏览器提供了大数据量的本地存储的方案：IndexedDB</p>
<ul>
<li>一般存储数据大小在 250M 以上</li>
<li>可以使用 localforage 插件（yarn add localforage），api 基本和 localStorage 类似，学习成本低</li>
</ul>
</li>
</ul>
<h2 id="URI-和-URL-有什么区别？"><a href="#URI-和-URL-有什么区别？" class="headerlink" title="URI 和 URL 有什么区别？"></a>URI 和 URL 有什么区别？</h2><ul>
<li><p>URL(Uniform Resource Identifier): 统一资源定位符</p>
<ul>
<li>如：<a target="_blank" rel="noopener" href="https://upos-sz-staticks3.bilivideo.com/cmaskboss/164203142_30_1.jpg">https://upos-sz-staticks3.bilivideo.com/cmaskboss/164203142_30_1.jpg</a></li>
</ul>
</li>
<li><p>URI(Uniform Resource Locator): 统一资源标识符</p>
<ul>
<li>如：164203142_30_1.jpg</li>
</ul>
</li>
<li><p>URN(Uniform Resource Name): 统一资源名称</p>
<ul>
<li>如：urn:isbn:9787115318893 (国际标准图书编号)，类似身份证</li>
</ul>
</li>
<li><p>URL 是 URI 的子集</p>
</li>
</ul>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><!--more-->

<pre><code>Date.now()  //获取当前时间毫秒数
var dt = new Date() //构造一个实例对象
dt.getTime()    //获取毫秒数
dt.getFullYear() //年
dt.getMonth()   //月（0-11）
dt.getDate()    //日 （0-31）
dt.getHours()   //小时（0-23）
dt.getMinutes() //分钟（0-59）
dt.getSeconds() //秒（0-59）
dt.getDay()     //星期几（0-6）
</code></pre>
<h2 id="如何监听未处理的异常"><a href="#如何监听未处理的异常" class="headerlink" title="如何监听未处理的异常"></a>如何监听未处理的异常</h2><ul>
<li>try…catch<ul>
<li>无法捕捉到语法错误，只能捕捉运行时错误</li>
<li>可以拿到出错的信息(出错的文件，行号，列号)</li>
</ul>
</li>
<li>window.onerror<ul>
<li>由于 try…catch 只能捕获块里面的错误，全局的一些错误可以用 window.onerror</li>
</ul>
</li>
<li>window.addEventListener(‘error’,callback):捕获资源错误</li>
<li>window.addEventListener(‘unhandledrejection’,callback):捕获 promise 类型错误</li>
<li>vue.config.errorHandler: vue 错误</li>
<li>componentDidCatch：错误边界函数</li>
</ul>
<h2 id="浏览器如何缓存"><a href="#浏览器如何缓存" class="headerlink" title="浏览器如何缓存"></a>浏览器如何缓存</h2><ul>
<li>html meta 标签控制缓存<ul>
<li><code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cahce&quot;&gt;</code> //告诉浏览器当前页面不被缓存</li>
</ul>
</li>
<li>http 头信息控制缓存<ul>
<li>Expires ——&gt; 过期时间</li>
<li>Cache-Control 响应头信息(no-cache、no-store、max-age、public)</li>
</ul>
</li>
</ul>
<h2 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h2><h2 id="for-遍历"><a href="#for-遍历" class="headerlink" title="for 遍历"></a>for 遍历</h2><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var flag;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        flag = 1;
        var newLen = newStr.length;
        for(var j=0; j&lt;newLen; j++)&#123;
            if(str[i] == newStr[j])&#123;
                flag = 0;
                break;
            &#125;
        &#125;
        if(flag)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h2 id="indexOf-方法"><a href="#indexOf-方法" class="headerlink" title="indexOf 方法"></a>indexOf 方法</h2><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(newStr.indexOf(str[i])==-1)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h2 id="search-方法"><a href="#search-方法" class="headerlink" title="search 方法"></a>search 方法</h2><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(newStr.search(str[i])==-1)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h2 id="对象属性法"><a href="#对象属性法" class="headerlink" title="对象属性法"></a>对象属性法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeRepeatStr</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> newStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> len = str.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[str[i]]) &#123;</span><br><span class="line">      newStr = newStr + str[i];</span><br><span class="line">      <span class="comment">//注意，这里的1是给对象属性赋值，这个值可以任意取。意思是把每个遍历的字符作为对象属性并赋值保存，保证该属性的唯一性</span></span><br><span class="line">      obj[str[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步和异步的区别，怎么异步加载-javascript"><a href="#同步和异步的区别，怎么异步加载-javascript" class="headerlink" title="同步和异步的区别，怎么异步加载 javascript?"></a>同步和异步的区别，怎么异步加载 javascript?</h2><!--more-->

<ul>
<li><p>同步模式<br>同步模式，又称阻塞模式，javascript 在默认情况下是会阻塞加载的，当前面的</p>
<p>javascript 请求没有处理和执行完时，会阻止浏览器的后续处理</p>
</li>
<li><p>异步模式<br>异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理</p>
</li>
<li><p>异步加载 JavaScript</p>
<ul>
<li><p>动态添加 script 标签</p>
</li>
<li><p>defer</p>
</li>
<li><p>async</p>
</li>
</ul>
<p>defer 属性和 async 都是属于 script 标签上面的属性，两者都能实现 JavaScript 的</p>
<p>异步加载。不同之处在于：async 在异步加载完成的时候就马上开始执行了，defer 会等到</p>
<p>html 加载完毕之后再执行。</p>
</li>
</ul>
<h2 id="Chrome-打开一个页面需要启动多少线程？分别有哪些线程？"><a href="#Chrome-打开一个页面需要启动多少线程？分别有哪些线程？" class="headerlink" title="Chrome 打开一个页面需要启动多少线程？分别有哪些线程？"></a>Chrome 打开一个页面需要启动多少线程？分别有哪些线程？</h2><!--more-->

<pre><code>最新Chrome浏览器包括：一个浏览器(Browser)主线程、一个GPU进程、一个网络(NetWork)
进程、多个渲染进程和多个插件进程
</code></pre>
<ul>
<li><p>线程：</p>
<ul>
<li><p>浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。</p>
</li>
<li><p>渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，<br>排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个<br>Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
</li>
<li><p>GPU 进程：Chrome 刚开始的时候是没有 GPU 进程的，而 GPU 使用的使用初衷是为了实现<br>3D CSS 效果，之后随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 称为<br>浏览器普遍的需求，最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
</li>
<li><p>网络进程：主要负责网页的网络资源加载，之前是作为一个模块运行在浏览器进程里面<br>的，最近才独立出来，称为一个单独的进程。</p>
</li>
<li><p>插件进程：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以<br>保证插件进程崩溃不会对浏览器和页面造成影响。</p>
</li>
</ul>
</li>
</ul>
<h2 id="CommonJS、AMD、CMD-是什么及区别？"><a href="#CommonJS、AMD、CMD-是什么及区别？" class="headerlink" title="CommonJS、AMD、CMD 是什么及区别？"></a>CommonJS、AMD、CMD 是什么及区别？</h2><!--more-->

<ul>
<li>CommonJS 是服务器端 js 模块化的规范，NodeJS 是这种规范的实现，加载模块使用 require 方法，</li>
</ul>
<p>导出使用 exports</p>
<ul>
<li>AMD 和 CMD 都是为了解决浏览器端模块化问题而产生的，AMD 规范对应的库 Require.js,</li>
</ul>
<p>CMD 规范对应的库 Sea.js</p>
<ul>
<li><p>AMD 和 CMD 的区别:</p>
<ul>
<li><p>AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</p>
</li>
<li><p>CMD 推崇就近依赖，只有在用到的某个模块的时候再去 require</p>
</li>
<li><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行，但 RequireJS(AMD)从 2.0 开始，也改为延迟执行</p>
</li>
<li><p>AMD 的 API 默认是一个当多个，CMD 的 API 严格区分，推崇职责单一</p>
</li>
</ul>
</li>
</ul>
<h2 id="js-加载-浏览器加载-时间线"><a href="#js-加载-浏览器加载-时间线" class="headerlink" title="js 加载(浏览器加载)时间线"></a>js 加载(浏览器加载)时间线</h2><pre><code>理论：它是根据js出生的那一刻开始记录的一系列浏览器按照顺序做的事，

就是加载顺序及一些优化
</code></pre>
 <!--more-->

<ul>
<li><p>创建 Document 对象，开始解析 web 页面，这个阶段 document.readyState = ‘loading’</p>
</li>
<li><p>遇见 link 外部 css，css 资源异步下载，并继续解析文档，下载和解析都不会阻塞构建 dom 树</p>
</li>
<li><p>遇见 script 外部 js，并且没有设置 async、defer，浏览器同步加载，并阻塞构建 dom 树，等待 js 加载完成并执行该脚本，然后继续解析文档</p>
</li>
<li><p>遇见 script 外部 js，并且设置了 async、defer，浏览器创建线程 加载，并继续解析文档，对于 async 属性的脚本，加载完成后立即执行。（异步加载禁止使用 document.write(),它会清除文档流）</p>
</li>
<li><p>遇见 img 等，先正常解析 dom 结构，然后浏览器异步加载 src，并继续解析文档</p>
</li>
<li><p>文档解析完成，document.readyState = ‘interactive’</p>
</li>
<li><p>文档解析完成后，所有设置 defer 的脚本会按照顺序执行。（也禁止使用 document.write()）</p>
</li>
<li><p>之后 document 对象触发 DOMContentLoaded 事件，标志程序执行从同步脚本执行阶段，转化为事件驱动阶段</p>
</li>
<li><p>当所有 async 的脚本加载并执行后、img 等加载完成后，document.readyState = ‘complete’,这时 window 对象触发 load 事件。</p>
</li>
<li><p>…</p>
</li>
</ul>
<h2 id="异步加载-js"><a href="#异步加载-js" class="headerlink" title="异步加载 js"></a>异步加载 js</h2><pre><code>javascript 异步加载的三种方案:
- defer
- async
- 动态创建 script，插入到 dom 中，加载完毕后 callback。
  简单实例：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var script = document.createElement(&#x27;script&#x27;)</span><br><span class="line"></span><br><span class="line">script.type = &#x27;text/javascript&#x27;</span><br><span class="line"></span><br><span class="line">script.src = demo.js</span><br><span class="line"></span><br><span class="line">script.onload = function() &#123; //兼容性很好，除了IE</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.head.appendChild(script)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//动态加载函数封装</span><br><span class="line">function asyncLoaded(url,callback)&#123;</span><br><span class="line">    var script = document.createElement(&quot;script&quot;);</span><br><span class="line">//  script.src = url;   假如说网速非常好，直接执行完成了，后面就监听不到状态的改变了</span><br><span class="line">    if(script.readyState)&#123;</span><br><span class="line">        script.onreadystatechange = function()&#123;</span><br><span class="line">            if(script.readyState == &quot;complete&quot; || script.readyState ==&quot;loaded&quot;)&#123;</span><br><span class="line">//  执行某个函数</span><br><span class="line">                callback()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        script.onload = function()&#123;</span><br><span class="line">//  执行某个函数</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = url;    //异步的过程</span><br><span class="line">    document.head.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncLoaded(&#x27;demo.js&#x27;, function()&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="async-和-defer-对比？"><a href="#async-和-defer-对比？" class="headerlink" title="async 和 defer 对比？"></a>async 和 defer 对比？</h2><pre><code>async和defer的解析过程：
· 浏览器解析到async的script标签，不会中断html解析，并行下载脚本，下载完成后中断html解析并执行脚本
· 浏览器解析到defer的script标签，不会中断html解析，并下下载脚本，当浏览器解析完html、DOMContentLoaded事件即将触发时执行脚本

async和defer的区别：
· async和defer仅对外部脚本有效
· async加载完立即执行，defer在html解析完成且dom构建完毕后延迟执行
· 如果存在多个js脚本，async那个先下载完成哪个先执行（无序），defer按照js脚本的书写顺序执行
· 同时存在async和defer时，defer不起作用
· DOMContentLoaded事件会等待defer的脚本执行完才触发
</code></pre>
<h2 id="js-请说说写一个拖拽组件的思路及注意事项"><a href="#js-请说说写一个拖拽组件的思路及注意事项" class="headerlink" title="[js] 请说说写一个拖拽组件的思路及注意事项?"></a>[js] 请说说写一个拖拽组件的思路及注意事项?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先，其实拖拽效果的思路是很简单的。主要就是三个步骤：</span><br><span class="line"></span><br><span class="line">1.onmousedown的时候，启动可拖拽事件，记录被拖拽元素的原始坐标参数。</span><br><span class="line"></span><br><span class="line">2.onmousemove的时候，实时记录鼠标移动的距离，结合被拖拽元素第一阶段的坐标参数，计算并设置新的坐标值。</span><br><span class="line"></span><br><span class="line">3.onmouseup的时候，关闭可拖拽事件，记录新的坐标值。</span><br><span class="line"></span><br><span class="line">注意：这里主要是通过绝对定位的top和left来确定元素的位置的，因此被拖拽元素的css一定要设置绝对定位。</span><br></pre></td></tr></table></figure>

<h2 id="为什么-try-catch-不能捕获到-promise-的错误？"><a href="#为什么-try-catch-不能捕获到-promise-的错误？" class="headerlink" title="为什么 try/catch 不能捕获到 promise 的错误？"></a>为什么 try/catch 不能捕获到 promise 的错误？</h2><ul>
<li><p>try-catch 主要用于捕获同步函数的异常，如果 try 里面的异步方法出现了异常，此时 catch 是无法捕获到异常的。ES6 中 Promise 对象的实例提供了 catch() 方法，表示异步捕获异常。</p>
</li>
<li><p>原因：当异步函数抛出异常时，对于宏任务而言，执行函数时已经将该函数推入栈，此时并不在 try-catch 所在的栈，所以 try-catch 并不能捕获到错误。对于微任务而言，比如 promise，promise 的构造函数的异常只能被自带的 reject 也就是.catch 函数捕获到。</p>
</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li><p>箭头函数的特点</p>
<ol>
<li>没有 arguments</li>
<li>无法通过 apply、call、bind 改变 this</li>
<li>某些肩头函数代码难以阅读</li>
</ol>
</li>
</ul>
<h2 id="for…in-和-for…of-有什么区别"><a href="#for…in-和-for…of-有什么区别" class="headerlink" title="for…in 和 for…of 有什么区别"></a>for…in 和 for…of 有什么区别</h2><ul>
<li><p>key 和 value</p>
<ol>
<li>for…in 遍历得到 key</li>
<li>for…of 遍历得到 value</li>
</ol>
</li>
<li><p>适用于不同的数据类型</p>
<ol>
<li>遍历对象： for…in 可以，for…of 不可以</li>
<li>遍历 Map、Set：for…of 可以，for…in 不可以</li>
<li>遍历 generator：for…of 可以，for…in 不可以</li>
</ol>
</li>
<li><p>可枚举 vs 可迭代</p>
<ol>
<li>for…in 用于可枚举（Object.getOwnPropertyDescriptors(obj)）数据，如对象、数组、字符串</li>
<li>for…of 用于可迭代(arr[Symbol.iterator])数据，如数组、字符串、Map、Set</li>
</ol>
</li>
</ul>
<h2 id="for-await…of-有什么作用？"><a href="#for-await…of-有什么作用？" class="headerlink" title="for await…of 有什么作用？"></a>for await…of 有什么作用？</h2><ul>
<li>for await…of 用于遍历多个 Promise</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPromise</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="title function_">createPromise</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> p2 = <span class="title function_">createPromise</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="keyword">const</span> p3 = <span class="title function_">createPromise</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> list = [p1, p2, p3];</span><br><span class="line">  <span class="keyword">const</span> list2 = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ---------------同时调用----------------</span></span><br><span class="line">  <span class="comment">// 方式一</span></span><br><span class="line">  <span class="comment">// const res1 = await p1;</span></span><br><span class="line">  <span class="comment">// console.log(res1);</span></span><br><span class="line">  <span class="comment">// const res2 = await p2;</span></span><br><span class="line">  <span class="comment">// console.log(res2);</span></span><br><span class="line">  <span class="comment">// const res3 = await p3;</span></span><br><span class="line">  <span class="comment">// console.log(res3);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方式二</span></span><br><span class="line">  <span class="comment">// Promise.all(list).then((res) =&gt; console.log(res));</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方式三</span></span><br><span class="line">  <span class="comment">// for await (let res of list) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(res);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// -----------------逐步调用---------------</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> list2) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">createPromise</span>(value);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="JS-严格模式有什么特点？"><a href="#JS-严格模式有什么特点？" class="headerlink" title="JS 严格模式有什么特点？"></a>JS 严格模式有什么特点？</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>; <span class="comment">//全局开启</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>; <span class="comment">// 局部开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点<ol>
<li>全局变量必须先声明</li>
<li>禁止使用 with</li>
<li>this 指向 undefined 而不是 window</li>
<li>函数参数不能重名</li>
<li>eval 有单独作用域，不推荐使用</li>
</ol>
</li>
</ul>
<h2 id="HTTP-跨域请求事为什么发送-options-请求？"><a href="#HTTP-跨域请求事为什么发送-options-请求？" class="headerlink" title="HTTP 跨域请求事为什么发送 options 请求？"></a>HTTP 跨域请求事为什么发送 options 请求？</h2><ul>
<li>跨域请求<ol>
<li>浏览器同源策略</li>
<li>同源策略一般限制 ajax 网络请求，不能跨域请求 server</li>
<li>不会限制<code>&lt;link&gt; &lt;img&gt; &lt;script&gt; &lt;iframe&gt;</code> 加载第三方资源</li>
</ol>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSONP</span></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">onSuccess</span> = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.aaa.com/api/getData&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="comment">// https://www.aaa.com/api/getData 返回一段字符串，交给前端执行达到传递数据的目的</span></span><br><span class="line"><span class="string">&#x27;onSuccess(&#123;data: &#123;/* 数据内容 */&#125;&#125;)&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CORS 配置允许跨域（服务端）</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://localhost:8080&#x27;</span>); <span class="comment">// 或者 *</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;X-Requested-With&#x27;</span>);</span><br><span class="line">response.<span class="title function_">setHeader</span>(</span><br><span class="line">  <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;</span></span><br><span class="line">);</span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>); <span class="comment">// 允许跨域接受cookie</span></span><br></pre></td></tr></table></figure>

<ul>
<li>答案<ol>
<li>options 请求，是跨域请求之前的预检查</li>
<li>浏览器自行发起的</li>
<li>不会影响实际的功能</li>
</ol>
</li>
</ul>
<h2 id="JS-内存泄漏如何检测？场景有哪些？"><a href="#JS-内存泄漏如何检测？场景有哪些？" class="headerlink" title="JS 内存泄漏如何检测？场景有哪些？"></a>JS 内存泄漏如何检测？场景有哪些？</h2><ul>
<li><p>垃圾回收 GC</p>
<ol>
<li>引用计数</li>
<li>标记清除</li>
</ol>
</li>
<li><p>场景</p>
<ol>
<li>意外的全局变量</li>
<li>遗忘的定时器</li>
<li>使用不当的闭包</li>
<li>遗漏的 DOM 元素</li>
<li>网络回调</li>
</ol>
</li>
<li><p>内存泄漏属于非预期的，闭包是主动行为，闭包非内存泄漏</p>
</li>
<li><p>可以使用 chrome devtools 的 performance 和 memory 工具类检测 js 内存</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dasusu/p/12200176.html">参考</a></p>
</li>
</ul>
<h2 id="vdom-真的很快吗？"><a href="#vdom-真的很快吗？" class="headerlink" title="vdom 真的很快吗？"></a>vdom 真的很快吗？</h2><ul>
<li><p>js 直接操作 dom 才是最快的，vdom 并不快</p>
</li>
<li><p>但是 vdom 是最合适“数据驱动视图”的技术方案</p>
</li>
</ul>
<h2 id="遍历数组，for-和-forEach-哪个快？"><a href="#遍历数组，for-和-forEach-哪个快？" class="headerlink" title="遍历数组，for 和 forEach 哪个快？"></a>遍历数组，for 和 forEach 哪个快？</h2><ul>
<li><p>时间复杂度都是 O(n)</p>
</li>
<li><p>结论：</p>
<ol>
<li>for 更快</li>
<li>forEach 每次都要创建一个函数来调用，而 for 不会创建函数</li>
<li>函数需要独立的作用域，会有额外的开销</li>
</ol>
</li>
</ul>
<h2 id="nodejs-如何开启进程，进程如何通讯？"><a href="#nodejs-如何开启进程，进程如何通讯？" class="headerlink" title="nodejs 如何开启进程，进程如何通讯？"></a>nodejs 如何开启进程，进程如何通讯？</h2><ul>
<li><p>进程 process VS 线程 thread</p>
<ol>
<li>进程： 进行资源分配和调度的最小单元，有独立内存空间</li>
<li>线程： 进行运算调度的最小单元，共享进程内存空间</li>
<li>js 是单线程的，但可以多进行执行，如 、WebWorker</li>
</ol>
</li>
<li><p>为何需要多进程？</p>
<ul>
<li>多核 CPU，更适合处理多进程</li>
<li>内存较大，多个进程才能更好的利用（单进程有内存上线）</li>
</ul>
</li>
<li><p>开启进程两种方法 child_process.fork， cluster.fork</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">fork</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">url</span> === <span class="string">&#x27;/xxx&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 开启子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> computeProcess = <span class="title function_">fork</span>(<span class="string">&#x27;./compute.js&#x27;</span>);</span><br><span class="line">    computeProcess.<span class="title function_">send</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    computeProcess.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&#x27;sum is&#x27;</span> + data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    computeProcess.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子进程因报错而退出&#x27;</span>);</span><br><span class="line">      computeProcess.<span class="title function_">kill</span>();</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;localhost: 3000 starting...&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compute.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子进程id&#x27;</span>, process.<span class="property">pid</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子进程接收到的数据&#x27;</span>, data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> sum = <span class="title function_">getSum</span>();</span><br><span class="line"></span><br><span class="line">  process.<span class="title function_">send</span>(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cpuCoreLength = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).<span class="title function_">cpus</span>().<span class="property">length</span>;</span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.<span class="property">isMaster</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpuCoreLength; i++) &#123;</span><br><span class="line">    cluster.<span class="title function_">fork</span>(); <span class="comment">// 开启子进程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">worker</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子进程退出&#x27;</span>);</span><br><span class="line">    cluster.<span class="title function_">fork</span>(); <span class="comment">// 进程守护</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  server.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请描述-JS-Bridge-的原理"><a href="#请描述-JS-Bridge-的原理" class="headerlink" title="请描述 JS Bridge 的原理"></a>请描述 JS Bridge 的原理</h2><ul>
<li><p>什么是 JS Bridge？</p>
<ul>
<li>js 无法直接调用 native API</li>
<li>需要通过一些特定的“格式”来调用</li>
<li>这些“格式”就统称 JS-Bridge，例如微信 JSSDK</li>
</ul>
</li>
<li><p>JS Bridge 的常见实现方式</p>
<ul>
<li>注册全局 API</li>
<li>URL Scheme</li>
</ul>
</li>
</ul>
<h2 id="requestIdleCallback-和-requestAnimationFrame-有什么区别？"><a href="#requestIdleCallback-和-requestAnimationFrame-有什么区别？" class="headerlink" title="requestIdleCallback 和 requestAnimationFrame 有什么区别？"></a>requestIdleCallback 和 requestAnimationFrame 有什么区别？</h2><pre><code>requestIdleCallback(callback, timeout):
· 低优先级
· 兼容性不好
· 执行时机：浏览器空闲时被调用
· 指定timeout，回调任务就会被放进事件循环队列，强制执行，但是会影响性能
requestAnimationFrame(callback):
· 高优先级
· 执行时机：下次重绘前执行传入的回调函数

- 补充
  - 两者都是宏任务(其实也算不上，重要的是执行时机)
</code></pre>
<h2 id="移动端-H5-click-有-300ms-延迟，如何解决？"><a href="#移动端-H5-click-有-300ms-延迟，如何解决？" class="headerlink" title="移动端 H5 click 有 300ms 延迟，如何解决？"></a>移动端 H5 click 有 300ms 延迟，如何解决？</h2><ul>
<li><p>背景：double tap to zoom</p>
</li>
<li><p>初期解决方案 FastClick</p>
<ul>
<li>监听 touchend 事件(touchstart touchend 会先于 click 触发)</li>
<li>使用自定义 DOM 事件模拟一个 click 事件</li>
<li>把默认的 click 事件(300ms 之后触发)禁止掉</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;load&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">FastClick</span>.<span class="title function_">attach</span>(<span class="variable language_">document</span>.<span class="property">body</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>现代浏览器的改进（width=device-width）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;id=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="网络请求中，token-和-cookie-有什么区别？"><a href="#网络请求中，token-和-cookie-有什么区别？" class="headerlink" title="网络请求中，token 和 cookie 有什么区别？"></a>网络请求中，token 和 cookie 有什么区别？</h2><ul>
<li><p>cookie</p>
<ul>
<li>http 无状态，每次请求都要带 cookie，以帮助识别身份</li>
<li>服务端也可以向客户端 set-cookie，cookie 大小限制 4kb</li>
<li>默认有跨域限制：不可跨域共享、传递 cookie</li>
</ul>
</li>
<li><p>token vs cookie</p>
<ul>
<li>cookie 是 http 规范，而 token 是自定义传递</li>
<li>cookie 会默认被浏览器存储，而 token 需自己存储</li>
<li>token 默认没有跨域限制</li>
</ul>
</li>
<li><p>JWT(JSON Web Token)</p>
<ul>
<li>前端发起登录，后端验证成功之后，返回一个加密的 token</li>
<li>前端自行存储这个 token（其中包含了用户信息，加密了）</li>
<li>以后访问服务端的接口，都带着这个 token，作为用户信息</li>
</ul>
</li>
</ul>
<h2 id="Session-和-JWT-哪个更好？"><a href="#Session-和-JWT-哪个更好？" class="headerlink" title="Session 和 JWT 哪个更好？"></a>Session 和 JWT 哪个更好？</h2><ul>
<li><p>session</p>
<ul>
<li>优点<ul>
<li>原理简单，易于学习</li>
<li>用户信息存储在服务端，可以快速封禁某个用户</li>
</ul>
</li>
<li>缺点<ul>
<li>占用服务端内存，硬件成本高</li>
<li>多进程，多服务器时，不好同步-需要使用第三方缓存，如 redis</li>
<li>默认有跨域限制</li>
</ul>
</li>
</ul>
</li>
<li><p>JWT</p>
<ul>
<li>优点<ul>
<li>不占用服务器内存</li>
<li>多进程、多服务器不受影响</li>
<li>没有跨域限制</li>
</ul>
</li>
<li>缺点<ul>
<li>用户信息存储在客户端，无法快速封禁某用户</li>
<li>万一服务器密钥被泄漏，则用户信息全部丢失</li>
<li>token 体积一般大于 cookie，会增加请求的数据量</li>
</ul>
</li>
</ul>
</li>
<li><p>答案</p>
<ul>
<li>如有严格管理用户信息的需求（保密、快速封禁），推荐 session</li>
<li>如没有特殊要求，则使用 JWT</li>
</ul>
</li>
</ul>
<h2 id="如何实现-SSO-单点登录？"><a href="#如何实现-SSO-单点登录？" class="headerlink" title="如何实现 SSO 单点登录？"></a>如何实现 SSO 单点登录？</h2><ul>
<li><p>基于 cookie（主域名相同）</p>
<ul>
<li>cookie 默认不可跨域共享，但有些情况下可设置共享</li>
<li>主域名相同，如<a target="_blank" rel="noopener" href="http://www.baidu.com,image.baidu.com/">www.baidu.com,image.baidu.com</a></li>
<li>设置 cookie domain 为主域名，即可共享 cookie</li>
</ul>
</li>
<li><p>SSO（主域名不相同，cookie 无法共享）</p>
<ul>
<li><img src="/images/md_img/sso.jpg" alt="sso"></li>
</ul>
</li>
</ul>
<h2 id="defer-和-async-有什么区别？"><a href="#defer-和-async-有什么区别？" class="headerlink" title="defer 和 async 有什么区别？"></a>defer 和 async 有什么区别？</h2><ul>
<li>区别 <img src="/images/md_img/defer_async.jpg" alt="区别"></li>
</ul>
<h2 id="prefetch-和-dns-prefetch-有什么区别？"><a href="#prefetch-和-dns-prefetch-有什么区别？" class="headerlink" title="prefetch 和 dns-prefetch 有什么区别？"></a>prefetch 和 dns-prefetch 有什么区别？</h2><ul>
<li>preload 资源在当前页面使用，会优先加载</li>
<li>prefetch 资源在未来页面使用，空闲时加载</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;other.js&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>dns-prefetch 即 DNS 预查询</li>
<li>preconnect 即 DNS 预连接</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.xxx.com/&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.xxx.com&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Map-和-WeakMap-的区别和应用场景？"><a href="#Map-和-WeakMap-的区别和应用场景？" class="headerlink" title="Map 和 WeakMap 的区别和应用场景？"></a>Map 和 WeakMap 的区别和应用场景？</h2><ul>
<li><p>Map：</p>
<ul>
<li>key 可以是任意数据类型</li>
<li>key 是强引用，只要键不释放，就会一直占着内存不会被 GC</li>
<li>能轻易转化为数据（扩展运算符），weakmap 做不到</li>
</ul>
</li>
<li><p>WeakMap:</p>
<ul>
<li>key 只能是非 null 的对象引用</li>
<li>key 是弱引用，没有其他引用存在时会被 GC</li>
<li>key 随时会被回收，所以 key 不可枚举，没有 size 等属性</li>
</ul>
</li>
<li><p>Map 场景：</p>
<ul>
<li>频繁的读写和查询</li>
<li>键值复杂的情况</li>
</ul>
</li>
</ul>
<h2 id="你知道哪些前端攻击？该如何预防？"><a href="#你知道哪些前端攻击？该如何预防？" class="headerlink" title="你知道哪些前端攻击？该如何预防？"></a>你知道哪些前端攻击？该如何预防？</h2><ul>
<li><p>xss</p>
<ul>
<li>Cross Site Script 跨站脚本攻击</li>
<li>手段：将 js 代码插入到网页内容中，渲染时执行 js 代码</li>
<li>预防：特殊字符替换（前端或后端）</li>
</ul>
</li>
<li><p>csrf</p>
<ul>
<li><p>Cross Site Request Forgery 跨站请求伪造</p>
</li>
<li><p>手段：诱导用户去访问另一个网站的接口，伪造请求</p>
</li>
<li><p>预防：严格的跨域限制 + 验证码机制</p>
</li>
<li><p>csrf 详细过程</p>
<ul>
<li>用户登录 A 网站，有了 A 网站的 cookie</li>
<li>诱导用户到 B 网站，并发起 A 网站的请求</li>
<li>A 网站的 API 发现有 cookie，认为是用户自己操作的</li>
</ul>
</li>
<li><p>csrf 预防手段</p>
<ul>
<li>严格的跨域请求限制，如判断 referer（请求来源）</li>
<li>为 cookie 设置 SameSite，禁止跨域传递 cookie</li>
<li>关键接口使用短信验证码</li>
</ul>
</li>
</ul>
</li>
<li><p>点击劫持</p>
<ul>
<li>click jacing</li>
<li>手段：诱导界面上蒙一个透明 iframe，诱导用户点击</li>
<li>预防：让 iframe 不能跨域加载</li>
</ul>
</li>
<li><p>DDos</p>
<ul>
<li>Distribute denial-of-service 分布式拒绝服务</li>
<li>手段：分布式的、大规模的流量访问，使服务器瘫痪</li>
<li>预防：软件层不好做，需硬件预防（如阿里云 WAF）</li>
</ul>
</li>
<li><p>SQL 注入</p>
<ul>
<li>手段：提交内容时写入 SQL 语句，破环数据库</li>
<li>预防：处理输入的内容，替换特殊字符</li>
</ul>
</li>
</ul>
<h2 id="重绘-repaint-重排-reflow-有什么区别？"><a href="#重绘-repaint-重排-reflow-有什么区别？" class="headerlink" title="重绘 repaint 重排 reflow 有什么区别？"></a>重绘 repaint 重排 reflow 有什么区别？</h2><ul>
<li><p>重绘 repaint</p>
<ul>
<li>元素外观改变，如颜色、背景色</li>
<li>但元素的尺寸、定位不变，不会影响到其他元素的位置</li>
</ul>
</li>
<li><p>重排 relfow</p>
<ul>
<li>重新计算尺寸和布局，可能会影响其他元素的位置</li>
<li>如元素高度增加，可能会使相邻元素位置下移</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li>重排比重绘影响更大，消耗更大</li>
<li>所以，要尽量避免无意义的重排</li>
</ul>
</li>
<li><p>减少重排的方法</p>
<ul>
<li>集中修改样式，或直接切换 css、class</li>
<li>修改之前先设置 display: none,脱离文档流</li>
<li>使用 BFC 特性，不影响其他元素位置</li>
<li>频发触发（resize、scroll）使用节流和防抖</li>
<li>使用 createDocumentFragment 批量操作 DOM</li>
<li>优化动画，使用 CSS3 和 requestAnimationFrame</li>
</ul>
</li>
</ul>
<h2 id="如何实现网页多标签通讯？"><a href="#如何实现网页多标签通讯？" class="headerlink" title="如何实现网页多标签通讯？"></a>如何实现网页多标签通讯？</h2><ul>
<li><p>使用 WebSocket</p>
<ul>
<li>无跨域限制</li>
<li>需要服务端支持，成本高</li>
</ul>
</li>
<li><p>localStorage（跨域不共享）</p>
<ul>
<li>同域的 A 和 B 两个页面</li>
<li>A 页面设置 localStorage</li>
<li>B 页面可监听到 localStorage 值的修改</li>
</ul>
</li>
<li><p>SharedWorker(必须同域)</p>
<ul>
<li>SharedWorker 是 WebWorker 的一种</li>
<li>WebWorker 可开启子进程执行 JS，但不能操作 DOM</li>
<li>SharedWorker 可单独开启一个进程，用于同域页面通讯</li>
</ul>
</li>
</ul>
<h2 id="网页和-iframe-如何通讯？"><a href="#网页和-iframe-如何通讯？" class="headerlink" title="网页和 iframe 如何通讯？"></a>网页和 iframe 如何通讯？</h2><ul>
<li>使用 postMessage 通讯</li>
<li>注意跨域的限制和判断</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父传子</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">iframe1</span>.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"><span class="comment">// 子传父</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"><span class="comment">// 接收</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">origin</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="请描述-koa2-洋葱圈模型？"><a href="#请描述-koa2-洋葱圈模型？" class="headerlink" title="请描述 koa2 洋葱圈模型？"></a>请描述 koa2 洋葱圈模型？</h2><ul>
<li><p>koa2</p>
<ul>
<li>一个简约、流行的 nodejs 框架</li>
<li>通过中间件组织代码</li>
<li>多个中间件以“洋葱圈模型”执行</li>
</ul>
</li>
<li><p>代码执行过程</p>
<ul>
<li><img src="/images/md_img/koa1.jpg" alt="koa1"></li>
</ul>
</li>
<li><p>洋葱圈模型(类似捕获冒泡)</p>
<ul>
<li><img src="/images/md_img/koa2.jpg" alt="koa2"></li>
</ul>
</li>
</ul>
<h2 id="H5-页面如何进行首屏优化？"><a href="#H5-页面如何进行首屏优化？" class="headerlink" title="H5 页面如何进行首屏优化？"></a>H5 页面如何进行首屏优化？</h2><ul>
<li><p>路由懒加载</p>
<ul>
<li>适用于 SPA</li>
<li>路由拆分，优先保证首页加载</li>
</ul>
</li>
<li><p>服务端渲染 SSR</p>
<ul>
<li>传统前后端分离（SPA）渲染页面的过程复杂</li>
<li>SSR 渲染页面过程简单，所有性能好</li>
<li>如果是纯 H5 页面，SSR 是性能优化的终极方案</li>
</ul>
</li>
<li><p>App 预取</p>
<ul>
<li>如果 H5 在 App WebView 中展示，可使用 App 预取</li>
<li>用户访问列表页面时，App 预加载文章首屏内容</li>
<li>用户进入 H5 页面，直接从 App 中获取内容，瞬间展示首屏</li>
</ul>
</li>
<li><p>分页</p>
<ul>
<li>针对列表页</li>
<li>默认只展示第一页内容</li>
<li>上滑加载更多</li>
</ul>
</li>
<li><p>图片懒加载 lazyload</p>
<ul>
<li>针对详情页</li>
<li>默认只展示文本内容，然后出发图片懒加载</li>
<li>注意：提前设置图片尺寸，尽量只重绘不重排</li>
</ul>
</li>
<li><p>Hybrid</p>
<ul>
<li>提前将 HTML、JS、CSS 下载到 App 内部</li>
<li>在 App webview 中使用 file：// 协议加载页面文件</li>
<li>再用 Ajax 获取内容并展示（也结合 App 预取）</li>
</ul>
</li>
</ul>
<h2 id="后端一次性返回-10w-条数据，你该如何渲染？"><a href="#后端一次性返回-10w-条数据，你该如何渲染？" class="headerlink" title="后端一次性返回 10w 条数据，你该如何渲染？"></a>后端一次性返回 10w 条数据，你该如何渲染？</h2><ul>
<li><p>设计不合理，后端调整(分页)</p>
</li>
<li><p>自定义中间层</p>
<ul>
<li>自定义 nodejs 中间层，获取并拆分这 10w 条数据</li>
<li>前端对接 nodejs 中间层，而不是服务端</li>
<li>成本比较高</li>
</ul>
</li>
<li><p>虚拟列表</p>
<ul>
<li>只渲染可视区域</li>
</ul>
</li>
</ul>
<h2 id="如果一个-H5-很慢，你该如何排查性能问题？"><a href="#如果一个-H5-很慢，你该如何排查性能问题？" class="headerlink" title="如果一个 H5 很慢，你该如何排查性能问题？"></a>如果一个 H5 很慢，你该如何排查性能问题？</h2><ul>
<li><p>前端性能指标</p>
<ul>
<li>First Paint（FP）</li>
<li>First ContentFul Paint（FCP）</li>
<li>DomContentLoaded（DCL）</li>
<li>Largest Contentful Paint（LCP）</li>
<li>Load（L）</li>
</ul>
</li>
<li><p>Chrome devtools</p>
<ul>
<li>Performance 可查看上述性能指标，并有网页快照</li>
<li>Network 可以查看各个资源的加载时间</li>
</ul>
</li>
<li><p>lighthouse（第三方性能评测工具）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// terminal</span></span><br><span class="line">lighthouse <span class="attr">https</span>:<span class="comment">//www.imooc.com/ --view --preset=desktop</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过以上工具来判读是加载慢还是渲染慢</p>
<ul>
<li>加载慢<ul>
<li>优化服务端硬件配置，使用 CDN</li>
<li>路由懒加载，大组件异步加载-减少主包的体积</li>
<li>优化 http 缓存策略</li>
</ul>
</li>
<li>渲染慢<ul>
<li>优化服务端接口（如 ajax 获取数据慢）</li>
<li>优化全段组件内部逻辑</li>
<li>服务端渲染 SSR</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><ul>
<li>识别所有值类型<ul>
<li>undefined</li>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>Symbol</li>
</ul>
</li>
<li>识别函数、<ul>
<li>function</li>
</ul>
</li>
<li>判断是否是引用类型<ul>
<li>object</li>
</ul>
</li>
</ul>
<h2 id="异步和单线程"><a href="#异步和单线程" class="headerlink" title="异步和单线程"></a>异步和单线程</h2><ul>
<li><p>js 是单线程语言，同时只能做一件事</p>
</li>
<li><p>浏览器和 nodejs 已支持启动进程，如 web worker</p>
</li>
<li><p>js 和 dom 渲染共用同一个线程，因为 js 可以修改 dom 结构，所以遇到等待（网络请求，定时任务）就会卡住</p>
<ul>
<li>网络请求，如 ajax 图片加载</li>
<li>定时任务，如 setTimeout</li>
</ul>
</li>
<li><p>所以需要异步（callback）</p>
</li>
<li><p>异步和同步的区别？</p>
<ul>
<li>基于 js 是单线程语言</li>
<li>异步不会阻塞代码执行</li>
<li>同步会阻塞代码执行</li>
</ul>
</li>
</ul>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><ul>
<li><p>for…in（以及 forEach、for）都是常规的同步遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">muti</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(num * num);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现象：1s后，同时打印 1，4，9</span></span><br><span class="line">nums.<span class="title function_">forEach</span>(<span class="keyword">async</span> (item) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">muti</span>(item);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现象：异步等待打印</span></span><br><span class="line">!(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">muti</span>(i);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><p>for…of 常用于异步的遍历</p>
</li>
</ul>
<h2 id="从-event-loop-解释，为什么微任务执行更早？"><a href="#从-event-loop-解释，为什么微任务执行更早？" class="headerlink" title="从 event loop 解释，为什么微任务执行更早？"></a>从 event loop 解释，为什么微任务执行更早？</h2><ul>
<li><p>宏任务：</p>
</li>
<li><p>setTimeout、setInterval、ajax、DOM 事件</p>
</li>
<li><p>微任务：</p>
</li>
<li><p>promise、async/await</p>
</li>
<li><p>微任务的执行时机要比宏任务要早</p>
</li>
<li><p>每次 call stack 清空，即每次轮询结束，即同步任务执行完成</p>
</li>
<li><p>如果 DOM 结构有改变，则会重新进行 DOM 渲染</p>
</li>
<li><p>宏任务：DOM 渲染后触发，如 setTimeout</p>
</li>
<li><p>微任务：DOM 渲染前触发，如 promise</p>
</li>
<li><p>所以：微任务先于宏任务先执行</p>
</li>
<li><p>补充：</p>
<ul>
<li>微任务都是 ES6 语法规定的</li>
<li>宏任务都是由浏览器规定的</li>
</ul>
</li>
</ul>
<h2 id="BOM-API"><a href="#BOM-API" class="headerlink" title="BOM API"></a>BOM API</h2><ul>
<li>navigator</li>
<li>screen</li>
<li>location</li>
<li>history</li>
</ul>
<h2 id="为何要将-css-文件放在-head-标签中呢？"><a href="#为何要将-css-文件放在-head-标签中呢？" class="headerlink" title="为何要将 css 文件放在 head 标签中呢？"></a>为何要将 css 文件放在 head 标签中呢？</h2><ul>
<li>css 放在 body 标签尾部时，DOMTree 构建完成之后便开始构建 RenderTree，并计算布局渲染网页，等加载解析完 css 之后，开始构建 CSSOMTree，并和 DOMTree 重新构建 RenderTree，重新计算布局渲染网页</li>
<li>css 放在 head 中，先加载 css，之后解析 css 构建 CSSOMTree，同时构建 DOMTree，CSSOMTree 和 DOMTree 都构建完成之后开始构建 Render Tree，计算布局网页</li>
<li>两者对比，css 放在 head 中比放在 body 标签尾部少了一次构建 RenderTree，一次计算布局和一次渲染网页，因此性能会更好，并且 css 放在 body 标签尾部会在网页中短暂出现裸奔的 html，不利于用户体验</li>
</ul>
<h2 id="为什么建议把-script-标签放在-body-最后？"><a href="#为什么建议把-script-标签放在-body-最后？" class="headerlink" title="为什么建议把 script 标签放在 body 最后？"></a>为什么建议把 script 标签放在 body 最后？</h2><ul>
<li>js 的下载和执行会阻塞 DOMTree 的构建，即会中断 DOMTree 的更新，所以如果把 script 标签放在首屏范围内的 HTML 代码中会截断首屏的内容。</li>
<li>普通 script 标签放在 body 底部，做与不做 async 或者 defer 处理都不会影响首屏时间，但是会影响 DomContentLoad 和 load 的时间，进而影响依赖他们的代码的执行的开始时间</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 页面的全部资源加载完成后才会执行，包括图片、视频等</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// DOM 渲染完成后即可执行，此时图片、视频可能还没有加载完</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="性能优化（空间换时间）"><a href="#性能优化（空间换时间）" class="headerlink" title="性能优化（空间换时间）"></a>性能优化（空间换时间）</h2><ul>
<li><p>性能优化原则</p>
<ul>
<li>多使用内存、缓存</li>
<li>减少 CUP 计算，减少网络加载耗时</li>
<li>适用于所有编程的性能优化-空间换时间</li>
</ul>
</li>
<li><p>减少资源体积：压缩代码</p>
</li>
<li><p>减少访问次数：合并代码，SSR 服务器渲染，缓存，精灵图</p>
<ul>
<li>缓存（webpack contenthash）<ul>
<li>静态资源加 hash 后缀，根据文件内容计算 hash</li>
<li>文件内容不变，则 hash 不变则 url 不变</li>
<li>url 和文件不变，则会自动触发 http 的缓存机制，返回 304</li>
</ul>
</li>
<li>SSR<ul>
<li>服务器端渲染：将网页和数据一起加载，一起渲染</li>
<li>非 SSR（前后端分离）：先加载网页，后加载数据，再渲染数据</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS 预解析</p>
</li>
<li><p>减少 cookie 大小，http 请求会携带 cookie</p>
</li>
<li><p>使用 http2 头部压缩</p>
</li>
<li><p>避免重定向：当页面发生了重定向，就会延迟整个 HTML 文档的传输。在 HTML 文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。</p>
</li>
<li><p>渲染优化</p>
<ul>
<li>css 放在 head，js 放在 body 最下面</li>
<li>尽早开始执行 js，用 DOMContentLoaded 触发</li>
<li>懒加载（图片懒加载-IntersectionObserver，下滑更多等）</li>
<li>对 DOM 查询进行缓存</li>
<li>减少 DOM 数量，大数据量分页、虚拟列表</li>
<li>合并频繁的 DOM 操作,document.createDocumentFragment()，减少 dom 操作次数</li>
<li>节流 throttle、防抖 debounce</li>
<li>使用 loading 图，提高用户视觉体验</li>
<li>使用 GPU 加速：使用 transform、opacity，要慎用低端机 GPU 差，占用较多内存，因此是否开启硬件加速，要用测试结果决定</li>
<li>使用 requestAnimationFrame 来实现视觉变化</li>
</ul>
</li>
<li><p>三方资源</p>
<ul>
<li>第三方资源、库使用 CDN</li>
<li>压缩图片体积，减少图片大小</li>
<li>图片使用 webp 格式，减少图片体积</li>
<li>preload 预先加载 css 文件或者字体文件、js 文件等<ul>
<li>浏览器需要先把 html 页面加载回来，才能知道下一步去加载那些 js、css 或字体文件，中间时间就被浪费掉了</li>
<li>可以在等待 html 响应的同时把重要的静态资源文件也加载回来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>XSS 跨站请求攻击<ul>
<li>攻击方式<ul>
<li>一个博客网站，我发表一篇博客，其中嵌入 script 脚本</li>
<li>脚本内容：获取 cookie，发送到我的服务器</li>
<li>发布这篇博客，有人查看，就可以回去到访问者的 cookie</li>
</ul>
</li>
<li>预防方式<ul>
<li>替换特殊字符</li>
</ul>
</li>
</ul>
</li>
<li>XSRF 跨站请求伪造<ul>
<li>预防<ul>
<li>增加验证，例如密码、短信验证、指纹等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ES6-新增的声明方式"><a href="#ES6-新增的声明方式" class="headerlink" title="ES6 新增的声明方式"></a>ES6 新增的声明方式</h2><ul>
<li>let、const<ul>
<li>不属于顶层对象 window</li>
<li>不允许重复声明</li>
<li>不存在变量提升</li>
<li>暂时性死区（不能在变量声明之前去使用）</li>
<li>块级作用域</li>
</ul>
</li>
</ul>
<h2 id="css-穿参给-js-的方法"><a href="#css-穿参给-js-的方法" class="headerlink" title="css 穿参给 js 的方法"></a>css 穿参给 js 的方法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">any-hover</span>: none) &#123;</span><br><span class="line">    <span class="selector-tag">body</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&#x27;hoverNone&#x27;</span>;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js获取</span><br><span class="line">const hover = getComputedStyle(document<span class="selector-class">.body</span>, &#x27;<span class="selector-pseudo">::before</span>&#x27;)<span class="selector-class">.content</span>;</span><br><span class="line">hover就是<span class="attribute">content</span>对应的值</span><br></pre></td></tr></table></figure>

<h2 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h2><blockquote>
<p>把复杂的代码按照功能的不同划分成不同的模块单独维护，提高开发效率，降低维护成本。模块化只是思想理论，不包含具体实现</p>
</blockquote>
<p>模块化的演进：</p>
<ol>
<li>基于文件划分模块的方式</li>
<li>每个模块暴露一个全局对象，所有模块成员都挂载在这个对象中</li>
<li>使用 IIFE 为模块提供私有空间</li>
<li>利用 IIFE 的参数作为依赖声明使用</li>
<li>模块化规范（AMD、CMD、CommonJS、ESM 等）</li>
</ol>
<h2 id="如何给所有-async-函数添加-try-catch？"><a href="#如何给所有-async-函数添加-try-catch？" class="headerlink" title="如何给所有 async 函数添加 try/catch？"></a>如何给所有 async 函数添加 try/catch？</h2><p>babel 插件：</p>
<ol>
<li><p>借助 AST 抽象语法树，遍历查找代码中的 await 关键字<br>· 词法分析、语法分析生成 AST 抽象语法树</p>
</li>
<li><p>找到 await 节点后，从父路径中查找声明的 async 函数，获取该函数的 body（函数中包含的代码）</p>
</li>
<li><p>创建 try/catch 语句，将原来的 async 的 body 放入其中<br>· 通过 bebel-template 插件以字符串形式的代码构建 AST 树节点，生成 try/catch 节点</p>
</li>
<li><p>最后将 try/catch 语句替换 async 的 body</p>
</li>
</ol>
<p>全局捕获 Promise 类型错误：</p>
<ol>
<li>window.addEventListener(‘unhandledrejection’, callback)</li>
</ol>
<h2 id="捕获错误都有哪些方式？"><a href="#捕获错误都有哪些方式？" class="headerlink" title="捕获错误都有哪些方式？"></a>捕获错误都有哪些方式？</h2><ol>
<li>try/catch：捕获常规运行错误、语法错误，异步错误捕获不到</li>
<li>window.onerror:js 运行时错误</li>
<li>window.addEventListener(‘error’, callback):捕获资源错误</li>
<li>window.addEventListener(‘unhandledrejection’, callback):捕获 promise 类型错误</li>
<li>vue.config.errorHandler: vue 错误</li>
<li>componentDidCatch: react 错误</li>
</ol>
<h2 id="inline、block-和-inline-block-的区别？"><a href="#inline、block-和-inline-block-的区别？" class="headerlink" title="inline、block 和 inline-block 的区别？"></a>inline、block 和 inline-block 的区别？</h2><ul>
<li><p>block 块级元素</p>
<ul>
<li>单独占一行，宽度自动填充父元素宽度</li>
<li>可以设置 width、height</li>
<li>可以设置 padding、margin</li>
</ul>
</li>
<li><p>inline 内联元素（行内元素）</p>
<ul>
<li>不会单独占一行，多个元素并排一行，宽度随内容变化</li>
<li>设置 width、height 无效</li>
<li>可以设置水平方向的 padding、margin，但是垂直方向设置无效（如 padding-top）无效</li>
</ul>
</li>
<li><p>inline-block 行内块元素</p>
<ul>
<li>不会单独占一行</li>
<li>可以设置 width、height</li>
<li>可以设置 padding、margin，垂直方向也可以设置生效</li>
</ul>
</li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/05/react%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">React深入浅出知识链路</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/05/jquery%E5%AD%A6%E4%B9%A0/"><span class="level-item">jQuery学习</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "dvbU6cs8mO4tpam28kfkNFaI-gzGzoHsz",
            appKey: "tfoqOv7jT6pDSo3Abm9K4Jok",
            
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/avatar.jpeg" alt="foolishmax"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">foolishmax</p><p class="is-size-6 is-block">Web Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#从浏览器地址栏输入-url-到显示页面的步骤"><span class="level-left"><span class="level-item">1</span><span class="level-item">从浏览器地址栏输入 url 到显示页面的步骤</span></span></a></li><li><a class="level is-mobile" href="#cookie"><span class="level-left"><span class="level-item">2</span><span class="level-item">cookie</span></span></a></li><li><a class="level is-mobile" href="#localStorage-会话存储-和-sessionStorage-本地存储"><span class="level-left"><span class="level-item">3</span><span class="level-item">localStorage 会话存储 和 sessionStorage 本地存储</span></span></a></li><li><a class="level is-mobile" href="#html5-的几种存储形式"><span class="level-left"><span class="level-item">4</span><span class="level-item">html5 的几种存储形式</span></span></a></li><li><a class="level is-mobile" href="#性能优化"><span class="level-left"><span class="level-item">5</span><span class="level-item">性能优化</span></span></a></li><li><a class="level is-mobile" href="#fetch-和-axios"><span class="level-left"><span class="level-item">6</span><span class="level-item">fetch 和 axios</span></span></a></li><li><a class="level is-mobile" href="#预编译"><span class="level-left"><span class="level-item">7</span><span class="level-item">预编译</span></span></a></li><li><a class="level is-mobile" href="#箭头函数中的-this"><span class="level-left"><span class="level-item">8</span><span class="level-item">箭头函数中的 this</span></span></a></li><li><a class="level is-mobile" href="#Map-和-Set-两种新的数据结构的区别？"><span class="level-left"><span class="level-item">9</span><span class="level-item">Map 和 Set 两种新的数据结构的区别？</span></span></a></li><li><a class="level is-mobile" href="#你对闭包了解多少？"><span class="level-left"><span class="level-item">10</span><span class="level-item">你对闭包了解多少？</span></span></a></li><li><a class="level is-mobile" href="#原型"><span class="level-left"><span class="level-item">11</span><span class="level-item">原型</span></span></a></li><li><a class="level is-mobile" href="#简单说下原型链"><span class="level-left"><span class="level-item">12</span><span class="level-item">简单说下原型链</span></span></a></li><li><a class="level is-mobile" href="#js-的-new-操作符都做了些什么？"><span class="level-left"><span class="level-item">13</span><span class="level-item">js 的 new 操作符都做了些什么？</span></span></a></li><li><a class="level is-mobile" href="#什么是会话-cookie-什么是持久-cookie"><span class="level-left"><span class="level-item">14</span><span class="level-item">什么是会话 cookie,什么是持久 cookie?</span></span></a></li><li><a class="level is-mobile" href="#es6-新特性"><span class="level-left"><span class="level-item">15</span><span class="level-item">es6 新特性</span></span></a></li><li><a class="level is-mobile" href="#图片懒加载原理"><span class="level-left"><span class="level-item">16</span><span class="level-item">图片懒加载原理</span></span></a></li><li><a class="level is-mobile" href="#AMD-和-CMD-的区别"><span class="level-left"><span class="level-item">17</span><span class="level-item">AMD 和 CMD 的区别</span></span></a></li><li><a class="level is-mobile" href="#如何实现-js-倒计时的纠偏？"><span class="level-left"><span class="level-item">18</span><span class="level-item">如何实现 js 倒计时的纠偏？</span></span></a></li><li><a class="level is-mobile" href="#js-的执行机制"><span class="level-left"><span class="level-item">19</span><span class="level-item">js 的执行机制</span></span></a></li><li><a class="level is-mobile" href="#V8-垃圾回收机制"><span class="level-left"><span class="level-item">20</span><span class="level-item">V8 垃圾回收机制</span></span></a></li><li><a class="level is-mobile" href="#如何阻止冒泡"><span class="level-left"><span class="level-item">21</span><span class="level-item">如何阻止冒泡?</span></span></a></li><li><a class="level is-mobile" href="#如何阻止默认事件？"><span class="level-left"><span class="level-item">22</span><span class="level-item">如何阻止默认事件？</span></span></a></li><li><a class="level is-mobile" href="#补充：事件绑定的封装"><span class="level-left"><span class="level-item">23</span><span class="level-item">补充：事件绑定的封装</span></span></a></li><li><a class="level is-mobile" href="#如何判断一个对象是否为数组"><span class="level-left"><span class="level-item">24</span><span class="level-item">如何判断一个对象是否为数组</span></span></a></li><li><a class="level is-mobile" href="#宏任务和微任务"><span class="level-left"><span class="level-item">25</span><span class="level-item">宏任务和微任务</span></span></a></li><li><a class="level is-mobile" href="#Http-的持久连接和管线化"><span class="level-left"><span class="level-item">26</span><span class="level-item">Http 的持久连接和管线化</span></span></a></li><li><a class="level is-mobile" href="#为什么利用多个域名来存储网站资源会更有效？"><span class="level-left"><span class="level-item">27</span><span class="level-item">为什么利用多个域名来存储网站资源会更有效？</span></span></a></li><li><a class="level is-mobile" href="#基本数据类型"><span class="level-left"><span class="level-item">28</span><span class="level-item">基本数据类型</span></span></a></li><li><a class="level is-mobile" href="#牛客学习"><span class="level-left"><span class="level-item">29</span><span class="level-item">牛客学习</span></span></a></li><li><a class="level is-mobile" href="#深度封装-typeof-判断"><span class="level-left"><span class="level-item">30</span><span class="level-item">深度封装 typeof 判断</span></span></a></li><li><a class="level is-mobile" href="#浏览器的-reflow-和-repaint"><span class="level-left"><span class="level-item">31</span><span class="level-item">浏览器的 reflow 和 repaint</span></span></a></li><li><a class="level is-mobile" href="#浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？"><span class="level-left"><span class="level-item">32</span><span class="level-item">浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？</span></span></a></li><li><a class="level is-mobile" href="#如何清除-token"><span class="level-left"><span class="level-item">33</span><span class="level-item">如何清除 token</span></span></a></li><li><a class="level is-mobile" href="#npm"><span class="level-left"><span class="level-item">34</span><span class="level-item">npm</span></span></a></li><li><a class="level is-mobile" href="#本地存储"><span class="level-left"><span class="level-item">35</span><span class="level-item">本地存储</span></span></a></li><li><a class="level is-mobile" href="#localStorage-超过最大限制（5M）怎么处理？"><span class="level-left"><span class="level-item">36</span><span class="level-item">localStorage 超过最大限制（5M）怎么处理？</span></span></a></li><li><a class="level is-mobile" href="#URI-和-URL-有什么区别？"><span class="level-left"><span class="level-item">37</span><span class="level-item">URI 和 URL 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#日期"><span class="level-left"><span class="level-item">38</span><span class="level-item">日期</span></span></a></li><li><a class="level is-mobile" href="#如何监听未处理的异常"><span class="level-left"><span class="level-item">39</span><span class="level-item">如何监听未处理的异常</span></span></a></li><li><a class="level is-mobile" href="#浏览器如何缓存"><span class="level-left"><span class="level-item">40</span><span class="level-item">浏览器如何缓存</span></span></a></li><li><a class="level is-mobile" href="#字符串去重"><span class="level-left"><span class="level-item">41</span><span class="level-item">字符串去重</span></span></a></li><li><a class="level is-mobile" href="#for-遍历"><span class="level-left"><span class="level-item">42</span><span class="level-item">for 遍历</span></span></a></li><li><a class="level is-mobile" href="#indexOf-方法"><span class="level-left"><span class="level-item">43</span><span class="level-item">indexOf 方法</span></span></a></li><li><a class="level is-mobile" href="#search-方法"><span class="level-left"><span class="level-item">44</span><span class="level-item">search 方法</span></span></a></li><li><a class="level is-mobile" href="#对象属性法"><span class="level-left"><span class="level-item">45</span><span class="level-item">对象属性法</span></span></a></li><li><a class="level is-mobile" href="#同步和异步的区别，怎么异步加载-javascript"><span class="level-left"><span class="level-item">46</span><span class="level-item">同步和异步的区别，怎么异步加载 javascript?</span></span></a></li><li><a class="level is-mobile" href="#Chrome-打开一个页面需要启动多少线程？分别有哪些线程？"><span class="level-left"><span class="level-item">47</span><span class="level-item">Chrome 打开一个页面需要启动多少线程？分别有哪些线程？</span></span></a></li><li><a class="level is-mobile" href="#CommonJS、AMD、CMD-是什么及区别？"><span class="level-left"><span class="level-item">48</span><span class="level-item">CommonJS、AMD、CMD 是什么及区别？</span></span></a></li><li><a class="level is-mobile" href="#js-加载-浏览器加载-时间线"><span class="level-left"><span class="level-item">49</span><span class="level-item">js 加载(浏览器加载)时间线</span></span></a></li><li><a class="level is-mobile" href="#异步加载-js"><span class="level-left"><span class="level-item">50</span><span class="level-item">异步加载 js</span></span></a></li><li><a class="level is-mobile" href="#async-和-defer-对比？"><span class="level-left"><span class="level-item">51</span><span class="level-item">async 和 defer 对比？</span></span></a></li><li><a class="level is-mobile" href="#js-请说说写一个拖拽组件的思路及注意事项"><span class="level-left"><span class="level-item">52</span><span class="level-item">[js] 请说说写一个拖拽组件的思路及注意事项?</span></span></a></li><li><a class="level is-mobile" href="#为什么-try-catch-不能捕获到-promise-的错误？"><span class="level-left"><span class="level-item">53</span><span class="level-item">为什么 try/catch 不能捕获到 promise 的错误？</span></span></a></li><li><a class="level is-mobile" href="#箭头函数"><span class="level-left"><span class="level-item">54</span><span class="level-item">箭头函数</span></span></a></li><li><a class="level is-mobile" href="#for…in-和-for…of-有什么区别"><span class="level-left"><span class="level-item">55</span><span class="level-item">for…in 和 for…of 有什么区别</span></span></a></li><li><a class="level is-mobile" href="#for-await…of-有什么作用？"><span class="level-left"><span class="level-item">56</span><span class="level-item">for await…of 有什么作用？</span></span></a></li><li><a class="level is-mobile" href="#JS-严格模式有什么特点？"><span class="level-left"><span class="level-item">57</span><span class="level-item">JS 严格模式有什么特点？</span></span></a></li><li><a class="level is-mobile" href="#HTTP-跨域请求事为什么发送-options-请求？"><span class="level-left"><span class="level-item">58</span><span class="level-item">HTTP 跨域请求事为什么发送 options 请求？</span></span></a></li><li><a class="level is-mobile" href="#JS-内存泄漏如何检测？场景有哪些？"><span class="level-left"><span class="level-item">59</span><span class="level-item">JS 内存泄漏如何检测？场景有哪些？</span></span></a></li><li><a class="level is-mobile" href="#vdom-真的很快吗？"><span class="level-left"><span class="level-item">60</span><span class="level-item">vdom 真的很快吗？</span></span></a></li><li><a class="level is-mobile" href="#遍历数组，for-和-forEach-哪个快？"><span class="level-left"><span class="level-item">61</span><span class="level-item">遍历数组，for 和 forEach 哪个快？</span></span></a></li><li><a class="level is-mobile" href="#nodejs-如何开启进程，进程如何通讯？"><span class="level-left"><span class="level-item">62</span><span class="level-item">nodejs 如何开启进程，进程如何通讯？</span></span></a></li><li><a class="level is-mobile" href="#请描述-JS-Bridge-的原理"><span class="level-left"><span class="level-item">63</span><span class="level-item">请描述 JS Bridge 的原理</span></span></a></li><li><a class="level is-mobile" href="#requestIdleCallback-和-requestAnimationFrame-有什么区别？"><span class="level-left"><span class="level-item">64</span><span class="level-item">requestIdleCallback 和 requestAnimationFrame 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#移动端-H5-click-有-300ms-延迟，如何解决？"><span class="level-left"><span class="level-item">65</span><span class="level-item">移动端 H5 click 有 300ms 延迟，如何解决？</span></span></a></li><li><a class="level is-mobile" href="#网络请求中，token-和-cookie-有什么区别？"><span class="level-left"><span class="level-item">66</span><span class="level-item">网络请求中，token 和 cookie 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#Session-和-JWT-哪个更好？"><span class="level-left"><span class="level-item">67</span><span class="level-item">Session 和 JWT 哪个更好？</span></span></a></li><li><a class="level is-mobile" href="#如何实现-SSO-单点登录？"><span class="level-left"><span class="level-item">68</span><span class="level-item">如何实现 SSO 单点登录？</span></span></a></li><li><a class="level is-mobile" href="#defer-和-async-有什么区别？"><span class="level-left"><span class="level-item">69</span><span class="level-item">defer 和 async 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#prefetch-和-dns-prefetch-有什么区别？"><span class="level-left"><span class="level-item">70</span><span class="level-item">prefetch 和 dns-prefetch 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#Map-和-WeakMap-的区别和应用场景？"><span class="level-left"><span class="level-item">71</span><span class="level-item">Map 和 WeakMap 的区别和应用场景？</span></span></a></li><li><a class="level is-mobile" href="#你知道哪些前端攻击？该如何预防？"><span class="level-left"><span class="level-item">72</span><span class="level-item">你知道哪些前端攻击？该如何预防？</span></span></a></li><li><a class="level is-mobile" href="#重绘-repaint-重排-reflow-有什么区别？"><span class="level-left"><span class="level-item">73</span><span class="level-item">重绘 repaint 重排 reflow 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#如何实现网页多标签通讯？"><span class="level-left"><span class="level-item">74</span><span class="level-item">如何实现网页多标签通讯？</span></span></a></li><li><a class="level is-mobile" href="#网页和-iframe-如何通讯？"><span class="level-left"><span class="level-item">75</span><span class="level-item">网页和 iframe 如何通讯？</span></span></a></li><li><a class="level is-mobile" href="#请描述-koa2-洋葱圈模型？"><span class="level-left"><span class="level-item">76</span><span class="level-item">请描述 koa2 洋葱圈模型？</span></span></a></li><li><a class="level is-mobile" href="#H5-页面如何进行首屏优化？"><span class="level-left"><span class="level-item">77</span><span class="level-item">H5 页面如何进行首屏优化？</span></span></a></li><li><a class="level is-mobile" href="#后端一次性返回-10w-条数据，你该如何渲染？"><span class="level-left"><span class="level-item">78</span><span class="level-item">后端一次性返回 10w 条数据，你该如何渲染？</span></span></a></li><li><a class="level is-mobile" href="#如果一个-H5-很慢，你该如何排查性能问题？"><span class="level-left"><span class="level-item">79</span><span class="level-item">如果一个 H5 很慢，你该如何排查性能问题？</span></span></a></li><li><a class="level is-mobile" href="#typeof-运算符"><span class="level-left"><span class="level-item">80</span><span class="level-item">typeof 运算符</span></span></a></li><li><a class="level is-mobile" href="#异步和单线程"><span class="level-left"><span class="level-item">81</span><span class="level-item">异步和单线程</span></span></a></li><li><a class="level is-mobile" href="#for…of"><span class="level-left"><span class="level-item">82</span><span class="level-item">for…of</span></span></a></li><li><a class="level is-mobile" href="#从-event-loop-解释，为什么微任务执行更早？"><span class="level-left"><span class="level-item">83</span><span class="level-item">从 event loop 解释，为什么微任务执行更早？</span></span></a></li><li><a class="level is-mobile" href="#BOM-API"><span class="level-left"><span class="level-item">84</span><span class="level-item">BOM API</span></span></a></li><li><a class="level is-mobile" href="#为何要将-css-文件放在-head-标签中呢？"><span class="level-left"><span class="level-item">85</span><span class="level-item">为何要将 css 文件放在 head 标签中呢？</span></span></a></li><li><a class="level is-mobile" href="#为什么建议把-script-标签放在-body-最后？"><span class="level-left"><span class="level-item">86</span><span class="level-item">为什么建议把 script 标签放在 body 最后？</span></span></a></li><li><a class="level is-mobile" href="#性能优化（空间换时间）"><span class="level-left"><span class="level-item">87</span><span class="level-item">性能优化（空间换时间）</span></span></a></li><li><a class="level is-mobile" href="#安全"><span class="level-left"><span class="level-item">88</span><span class="level-item">安全</span></span></a></li><li><a class="level is-mobile" href="#ES6-新增的声明方式"><span class="level-left"><span class="level-item">89</span><span class="level-item">ES6 新增的声明方式</span></span></a></li><li><a class="level is-mobile" href="#css-穿参给-js-的方法"><span class="level-left"><span class="level-item">90</span><span class="level-item">css 穿参给 js 的方法</span></span></a></li><li><a class="level is-mobile" href="#前端模块化"><span class="level-left"><span class="level-item">91</span><span class="level-item">前端模块化</span></span></a></li><li><a class="level is-mobile" href="#如何给所有-async-函数添加-try-catch？"><span class="level-left"><span class="level-item">92</span><span class="level-item">如何给所有 async 函数添加 try/catch？</span></span></a></li><li><a class="level is-mobile" href="#捕获错误都有哪些方式？"><span class="level-left"><span class="level-item">93</span><span class="level-item">捕获错误都有哪些方式？</span></span></a></li><li><a class="level is-mobile" href="#inline、block-和-inline-block-的区别？"><span class="level-left"><span class="level-item">94</span><span class="level-item">inline、block 和 inline-block 的区别？</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/favicon.svg" alt="foolishmax" height="28"></a><p class="is-size-7"><span>&copy; 2023 foolishmax</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>