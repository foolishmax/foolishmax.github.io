<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[toc] 从浏览器地址栏输入url到显示页面的步骤1. 浏览器查看缓存(浏览器对应的都会有cache文件)。 若请求有缓存且未过期，则取缓存资源提供给客户端，否则发起请求与服务器进行验证。 检验是否过期通常有两个HTTP头：Expires、Cache-control 2.浏览器需要获取域名对应的ip地址，过程如下： 1.本地host文件查找 - 浏览器解析URL获取协议、域名、端口、path路径">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题目总结">
<meta property="og:url" content="http://yoursite.com/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Foolish-Max">
<meta property="og:description" content="[toc] 从浏览器地址栏输入url到显示页面的步骤1. 浏览器查看缓存(浏览器对应的都会有cache文件)。 若请求有缓存且未过期，则取缓存资源提供给客户端，否则发起请求与服务器进行验证。 检验是否过期通常有两个HTTP头：Expires、Cache-control 2.浏览器需要获取域名对应的ip地址，过程如下： 1.本地host文件查找 - 浏览器解析URL获取协议、域名、端口、path路径">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2021-10-04T13:54:55.000Z">
<meta property="article:modified_time" content="2021-10-04T13:56:31.462Z">
<meta property="article:author" content="Foolish-Max">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://yoursite.com/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试题目总结 | Foolish-Max</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Foolish-Max" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Foolish-Max</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">合抱之木始于毫末，万丈高楼起于垒土</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Foolish-Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Foolish-Max">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题目总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-04 21:54:55 / 修改时间：21:56:31" itemprop="dateCreated datePublished" datetime="2021-10-04T21:54:55+08:00">2021-10-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[toc]</p>
<h2 id="从浏览器地址栏输入url到显示页面的步骤"><a href="#从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤"></a>从浏览器地址栏输入url到显示页面的步骤</h2><pre><code>1. 浏览器查看缓存(浏览器对应的都会有cache文件)。
若请求有缓存且未过期，则取缓存资源提供给客户端，否则发起请求与服务器进行验证。
检验是否过期通常有两个HTTP头：Expires、Cache-control
2.浏览器需要获取域名对应的ip地址，过程如下：
1.本地host文件查找
- 浏览器解析URL获取协议、域名、端口、path路径，然后查看本地硬盘中hosts文件，看是否存在与这个域名对应的规则，如果有就直接使用hosts文件里面的ip地址。
2.路由器缓存
3.ISP DNS(Domain Name System域名系统)(情报局)缓存（互联网提供服务商）-本地DNS服务器以递归方式进行查询缓存记录，
若没有就向跟DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器，
本地DNS服务器把对应关系草存在缓存中（一边下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。
3.客户端发送HTTP请求。
4.TCP传输报文（三次握手四次挥手）
5.向客户端返回资源
6.解析HTML文档，构建DOM树，CSSOM树，下载资源，执行js脚本等。
</code></pre>
<span id="more"></span>

<h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个域名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</span><br></pre></td></tr></table></figure>

<h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">强缓存：（expires、Cache-Control）在过期时间内，浏览器再次加载资源时，不会向服务器发起请求，直接从缓存中读取资源</span><br><span class="line"></span><br><span class="line">协商缓存：向服务器发送请求，服务器会根据请求头（request header）的一些参数（Etag、last-modified）来判断是否命中协商缓存，首先根据Etag的值判断请求的文件有没有被修改，如果Etag一致则没有被修改，命中协商缓存返回304，如果不一致则返回新的资源并带上新的Etag返回200状态码。如果没有Etag值，则对比If-Modified-Since和请求文件的最后修改时间，一致则命中协商缓存返回304，不一致则返回新的last-modified和200状态码</span><br></pre></td></tr></table></figure>

<h2 id="http协议的特点"><a href="#http协议的特点" class="headerlink" title="http协议的特点"></a>http协议的特点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.支持客户&#x2F;服务器模式</span><br><span class="line">2.简单快速：客户向服务器发送请求时，只需传送请求方法和路径。</span><br><span class="line">3.灵活：http允许传输任意类型的数据对象（Content-Type内容编码类型）</span><br><span class="line"></span><br><span class="line">application&#x2F;x-www-form-urlencoded 常见post提交数据格式（key-value格式）</span><br><span class="line">application&#x2F;json</span><br><span class="line"></span><br><span class="line">4.无连接：限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。（原因是早期服务器需要同时面对全世界数十万、上百万的客户端的网页访问，但是每次客户端与服务端传输的数据关联性很低，就会导致大部分通过会很空闲，无端占用资源）</span><br><span class="line"></span><br><span class="line">（解决无连接）Keep-Alive：使客户端到服务端之间的Http连接保持，不会断开，当再次对服务器发送请求时，keep-Alive功能避免了重新建立连接</span><br><span class="line"></span><br><span class="line">5.无状态：Http是一个无状态协议，就是每个请求都是独立的，数据传输完毕不会记录任何信息。缺点就是如果后续处理需要前面的信息，就必须重传，就会导致每次连接传送的数据量增加，如果服务器不需要前面信息的时候应答就会很快。</span><br><span class="line"></span><br><span class="line">（解决无状态）怎样保持http连接状态呢</span><br><span class="line">Cookie（每次http请求的时候，客户端都需要发送响应的cookie信息到服务端，服务端根据cookie判断来自哪个客户端）</span><br><span class="line">服务端生成cookie，客户端保存</span><br><span class="line"></span><br><span class="line">Session</span><br><span class="line">服务端生成一个sessionid，在客户端下次请求的时候在cookie里面记录这个sessionid，然后发送给服务端，服务端再根据cookie中的sessionid来识别客户端返回资源数据。</span><br><span class="line"></span><br><span class="line">禁用cookie怎么办？</span><br><span class="line">url重写，每次http请求的时候，在url后面拼接sid&#x3D;**参数</span><br><span class="line"></span><br><span class="line">withCredentials:指定在涉及到跨域请求时，是否携带cookie信息，默认为false</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>

<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.存取方式不同： cookie只能保存ASCII字符串，session能够存储任意类型的数据</span><br><span class="line">2.隐私策略不同</span><br><span class="line">3.cookie是存在客户端，session是存在服务器的</span><br><span class="line">4.浏览器的支持不同，浏览器可以禁用cookie</span><br></pre></td></tr></table></figure>

<h2 id="权限身份验证"><a href="#权限身份验证" class="headerlink" title="权限身份验证"></a>权限身份验证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">一般都是通过sessionid来进行用户身份验证，sessionid一般会存放在redis中。</span><br><span class="line">1.用户向服务端发送用户名和密码进行登陆</span><br><span class="line">2.服务器验证通过后，服务器为用户创建一个session，并将session信息存储起来</span><br><span class="line">3.服务器向用户返回一个sessionid，写入用户的cookie</span><br><span class="line">4.当用户保持登陆状态时，每次后续请求都会一起发送给后端</span><br><span class="line">5.服务器将存储在cookie中的sessionid和存储在内存或者数据库中的sessin信息进行一个比较，验证用户身份，然后返回响应信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.依赖session的关键业务一定要确保客户端开启了cookie</span><br><span class="line">2.注意session的过期时间</span><br><span class="line"></span><br><span class="line">一般在http header的Authorization字段中添加token</span><br></pre></td></tr></table></figure>

<h2 id="禁用cookie之后session还能用吗？"><a href="#禁用cookie之后session还能用吗？" class="headerlink" title="禁用cookie之后session还能用吗？"></a>禁用cookie之后session还能用吗？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url重写，例如 https:&#x2F;&#x2F;javascript.cn&#x2F;?session_id&#x3D;xxx</span><br><span class="line">缺点是安全性降低，可以对sessionid进行一次加密后传输</span><br></pre></td></tr></table></figure>

<h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.url可见性：get参数url可见，post参数url不可见</span><br><span class="line">2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数</span><br><span class="line">3.缓存性：get请求可以缓存，post请求不可以缓存</span><br><span class="line">4.get请求网页回退时，不产生影响，post请求网页回退会重新发请求</span><br><span class="line">5.传输数据：get一般传输数据大小不超过4k，post可以传输大量数据</span><br><span class="line">6.post较get安全性较高，get是不安全的因为url可见，可能会泄漏私密信息</span><br></pre></td></tr></table></figure>

<h2 id="http常见的请求头字段"><a href="#http常见的请求头字段" class="headerlink" title="http常见的请求头字段"></a>http常见的请求头字段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Accept: 浏览器可接受的数据类型</span><br><span class="line">Accept-Charset: 浏览器可接受的字符集</span><br><span class="line">Accept-Encoding：浏览器能够进行解码的数据编码方式</span><br><span class="line">Accept-Language： 浏览器所希望的语言种类</span><br><span class="line">Connection：是否需要持久连接，值“Keep-Alive”，HTTP1.1默认进行持久连接</span><br><span class="line">Cookie：cookie信息</span><br><span class="line">content-type</span><br><span class="line">If-Modified-Since：内容被修改才会返回</span><br><span class="line">User-Agent：浏览器类型</span><br><span class="line"></span><br><span class="line">响应头：</span><br><span class="line">content-Length: 表示内容长度</span><br><span class="line">content-type：文档类型</span><br><span class="line">Date：当前时间</span><br><span class="line">Expires：指定缓存过期时间</span><br><span class="line">Last-Modified：文档过期时间</span><br></pre></td></tr></table></figure>

<h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http是超文本传输协议，信息是明文传输，https是更加安全的ssl加密传输协议</span><br><span class="line">http默认是80端口，https默认是443端口</span><br><span class="line">https需要申请CA证书</span><br><span class="line">https是http + ssl&#x2F;tls（数字证书）进行组合的更加安全的传输协议</span><br><span class="line"></span><br><span class="line">https工作原理（非对称加密）</span><br><span class="line">1.服务端向客户端传递证书作为公钥</span><br><span class="line">2.客户端对证书进行解析，判断证书的办法机构和过期时间等，如果都没有问题，生成一个随机值作为私钥，然后使用证书进行加密发送给服务端</span><br><span class="line">3.服务端解密得到客户端私钥</span><br><span class="line">4.之后双方利用私钥进行加密解密，完成信息的通信</span><br></pre></td></tr></table></figure>

<h2 id="xss（跨域脚本攻击）csrf（跨站请求伪造）"><a href="#xss（跨域脚本攻击）csrf（跨站请求伪造）" class="headerlink" title="xss（跨域脚本攻击）csrf（跨站请求伪造）"></a>xss（跨域脚本攻击）csrf（跨站请求伪造）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">csrf: 需要用户先登陆网站A，获取cookie，利用的是网站A本身的漏洞，去请求网站A的api，---进行token验证，referer验证，只接收本站的请求</span><br><span class="line"></span><br><span class="line">xss：向网站A注入js代码，然后执行js代码，篡改网站A的内容，破坏页面正常结构，插入恶意广告。---编码转换</span><br></pre></td></tr></table></figure>

<h2 id="http1-0、http1-1和http2-0的区别"><a href="#http1-0、http1-1和http2-0的区别" class="headerlink" title="http1.0、http1.1和http2.0的区别"></a>http1.0、http1.1和http2.0的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#x2F;1.0 每个请求都要建立一个连接</span><br><span class="line">http&#x2F;1.1 多了长连接keep-alive，若干个请求需要排队串行化单线程处理，会发生网络请求阻塞问题。</span><br><span class="line">http&#x2F;2.0 同一个连接可以有多个请求，各个请求直接互不影响（进行了头部压缩和多路复用的优化）</span><br></pre></td></tr></table></figure>

<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单例模式 （class组件中new store创建store实例）</span><br><span class="line">工厂模式 （mobx store中creatLayoutStore）</span><br><span class="line">观察者模式 </span><br><span class="line">发布订阅模式</span><br><span class="line">装饰器模式 （移动、pc配置同步@sync）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* TCP是面向连接的协议，发送数据前先要建立连接，TCP提供可靠的服务，通过TCP建立连接传输的数据不会丢失，没有重复，并且按照顺序到达。</span><br><span class="line">* UDP是无连接的协议，发送数据前不需要建立连接，是不可靠的</span><br><span class="line">* TCP只支持点对点通信，而UDP支持一对一，多对多</span><br><span class="line">* TCP是面向字节流的，UDP是面向报文的</span><br><span class="line">* TCP通信类似打电话，接通后需要确认身份，才可以开始通信</span><br><span class="line">* UDP类似广播直接进行通信</span><br></pre></td></tr></table></figure>

<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">应用层（应用层就是向用户提供通信服务的活动，提供用户程序接口HTTP、DNS）</span><br><span class="line">传输层（传输层为两台主机上的应用程序提供端到端的通信TCP，UDP）</span><br><span class="line">网络层（网络层实现数据包的选路和转发）</span><br><span class="line">数据链路层（ARP地址解析协议、RARP逆地址解析协议，使用物理地址寻找一台机器）</span><br></pre></td></tr></table></figure>

<h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正向代理是客户端代理，服务端不知道是哪个客户端发起的请求</span><br><span class="line">反向代理是服务端代理，客户端不知道是哪个服务端提供的资源</span><br></pre></td></tr></table></figure>

<h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应用层</span><br><span class="line">表示层</span><br><span class="line">会话层</span><br><span class="line"></span><br><span class="line">传输层</span><br><span class="line"></span><br><span class="line">网络层</span><br><span class="line"></span><br><span class="line">数据链路层</span><br><span class="line">物理层</span><br></pre></td></tr></table></figure>

<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>为什么需要三次握手？<br>两次握手第二次结束后，服务端并不能保证客户端已经接收到了第二次的应答信息，如此一来服务器会一直保持通信过程，因为TCP通信会占用端口，造成资源浪费。</p>
<p>防止已失效的连接请求报文段突然又传送到服务端，产生错误。<br>如上述情况，如果client没有再次向server发出确认，server收不到确认就不会建立连接，可以避免server端一直等待浪费资源。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/rememberyf/article/details/80309148">https://blog.csdn.net/rememberyf/article/details/80309148</a></li>
</ul>
<h2 id="301和302的区别"><a href="#301和302的区别" class="headerlink" title="301和302的区别"></a>301和302的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">301 表示资源被永久移除，浏览器在拿到状态码后跳转到一个新的URL地址，可从相应头的location首部中获取，搜索引擎在抓取新内容的同时也将就地址交换为重定向之后的网址。</span><br><span class="line"></span><br><span class="line">302 表示地址资源还在，仍可以访问，搜索引擎会抓取新的内容而保存旧的地址，seo 302 优于301.</span><br><span class="line"></span><br><span class="line">重定向的原因：</span><br><span class="line">网站调整（改变网页目录结构）</span><br><span class="line">页面被移到一个新地址</span><br><span class="line">页面扩展名改变 .php -&gt;.html</span><br><span class="line">如果不做重定向会返回404页面，会白白流失用户访问量。</span><br><span class="line"></span><br><span class="line">1XX 信息性状态码，表示接受的请求正在处理</span><br><span class="line">2XX 成功状态码，表示请求被正常处理完毕</span><br><span class="line">3XX 重定向状态码，表示需要进行附加操作以完成请求</span><br><span class="line">4XX 客户端错误状态码，表示服务器无法处理请求</span><br><span class="line">    400 Bad Request请求出现语法错误</span><br><span class="line">    401 被请求的页面需要用户名和密码</span><br><span class="line">    403 forbidden 请求页面的访问被禁止</span><br><span class="line">    404 资源未找到</span><br><span class="line">5XX 服务器错误状态码，表示服务器处理请求出错</span><br><span class="line">    502 网关错误</span><br><span class="line">    503 服务器超负载或者停机维护，无法处理请求</span><br><span class="line">    504 网关超时</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul>
<li>cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据cookie追踪用户在不同页面的访问信息。</li>
<li>cookie特点<ul>
<li>1.大小限制，cookie大小限制在4KB以内</li>
<li>2.宽带限制，cookie数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。</li>
<li>3.安全风险，cookie会频繁的在网络中传送，不加密的情况下是有安全风险的。</li>
<li>4.操作复杂<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name: string, value: string) &#123;</span><br><span class="line">    const exp &#x3D; new Date();    </span><br><span class="line">    &#x2F;&#x2F;过期时间设置为一天</span><br><span class="line">    exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000);</span><br><span class="line">    document.cookie &#x3D; &#96;$&#123;name&#125;&#x3D;$&#123;escape(value);expires&#x3D;$&#123;exp.toString()&#125;&#125;&#96;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="localStorage会话存储-和-sessionStorage本地存储"><a href="#localStorage会话存储-和-sessionStorage本地存储" class="headerlink" title="localStorage会话存储 和 sessionStorage本地存储"></a>localStorage会话存储 和 sessionStorage本地存储</h2><ul>
<li>1.存储容量大</li>
<li>2.零宽带，仅存储在本地，不会和服务器发生任何交互行为，不存在网络宽带占用问题。</li>
<li>3.编程接口，提供一套丰富的接口，操作数据更加方便。</li>
<li>4.独立的存储空间，不会造成数据的混乱。</li>
</ul>
<ul>
<li><p>主要区别在于数据存储的 <code>时间范围</code>和<code>页面范围</code></p>
<ul>
<li>sessionStorage: 数据只存储到窗口或标签关闭时，只在当前窗口的当前标签内可见,5M左右，不同浏览器不同大小。</li>
<li>localStorage: 数据会一直存在除非手动清除，数据可被同源(协议、域名、端口号一致)的每个窗口或标签共享,5M左右，不同浏览器不同大小。</li>
</ul>
</li>
<li><p>监测是否支持web Storage</p>
<ul>
<li>1.通过window.sessionStorage,window.localStorage判断浏览器是否支持</li>
<li>2.通过try{}catch{} 执行一下storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。</li>
</ul>
</li>
</ul>
<h2 id="html5的几种存储形式"><a href="#html5的几种存储形式" class="headerlink" title="html5的几种存储形式"></a>html5的几种存储形式</h2><ul>
<li>1.本地存储 localStorage,sessionStorage</li>
<li>2.离线缓存 application cache</li>
<li><ol start="3">
<li>indexedDb,webSQL</li>
</ol>
</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.负载均衡、CDN加速、设置缓存、</span><br><span class="line">2.业务逻辑优化</span><br><span class="line">3.代码程序优化（组件按需加载、图片懒加载，代码压缩）</span><br><span class="line">4.避免重绘回流</span><br><span class="line">重绘：页面元素的样式改变不会影响它在文档流中的位置时发生重绘</span><br><span class="line">回流：DOM尺寸大小结构发生变化时</span><br><span class="line">回流一定会导致重绘</span><br><span class="line">如何避免：</span><br><span class="line">1.避免频繁操作dom，通过创建document.createDocumentFragment()一次性插入需要操作的dom</span><br><span class="line">2.具有复杂动画的Dom元素使用绝对定位，使其脱离文档流</span><br><span class="line">3.合并对于Dom中style样式的操作</span><br><span class="line">4.避免使用css表达式 calc()</span><br></pre></td></tr></table></figure>

<h2 id="fetch和axios"><a href="#fetch和axios" class="headerlink" title="fetch和axios"></a>fetch和axios</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch取消发送</span><br><span class="line">1.创建一个AbortController实例</span><br><span class="line">2.该实例具有signal属性</span><br><span class="line">3.将signal传递给fetch option</span><br><span class="line">4.调用AbortController的abort属性来取消所有使用该信号的fetch</span><br><span class="line"></span><br><span class="line">axios取消发送</span><br><span class="line">1.const cancelToken &#x3D; axios.CancelToken</span><br><span class="line">2.const source &#x3D; CancelToken.source()</span><br><span class="line">3.axios.get(&#39;&#x2F;xxx&#39;,&#123;cancelToken: source.token&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="flex常用属性，grid布局"><a href="#flex常用属性，grid布局" class="headerlink" title="flex常用属性，grid布局"></a>flex常用属性，grid布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flex属性：</span><br><span class="line">1.flex-direction属性，决定主轴方向</span><br><span class="line">2.flex-wrap属性，控制换行</span><br><span class="line">3.flex-flow属性，flex-direction和flex-wrap的简写形式，默认值flex-flow: row  nowrap;</span><br><span class="line">4.justify-content属性，项目主轴上的对齐方式</span><br><span class="line">5.align-item属性，项目在交叉轴上的对齐方式</span><br><span class="line">6.align-content属性，多个轴线的时候在元素在交叉轴的对齐方式，只有一根轴线时不起作用</span><br><span class="line">flex（子元素的属性）：</span><br><span class="line">1.order属性,定义项目的排列顺序，数值越小，排列越靠前，默认为0.</span><br><span class="line">2.align-self属性，允许单个项目与其他项目不一样的对齐方式，会覆盖align-items属性.</span><br><span class="line">3.flex属性，flex-grow、flex-shrink、flex-basis简写，默认为0 1 auto</span><br><span class="line">    auto(1 1 auto)       none(0 0 auto)</span><br><span class="line">4.flex-grow属性，定义项目的放大比例，默认为0，即如果存在剩余空间也不放大，1等分，一个项目为2，其他为1，则前者占据空间是其他的两倍。</span><br><span class="line">5.flex-shrink属性，定义项目的缩小比例，默认为1，空间不足则缩小，如果所有项目都为1，则等比例缩小，如果有的项目为0，则空间不足时为0的不缩小，负值无效</span><br><span class="line">6.flex-basis属性，项目占据的固定空间</span><br></pre></td></tr></table></figure>

<h2 id="padding-bottom实现子元素高度等于父元素宽度问题"><a href="#padding-bottom实现子元素高度等于父元素宽度问题" class="headerlink" title="padding-bottom实现子元素高度等于父元素宽度问题"></a>padding-bottom实现子元素高度等于父元素宽度问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当margin或者padding取值是百分比的时候，无论是left，right或者top，bottom，都是以父元素的width为参考物，进行提前占位</span><br></pre></td></tr></table></figure>


<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在作用域的创建阶段（预编译阶段），会生成js的变量对象（VO对象）供js引擎去访问。</span><br><span class="line">1.创建ao对象</span><br><span class="line">2.找形参和变量声明，作为ao对象的属性名，值为undefined</span><br><span class="line">3.实参和形参相统一</span><br><span class="line">4.找函数声明，如果名字和变量相同则覆盖变量声明</span><br><span class="line">5.解释执行</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.箭头函数中的this是在定义函数的时候绑定的（继承自父执行上下文中的this），而不是执行函数时绑定。</span><br><span class="line">2.箭头函数没有this，所以不能用作构造函数。</span><br></pre></td></tr></table></figure>
<h2 id="Map和Set两种新的数据结构的区别？"><a href="#Map和Set两种新的数据结构的区别？" class="headerlink" title="Map和Set两种新的数据结构的区别？"></a>Map和Set两种新的数据结构的区别？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Map类似Object是一种键值对集合，区别在于Map的键不仅限于字符串，其他各种类型的值都可以作为Map的键</span><br><span class="line"></span><br><span class="line">2.Set是类似数组的一种数据结构，不点在于Set中没有重复的值</span><br></pre></td></tr></table></figure>

<h2 id="你对闭包了解多少？"><a href="#你对闭包了解多少？" class="headerlink" title="你对闭包了解多少？"></a>你对闭包了解多少？</h2><pre><code>解释一下作用域链是如何产生的
解释一下js执行山下文的创建、执行过程
解释一下闭包所产生的变量放在哪里
</code></pre>
<ul>
<li>闭包的定义：闭包就是能够读取其他函数内部变量的函数。</li>
<li>闭包的底层实现原理</li>
<li>js执行上下文：</li>
<li><img src="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70" alt="image"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">js运行三部曲</span><br><span class="line">1.语法分析</span><br><span class="line">2.预编译</span><br><span class="line">3.解释执行</span><br><span class="line"></span><br><span class="line">js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。</span><br><span class="line">预编译的环境需要个环境，这个环境就是执行上下文。</span><br><span class="line"></span><br><span class="line">js执行上下文分为三种：</span><br><span class="line">1.全局执行上下文：代码开始执行时首先进入的环境</span><br><span class="line">2.函数执行上下文：函数调用时，会开始执行函数中的代码</span><br><span class="line">3.eval执行上下文：不建议使用</span><br><span class="line"></span><br><span class="line">执行上下文的周期，分为两个阶段</span><br><span class="line">1.创建阶段</span><br><span class="line">    创建词法环境</span><br><span class="line">    生成变量对象VO，建立作用域链</span><br><span class="line">    确认this指向，并绑定this</span><br><span class="line">2.执行阶段</span><br><span class="line">    进行变量赋值，函数引用以及执行代码</span><br><span class="line">    </span><br><span class="line">预编译发生在函数执行前，预编译四部曲：</span><br><span class="line">1.创建AO对象</span><br><span class="line">2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined</span><br><span class="line">3.将形参和实参相统一</span><br><span class="line">4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）</span><br><span class="line">5.最后程序输出变量值的时候，就是从AO对象中拿</span><br><span class="line">（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，</span><br><span class="line">就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包）</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student.__proto__ &#x3D;&#x3D;&#x3D; Student.prototype</span><br><span class="line">1.每个函数function都由一个prototype，即显式原型。是在定义函数的时候自动添加的，默认是一个空的Object对象</span><br><span class="line">2.每个引用类型都有一个__proto__,即隐式原型。是创建对象时自动添加的，默认值为构造函数的prototype属性值</span><br><span class="line">实例对象的隐式原型 等于 对应构造函数或类的显式原型</span><br><span class="line">能直接操作显式原型，不能直接操作隐式原型</span><br></pre></td></tr></table></figure>

<h2 id="js的new操作符都做了些什么？"><a href="#js的new操作符都做了些什么？" class="headerlink" title="js的new操作符都做了些什么？"></a>js的new操作符都做了些什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个空的js对象&#123;&#125;</span><br><span class="line">2. 将空对象的隐式原型__proto__指向构造函数的原型</span><br><span class="line">3. 将空对象作为构造函数的上下文（改变this指向）</span><br><span class="line">4. 对构造函数返回值做判断</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line">function create(fn, ...args) &#123;</span><br><span class="line">    let obj &#x3D; Object.create(&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; obj.__proto__ &#x3D; fn.prototype;</span><br><span class="line">    Object.setPrototypeOf(obj, fn.prototype);</span><br><span class="line">    </span><br><span class="line">    let result &#x3D; fn.apply(obj, args);</span><br><span class="line">    </span><br><span class="line">    return result instanceof Object ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">在new的时候，会对构造函数的返回值做一些判断</span><br><span class="line">1. 如果返回值是基础类型数据，则忽略返回值</span><br><span class="line">2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效</span><br></pre></td></tr></table></figure>




<h2 id="calc-support-media各自的含义及用法？"><a href="#calc-support-media各自的含义及用法？" class="headerlink" title="calc, support, media各自的含义及用法？"></a>calc, support, media各自的含义及用法？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@support 主要用于检测浏览器是否支持css的某个属性，相当于条件语句，支持的话写一套样式，</span><br><span class="line">不支持写另外一套样式，例如</span><br><span class="line">    @supports (display: grid) &#123;</span><br><span class="line">      div &#123;</span><br><span class="line">        display: grid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @supports not (display: grid) &#123;</span><br><span class="line">      div &#123;</span><br><span class="line">        float: right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">calc(): 用于动态计算值，支持 + - * &#x2F; 运算。</span><br><span class="line"></span><br><span class="line">@media查询：可以针对不同的媒体类型定义不同的样式。</span><br></pre></td></tr></table></figure>
<h2 id="什么是会话cookie-什么是持久cookie"><a href="#什么是会话cookie-什么是持久cookie" class="headerlink" title="什么是会话cookie,什么是持久cookie?"></a>什么是会话cookie,什么是持久cookie?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie是服务器返回的，指定了expire（有效期）的是持久cookie,没有指定的是会话cookie</span><br></pre></td></tr></table></figure>


<h2 id="img标签title和alt属性"><a href="#img标签title和alt属性" class="headerlink" title="img标签title和alt属性"></a>img标签title和alt属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alt: 图片加载失败时，显示在网页上的替代文字</span><br><span class="line">title: 鼠标放在图片上的提示文字</span><br><span class="line"></span><br><span class="line">alt是必须属性，可以为空；title为非必须</span><br></pre></td></tr></table></figure>

<h2 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.let和const</span><br><span class="line">2.模版字符串</span><br><span class="line">3.箭头函数</span><br><span class="line">4.函数可以设置默认参数值</span><br><span class="line">5.扩展运算符</span><br><span class="line">6.对象和数组的解构</span><br><span class="line">7.class</span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载原理"><a href="#图片懒加载原理" class="headerlink" title="图片懒加载原理"></a>图片懒加载原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器是否发起请求是根据&lt;img &#x2F;&gt;标签的src属性</span><br><span class="line">2. 所以懒加载的关键是：在图片没有进入可视区域时，</span><br><span class="line">先不给&lt;img &#x2F;&gt;的src属性赋值，等到图片进入可是区域再给src赋值。</span><br><span class="line"></span><br><span class="line">当图片底边距离页面的偏移（图片高度+图片距离顶部偏移高度）</span><br><span class="line">小于等于</span><br><span class="line">浏览器底边距离页面顶部高度（浏览器一屏高度 + 滚动区域）</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="H5新增了哪些标签？"><a href="#H5新增了哪些标签？" class="headerlink" title="H5新增了哪些标签？"></a>H5新增了哪些标签？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article、aside、audio、video、footer、header、nav、section</span><br></pre></td></tr></table></figure>

<h2 id="SVG和Canvas的区别？"><a href="#SVG和Canvas的区别？" class="headerlink" title="SVG和Canvas的区别？"></a>SVG和Canvas的区别？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.svg:表示以XML格式定义图像的可伸缩矢量图形。</span><br><span class="line">2.canvas：通过js来绘制2D图形</span><br><span class="line"></span><br><span class="line">svg通过标签fill属性可以调整颜色</span><br></pre></td></tr></table></figure>




<h2 id="AMD-和-CMD的区别"><a href="#AMD-和-CMD的区别" class="headerlink" title="AMD 和 CMD的区别"></a>AMD 和 CMD的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">共同点：</span><br><span class="line">1.两者都是框架在推广过程中对模块定义的规范产出</span><br><span class="line">2.都是异步加载模块</span><br><span class="line">不同点：</span><br><span class="line">1.AMD是RequireJs在推广过程中对模块定义的规范产出，CMD是SeaJs在推广过程中对模块定义的规范化产出</span><br><span class="line">2.AMD推崇依赖前置，CMD推崇依赖就近</span><br><span class="line">3.AMD的应用体验好，因为模块提前执行了，CMD性能好，因为只有用户需要的时候才执行</span><br></pre></td></tr></table></figure>


<h2 id="如何实现js倒计时的纠偏？"><a href="#如何实现js倒计时的纠偏？" class="headerlink" title="如何实现js倒计时的纠偏？"></a>如何实现js倒计时的纠偏？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 第一种通过前端定时向服务端发送请求获取最新的时间差，以此来校准倒计时时间。</span><br><span class="line">2. 通过前端根据偏差时间来自动调整下次间隔的时间来实现，首先以setTimeout递归的方式来实现倒计时，</span><br><span class="line">通过一个变量记录倒计时的秒数，根据秒数和间隔时间计算出此时无偏差时应该显示的时间，</span><br><span class="line">然后拿当前真实时间与这个时间相减，就可以得到时间的偏差大小，因此在设置下一个定时器的时候，</span><br><span class="line">间隔时间减去这个偏差大小就可以纠正时间误差。</span><br></pre></td></tr></table></figure>

<h2 id="js的执行机制"><a href="#js的执行机制" class="headerlink" title="js的执行机制"></a>js的执行机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">js是单线程的，处理js任务只能一个一个顺序执行，js中把任务分为了同步任务和异步任务，</span><br><span class="line">同步任务进入主线程先执行，异步任务进入Event Table并注册函数，指定事情完成后，Event Table就会将函数移入到事件队列Event Queque中，等待主线程任务执行完毕，</span><br><span class="line">就会从事件队列中取出对应事件进入主线程执行。</span><br><span class="line"></span><br><span class="line">macro-task（宏任务）：包括整体代码script、setTimeout、setInterval</span><br><span class="line">micro-task（微任务）：Promise.then、process.nextTick</span><br><span class="line">微任务先于宏任务先执行（除了script）执行过程不同任务进入不同的event quue</span><br><span class="line"></span><br><span class="line">js先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，</span><br><span class="line">遇到宏任务放到宏任务事件队列中。</span><br><span class="line"></span><br><span class="line">然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，</span><br><span class="line">等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，</span><br><span class="line">执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，</span><br><span class="line">就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，</span><br><span class="line">以此类推。</span><br></pre></td></tr></table></figure>

<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="请说一下你对React的理解？"><a href="#请说一下你对React的理解？" class="headerlink" title="请说一下你对React的理解？"></a>请说一下你对React的理解？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. react是一个网页的UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</span><br><span class="line">2. react的核心设计思路有三个：</span><br><span class="line">声明式</span><br><span class="line">    命令式：命令程序一步一步的执行操作</span><br><span class="line">    声明式：只需告诉程序我们想要的结果，其他的交给程序去做。</span><br><span class="line">组件化</span><br><span class="line">    将视图拆分和模块复用，做到高内聚低耦合</span><br><span class="line"></span><br><span class="line">通用性</span><br><span class="line">    一次学习，随处编写。RN，react360等，跨平台底层靠虚拟DOM实现</span><br><span class="line">    </span><br><span class="line">3. 缺点</span><br><span class="line">1.没有官方系统解决方案，在开发大型应用时需要向社区寻找并整合解决方案。</span><br><span class="line">2.过于灵活，需要注意代码规范</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="React-lazy懒加载"><a href="#React-lazy懒加载" class="headerlink" title="React.lazy懒加载"></a>React.lazy懒加载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; React.lazy方法可以异步加载组件</span><br><span class="line">const Foo &#x3D; React.lazy(() &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;Foo&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; React.lazy不能单独使用，需要配合React.suspense,用来包裹异步组件，添加loading效果等。</span><br><span class="line">&lt;React.Suspense fallback&#x3D;&#123;&lt;div&gt;loading...&lt;&#x2F;div&gt;&#125;&gt;</span><br><span class="line">    &lt;Foo &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;React.Suspense&gt;</span><br><span class="line"></span><br><span class="line">React.lazy原理</span><br><span class="line">React.lazy使用import来懒加载组件，import在webpack中最终会调用requireEnsure方法，动态插入script来请求js文件，类似jsonp的形式。</span><br></pre></td></tr></table></figure>

<h2 id="类组件和函数组件之间的区别？"><a href="#类组件和函数组件之间的区别？" class="headerlink" title="类组件和函数组件之间的区别？"></a>类组件和函数组件之间的区别？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">接受属性返回React元素</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line">    1.编程思想不同：类组件需要创建实例，基于面向对象的方式编程。函数式组件接受输入返回输出，属于函数式编程的思想。</span><br><span class="line">    2.内存占用：类组件需要创建实例，会占用内存，函数组件不需要创建实例，可以节约内存</span><br><span class="line">    3.捕获特性：函数组件具有捕获特性</span><br><span class="line">    4.可测试性：函数组件更方便编写单元测试</span><br><span class="line">    5.状态：类组件有实例可以维护自己的状态，函数组件可以使用useState维护自己的状态</span><br><span class="line">    6.声明周期：类组件有生命周期，可以在生命周期内写逻辑，函数组件可以在useEffect中</span><br><span class="line">    7.逻辑复用：函数组件通过继承实现逻辑复用，函数组件可以通过自定义hooks实现逻辑复用</span><br><span class="line">    8.性能优化：类组件通过shouldComponentUpdate和PureComponent来跳过更新，函数组件通过React.memo</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="当调用setState的时候，发生了什么事？"><a href="#当调用setState的时候，发生了什么事？" class="headerlink" title="当调用setState的时候，发生了什么事？"></a>当调用setState的时候，发生了什么事？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将传递给setState的参数对象合并到组件的当前的状态，react遍历dom节点，计算差异，更新UI。</span><br><span class="line">https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000018250127</span><br></pre></td></tr></table></figure>

<h2 id="为什么setState的参数是一个callback而不是一个对象"><a href="#为什么setState的参数是一个callback而不是一个对象" class="headerlink" title="为什么setState的参数是一个callback而不是一个对象"></a>为什么setState的参数是一个callback而不是一个对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因为this.props和this.state的更新可能是异步的，不能依赖它们的值去计算下一个state</span><br><span class="line">(更新状态不要直接修改this.state，虽然状态可以改变，但不会触发组件的更新)</span><br><span class="line"></span><br><span class="line">setState何时同步何时异步？</span><br><span class="line">异步：由React控制的事件处理程序以及生命周期函数中调用setState为异步</span><br><span class="line">同步：React控制之外的原生js绑定的事件、setTimeout&#x2F;setInterval等。</span><br></pre></td></tr></table></figure>

<h2 id="setState-什么时候同步什么时候异步？"><a href="#setState-什么时候同步什么时候异步？" class="headerlink" title="setState 什么时候同步什么时候异步？"></a>setState 什么时候同步什么时候异步？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">react三个模式：</span><br><span class="line">1.legacy模式： 通过ReactDOM.render(&lt;App &#x2F;&gt;, rootNode)创建的，当前react的使用方式</span><br><span class="line">2.blocking模式：通过ReactDOM.createBlockingRoot(rootNode).render(&lt;App &#x2F;&gt;),实验阶段，作为迁移到concurrent模式的第一个步骤</span><br><span class="line">3.concurrent模式，通过ReactDOM.createRoot(rootNode).render(&lt;App &#x2F;&gt;),实验阶段，未来react的默认开发模式</span><br><span class="line"></span><br><span class="line">setState 只在合成事件（react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件）和钩子函数（生命周期中）是异步的，在原生事件和setTimeout中都是同步的。</span><br><span class="line"></span><br><span class="line">不同模式执行结果不同，legacy模式命中batchedUpadates（批处理）时异步，为命中时同步</span><br><span class="line">concurrent模式都是异步的</span><br><span class="line"></span><br><span class="line">setState异步并不是说内部由异步代码实现，其本身执行过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了“异步”</span><br><span class="line"></span><br><span class="line">可以通过第二个参数的callback回调函数中拿到最新的值，在异步中如果对同一个值进行多次setState，那么setState的批量更新策略会将其覆盖，去最后一次的执行，如果同时setState多个值，会在更新时对其进行合并批量更新。</span><br></pre></td></tr></table></figure>

<h2 id="react渲染机制"><a href="#react渲染机制" class="headerlink" title="react渲染机制"></a>react渲染机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">首先打开页面会渲染出一颗DOM树，更新数据会生成一颗虚拟DOM树，通过diff算法，</span><br><span class="line">比较两颗DOM树的差异，找到更新的地方进行批量改动。</span><br><span class="line"></span><br><span class="line">diff：计算一棵树形结构到另一颗树形结构的最少操作。</span><br><span class="line"></span><br><span class="line">1.把树形结构按照层级分解，只比较同级元素</span><br><span class="line">2.给列表结构的每个单元添加唯一的 key 属性，方便比较</span><br><span class="line">3.diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。（官方也不推荐）</span><br></pre></td></tr></table></figure>

<h2 id="React-StrictMode-目前有助于："><a href="#React-StrictMode-目前有助于：" class="headerlink" title="React.StrictMode 目前有助于："></a>React.StrictMode 目前有助于：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">识别不安全的生命周期</span><br><span class="line">关于使用过时字符串 ref API 的警告</span><br><span class="line">关于使用废弃的 findDOMNode 方法的警告</span><br><span class="line">检测意外的副作用</span><br><span class="line">检测过时的 context API</span><br></pre></td></tr></table></figure>

<h2 id="虚拟DOM优点"><a href="#虚拟DOM优点" class="headerlink" title="虚拟DOM优点"></a>虚拟DOM优点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 减少不必要的DOM操作</span><br><span class="line">    1.1虚拟dom可以将多次操作合并为一次操作，比如添加100个节点，确是一个一个操作的</span><br><span class="line">    1.2虚拟dom借助dom diff可以将多余的操作省略掉，比如添加100个节点，其中10个是新增的</span><br><span class="line">    </span><br><span class="line">2. 跨平台渲染</span><br><span class="line">    1.因为虚拟dom本质上是一个js对象</span><br><span class="line">    </span><br><span class="line">react虚拟dom结构:</span><br><span class="line"></span><br><span class="line">const vNode &#x3D; &#123;</span><br><span class="line">    key: null,</span><br><span class="line">    props:&#123;</span><br><span class="line">        children: [</span><br><span class="line">            &#123;type: &#39;span&#39;, ....&#125;,</span><br><span class="line">        ],</span><br><span class="line">        className: &#39;red&#39;,</span><br><span class="line">        onClick: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ref: null,</span><br><span class="line">    type: &#39;div&#39;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建虚拟dom：React.createElement</span><br></pre></td></tr></table></figure>

<h2 id="diff-策略"><a href="#diff-策略" class="headerlink" title="diff 策略"></a>diff 策略</h2><p>`<br>策略一： tree diff<br>1.React对树进行分层比较，两颗虚拟DOM树只会对同一层级的DOM节点进行比较。<br>如果存在跨层级的操作，只会进行创建和删除<br>2.如果节点是组件就进行Component diff<br>3.如果节点是标签就进行Element diff</p>
<p>策略二：component diff<br>如果为非同类型组件的话标记组件为dirty component，替换组件下所有子节点，<br>类型相同更新属性，然后深入组件进行Tree diff（递归遍历对比）</p>
<p>策略三：element diff<br>如果节点是原生标签，则看标签名<br>标签名不同直接替换，相同更新属性，然后进入标签进行Tree diff（递归遍历对比）<br>`</p>
<h2 id="shouldComponentUpdate-nextProps-nextState-是做什么的，（react性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-nextProps-nextState-是做什么的，（react性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)是做什么的，（react性能优化是哪个周期函数？）"></a>shouldComponentUpdate(nextProps, nextState)是做什么的，（react性能优化是哪个周期函数？）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新绘制dom,</span><br><span class="line">由于渲染dom非常消耗性能，合理的调用shouldComponentUpdate方法可以极大的提高性能。</span><br></pre></td></tr></table></figure>

<h2 id="createElement-和-cloneElement有什么区别？"><a href="#createElement-和-cloneElement有什么区别？" class="headerlink" title="createElement 和 cloneElement有什么区别？"></a>createElement 和 cloneElement有什么区别？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">React.createElement()构建React元素。</span><br><span class="line">接受三个参数，第一个参数为标签名，如div、span等，或者react组件，第二个参数为传入的属性，第三个为组件的子组件。</span><br><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">React.cloneElement(),第一个参数传入react元素不是标签名，第二个参数传入属性，新添加的属性会并入原有的属性，第三个参数为子组件</span><br><span class="line">React.cloneElement(</span><br><span class="line">    element,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h2 id="虚拟DOM的优缺点？"><a href="#虚拟DOM的优缺点？" class="headerlink" title="虚拟DOM的优缺点？"></a>虚拟DOM的优缺点？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">1. 处理了浏览器兼容性问题，避免了用户操作真实DOM</span><br><span class="line">2.内容经过xss处理，可以防范xss攻击</span><br><span class="line">3.跨平台开发</span><br><span class="line">4.更新的时候可以实现差异化更新，减少更新DOM的操作</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1.虚拟DOM需要消耗额外的内存</span><br><span class="line">2.首次渲染不一定会更快</span><br></pre></td></tr></table></figure>

<h2 id="React中创建组件的方式"><a href="#React中创建组件的方式" class="headerlink" title="React中创建组件的方式"></a>React中创建组件的方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createClass()、ES6 class组件 无无状态函数式组件</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="react中key的作用"><a href="#react中key的作用" class="headerlink" title="react中key的作用"></a>react中key的作用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key在react中用于追踪哪些列表中元素被修改、添加或者移除的辅助标识。</span><br><span class="line"></span><br><span class="line">在开发中，需要保证某个元素的key在同级元素中具有唯一性。</span><br><span class="line"></span><br><span class="line">diff算法会借助元素的key值来判断元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染</span><br></pre></td></tr></table></figure>

<h2 id="react优势"><a href="#react优势" class="headerlink" title="react优势"></a>react优势</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 速度快：不直接操作dom，采用虚拟dom的概念</span><br><span class="line">2.跨浏览器兼容，兼容性好</span><br><span class="line">3.一切都是component，代码更加模块化，可维护性高</span><br><span class="line">4.单向数据流，采用Flux单向数据层架构</span><br></pre></td></tr></table></figure>

<h2 id="react事件机制"><a href="#react事件机制" class="headerlink" title="react事件机制"></a>react事件机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">react的事件机制利用了事件委托机制，事件并没有真正的绑定在真实的dom节点上，</span><br><span class="line">而是把事件绑定在结构的最外层document，使用统一的事件监听器，所有事件都由这个监听器统一分发。</span><br><span class="line"></span><br><span class="line">组件挂载和更新时，会将绑定的事件分门别类的放进一个叫EvnentPluginHub的事件池中。</span><br><span class="line"></span><br><span class="line">事件触发时，根据事件产生的Event对象找到触发事件的组件，再通过组件标识和事件类型</span><br><span class="line">从事件池中找到对应的事件监听回调，然后执行相关的监听函数。</span><br></pre></td></tr></table></figure>

<h2 id="异步回调中怎么使用syntheticEvent？"><a href="#异步回调中怎么使用syntheticEvent？" class="headerlink" title="异步回调中怎么使用syntheticEvent？"></a>异步回调中怎么使用syntheticEvent？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在合成事件机制里，一旦事件监听回调执行，合成事件对象就会被销毁，异步回调执行的时候</span><br><span class="line">合成事件对象早就被销毁了。</span><br><span class="line">解决方法：执行event.persist(),通知react不需要回收。</span><br></pre></td></tr></table></figure>

<h2 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">React 16推出Fiber之后，如果要开启async rendering，那么在render函数之前的所有函数都有可能被执行多次</span><br><span class="line"></span><br><span class="line">废弃：</span><br><span class="line">componentWillMount</span><br><span class="line">componentWillReceiveProps(nextProps)</span><br><span class="line">componentWillUpdate(nextProps, nextState)</span><br><span class="line">代替：</span><br><span class="line">静态函数：static getDerivedStateFromProps(nextProps, prevState)</span><br><span class="line"></span><br><span class="line">静态函数：static getDerivedStateFromError(error) &#x2F;&#x2F; 渲染备用UI</span><br><span class="line">此生命周期return的值会自动调用setState，将值和state合并</span><br><span class="line">运行事件节点：子组件被渲染发生错误后且在页面更新前</span><br><span class="line"></span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) 此生命周期的返回值将作为参数传递给componentDidUpdate()</span><br><span class="line"></span><br><span class="line">componentDidCatch(error, info) &#x2F;&#x2F; 打印错误信息</span><br><span class="line"></span><br><span class="line">错误边界无法捕获的错误：</span><br><span class="line">1.组件自身的错误</span><br><span class="line">2.异步错误，setTimeout</span><br><span class="line">3.事件中的错误，比如click事件中发生错误</span><br></pre></td></tr></table></figure>

<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 构建action，通过创建一个函数，返回一个对象，需要携带type属性</span><br><span class="line"></span><br><span class="line">2. 构建reducer，用来响应action，然后通过return把数据传回store</span><br><span class="line"></span><br><span class="line">3. 利用createStore来构建store，把reducer作为参数传入</span><br><span class="line"></span><br><span class="line">4. 利用store.subscribe()注册监听</span><br><span class="line"></span><br><span class="line">5. 利用store.dispatch()发送action</span><br><span class="line"></span><br><span class="line">6. 利用store.getState()拿到值</span><br></pre></td></tr></table></figure>

<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><h2 id="ts中type和interface的区别"><a href="#ts中type和interface的区别" class="headerlink" title="ts中type和interface的区别"></a>ts中type和interface的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">1.都可以描述一个对象和函数</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface SetUser &#123;</span><br><span class="line">    (name: string): void;</span><br><span class="line">&#125;</span><br><span class="line">type User &#x3D; &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">type SetUser &#x3D; (name: string): void;</span><br><span class="line"></span><br><span class="line">2.扩展与交叉类型</span><br><span class="line">interface可以extends进行类型扩展，type可以通过交叉类型实现interface的extend行为。</span><br><span class="line">interface可以exteds  type，type也可以与interface类型交叉（&amp;符号）</span><br><span class="line">不同点：</span><br><span class="line">1.type可以声明基本类型别名，联合类型，元祖等类型</span><br><span class="line">基本类型别名</span><br><span class="line">type Name &#x3D; string;</span><br><span class="line">联合类型</span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wang();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line">type Pet &#x3D; Dog | Cat;</span><br><span class="line">元祖类型</span><br><span class="line">type PetList &#x3D; [Dog, Cat];</span><br><span class="line"></span><br><span class="line">2. interface能够声明合并</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface User &#123;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">&#x3D;</span><br><span class="line">&#x2F;**</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="ts中如何实现一个函数的重载"><a href="#ts中如何实现一个函数的重载" class="headerlink" title="ts中如何实现一个函数的重载"></a>ts中如何实现一个函数的重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js是动态类型语言，所以是没有overload的，但js可以在运行的时候判断类型</span><br><span class="line">ts的重载只是重载函数声明，函数的实现还是只有一个</span><br></pre></td></tr></table></figure>

<h2 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable &#x2F;&#x2F;被观察者</span><br><span class="line">Observer &#x2F;&#x2F; 观察者</span><br><span class="line">Reaction &#x2F;&#x2F;响应</span><br><span class="line"></span><br><span class="line">mobx底层对数据的观察是使用Object.defineProperty(mobx4)或Proxy(mobx5)</span><br><span class="line">observer这个装饰器，对react组件的render方法进行跟踪，将render方法加入到各个observable的依赖中，当observale发生变化的时候，就会调用forceUpdate更新组件</span><br><span class="line">（mobx4将Array用类数组对象来模拟的，通过包装类封装为一个对象）</span><br></pre></td></tr></table></figure>

<h2 id="webpack常用loader"><a href="#webpack常用loader" class="headerlink" title="webpack常用loader"></a>webpack常用loader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">样式：style-loader、css-loader、less-loader、sass-loader</span><br><span class="line">文件：file-loader、url-loader</span><br><span class="line">编译：babel-loader、ts-loader</span><br><span class="line">校验：eslint-loader</span><br><span class="line"></span><br><span class="line">常用的plugin</span><br><span class="line">html-webpack-plugin</span><br><span class="line">webpack-bundle-analyzer 打包分析</span><br><span class="line">HotModuleReplacementPlugin 热更新</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自己写webpack插件：</span><br><span class="line">主要就是通过访问compliler和compilation拦截webpack的执行</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">垃圾收集器会定期（周期性）的找出那些不再继续使用的变量，释放其内存，因为开销比较大，所以会按照固定的时间间隔周期性的执行</span><br><span class="line"></span><br><span class="line">最常用的两种方法：标记清除（常用）和引用计数</span><br><span class="line"></span><br><span class="line">标记清除：变量进入作用域，进行标记，离开作用域进行清除回收</span><br><span class="line"></span><br><span class="line">引用计数：就是跟踪记录每个值被引用的次数，引用一次加1，删除减1，引用计数为0时，进行回收，（循环引用可能会导致内存泄漏）</span><br><span class="line"></span><br><span class="line">常见的内存泄漏原因：</span><br><span class="line">全局变量过多引起内存泄漏</span><br><span class="line">闭包</span><br><span class="line">dom事件未清除</span><br><span class="line">循环引用</span><br></pre></td></tr></table></figure>

<h2 id="谈谈你对webpack的理解？"><a href="#谈谈你对webpack的理解？" class="headerlink" title="谈谈你对webpack的理解？"></a>谈谈你对webpack的理解？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">webpack是一个打包模块化js的工具，在webpack里一切文件皆模块</span><br><span class="line">，通过loader转换，通过plugin注入钩子，最后输出由多个</span><br><span class="line">模块组合成的文件，webpack专注构建模块化。WebPack可</span><br><span class="line">以看做是模块的打包机器：它做的事情是，分析你的项目</span><br><span class="line">结构，找到js模块及其它的一些浏览器不能直接运行的</span><br><span class="line">拓展语言，例如：Scss，TS等，并将其打包为合适的格式</span><br><span class="line">以供浏览器使用。</span><br></pre></td></tr></table></figure>

<h2 id="说说webpack与grunt、gulp的不同？"><a href="#说说webpack与grunt、gulp的不同？" class="headerlink" title="说说webpack与grunt、gulp的不同？"></a>说说webpack与grunt、gulp的不同？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">三者都是前端构建工具，grunt和gulp在早期比较流行，</span><br><span class="line">现在webpack相对来说比较主，不过一些轻量化的任务</span><br><span class="line">还是会用gulp来处理，比如单独打包CSS文件等。</span><br><span class="line"></span><br><span class="line">grunt和gulp是基于任务和流（Task、Stream）的。</span><br><span class="line">类似jQuery，找到一个（或一类）文件，对其做一</span><br><span class="line">系列链式操作，更新流上的数据，整条链式操作</span><br><span class="line">构成了一个任务，多个任务就构成了web的构建流程。</span><br><span class="line"></span><br><span class="line">webpack是基于入口的。webpack会自动地递归解析</span><br><span class="line">入口所需要加载的所有资源文件，然后用不同的</span><br><span class="line">Loader来处理不同的文件，用Plugin来扩展webpack功能。</span><br><span class="line"></span><br><span class="line">所以，从构建来说，gulp和grunt需要开发者将整个</span><br><span class="line">前端构建过程拆分成多个&#96;Task&#96;，并合理控制所有&#96;Task&#96;的</span><br><span class="line">调用关系；webpack需要开发者找到入口，并需要清楚对</span><br><span class="line">于不同的资源应该使什么Loader做何种解析和加工对</span><br><span class="line">于知识背景来说，gulp更像后端开发者的思路，</span><br><span class="line">需要对于整个流程了如指掌webpack更倾向于前端开发者的思路</span><br></pre></td></tr></table></figure>

<h2 id="什么是bundle-什么是chunk，什么是module"><a href="#什么是bundle-什么是chunk，什么是module" class="headerlink" title="什么是bundle,什么是chunk，什么是module?"></a>什么是bundle,什么是chunk，什么是module?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bundle：是由webpack打包出来的文件</span><br><span class="line">chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割</span><br><span class="line">module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块</span><br></pre></td></tr></table></figure>

<h2 id="什么是Loader-什么是Plugin"><a href="#什么是Loader-什么是Plugin" class="headerlink" title="什么是Loader?什么是Plugin?"></a>什么是Loader?什么是Plugin?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Loaders是用来告诉webpack如何转化处理某一类型的文件，</span><br><span class="line">并且引入到打包出的文中</span><br><span class="line">2）Plugin是用来自定义webpack打包过程的方式，</span><br><span class="line">一个插件是含有apply方法的一个，通过这个方法可以参与</span><br><span class="line">到整个webpack打包的各个流程(生命周期)。</span><br></pre></td></tr></table></figure>

<h2 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file-loader：把文件输出到一个文件夹中，在代码中通过</span><br><span class="line">相对URL去引用输出的文件</span><br><span class="line">url-loader：和file-loader类似，但是能在文件很小的情况下</span><br><span class="line">以base64的方式把文件内容注入到代码中去</span><br><span class="line">source-map-loader：加载额外的Source Map文件，以方便断点调试</span><br><span class="line">image-loader：加载并且压缩图片文件</span><br><span class="line">babel-loader：把ES6转换成ES5</span><br><span class="line">css-loader：加载CSS，支持模块化、压缩、文件导入等特性</span><br><span class="line">style-loader：把CSS代码注入到JavaScript中，通过DOM操作去加载CSS。</span><br><span class="line">eslint-loader：通过ESLint检查JavaScript代码</span><br></pre></td></tr></table></figure>

<h2 id="有哪些常见的Plugin？他们是解决什么问题的？"><a href="#有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Plugin？他们是解决什么问题的？"></a>有哪些常见的Plugin？他们是解决什么问题的？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define-plugin：定义环境变量</span><br><span class="line">commons-chunk-plugin：提取公共代码</span><br><span class="line">uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</span><br></pre></td></tr></table></figure>

<h2 id="Loader和Plugin的不同？"><a href="#Loader和Plugin的不同？" class="headerlink" title="Loader和Plugin的不同？"></a>Loader和Plugin的不同？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">不同的作用</span><br><span class="line">Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，</span><br><span class="line">但是webpack原生是只能解析js文件，如果想将其他文件</span><br><span class="line">也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</span><br><span class="line"></span><br><span class="line">Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br><span class="line"></span><br><span class="line">不同的用法</span><br><span class="line">Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么</span><br><span class="line">类型的文件（test），使用什么加载(loader)和使用的参数（options）</span><br><span class="line"></span><br><span class="line">Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</span><br></pre></td></tr></table></figure>

<h2 id="webpack的构建流程是什么"><a href="#webpack的构建流程是什么" class="headerlink" title="webpack的构建流程是什么?"></a>webpack的构建流程是什么?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</span><br><span class="line">初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</span><br><span class="line">开始编译：用上一步得到的参数初始化Compiler对象，</span><br><span class="line">加载所有配置的插件，执行对象的 run 方法开始执行编译；</span><br><span class="line"></span><br><span class="line">确定入口：根据配置中的 entry 找出所有的入口文件；</span><br><span class="line"></span><br><span class="line">编译模块：从入口文件出发，调用所有配置的 Loader</span><br><span class="line">对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到</span><br><span class="line">所有入口依赖的文件都经过了本步骤的处理；</span><br><span class="line"></span><br><span class="line">完成模块编译：在经过第4步使用Loader翻译完所有模块后，</span><br><span class="line">得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</span><br><span class="line"></span><br><span class="line">输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk转换成一个单独的文件加入到输</span><br><span class="line">出列表，这步是可以修改输出内容的最后机会；</span><br><span class="line"></span><br><span class="line">输出完成：在确定好输出内容后，根据配置确定输出的</span><br><span class="line">路径和文件名，把文件内容写入到文件系统。</span><br><span class="line"></span><br><span class="line">在以上过程中，Webpack会在特定的时间点广播出特定</span><br><span class="line">的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，</span><br><span class="line">并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</span><br></pre></td></tr></table></figure>

<h2 id="描述一下编写loader或plugin的思路？"><a href="#描述一下编写loader或plugin的思路？" class="headerlink" title="描述一下编写loader或plugin的思路？"></a>描述一下编写loader或plugin的思路？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，</span><br><span class="line">并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。</span><br><span class="line">编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。</span><br><span class="line">相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br></pre></td></tr></table></figure>

<h2 id="如何利用webpack来优化前端性能？"><a href="#如何利用webpack来优化前端性能？" class="headerlink" title="如何利用webpack来优化前端性能？"></a>如何利用webpack来优化前端性能？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用webpack优化前端性能是指优化webpack的输出结果，</span><br><span class="line">让打包的最终结果在浏览器运行快速高效。</span><br><span class="line"></span><br><span class="line">压缩代码。删除多余的代码、注释、简化代码的写法等等方式。</span><br><span class="line">可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件</span><br><span class="line">，利用cssnano（css-loader?minimize）来压缩css</span><br><span class="line"></span><br><span class="line">利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对</span><br><span class="line">应的路径。可以利用webpack对于output参数和各loader的publicPath</span><br><span class="line">参数来修改资源路径</span><br><span class="line"></span><br><span class="line">删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。</span><br><span class="line"></span><br><span class="line">可以通过在启动webpack时追加参数--optimize-minimize来</span><br><span class="line">实现提取公共代码。</span><br></pre></td></tr></table></figure>

<h2 id="如何提高webpack的构建速度？"><a href="#如何提高webpack的构建速度？" class="headerlink" title="如何提高webpack的构建速度？"></a>如何提高webpack的构建速度？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">多入口情况下，使用CommonsChunkPlugin来提取公共代码</span><br><span class="line">通过externals配置来提取常用库</span><br><span class="line">利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，</span><br><span class="line">再通过DllReferencePlugin将预编译的模块加载进来。</span><br><span class="line">使用Happypack 实现多线程加速编译</span><br><span class="line">使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</span><br><span class="line">使用Tree-shaking和Scope Hoisting来剔除多余代码</span><br></pre></td></tr></table></figure>

<h2 id="怎么配置单页应用？怎么配置多页应用？"><a href="#怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="怎么配置单页应用？怎么配置多页应用？"></a>怎么配置单页应用？怎么配置多页应用？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用webpack的AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。</span><br><span class="line">多页应用中要注意的是：每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表,随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</span><br></pre></td></tr></table></figure>

<h2 id="vue项目中实现按需加载？"><a href="#vue项目中实现按需加载？" class="headerlink" title="vue项目中实现按需加载？"></a>vue项目中实现按需加载？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。</span><br><span class="line">不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。</span><br><span class="line">	</span><br><span class="line">单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</span><br><span class="line"></span><br><span class="line">通过import(*)语句来控制加载时机，webpack内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个chunk。当代码执行到import(*)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill</span><br></pre></td></tr></table></figure>


<p>自主搭建、灵活定制、高效复用</p>
<p>1.单向链表的创建、插入和反转<br>2.二叉搜索树的查找、插入、删除思想，写伪代码<br>3.tcp链接和释放过程，http，https，tcp和udp比较<br>4.链表顺序翻转</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"># 面经</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%97%AD%E6%B8%85%E9%99%A4token/" rel="prev" title="浏览器关闭清除token">
      <i class="fa fa-chevron-left"></i> 浏览器关闭清除token
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%89%8B%E5%86%99%E9%83%A8%E5%88%86/" rel="next" title="面试题目手写部分">
      面试题目手写部分 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.</span> <span class="nav-text">从浏览器地址栏输入url到显示页面的步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">2.</span> <span class="nav-text">DNS负载均衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-number">3.</span> <span class="nav-text">强缓存和协商缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">http协议的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">cookie和session的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="nav-number">6.</span> <span class="nav-text">权限身份验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E7%94%A8cookie%E4%B9%8B%E5%90%8Esession%E8%BF%98%E8%83%BD%E7%94%A8%E5%90%97%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">禁用cookie之后session还能用吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">get和post的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%AD%97%E6%AE%B5"><span class="nav-number">9.</span> <span class="nav-text">http常见的请求头字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">http和https的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xss%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%89csrf%EF%BC%88%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">xss（跨域脚本攻击）csrf（跨站请求伪造）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http1-0%E3%80%81http1-1%E5%92%8Chttp2-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">http1.0、http1.1和http2.0的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">13.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E4%B8%8EUDP%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">TCP与UDP区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP%E6%A8%A1%E5%9E%8B"><span class="nav-number">15.</span> <span class="nav-text">TCP&#x2F;IP模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="nav-number">16.</span> <span class="nav-text">正向代理和反向代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OSI%E6%A8%A1%E5%9E%8B"><span class="nav-number">17.</span> <span class="nav-text">OSI模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">18.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">19.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">20.</span> <span class="nav-text">301和302的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie"><span class="nav-number">21.</span> <span class="nav-text">cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#localStorage%E4%BC%9A%E8%AF%9D%E5%AD%98%E5%82%A8-%E5%92%8C-sessionStorage%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-number">22.</span> <span class="nav-text">localStorage会话存储 和 sessionStorage本地存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#html5%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F"><span class="nav-number">23.</span> <span class="nav-text">html5的几种存储形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">24.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fetch%E5%92%8Caxios"><span class="nav-number">25.</span> <span class="nav-text">fetch和axios</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flex%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%EF%BC%8Cgrid%E5%B8%83%E5%B1%80"><span class="nav-number">26.</span> <span class="nav-text">flex常用属性，grid布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#padding-bottom%E5%AE%9E%E7%8E%B0%E5%AD%90%E5%85%83%E7%B4%A0%E9%AB%98%E5%BA%A6%E7%AD%89%E4%BA%8E%E7%88%B6%E5%85%83%E7%B4%A0%E5%AE%BD%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="nav-number">27.</span> <span class="nav-text">padding-bottom实现子元素高度等于父元素宽度问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91"><span class="nav-number">28.</span> <span class="nav-text">预编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this"><span class="nav-number">29.</span> <span class="nav-text">箭头函数中的this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E5%92%8CSet%E4%B8%A4%E7%A7%8D%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">Map和Set两种新的数据结构的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">你对闭包了解多少？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B"><span class="nav-number">32.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%83%BD%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">33.</span> <span class="nav-text">js的new操作符都做了些什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#calc-support-media%E5%90%84%E8%87%AA%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">calc, support, media各自的含义及用法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%9A%E8%AF%9Dcookie-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%81%E4%B9%85cookie"><span class="nav-number">35.</span> <span class="nav-text">什么是会话cookie,什么是持久cookie?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#img%E6%A0%87%E7%AD%BEtitle%E5%92%8Calt%E5%B1%9E%E6%80%A7"><span class="nav-number">36.</span> <span class="nav-text">img标签title和alt属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#es6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">37.</span> <span class="nav-text">es6新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="nav-number">38.</span> <span class="nav-text">图片懒加载原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">39.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#H5%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">H5新增了哪些标签？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SVG%E5%92%8CCanvas%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">SVG和Canvas的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AMD-%E5%92%8C-CMD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">42.</span> <span class="nav-text">AMD 和 CMD的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0js%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E7%BA%A0%E5%81%8F%EF%BC%9F"><span class="nav-number">43.</span> <span class="nav-text">如何实现js倒计时的纠偏？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">44.</span> <span class="nav-text">js的执行机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React"><span class="nav-number"></span> <span class="nav-text">React</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9React%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">请说一下你对React的理解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-lazy%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.</span> <span class="nav-text">React.lazy懒加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">类组件和函数组件之间的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E8%B0%83%E7%94%A8setState%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">当调用setState的时候，发生了什么事？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88setState%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AAcallback%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">为什么setState的参数是一个callback而不是一个对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setState-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%90%8C%E6%AD%A5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BC%82%E6%AD%A5%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">setState 什么时候同步什么时候异步？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">react渲染机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-StrictMode-%E7%9B%AE%E5%89%8D%E6%9C%89%E5%8A%A9%E4%BA%8E%EF%BC%9A"><span class="nav-number">8.</span> <span class="nav-text">React.StrictMode 目前有助于：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM%E4%BC%98%E7%82%B9"><span class="nav-number">9.</span> <span class="nav-text">虚拟DOM优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#diff-%E7%AD%96%E7%95%A5"><span class="nav-number">10.</span> <span class="nav-text">diff 策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shouldComponentUpdate-nextProps-nextState-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%8C%EF%BC%88react%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%98%AF%E5%93%AA%E4%B8%AA%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%EF%BC%9F%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">shouldComponentUpdate(nextProps, nextState)是做什么的，（react性能优化是哪个周期函数？）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#createElement-%E5%92%8C-cloneElement%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">createElement 和 cloneElement有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">虚拟DOM的优缺点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">14.</span> <span class="nav-text">React中创建组件的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#-1"><span class="nav-number">15.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">16.</span> <span class="nav-text">react中key的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react%E4%BC%98%E5%8A%BF"><span class="nav-number">17.</span> <span class="nav-text">react优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">18.</span> <span class="nav-text">react事件机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8syntheticEvent%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">异步回调中怎么使用syntheticEvent？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">20.</span> <span class="nav-text">React生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux"><span class="nav-number">21.</span> <span class="nav-text">Redux</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Typescript"><span class="nav-number"></span> <span class="nav-text">Typescript</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ts%E4%B8%ADtype%E5%92%8Cinterface%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">ts中type和interface的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ts%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">2.</span> <span class="nav-text">ts中如何实现一个函数的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mobx"><span class="nav-number">3.</span> <span class="nav-text">mobx</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack%E5%B8%B8%E7%94%A8loader"><span class="nav-number">4.</span> <span class="nav-text">webpack常用loader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">垃圾回收机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9webpack%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">谈谈你对webpack的理解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4webpack%E4%B8%8Egrunt%E3%80%81gulp%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">说说webpack与grunt、gulp的不同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFbundle-%E4%BB%80%E4%B9%88%E6%98%AFchunk%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFmodule"><span class="nav-number">8.</span> <span class="nav-text">什么是bundle,什么是chunk，什么是module?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFLoader-%E4%BB%80%E4%B9%88%E6%98%AFPlugin"><span class="nav-number">9.</span> <span class="nav-text">什么是Loader?什么是Plugin?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84Loader%EF%BC%9F%E4%BB%96%E4%BB%AC%E6%98%AF%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">有哪些常见的Loader？他们是解决什么问题的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84Plugin%EF%BC%9F%E4%BB%96%E4%BB%AC%E6%98%AF%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">有哪些常见的Plugin？他们是解决什么问题的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loader%E5%92%8CPlugin%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">Loader和Plugin的不同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">13.</span> <span class="nav-text">webpack的构建流程是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E7%BC%96%E5%86%99loader%E6%88%96plugin%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">描述一下编写loader或plugin的思路？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8webpack%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">如何利用webpack来优化前端性能？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">如何提高webpack的构建速度？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%9F%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">怎么配置单页应用？怎么配置多页应用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">vue项目中实现按需加载？</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Foolish-Max</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Foolish-Max</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">236k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
