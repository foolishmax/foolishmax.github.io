<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>面试题目总结 - foolishmax</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="foolishmax"><meta name="msapplication-TileImage" content="/images/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="foolishmax"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="[toc] 从浏览器地址栏输入 url 到显示页面的步骤"><meta property="og:type" content="blog"><meta property="og:title" content="面试题目总结"><meta property="og:url" content="https://github.com/foolishmax/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="foolishmax"><meta property="og:description" content="[toc] 从浏览器地址栏输入 url 到显示页面的步骤"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70"><meta property="og:image" content="https://github.com/images/md_img/%E6%87%92%E5%8A%A0%E8%BD%BD.webp"><meta property="article:published_time" content="2021-10-04T13:54:55.000Z"><meta property="article:modified_time" content="2023-03-15T07:05:20.765Z"><meta property="article:author" content="foolishmax"><meta property="article:tag" content="面经"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/foolishmax/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"},"headline":"面试题目总结","image":["https://github.com/images/md_img/%E6%87%92%E5%8A%A0%E8%BD%BD.webp"],"datePublished":"2021-10-04T13:54:55.000Z","dateModified":"2023-03-15T07:05:20.765Z","author":{"@type":"Person","name":"foolishmax"},"publisher":{"@type":"Organization","name":"foolishmax","logo":{"@type":"ImageObject","url":"https://github.com/images/favicon.svg"}},"description":"[toc] 从浏览器地址栏输入 url 到显示页面的步骤"}</script><link rel="canonical" href="https://github.com/foolishmax/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="foolishmax" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/favicon.svg" alt="foolishmax" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">档案</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/foolishmax"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="detail column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-04T13:54:55.000Z" title="10/4/2021, 9:54:55 PM">2021-10-04</time>发表</span><span class="level-item"><time dateTime="2023-03-15T07:05:20.765Z" title="3/15/2023, 3:05:20 PM">2023-03-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span><span class="level-item">3 小时读完 (大约25898个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">面试题目总结</h1><div class="content"><p>[toc]</p>
<h2 id="从浏览器地址栏输入-url-到显示页面的步骤"><a href="#从浏览器地址栏输入-url-到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入 url 到显示页面的步骤"></a>从浏览器地址栏输入 url 到显示页面的步骤</h2><span id="more"></span>

<pre><code>1. 浏览器查看缓存(浏览器对应的都会有cache文件)。
若请求有缓存且未过期，则取缓存资源提供给客户端，否则发起请求与服务器进行验证。
检验是否过期通常有两个HTTP头：Expires、Cache-control
2.浏览器需要获取域名对应的ip地址，过程如下：
1.本地host文件查找
- 浏览器解析URL获取协议、域名、端口、path路径，然后查看本地硬盘中hosts文件，看是否存在与这个域名对应的规则，如果有就直接使用hosts文件里面的ip地址。
2.路由器缓存
3.ISP DNS(Domain Name System域名系统)(情报局)缓存（互联网提供服务商）-本地DNS服务器以递归方式进行查询缓存记录，
若没有就向跟DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器，
本地DNS服务器把对应关系草存在缓存中（一边下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。
3.客户端发送HTTP请求。
4.TCP传输报文（三次握手四次挥手）
5.向客户端返回资源
6.解析HTML文档，构建DOM树，CSSOM树，下载资源，执行js脚本等。
</code></pre>
<p>扩展：<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3NDY4NDgyOQ==&mid=2247491757&idx=1&sn=a956c6c62c98e2d5ee71c8ed8d3a3eb8&chksm=cecfa85ff9b82149a3e50e81789b29cc0923745cf8a8f7713619aa2499753a3de760f24e6f93&scene=132#wechat_redirect">收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？</a></p>
<h2 id="DNS-负载均衡"><a href="#DNS-负载均衡" class="headerlink" title="DNS 负载均衡"></a>DNS 负载均衡</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个域名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</span><br></pre></td></tr></table></figure>

<h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">强缓存：（expires、Cache-Control）在过期时间内，浏览器再次加载资源时，不会向服务器发起请求，直接从缓存中读取资源</span><br><span class="line"></span><br><span class="line">协商缓存：向服务器发送请求，服务器会根据请求头（request header）的一些参数（Etag、last-modified）来判断是否命中协商缓存，首先根据Etag的值判断请求的文件有没有被修改，如果Etag一致则没有被修改，命中协商缓存返回304，如果不一致则返回新的资源并带上新的Etag返回200状态码。如果没有Etag值，则对比If-Modified-Since和请求文件的最后修改时间，一致则命中协商缓存返回304，不一致则返回新的last-modified和200状态码</span><br></pre></td></tr></table></figure>

<h2 id="http-协议的特点"><a href="#http-协议的特点" class="headerlink" title="http 协议的特点"></a>http 协议的特点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.支持客户/服务器模式</span><br><span class="line">2.简单快速：客户向服务器发送请求时，只需传送请求方法和路径。</span><br><span class="line">3.灵活：http允许传输任意类型的数据对象（Content-Type内容编码类型）</span><br><span class="line"></span><br><span class="line">application/x-www-form-urlencoded 常见post提交数据格式（key-value格式）</span><br><span class="line">application/json</span><br><span class="line"></span><br><span class="line">4.无连接：限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。（原因是早期服务器需要同时面对全世界数十万、上百万的客户端的网页访问，但是每次客户端与服务端传输的数据关联性很低，就会导致大部分通过会很空闲，无端占用资源）</span><br><span class="line"></span><br><span class="line">（解决无连接）Keep-Alive：使客户端到服务端之间的Http连接保持，不会断开，当再次对服务器发送请求时，keep-Alive功能避免了重新建立连接</span><br><span class="line"></span><br><span class="line">5.无状态：Http是一个无状态协议，就是每个请求都是独立的，数据传输完毕不会记录任何信息。缺点就是如果后续处理需要前面的信息，就必须重传，就会导致每次连接传送的数据量增加，如果服务器不需要前面信息的时候应答就会很快。</span><br><span class="line"></span><br><span class="line">（解决无状态）怎样保持http连接状态呢</span><br><span class="line">Cookie（每次http请求的时候，客户端都需要发送响应的cookie信息到服务端，服务端根据cookie判断来自哪个客户端）</span><br><span class="line">服务端生成cookie，客户端保存</span><br><span class="line"></span><br><span class="line">Session</span><br><span class="line">服务端生成一个sessionid，在客户端下次请求的时候在cookie里面记录这个sessionid，然后发送给服务端，服务端再根据cookie中的sessionid来识别客户端返回资源数据。</span><br><span class="line"></span><br><span class="line">禁用cookie怎么办？</span><br><span class="line">url重写，每次http请求的时候，在url后面拼接sid=**参数</span><br><span class="line"></span><br><span class="line">withCredentials:指定在涉及到跨域请求时，是否携带cookie信息，默认为false</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>

<h2 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="headerlink" title="cookie 和 session 的区别"></a>cookie 和 session 的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.存取方式不同： cookie只能保存ASCII字符串，session能够存储任意类型的数据</span><br><span class="line">2.隐私策略不同</span><br><span class="line">3.cookie是存在客户端，session是存在服务器的</span><br><span class="line">4.浏览器的支持不同，浏览器可以禁用cookie</span><br></pre></td></tr></table></figure>

<h2 id="权限身份验证"><a href="#权限身份验证" class="headerlink" title="权限身份验证"></a>权限身份验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">一般都是通过sessionid来进行用户身份验证，sessionid一般会存放在redis中。</span><br><span class="line">1.用户向服务端发送用户名和密码进行登陆</span><br><span class="line">2.服务器验证通过后，服务器为用户创建一个session，并将session信息存储起来</span><br><span class="line">3.服务器向用户返回一个sessionid，写入用户的cookie</span><br><span class="line">4.当用户保持登陆状态时，每次后续请求都会一起发送给后端</span><br><span class="line">5.服务器将存储在cookie中的sessionid和存储在内存或者数据库中的sessin信息进行一个比较，验证用户身份，然后返回响应信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.依赖session的关键业务一定要确保客户端开启了cookie</span><br><span class="line">2.注意session的过期时间</span><br><span class="line"></span><br><span class="line">一般在http header的Authorization字段中添加token</span><br></pre></td></tr></table></figure>

<h2 id="禁用-cookie-之后-session-还能用吗？"><a href="#禁用-cookie-之后-session-还能用吗？" class="headerlink" title="禁用 cookie 之后 session 还能用吗？"></a>禁用 cookie 之后 session 还能用吗？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url重写，例如 https://javascript.cn/?session_id=xxx</span><br><span class="line">缺点是安全性降低，可以对sessionid进行一次加密后传输</span><br></pre></td></tr></table></figure>

<h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.url可见性：get参数url可见，post参数url不可见</span><br><span class="line">2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数</span><br><span class="line">3.缓存性：get请求可以缓存，post请求不可以缓存</span><br><span class="line">4.get请求网页回退时，不产生影响，post请求网页回退会重新发请求</span><br><span class="line">5.传输数据：get一般传输数据大小不超过4k，post可以传输大量数据</span><br><span class="line">6.post较get安全性较高，get是不安全的因为url可见，可能会泄漏私密信息</span><br></pre></td></tr></table></figure>

<h2 id="http-常见的请求头字段"><a href="#http-常见的请求头字段" class="headerlink" title="http 常见的请求头字段"></a>http 常见的请求头字段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Accept: 浏览器可接受的数据类型</span><br><span class="line">Accept-Charset: 浏览器可接受的字符集</span><br><span class="line">Accept-Encoding：浏览器能够进行解码的数据编码方式</span><br><span class="line">Accept-Language： 浏览器所希望的语言种类</span><br><span class="line">Connection：是否需要持久连接，值“Keep-Alive”，HTTP1.1默认进行持久连接</span><br><span class="line">Cookie：cookie信息</span><br><span class="line">content-type</span><br><span class="line">If-Modified-Since：内容被修改才会返回</span><br><span class="line">User-Agent：浏览器类型</span><br><span class="line"></span><br><span class="line">响应头：</span><br><span class="line">content-Length: 表示内容长度</span><br><span class="line">content-type：文档类型</span><br><span class="line">Date：当前时间</span><br><span class="line">Expires：指定缓存过期时间</span><br><span class="line">Last-Modified：文档过期时间</span><br></pre></td></tr></table></figure>

<h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http是超文本传输协议，信息是明文传输，https是更加安全的ssl加密传输协议</span><br><span class="line">http默认是80端口，https默认是443端口</span><br><span class="line">https需要申请CA证书</span><br><span class="line">https是http + ssl/tls（数字证书）进行组合的更加安全的传输协议</span><br><span class="line"></span><br><span class="line">https工作原理（非对称加密）</span><br><span class="line">1.服务端向客户端传递证书作为公钥</span><br><span class="line">2.客户端对证书进行解析，判断证书的办法机构和过期时间等，如果都没有问题，生成一个随机值作为私钥，然后使用证书进行加密发送给服务端</span><br><span class="line">3.服务端解密得到客户端私钥</span><br><span class="line">4.之后双方利用私钥进行加密解密，完成信息的通信</span><br></pre></td></tr></table></figure>

<h2 id="xss（跨域脚本攻击）csrf（跨站请求伪造）"><a href="#xss（跨域脚本攻击）csrf（跨站请求伪造）" class="headerlink" title="xss（跨域脚本攻击）csrf（跨站请求伪造）"></a>xss（跨域脚本攻击）csrf（跨站请求伪造）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">csrf: 需要用户先登陆网站A，获取cookie，利用的是网站A本身的漏洞，去请求网站A的api，---进行token验证，referer验证，只接收本站的请求</span><br><span class="line"></span><br><span class="line">xss：向网站A注入js代码，然后执行js代码，篡改网站A的内容，破坏页面正常结构，插入恶意广告。---编码转换</span><br></pre></td></tr></table></figure>

<h2 id="什么是跨域？解决跨域的方法有哪些"><a href="#什么是跨域？解决跨域的方法有哪些" class="headerlink" title="什么是跨域？解决跨域的方法有哪些?"></a>什么是跨域？解决跨域的方法有哪些?</h2><!--more-->

<ul>
<li><p>同源策略</p>
<ul>
<li>是一种浏览器的安全策略</li>
<li>协议、域名、端口号必须完全一致</li>
<li>不同源的客户端脚本在没有明确的授权的情况下，不能读取对方的资源</li>
</ul>
</li>
<li><p>跨域</p>
<ul>
<li>指一个域下的文档或脚本尝试去请求另一个域下的资源。</li>
</ul>
</li>
</ul>
<!-- more -->

<ul>
<li><p>解决跨域</p>
<ul>
<li><p>jsonp</p>
</li>
<li><p>postMessage 跨域</p>
</li>
<li><p>WebSocket 协议跨域</p>
</li>
<li><p>CORS（跨域资源共享，服务端设置 Access-Control-Allow-Origin，前端无需设置，<br>若要带 cookie 请求，前后端都要设置）</p>
</li>
<li><p>nginx 反向代理接口跨域</p>
</li>
<li><p>document.domain(两个页面通过 js 强制设置 document.domain 为基础主域，针对基础域名相同的情况)</p>
</li>
<li><p>window.name + iframe</p>
</li>
<li><p>location.hash + iframe</p>
</li>
<li><p>…</p>
</li>
</ul>
</li>
<li><p>实现 jsonp 跨域</p>
<ul>
<li>通常为了减轻 web 服务器的负载，我们把 js、css、img 等静态资源分离到另一台独立域名<br>的服务器上，在 html 页面中再通过响应的标签从不同域名加载静态资源。jsonp 就是利用此<br>原理，动态创建 script，再请求一个带参网址实现跨域通信</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var script = document.createElement(&#x27;script&#x27;)</span><br><span class="line">    script.type = &#x27;text/javascript&#x27;</span><br><span class="line"></span><br><span class="line">    //传参一个回调函数名给后端，方便后端返回时执行这个前端定义的回调函数</span><br><span class="line">    script.src = &#x27;http://www.xxx.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line"></span><br><span class="line">    //回调执行函数</span><br><span class="line">    function handleCallbak(res) &#123;</span><br><span class="line">        alert(JSOn.stringify(res))</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="http1-0、http1-1-和-http2-0-的区别"><a href="#http1-0、http1-1-和-http2-0-的区别" class="headerlink" title="http1.0、http1.1 和 http2.0 的区别"></a>http1.0、http1.1 和 http2.0 的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http/1.0 每个请求都要建立一个连接</span><br><span class="line">http/1.1 多了长连接keep-alive，若干个请求需要排队串行化单线程处理，会发生网络请求阻塞问题。</span><br><span class="line">http/2.0 同一个连接可以有多个请求，各个请求直接互不影响（进行了头部压缩和多路复用的优化）</span><br></pre></td></tr></table></figure>

<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单例模式 （class组件中new store创建store实例）</span><br><span class="line">工厂模式 （mobx store中creatLayoutStore）</span><br><span class="line">观察者模式</span><br><span class="line">发布订阅模式</span><br><span class="line">装饰器模式 （移动、pc配置同步@sync）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TCP-与-UDP-区别"><a href="#TCP-与-UDP-区别" class="headerlink" title="TCP 与 UDP 区别"></a>TCP 与 UDP 区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* TCP是面向连接的协议，发送数据前先要建立连接，TCP提供可靠的服务，通过TCP建立连接传输的数据不会丢失，没有重复，并且按照顺序到达。</span><br><span class="line">* UDP是无连接的协议，发送数据前不需要建立连接，是不可靠的</span><br><span class="line">* TCP只支持点对点通信，而UDP支持一对一，多对多</span><br><span class="line">* TCP是面向字节流的，UDP是面向报文的</span><br><span class="line">* TCP通信类似打电话，接通后需要确认身份，才可以开始通信</span><br><span class="line">* UDP类似广播直接进行通信</span><br></pre></td></tr></table></figure>

<h2 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP/IP 模型"></a>TCP/IP 模型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">应用层（应用层就是向用户提供通信服务的活动，提供用户程序接口HTTP、DNS）</span><br><span class="line">传输层（传输层为两台主机上的应用程序提供端到端的通信TCP，UDP）</span><br><span class="line">网络层（网络层实现数据包的选路和转发）</span><br><span class="line">数据链路层（ARP地址解析协议、RARP逆地址解析协议，使用物理地址寻找一台机器）</span><br></pre></td></tr></table></figure>

<h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正向代理是客户端代理，服务端不知道是哪个客户端发起的请求</span><br><span class="line">反向代理是服务端代理，客户端不知道是哪个服务端提供的资源</span><br></pre></td></tr></table></figure>

<h2 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应用层</span><br><span class="line">表示层</span><br><span class="line">会话层</span><br><span class="line"></span><br><span class="line">传输层</span><br><span class="line"></span><br><span class="line">网络层</span><br><span class="line"></span><br><span class="line">数据链路层</span><br><span class="line">物理层</span><br></pre></td></tr></table></figure>

<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>为什么需要三次握手？<br>两次握手第二次结束后，服务端并不能保证客户端已经接收到了第二次的应答信息，如此一来服务器会一直保持通信过程，因为 TCP 通信会占用端口，造成资源浪费。</p>
<p>防止已失效的连接请求报文段突然又传送到服务端，产生错误。<br>如上述情况，如果 client 没有再次向 server 发出确认，server 收不到确认就不会建立连接，可以避免 server 端一直等待浪费资源。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/rememberyf/article/details/80309148">https://blog.csdn.net/rememberyf/article/details/80309148</a></li>
</ul>
<h2 id="301-和-302-的区别"><a href="#301-和-302-的区别" class="headerlink" title="301 和 302 的区别"></a>301 和 302 的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">301 表示资源被永久移除，浏览器在拿到状态码后跳转到一个新的URL地址，可从相应头的location首部中获取，搜索引擎在抓取新内容的同时也将就地址交换为重定向之后的网址。</span><br><span class="line"></span><br><span class="line">302 表示地址资源还在，仍可以访问，搜索引擎会抓取新的内容而保存旧的地址，seo 302 优于301.</span><br><span class="line"></span><br><span class="line">重定向的原因：</span><br><span class="line">网站调整（改变网页目录结构）</span><br><span class="line">页面被移到一个新地址</span><br><span class="line">页面扩展名改变 .php -&gt;.html</span><br><span class="line">如果不做重定向会返回404页面，会白白流失用户访问量。</span><br><span class="line"></span><br><span class="line">1XX 信息性状态码，表示接受的请求正在处理</span><br><span class="line">2XX 成功状态码，表示请求被正常处理完毕</span><br><span class="line">3XX 重定向状态码，表示需要进行附加操作以完成请求</span><br><span class="line">4XX 客户端错误状态码，表示服务器无法处理请求</span><br><span class="line">    400 Bad Request请求出现语法错误</span><br><span class="line">    401 被请求的页面需要用户名和密码</span><br><span class="line">    403 forbidden 请求页面的访问被禁止</span><br><span class="line">    404 资源未找到</span><br><span class="line">5XX 服务器错误状态码，表示服务器处理请求出错</span><br><span class="line">    502 网关错误</span><br><span class="line">    503 服务器超负载或者停机维护，无法处理请求</span><br><span class="line">    504 网关超时</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul>
<li>cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据 cookie 追踪用户在不同页面的访问信息。</li>
<li>cookie 特点<ul>
<li>1.大小限制，cookie 大小限制在 4KB 以内</li>
<li>2.宽带限制，cookie 数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。</li>
<li>3.安全风险，cookie 会频繁的在网络中传送，不加密的情况下是有安全风险的。</li>
<li>4.操作复杂<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name: string, value: string) &#123;</span><br><span class="line">    const exp = new Date();</span><br><span class="line">    //过期时间设置为一天</span><br><span class="line">    exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000);</span><br><span class="line">    document.cookie = `$&#123;name&#125;=$&#123;escape(value);expires=$&#123;exp.toString()&#125;&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="localStorage-会话存储-和-sessionStorage-本地存储"><a href="#localStorage-会话存储-和-sessionStorage-本地存储" class="headerlink" title="localStorage 会话存储 和 sessionStorage 本地存储"></a>localStorage 会话存储 和 sessionStorage 本地存储</h2><ul>
<li>1.存储容量大</li>
<li>2.零宽带，仅存储在本地，不会和服务器发生任何交互行为，不存在网络宽带占用问题。</li>
<li>3.编程接口，提供一套丰富的接口，操作数据更加方便。</li>
<li>4.独立的存储空间，不会造成数据的混乱。</li>
</ul>
<ul>
<li><p>主要区别在于数据存储的 <code>时间范围</code>和<code>页面范围</code></p>
<ul>
<li>sessionStorage: 数据只存储到窗口或标签关闭时，只在当前窗口的当前标签内可见,5M 左右，不同浏览器不同大小。</li>
<li>localStorage: 数据会一直存在除非手动清除，数据可被同源(协议、域名、端口号一致)的每个窗口或标签共享,5M 左右，不同浏览器不同大小。</li>
</ul>
</li>
<li><p>监测是否支持 web Storage</p>
<ul>
<li>1.通过 window.sessionStorage,window.localStorage 判断浏览器是否支持</li>
<li>2.通过 try{}catch{} 执行一下 storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。</li>
</ul>
</li>
</ul>
<h2 id="html5-的几种存储形式"><a href="#html5-的几种存储形式" class="headerlink" title="html5 的几种存储形式"></a>html5 的几种存储形式</h2><ul>
<li>1.本地存储 localStorage,sessionStorage</li>
<li>2.离线缓存 application cache</li>
<li><ol start="3">
<li>indexedDb,webSQL</li>
</ol>
</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.负载均衡、CDN加速、设置缓存、</span><br><span class="line">2.业务逻辑优化</span><br><span class="line">3.代码程序优化（组件按需加载、图片懒加载，代码压缩）</span><br><span class="line">4.避免重绘回流</span><br><span class="line">重绘：页面元素的样式改变不会影响它在文档流中的位置时发生重绘</span><br><span class="line">回流：DOM尺寸大小结构发生变化时</span><br><span class="line">回流一定会导致重绘</span><br><span class="line">如何避免：</span><br><span class="line">1.避免频繁操作dom，通过创建document.createDocumentFragment()一次性插入需要操作的dom</span><br><span class="line">2.具有复杂动画的Dom元素使用绝对定位，使其脱离文档流</span><br><span class="line">3.合并对于Dom中style样式的操作</span><br><span class="line">4.避免使用css表达式 calc()</span><br></pre></td></tr></table></figure>

<h2 id="fetch-和-axios"><a href="#fetch-和-axios" class="headerlink" title="fetch 和 axios"></a>fetch 和 axios</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch取消发送</span><br><span class="line">1.创建一个AbortController实例</span><br><span class="line">2.该实例具有signal属性</span><br><span class="line">3.将signal传递给fetch option</span><br><span class="line">4.调用AbortController的abort属性来取消所有使用该信号的fetch</span><br><span class="line"></span><br><span class="line">axios取消发送</span><br><span class="line">1.const cancelToken = axios.CancelToken</span><br><span class="line">2.const source = CancelToken.source()</span><br><span class="line">3.axios.get(&#x27;/xxx&#x27;,&#123;cancelToken: source.token&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="flex-常用属性，grid-布局"><a href="#flex-常用属性，grid-布局" class="headerlink" title="flex 常用属性，grid 布局"></a>flex 常用属性，grid 布局</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flex属性：</span><br><span class="line">1.flex-direction属性，决定主轴方向</span><br><span class="line">2.flex-wrap属性，控制换行</span><br><span class="line">3.flex-flow属性，flex-direction和flex-wrap的简写形式，默认值flex-flow: row  nowrap;</span><br><span class="line">4.justify-content属性，项目主轴上的对齐方式</span><br><span class="line">5.align-item属性，项目在交叉轴上的对齐方式</span><br><span class="line">6.align-content属性，多个轴线的时候在元素在交叉轴的对齐方式，只有一根轴线时不起作用</span><br><span class="line">flex（子元素的属性）：</span><br><span class="line">1.order属性,定义项目的排列顺序，数值越小，排列越靠前，默认为0.</span><br><span class="line">2.align-self属性，允许单个项目与其他项目不一样的对齐方式，会覆盖align-items属性.</span><br><span class="line">3.flex属性，flex-grow、flex-shrink、flex-basis简写，默认为0 1 auto</span><br><span class="line">    auto(1 1 auto)       none(0 0 auto)</span><br><span class="line">4.flex-grow属性，定义项目的放大比例，默认为0，即如果存在剩余空间也不放大，1等分，一个项目为2，其他为1，则前者占据空间是其他的两倍。</span><br><span class="line">5.flex-shrink属性，定义项目的缩小比例，默认为1，空间不足则缩小，如果所有项目都为1，则等比例缩小，如果有的项目为0，则空间不足时为0的不缩小，负值无效</span><br><span class="line">6.flex-basis属性，项目占据的固定空间</span><br></pre></td></tr></table></figure>

<h2 id="padding-bottom-实现子元素高度等于父元素宽度问题"><a href="#padding-bottom-实现子元素高度等于父元素宽度问题" class="headerlink" title="padding-bottom 实现子元素高度等于父元素宽度问题"></a>padding-bottom 实现子元素高度等于父元素宽度问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当margin或者padding取值是百分比的时候，无论是left，right或者top，bottom，都是以父元素的width为参考物，进行提前占位</span><br></pre></td></tr></table></figure>

<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在作用域的创建阶段（预编译阶段），会生成js的变量对象（VO对象）供js引擎去访问。</span><br><span class="line">1.创建ao对象</span><br><span class="line">2.找形参和变量声明，作为ao对象的属性名，值为undefined</span><br><span class="line">3.实参和形参相统一</span><br><span class="line">4.找函数声明，如果名字和变量相同则覆盖变量声明</span><br><span class="line">5.解释执行</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.箭头函数中的this是在定义函数的时候绑定的（继承自父执行上下文中的this），而不是执行函数时绑定。</span><br><span class="line">2.箭头函数没有this，所以不能用作构造函数。</span><br></pre></td></tr></table></figure>

<h2 id="Map-和-Set-两种新的数据结构的区别？"><a href="#Map-和-Set-两种新的数据结构的区别？" class="headerlink" title="Map 和 Set 两种新的数据结构的区别？"></a>Map 和 Set 两种新的数据结构的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Map类似Object是一种键值对集合，区别在于Map的键不仅限于字符串，其他各种类型的值都可以作为Map的键</span><br><span class="line"></span><br><span class="line">2.Set是类似数组的一种数据结构，不点在于Set中没有重复的值</span><br></pre></td></tr></table></figure>

<h2 id="你对闭包了解多少？"><a href="#你对闭包了解多少？" class="headerlink" title="你对闭包了解多少？"></a>你对闭包了解多少？</h2><pre><code>解释一下作用域链是如何产生的
解释一下js执行山下文的创建、执行过程
解释一下闭包所产生的变量放在哪里
</code></pre>
<ul>
<li>闭包的定义：闭包就是能够读取其他函数内部变量的函数。</li>
<li>闭包的底层实现原理</li>
<li>js 执行上下文：</li>
<li><img src="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70" alt="image"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">js运行三部曲</span><br><span class="line">1.语法分析</span><br><span class="line">2.预编译</span><br><span class="line">3.解释执行</span><br><span class="line"></span><br><span class="line">js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。</span><br><span class="line">预编译的环境需要个环境，这个环境就是执行上下文。</span><br><span class="line"></span><br><span class="line">js执行上下文分为三种：</span><br><span class="line">1.全局执行上下文：代码开始执行时首先进入的环境</span><br><span class="line">2.函数执行上下文：函数调用时，会开始执行函数中的代码</span><br><span class="line">3.eval执行上下文：不建议使用</span><br><span class="line"></span><br><span class="line">执行上下文的周期，分为两个阶段</span><br><span class="line">1.创建阶段</span><br><span class="line">    创建词法环境</span><br><span class="line">    生成变量对象VO，建立作用域链</span><br><span class="line">    确认this指向，并绑定this</span><br><span class="line">2.执行阶段</span><br><span class="line">    进行变量赋值，函数引用以及执行代码</span><br><span class="line"></span><br><span class="line">预编译发生在函数执行前，预编译四部曲：</span><br><span class="line">1.创建AO对象</span><br><span class="line">2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined</span><br><span class="line">3.将形参和实参相统一</span><br><span class="line">4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）</span><br><span class="line">5.最后程序输出变量值的时候，就是从AO对象中拿</span><br><span class="line">（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，</span><br><span class="line">就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包）</span><br></pre></td></tr></table></figure>

<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student.__proto__ === Student.prototype</span><br><span class="line">1.每个函数function都由一个prototype，即显式原型。是在定义函数的时候自动添加的，默认是一个空的Object对象</span><br><span class="line">2.每个引用类型都有一个__proto__,即隐式原型。是创建对象时自动添加的，默认值为构造函数的prototype属性值</span><br><span class="line">实例对象的隐式原型 等于 对应构造函数或类的显式原型</span><br><span class="line">能直接操作显式原型，不能直接操作隐式原型</span><br></pre></td></tr></table></figure>

<h2 id="简单说下原型链"><a href="#简单说下原型链" class="headerlink" title="简单说下原型链"></a>简单说下原型链</h2><ul>
<li><p>原型链是由原型对象组成的，每个对象都有<strong>proto</strong>属性，指向了创建该对象的构造函数的<br>原型，<strong>proto</strong>将对象连接起来组成了原型链。</p>
</li>
<li><p>原型链：用来实现继承和共享属性的有限对象链。</p>
</li>
<li><p>每个对象都有<strong>proto</strong>（隐式原型）属性，指向创建该对象的构造函数的原型。其实<br>这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能<br>访问到，所以使用 <em>proto</em> 来访问。</p>
</li>
<li><p>对象的隐式原型等于对象的构造函数的显式原型：obj.<strong>proto</strong> === Object.prototype</p>
</li>
<li><p>访问属性的时候，js 引擎会调用内部的默认。。。。。。[[Get]]操作，[[Get]]操作首先会检查对象本身是否包含这个属性<br>如果对象没有这个属性，则对象可以通过<strong>proto</strong>来寻找不属于该对象的属性，<strong>proto</strong><br>将对象和原型连接起来形成原型链</p>
</li>
<li><p>Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎创建。</p>
</li>
</ul>
<h2 id="js-的-new-操作符都做了些什么？"><a href="#js-的-new-操作符都做了些什么？" class="headerlink" title="js 的 new 操作符都做了些什么？"></a>js 的 new 操作符都做了些什么？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个空的js对象&#123;&#125;</span><br><span class="line">2. 将空对象的隐式原型__proto__指向构造函数的原型</span><br><span class="line">3. 将空对象作为构造函数的上下文（改变this指向）</span><br><span class="line">4. 对构造函数返回值做判断</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line">function create(fn, ...args) &#123;</span><br><span class="line">    let obj = Object.create(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    // obj.__proto__ = fn.prototype;</span><br><span class="line">    Object.setPrototypeOf(obj, fn.prototype);</span><br><span class="line"></span><br><span class="line">    let result = fn.apply(obj, args);</span><br><span class="line"></span><br><span class="line">    return result instanceof Object ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">在new的时候，会对构造函数的返回值做一些判断</span><br><span class="line">1. 如果返回值是基础类型数据，则忽略返回值</span><br><span class="line">2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效</span><br></pre></td></tr></table></figure>

<h2 id="calc-support-media-各自的含义及用法？"><a href="#calc-support-media-各自的含义及用法？" class="headerlink" title="calc, support, media 各自的含义及用法？"></a>calc, support, media 各自的含义及用法？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@support 主要用于检测浏览器是否支持css的某个属性，相当于条件语句，支持的话写一套样式，</span><br><span class="line">不支持写另外一套样式，例如</span><br><span class="line">    @supports (display: grid) &#123;</span><br><span class="line">      div &#123;</span><br><span class="line">        display: grid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @supports not (display: grid) &#123;</span><br><span class="line">      div &#123;</span><br><span class="line">        float: right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">calc(): 用于动态计算值，支持 + - * / 运算。</span><br><span class="line"></span><br><span class="line">@media查询：可以针对不同的媒体类型定义不同的样式。</span><br></pre></td></tr></table></figure>

<h2 id="什么是会话-cookie-什么是持久-cookie"><a href="#什么是会话-cookie-什么是持久-cookie" class="headerlink" title="什么是会话 cookie,什么是持久 cookie?"></a>什么是会话 cookie,什么是持久 cookie?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie是服务器返回的，指定了expire（有效期）的是持久cookie,没有指定的是会话cookie</span><br></pre></td></tr></table></figure>

<h2 id="img-标签-title-和-alt-属性"><a href="#img-标签-title-和-alt-属性" class="headerlink" title="img 标签 title 和 alt 属性"></a>img 标签 title 和 alt 属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alt: 图片加载失败时，显示在网页上的替代文字</span><br><span class="line">title: 鼠标放在图片上的提示文字</span><br><span class="line"></span><br><span class="line">alt是必须属性，可以为空；title为非必须</span><br></pre></td></tr></table></figure>

<h2 id="es6-新特性"><a href="#es6-新特性" class="headerlink" title="es6 新特性"></a>es6 新特性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.let和const</span><br><span class="line">2.模版字符串</span><br><span class="line">3.箭头函数</span><br><span class="line">4.函数可以设置默认参数值</span><br><span class="line">5.扩展运算符</span><br><span class="line">6.对象和数组的解构</span><br><span class="line">7.class</span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载原理"><a href="#图片懒加载原理" class="headerlink" title="图片懒加载原理"></a>图片懒加载原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器是否发起请求是根据&lt;img /&gt;标签的src属性</span><br><span class="line">2. 所以懒加载的关键是：在图片没有进入可视区域时，</span><br><span class="line">先不给&lt;img /&gt;的src属性赋值，等到图片进入可是区域再给data-src -&gt; src赋值。</span><br><span class="line"></span><br><span class="line">当图片底边距离页面的偏移（图片高度+图片距离顶部偏移高度）</span><br><span class="line">小于等于</span><br><span class="line">浏览器底边距离页面顶部高度（浏览器一屏高度 + 滚动区域）</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="/images/md_img/%E6%87%92%E5%8A%A0%E8%BD%BD.webp" alt="图片懒加载"></li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="H5-新增了哪些标签？"><a href="#H5-新增了哪些标签？" class="headerlink" title="H5 新增了哪些标签？"></a>H5 新增了哪些标签？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article、aside、audio、video、footer、header、nav、section</span><br></pre></td></tr></table></figure>

<h2 id="SVG-和-Canvas-的区别？"><a href="#SVG-和-Canvas-的区别？" class="headerlink" title="SVG 和 Canvas 的区别？"></a>SVG 和 Canvas 的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.svg:表示以XML格式定义图像的可伸缩矢量图形。</span><br><span class="line">2.canvas：通过js来绘制2D图形</span><br><span class="line"></span><br><span class="line">svg通过标签fill属性可以调整颜色</span><br></pre></td></tr></table></figure>

<h2 id="AMD-和-CMD-的区别"><a href="#AMD-和-CMD-的区别" class="headerlink" title="AMD 和 CMD 的区别"></a>AMD 和 CMD 的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">共同点：</span><br><span class="line">1.两者都是框架在推广过程中对模块定义的规范产出</span><br><span class="line">2.都是异步加载模块</span><br><span class="line">不同点：</span><br><span class="line">1.AMD是RequireJs在推广过程中对模块定义的规范产出，CMD是SeaJs在推广过程中对模块定义的规范化产出</span><br><span class="line">2.AMD推崇依赖前置，CMD推崇依赖就近</span><br><span class="line">3.AMD的应用体验好，因为模块提前执行了，CMD性能好，因为只有用户需要的时候才执行</span><br></pre></td></tr></table></figure>

<h2 id="如何实现-js-倒计时的纠偏？"><a href="#如何实现-js-倒计时的纠偏？" class="headerlink" title="如何实现 js 倒计时的纠偏？"></a>如何实现 js 倒计时的纠偏？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 第一种通过前端定时向服务端发送请求获取最新的时间差，以此来校准倒计时时间。</span><br><span class="line">2. 通过前端根据偏差时间来自动调整下次间隔的时间来实现，首先以setTimeout递归的方式来实现倒计时，</span><br><span class="line">通过一个变量记录倒计时的秒数，根据秒数和间隔时间计算出此时无偏差时应该显示的时间，</span><br><span class="line">然后拿当前真实时间与这个时间相减，就可以得到时间的偏差大小，因此在设置下一个定时器的时候，</span><br><span class="line">间隔时间减去这个偏差大小就可以纠正时间误差。</span><br></pre></td></tr></table></figure>

<h2 id="js-的执行机制"><a href="#js-的执行机制" class="headerlink" title="js 的执行机制"></a>js 的执行机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">js是单线程的，处理js任务只能一个一个顺序执行，js中把任务分为了同步任务和异步任务，</span><br><span class="line">同步任务进入主线程先执行，异步任务进入Event Table并注册函数，指定事情完成后，Event Table就会将函数移入到事件队列Event Queque中，等待主线程任务执行完毕，</span><br><span class="line">就会从事件队列中取出对应事件进入主线程执行。</span><br><span class="line"></span><br><span class="line">macro-task（宏任务）：包括整体代码script、setTimeout、setInterval</span><br><span class="line">micro-task（微任务）：Promise.then、process.nextTick</span><br><span class="line">微任务先于宏任务先执行（除了script）执行过程不同任务进入不同的event quue</span><br><span class="line"></span><br><span class="line">js先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，</span><br><span class="line">遇到宏任务放到宏任务事件队列中。</span><br><span class="line"></span><br><span class="line">然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，</span><br><span class="line">等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，</span><br><span class="line">执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，</span><br><span class="line">就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，</span><br><span class="line">以此类推。</span><br></pre></td></tr></table></figure>

<h2 id="请说一下你对-React-的理解？"><a href="#请说一下你对-React-的理解？" class="headerlink" title="请说一下你对 React 的理解？"></a>请说一下你对 React 的理解？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. react是一个网页的UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</span><br><span class="line">2. react的核心设计思路有三个：</span><br><span class="line">声明式</span><br><span class="line">    命令式：命令程序一步一步的执行操作</span><br><span class="line">    声明式：只需告诉程序我们想要的结果，其他的交给程序去做。</span><br><span class="line">组件化</span><br><span class="line">    将视图拆分和模块复用，做到高内聚低耦合</span><br><span class="line"></span><br><span class="line">通用性</span><br><span class="line">    一次学习，随处编写。RN，react360等，跨平台底层靠虚拟DOM实现</span><br><span class="line"></span><br><span class="line">3. 缺点</span><br><span class="line">1.没有官方系统解决方案，在开发大型应用时需要向社区寻找并整合解决方案。</span><br><span class="line">2.过于灵活，需要注意代码规范</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="React-lazy-懒加载"><a href="#React-lazy-懒加载" class="headerlink" title="React.lazy 懒加载"></a>React.lazy 懒加载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// React.lazy方法可以异步加载组件</span><br><span class="line">const Foo = React.lazy(() =&gt; import(&#x27;../components/Foo&#x27;)</span><br><span class="line"></span><br><span class="line">// React.lazy不能单独使用，需要配合React.suspense,用来包裹异步组件，添加loading效果等。</span><br><span class="line">&lt;React.Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">    &lt;Foo /&gt;</span><br><span class="line">&lt;/React.Suspense&gt;</span><br><span class="line"></span><br><span class="line">React.lazy原理</span><br><span class="line">React.lazy使用import来懒加载组件，import在webpack中最终会调用requireEnsure方法，动态插入script来请求js文件，类似jsonp的形式。</span><br></pre></td></tr></table></figure>

<h2 id="类组件和函数组件之间的区别？"><a href="#类组件和函数组件之间的区别？" class="headerlink" title="类组件和函数组件之间的区别？"></a>类组件和函数组件之间的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">接受属性返回React元素</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line">    1.编程思想不同：类组件需要创建实例，基于面向对象的方式编程。函数式组件接受输入返回输出，属于函数式编程的思想。</span><br><span class="line">    2.内存占用：类组件需要创建实例，会占用内存，函数组件不需要创建实例，可以节约内存</span><br><span class="line">    3.捕获特性：函数组件具有捕获特性</span><br><span class="line">    4.可测试性：函数组件更方便编写单元测试</span><br><span class="line">    5.状态：类组件有实例可以维护自己的状态，函数组件可以使用useState维护自己的状态</span><br><span class="line">    6.声明周期：类组件有生命周期，可以在生命周期内写逻辑，函数组件可以在useEffect中</span><br><span class="line">    7.逻辑复用：函数组件通过继承实现逻辑复用，函数组件可以通过自定义hooks实现逻辑复用</span><br><span class="line">    8.性能优化：类组件通过shouldComponentUpdate和PureComponent来跳过更新，函数组件通过React.memo</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="当调用-setState-的时候，发生了什么事？"><a href="#当调用-setState-的时候，发生了什么事？" class="headerlink" title="当调用 setState 的时候，发生了什么事？"></a>当调用 setState 的时候，发生了什么事？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将传递给setState的参数对象合并到组件的当前的状态，react遍历dom节点，计算差异，更新UI。</span><br><span class="line">https://segmentfault.com/a/1190000018250127</span><br></pre></td></tr></table></figure>

<h2 id="为什么-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么 setState 的参数是一个 callback 而不是一个对象"></a>为什么 setState 的参数是一个 callback 而不是一个对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因为this.props和this.state的更新可能是异步的，不能依赖它们的值去计算下一个state</span><br><span class="line">(更新状态不要直接修改this.state，虽然状态可以改变，但不会触发组件的更新)</span><br><span class="line"></span><br><span class="line">setState何时同步何时异步？</span><br><span class="line">异步：由React控制的事件处理程序以及生命周期函数中调用setState为异步</span><br><span class="line">同步：React控制之外的原生js绑定的事件、setTimeout/setInterval等。</span><br></pre></td></tr></table></figure>

<h2 id="setState-什么时候同步什么时候异步？"><a href="#setState-什么时候同步什么时候异步？" class="headerlink" title="setState 什么时候同步什么时候异步？"></a>setState 什么时候同步什么时候异步？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">react三个模式：</span><br><span class="line">1.legacy模式： 通过ReactDOM.render(&lt;App /&gt;, rootNode)创建的，当前react的使用方式</span><br><span class="line">2.blocking模式：通过ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;),实验阶段，作为迁移到concurrent模式的第一个步骤</span><br><span class="line">3.concurrent模式，通过ReactDOM.createRoot(rootNode).render(&lt;App /&gt;),实验阶段，未来react的默认开发模式</span><br><span class="line"></span><br><span class="line">setState 只在合成事件（react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件）和钩子函数（生命周期中）是异步的，在原生事件和setTimeout中都是同步的。</span><br><span class="line"></span><br><span class="line">不同模式执行结果不同，legacy模式命中batchedUpadates（批处理）时异步，为命中时同步</span><br><span class="line">concurrent模式都是异步的</span><br><span class="line"></span><br><span class="line">setState异步并不是说内部由异步代码实现，其本身执行过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了“异步”</span><br><span class="line"></span><br><span class="line">可以通过第二个参数的callback回调函数中拿到最新的值，在异步中如果对同一个值进行多次setState，那么setState的批量更新策略会将其覆盖，去最后一次的执行，如果同时setState多个值，会在更新时对其进行合并批量更新。</span><br></pre></td></tr></table></figure>

<h2 id="react-渲染机制"><a href="#react-渲染机制" class="headerlink" title="react 渲染机制"></a>react 渲染机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">首先打开页面会渲染出一颗DOM树，更新数据会生成一颗虚拟DOM树，通过diff算法，</span><br><span class="line">比较两颗DOM树的差异，找到更新的地方进行批量改动。</span><br><span class="line"></span><br><span class="line">diff：计算一棵树形结构到另一颗树形结构的最少操作。</span><br><span class="line"></span><br><span class="line">1.把树形结构按照层级分解，只比较同级元素</span><br><span class="line">2.给列表结构的每个单元添加唯一的 key 属性，方便比较</span><br><span class="line">3.diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。（官方也不推荐）</span><br></pre></td></tr></table></figure>

<h2 id="React-StrictMode-目前有助于："><a href="#React-StrictMode-目前有助于：" class="headerlink" title="React.StrictMode 目前有助于："></a>React.StrictMode 目前有助于：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">识别不安全的生命周期</span><br><span class="line">关于使用过时字符串 ref API 的警告</span><br><span class="line">关于使用废弃的 findDOMNode 方法的警告</span><br><span class="line">检测意外的副作用</span><br><span class="line">检测过时的 context API</span><br></pre></td></tr></table></figure>

<h2 id="虚拟-DOM-优点"><a href="#虚拟-DOM-优点" class="headerlink" title="虚拟 DOM 优点"></a>虚拟 DOM 优点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 减少不必要的DOM操作</span><br><span class="line">    1.1虚拟dom可以将多次操作合并为一次操作，比如添加100个节点，确是一个一个操作的</span><br><span class="line">    1.2虚拟dom借助dom diff可以将多余的操作省略掉，比如添加100个节点，其中10个是新增的</span><br><span class="line"></span><br><span class="line">2. 跨平台渲染</span><br><span class="line">    1.因为虚拟dom本质上是一个js对象</span><br><span class="line"></span><br><span class="line">react虚拟dom结构:</span><br><span class="line"></span><br><span class="line">const vNode = &#123;</span><br><span class="line">    key: null,</span><br><span class="line">    props:&#123;</span><br><span class="line">        children: [</span><br><span class="line">            &#123;type: &#x27;span&#x27;, ....&#125;,</span><br><span class="line">        ],</span><br><span class="line">        className: &#x27;red&#x27;,</span><br><span class="line">        onClick: () =&gt; &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ref: null,</span><br><span class="line">    type: &#x27;div&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建虚拟dom：React.createElement</span><br></pre></td></tr></table></figure>

<h2 id="diff-策略"><a href="#diff-策略" class="headerlink" title="diff 策略"></a>diff 策略</h2><p>`<br>策略一： tree diff<br>1.React 对树进行分层比较，两颗虚拟 DOM 树只会对同一层级的 DOM 节点进行比较。<br>如果存在跨层级的操作，只会进行创建和删除 2.如果节点是组件就进行 Component diff 3.如果节点是标签就进行 Element diff</p>
<p>策略二：component diff<br>如果为非同类型组件的话标记组件为 dirty component，替换组件下所有子节点，<br>类型相同更新属性，然后深入组件进行 Tree diff（递归遍历对比）</p>
<p>策略三：element diff<br>如果节点是原生标签，则看标签名<br>标签名不同直接替换，相同更新属性，然后进入标签进行 Tree diff（递归遍历对比）<br>`</p>
<h2 id="shouldComponentUpdate-nextProps-nextState-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-nextProps-nextState-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)是做什么的，（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate(nextProps, nextState)是做什么的，（react 性能优化是哪个周期函数？）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新绘制dom,</span><br><span class="line">由于渲染dom非常消耗性能，合理的调用shouldComponentUpdate方法可以极大的提高性能。</span><br></pre></td></tr></table></figure>

<h2 id="createElement-和-cloneElement-有什么区别？"><a href="#createElement-和-cloneElement-有什么区别？" class="headerlink" title="createElement 和 cloneElement 有什么区别？"></a>createElement 和 cloneElement 有什么区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">React.createElement()构建React元素。</span><br><span class="line">接受三个参数，第一个参数为标签名，如div、span等，或者react组件，第二个参数为传入的属性，第三个为组件的子组件。</span><br><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">React.cloneElement(),第一个参数传入react元素不是标签名，第二个参数传入属性，新添加的属性会并入原有的属性，第三个参数为子组件</span><br><span class="line">React.cloneElement(</span><br><span class="line">    element,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="虚拟-DOM-的优缺点？"><a href="#虚拟-DOM-的优缺点？" class="headerlink" title="虚拟 DOM 的优缺点？"></a>虚拟 DOM 的优缺点？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">1. 处理了浏览器兼容性问题，避免了用户操作真实DOM</span><br><span class="line">2.内容经过xss处理，可以防范xss攻击</span><br><span class="line">3.跨平台开发</span><br><span class="line">4.更新的时候可以实现差异化更新，减少更新DOM的操作</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1.虚拟DOM需要消耗额外的内存</span><br><span class="line">2.首次渲染不一定会更快</span><br></pre></td></tr></table></figure>

<h2 id="React-中创建组件的方式"><a href="#React-中创建组件的方式" class="headerlink" title="React 中创建组件的方式"></a>React 中创建组件的方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createClass()、ES6 class组件 无无状态函数式组件</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="react-中-key-的作用"><a href="#react-中-key-的作用" class="headerlink" title="react 中 key 的作用"></a>react 中 key 的作用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key在react中用于追踪哪些列表中元素被修改、添加或者移除的辅助标识。</span><br><span class="line"></span><br><span class="line">在开发中，需要保证某个元素的key在同级元素中具有唯一性。</span><br><span class="line"></span><br><span class="line">diff算法会借助元素的key值来判断元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染</span><br></pre></td></tr></table></figure>

<h2 id="react-优势"><a href="#react-优势" class="headerlink" title="react 优势"></a>react 优势</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 速度快：不直接操作dom，采用虚拟dom的概念</span><br><span class="line">2.跨浏览器兼容，兼容性好</span><br><span class="line">3.一切都是component，代码更加模块化，可维护性高</span><br><span class="line">4.单向数据流，采用Flux单向数据层架构</span><br></pre></td></tr></table></figure>

<h2 id="react-事件机制"><a href="#react-事件机制" class="headerlink" title="react 事件机制"></a>react 事件机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">react的事件机制利用了事件委托机制，事件并没有真正的绑定在真实的dom节点上，</span><br><span class="line">而是把事件绑定在结构的最外层document，使用统一的事件监听器，所有事件都由这个监听器统一分发。</span><br><span class="line"></span><br><span class="line">组件挂载和更新时，会将绑定的事件分门别类的放进一个叫EvnentPluginHub的事件池中。</span><br><span class="line"></span><br><span class="line">事件触发时，根据事件产生的Event对象找到触发事件的组件，再通过组件标识和事件类型</span><br><span class="line">从事件池中找到对应的事件监听回调，然后执行相关的监听函数。</span><br></pre></td></tr></table></figure>

<h2 id="异步回调中怎么使用-syntheticEvent？"><a href="#异步回调中怎么使用-syntheticEvent？" class="headerlink" title="异步回调中怎么使用 syntheticEvent？"></a>异步回调中怎么使用 syntheticEvent？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在合成事件机制里，一旦事件监听回调执行，合成事件对象就会被销毁，异步回调执行的时候</span><br><span class="line">合成事件对象早就被销毁了。</span><br><span class="line">解决方法：执行event.persist(),通知react不需要回收。</span><br></pre></td></tr></table></figure>

<h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">React 16推出Fiber之后，如果要开启async rendering，那么在render函数之前的所有函数都有可能被执行多次</span><br><span class="line"></span><br><span class="line">废弃：</span><br><span class="line">componentWillMount</span><br><span class="line">componentWillReceiveProps(nextProps)</span><br><span class="line">componentWillUpdate(nextProps, nextState)</span><br><span class="line">代替：</span><br><span class="line">静态函数：static getDerivedStateFromProps(nextProps, prevState)</span><br><span class="line"></span><br><span class="line">静态函数：static getDerivedStateFromError(error) // 渲染备用UI</span><br><span class="line">此生命周期return的值会自动调用setState，将值和state合并</span><br><span class="line">运行事件节点：子组件被渲染发生错误后且在页面更新前</span><br><span class="line"></span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) 此生命周期的返回值将作为参数传递给componentDidUpdate()</span><br><span class="line"></span><br><span class="line">componentDidCatch(error, info) // 打印错误信息</span><br><span class="line"></span><br><span class="line">错误边界无法捕获的错误：</span><br><span class="line">1.组件自身的错误</span><br><span class="line">2.异步错误，setTimeout</span><br><span class="line">3.事件中的错误，比如click事件中发生错误</span><br></pre></td></tr></table></figure>

<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 构建action，通过创建一个函数，返回一个对象，需要携带type属性</span><br><span class="line"></span><br><span class="line">2. 构建reducer，用来响应action，然后通过return把数据传回store</span><br><span class="line"></span><br><span class="line">3. 利用createStore来构建store，把reducer作为参数传入</span><br><span class="line"></span><br><span class="line">4. 利用store.subscribe()注册监听</span><br><span class="line"></span><br><span class="line">5. 利用store.dispatch()发送action</span><br><span class="line"></span><br><span class="line">6. 利用store.getState()拿到值</span><br></pre></td></tr></table></figure>

<h2 id="ts-中-type-和-interface-的区别"><a href="#ts-中-type-和-interface-的区别" class="headerlink" title="ts 中 type 和 interface 的区别"></a>ts 中 type 和 interface 的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">1.都可以描述一个对象和函数</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface SetUser &#123;</span><br><span class="line">    (name: string): void;</span><br><span class="line">&#125;</span><br><span class="line">type User = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">type SetUser = (name: string): void;</span><br><span class="line"></span><br><span class="line">2.扩展与交叉类型</span><br><span class="line">interface可以extends进行类型扩展，type可以通过交叉类型实现interface的extend行为。</span><br><span class="line">interface可以exteds  type，type也可以与interface类型交叉（&amp;符号）</span><br><span class="line">不同点：</span><br><span class="line">1.type可以声明基本类型别名，联合类型，元祖等类型</span><br><span class="line">基本类型别名</span><br><span class="line">type Name = string;</span><br><span class="line">联合类型</span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wang();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line">type Pet = Dog | Cat;</span><br><span class="line">元祖类型</span><br><span class="line">type PetList = [Dog, Cat];</span><br><span class="line"></span><br><span class="line">2. interface能够声明合并</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface User &#123;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">=</span><br><span class="line">/**</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="ts-中如何实现一个函数的重载"><a href="#ts-中如何实现一个函数的重载" class="headerlink" title="ts 中如何实现一个函数的重载"></a>ts 中如何实现一个函数的重载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js是动态类型语言，所以是没有overload的，但js可以在运行的时候判断类型</span><br><span class="line">ts的重载只是重载函数声明，函数的实现还是只有一个</span><br></pre></td></tr></table></figure>

<h2 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable //被观察者</span><br><span class="line">Observer // 观察者</span><br><span class="line">Reaction //响应</span><br><span class="line"></span><br><span class="line">mobx底层对数据的观察是使用Object.defineProperty(mobx4)或Proxy(mobx5)</span><br><span class="line">observer这个装饰器，对react组件的render方法进行跟踪，将render方法加入到各个observable的依赖中，当observale发生变化的时候，就会调用forceUpdate更新组件</span><br><span class="line">（mobx4将Array用类数组对象来模拟的，通过包装类封装为一个对象）</span><br></pre></td></tr></table></figure>

<h2 id="webpack-常用-loader"><a href="#webpack-常用-loader" class="headerlink" title="webpack 常用 loader"></a>webpack 常用 loader</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">样式：style-loader、css-loader、less-loader、sass-loader</span><br><span class="line">文件：file-loader、url-loader</span><br><span class="line">编译：babel-loader、ts-loader</span><br><span class="line">校验：eslint-loader</span><br><span class="line"></span><br><span class="line">常用的plugin</span><br><span class="line">html-webpack-plugin</span><br><span class="line">webpack-bundle-analyzer 打包分析</span><br><span class="line">HotModuleReplacementPlugin 热更新</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自己写webpack插件：</span><br><span class="line">主要就是通过访问compliler和compilation拦截webpack的执行</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">垃圾收集器会定期（周期性）的找出那些不再继续使用的变量，释放其内存，因为开销比较大，所以会按照固定的时间间隔周期性的执行</span><br><span class="line"></span><br><span class="line">最常用的两种方法：标记清除（常用）和引用计数</span><br><span class="line"></span><br><span class="line">标记清除：变量进入作用域，进行标记，离开作用域进行清除回收</span><br><span class="line"></span><br><span class="line">引用计数：就是跟踪记录每个值被引用的次数，引用一次加1，删除减1，引用计数为0时，进行回收，（循环引用可能会导致内存泄漏）</span><br><span class="line"></span><br><span class="line">常见的内存泄漏原因：</span><br><span class="line">全局变量过多引起内存泄漏</span><br><span class="line">闭包</span><br><span class="line">dom事件未清除</span><br><span class="line">循环引用</span><br></pre></td></tr></table></figure>

<h2 id="谈谈你对-webpack-的理解？"><a href="#谈谈你对-webpack-的理解？" class="headerlink" title="谈谈你对 webpack 的理解？"></a>谈谈你对 webpack 的理解？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">webpack是一个打包模块化js的工具，在webpack里一切文件皆模块</span><br><span class="line">，通过loader转换，通过plugin注入钩子，最后输出由多个</span><br><span class="line">模块组合成的文件，webpack专注构建模块化。WebPack可</span><br><span class="line">以看做是模块的打包机器：它做的事情是，分析你的项目</span><br><span class="line">结构，找到js模块及其它的一些浏览器不能直接运行的</span><br><span class="line">拓展语言，例如：Scss，TS等，并将其打包为合适的格式</span><br><span class="line">以供浏览器使用。</span><br></pre></td></tr></table></figure>

<h2 id="说说-webpack-与-grunt、gulp-的不同？"><a href="#说说-webpack-与-grunt、gulp-的不同？" class="headerlink" title="说说 webpack 与 grunt、gulp 的不同？"></a>说说 webpack 与 grunt、gulp 的不同？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">三者都是前端构建工具，grunt和gulp在早期比较流行，</span><br><span class="line">现在webpack相对来说比较主，不过一些轻量化的任务</span><br><span class="line">还是会用gulp来处理，比如单独打包CSS文件等。</span><br><span class="line"></span><br><span class="line">grunt和gulp是基于任务和流（Task、Stream）的。</span><br><span class="line">类似jQuery，找到一个（或一类）文件，对其做一</span><br><span class="line">系列链式操作，更新流上的数据，整条链式操作</span><br><span class="line">构成了一个任务，多个任务就构成了web的构建流程。</span><br><span class="line"></span><br><span class="line">webpack是基于入口的。webpack会自动地递归解析</span><br><span class="line">入口所需要加载的所有资源文件，然后用不同的</span><br><span class="line">Loader来处理不同的文件，用Plugin来扩展webpack功能。</span><br><span class="line"></span><br><span class="line">所以，从构建来说，gulp和grunt需要开发者将整个</span><br><span class="line">前端构建过程拆分成多个`Task`，并合理控制所有`Task`的</span><br><span class="line">调用关系；webpack需要开发者找到入口，并需要清楚对</span><br><span class="line">于不同的资源应该使什么Loader做何种解析和加工对</span><br><span class="line">于知识背景来说，gulp更像后端开发者的思路，</span><br><span class="line">需要对于整个流程了如指掌webpack更倾向于前端开发者的思路</span><br></pre></td></tr></table></figure>

<h2 id="什么是-bundle-什么是-chunk，什么是-module"><a href="#什么是-bundle-什么是-chunk，什么是-module" class="headerlink" title="什么是 bundle,什么是 chunk，什么是 module?"></a>什么是 bundle,什么是 chunk，什么是 module?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bundle：是由webpack打包出来的文件</span><br><span class="line">chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割</span><br><span class="line">module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块</span><br></pre></td></tr></table></figure>

<h2 id="什么是-Loader-什么是-Plugin"><a href="#什么是-Loader-什么是-Plugin" class="headerlink" title="什么是 Loader?什么是 Plugin?"></a>什么是 Loader?什么是 Plugin?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Loaders是用来告诉webpack如何转化处理某一类型的文件，</span><br><span class="line">并且引入到打包出的文中</span><br><span class="line">2）Plugin是用来自定义webpack打包过程的方式，</span><br><span class="line">一个插件是含有apply方法的一个，通过这个方法可以参与</span><br><span class="line">到整个webpack打包的各个流程(生命周期)。</span><br></pre></td></tr></table></figure>

<h2 id="有哪些常见的-Loader？他们是解决什么问题的？"><a href="#有哪些常见的-Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的 Loader？他们是解决什么问题的？"></a>有哪些常见的 Loader？他们是解决什么问题的？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file-loader：把文件输出到一个文件夹中，在代码中通过</span><br><span class="line">相对URL去引用输出的文件</span><br><span class="line">url-loader：和file-loader类似，但是能在文件很小的情况下</span><br><span class="line">以base64的方式把文件内容注入到代码中去</span><br><span class="line">source-map-loader：加载额外的Source Map文件，以方便断点调试</span><br><span class="line">image-loader：加载并且压缩图片文件</span><br><span class="line">babel-loader：把ES6转换成ES5</span><br><span class="line">css-loader：加载CSS，支持模块化、压缩、文件导入等特性</span><br><span class="line">style-loader：把CSS代码注入到JavaScript中，通过DOM操作去加载CSS。</span><br><span class="line">eslint-loader：通过ESLint检查JavaScript代码</span><br></pre></td></tr></table></figure>

<h2 id="有哪些常见的-Plugin？他们是解决什么问题的？"><a href="#有哪些常见的-Plugin？他们是解决什么问题的？" class="headerlink" title="有哪些常见的 Plugin？他们是解决什么问题的？"></a>有哪些常见的 Plugin？他们是解决什么问题的？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define-plugin：定义环境变量</span><br><span class="line">commons-chunk-plugin：提取公共代码</span><br><span class="line">uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</span><br></pre></td></tr></table></figure>

<h2 id="Loader-和-Plugin-的不同？"><a href="#Loader-和-Plugin-的不同？" class="headerlink" title="Loader 和 Plugin 的不同？"></a>Loader 和 Plugin 的不同？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">不同的作用</span><br><span class="line">Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，</span><br><span class="line">但是webpack原生是只能解析js文件，如果想将其他文件</span><br><span class="line">也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</span><br><span class="line"></span><br><span class="line">Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br><span class="line"></span><br><span class="line">不同的用法</span><br><span class="line">Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么</span><br><span class="line">类型的文件（test），使用什么加载(loader)和使用的参数（options）</span><br><span class="line"></span><br><span class="line">Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</span><br></pre></td></tr></table></figure>

<h2 id="webpack-的构建流程是什么"><a href="#webpack-的构建流程是什么" class="headerlink" title="webpack 的构建流程是什么?"></a>webpack 的构建流程是什么?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</span><br><span class="line">初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</span><br><span class="line">开始编译：用上一步得到的参数初始化Compiler对象，</span><br><span class="line">加载所有配置的插件，执行对象的 run 方法开始执行编译；</span><br><span class="line"></span><br><span class="line">确定入口：根据配置中的 entry 找出所有的入口文件；</span><br><span class="line"></span><br><span class="line">编译模块：从入口文件出发，调用所有配置的 Loader</span><br><span class="line">对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到</span><br><span class="line">所有入口依赖的文件都经过了本步骤的处理；</span><br><span class="line"></span><br><span class="line">完成模块编译：在经过第4步使用Loader翻译完所有模块后，</span><br><span class="line">得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</span><br><span class="line"></span><br><span class="line">输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk转换成一个单独的文件加入到输</span><br><span class="line">出列表，这步是可以修改输出内容的最后机会；</span><br><span class="line"></span><br><span class="line">输出完成：在确定好输出内容后，根据配置确定输出的</span><br><span class="line">路径和文件名，把文件内容写入到文件系统。</span><br><span class="line"></span><br><span class="line">在以上过程中，Webpack会在特定的时间点广播出特定</span><br><span class="line">的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，</span><br><span class="line">并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</span><br></pre></td></tr></table></figure>

<h2 id="描述一下编写-loader-或-plugin-的思路？"><a href="#描述一下编写-loader-或-plugin-的思路？" class="headerlink" title="描述一下编写 loader 或 plugin 的思路？"></a>描述一下编写 loader 或 plugin 的思路？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，</span><br><span class="line">并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。</span><br><span class="line">编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。</span><br><span class="line">相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br></pre></td></tr></table></figure>

<h2 id="如何利用-webpack-来优化前端性能？"><a href="#如何利用-webpack-来优化前端性能？" class="headerlink" title="如何利用 webpack 来优化前端性能？"></a>如何利用 webpack 来优化前端性能？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用webpack优化前端性能是指优化webpack的输出结果，</span><br><span class="line">让打包的最终结果在浏览器运行快速高效。</span><br><span class="line"></span><br><span class="line">压缩代码。删除多余的代码、注释、简化代码的写法等等方式。</span><br><span class="line">可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件</span><br><span class="line">，利用cssnano（css-loader?minimize）来压缩css</span><br><span class="line"></span><br><span class="line">利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对</span><br><span class="line">应的路径。可以利用webpack对于output参数和各loader的publicPath</span><br><span class="line">参数来修改资源路径</span><br><span class="line"></span><br><span class="line">删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。</span><br><span class="line"></span><br><span class="line">可以通过在启动webpack时追加参数--optimize-minimize来</span><br><span class="line">实现提取公共代码。</span><br></pre></td></tr></table></figure>

<h2 id="如何提高-webpack-的构建速度？"><a href="#如何提高-webpack-的构建速度？" class="headerlink" title="如何提高 webpack 的构建速度？"></a>如何提高 webpack 的构建速度？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">多入口情况下，使用CommonsChunkPlugin来提取公共代码</span><br><span class="line">通过externals配置来提取常用库</span><br><span class="line">利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，</span><br><span class="line">再通过DllReferencePlugin将预编译的模块加载进来。</span><br><span class="line">使用Happypack 实现多线程加速编译</span><br><span class="line">使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</span><br><span class="line">使用Tree-shaking和Scope Hoisting来剔除多余代码</span><br></pre></td></tr></table></figure>

<h2 id="怎么配置单页应用？怎么配置多页应用？"><a href="#怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="怎么配置单页应用？怎么配置多页应用？"></a>怎么配置单页应用？怎么配置多页应用？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用webpack的AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。</span><br><span class="line">多页应用中要注意的是：每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表,随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</span><br></pre></td></tr></table></figure>

<h2 id="vue-项目中实现按需加载？"><a href="#vue-项目中实现按需加载？" class="headerlink" title="vue 项目中实现按需加载？"></a>vue 项目中实现按需加载？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。</span><br><span class="line">不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。</span><br><span class="line"></span><br><span class="line">单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</span><br><span class="line"></span><br><span class="line">通过import(*)语句来控制加载时机，webpack内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个chunk。当代码执行到import(*)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill</span><br></pre></td></tr></table></figure>

<p>自主搭建、灵活定制、高效复用</p>
<p>1.单向链表的创建、插入和反转 2.二叉搜索树的查找、插入、删除思想，写伪代码<br>3.tcp 链接和释放过程，http，https，tcp 和 udp 比较 4.链表顺序翻转</p>
<h2 id="如何阻止冒泡"><a href="#如何阻止冒泡" class="headerlink" title="如何阻止冒泡?"></a>如何阻止冒泡?</h2><pre><code>W3C的方法e.stopPropagation(),IE使用e.cancelBubble = true;

封装：
    //阻止冒泡行为
    function stopBubble(e) &#123;
        //如果提供了事件对象，则这是一个非IE浏览器
        if (e &amp;&amp; e.stopPropagation) e.stopPropagation()
        //IE的方法
        else window.event.cancelBubble = true
    &#125;
</code></pre>
<h2 id="如何阻止默认事件？"><a href="#如何阻止默认事件？" class="headerlink" title="如何阻止默认事件？"></a>如何阻止默认事件？</h2><pre><code>W3C的方法是e.preventDefault(),IE使用e.returnValue = false

封装：
    //阻止浏览器的默认行为
    function stopDefault (e) &#123;
        if (e &amp;&amp; e.preventDefault) e.preventDefault()
        //IE中阻止默认事件的方法
        else window.event.returnValue = false
        return false
    &#125;
</code></pre>
<h2 id="补充：事件绑定的封装"><a href="#补充：事件绑定的封装" class="headerlink" title="补充：事件绑定的封装"></a>补充：事件绑定的封装</h2><pre><code>function addEvent(element,type,handle) &#123;
    if(element.addEventListener)&#123;
        element.addEventListener(type,handle,false);
    &#125;else if(element.attachEvent)&#123;
        element.attachEvent(&#39;on&#39;+type,function () &#123;
            handle.call(element);
        &#125;)
    &#125;else &#123;
        element[&#39;on&#39;+type] = handle;
    &#125;
&#125;
</code></pre>
<h2 id="JS-如何设置获取盒子模型对应的宽和高？"><a href="#JS-如何设置获取盒子模型对应的宽和高？" class="headerlink" title="JS 如何设置获取盒子模型对应的宽和高？"></a>JS 如何设置获取盒子模型对应的宽和高？</h2><ul>
<li><p>dom.style.width/height</p>
</li>
<li><p>dom.currentStyle.width/height (ie 支持)</p>
</li>
<li><p>window.getComputedStyle(dom).width/height</p>
</li>
<li><p>dom.getBoundingClientRect().width/height</p>
</li>
</ul>
<h4 id="如何判断一个对象是否为数组"><a href="#如何判断一个对象是否为数组" class="headerlink" title="如何判断一个对象是否为数组"></a>如何判断一个对象是否为数组</h4><pre><code>1. Array.prototype.isPrototypeOf(obj)方法，判断Array.prototype是不是在obj的原型链中，
如果在，则返回true，否则返回false。

2. obj instanceof Array

3. Object.prototype.toString.call(obj); //(===&quot;[object Array]&quot;)

4.Array.isArray(obj)
</code></pre>
<h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><pre><code>1.macro-task(宏任务)：包括整体代码script、setTimeout、setInterval
2.micro-task(微任务)：Promise.then、process.nextTick
</code></pre>
<h4 id="Http-的持久连接和管线化"><a href="#Http-的持久连接和管线化" class="headerlink" title="Http 的持久连接和管线化"></a>Http 的持久连接和管线化</h4><pre><code>1. 什么是持久连接？
    HTTP1.1规定了默认保持持久连接，数据传输完成也保持TCP连接不断开，等待同域名下
    继续使用这个通道传输数据,在一个TCP连接上传输多个HTTP请求和响应。

    持久连接避免了重新建立连接，大大减少了建立和关闭连接的消耗和延迟，HTTP的连接是建立
    在TCP协议之上的，建立一条TCP连接需要三次握手，TCP连接关闭需要四次挥手，这些都需要时间。

2. 什么是管线化？
    持久连接：
        请求1 ——&gt; 响应1 ——&gt; 请求2 ——&gt; 响应2
    管线化：
        请求1 ——&gt; 请求2 ——&gt; 响应1 ——&gt; 响应2

    管线化机制需要通过持久化连接完成。

    持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后，
    才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。
    实现并行发送请求。

    只有GET和HEAD请求可以进行管线化，而POST有所限制。

    初次建立连接不应启动管线机制，因为对方服务器不一定支持HTTP1.1版本的协议。
</code></pre>
<h4 id="为什么利用多个域名来存储网站资源会更有效？"><a href="#为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="为什么利用多个域名来存储网站资源会更有效？"></a>为什么利用多个域名来存储网站资源会更有效？</h4><pre><code>1.CDN 是构建在网络之上的内容分发网络，可以使用户就近获取资源，减低网络拥塞，提高用户
访问的响应效率以及命中率。

2.突破浏览器的并发限制，同一时间针对同一域名下的请求有一定的数量限制，超过限定数目
的请求会被阻塞。

3.节约cookie带宽

4.减少主域名的连接数，优化页面响应速度

5.防止不必要的安全问题
</code></pre>
<h4 id="CSS-权重（156-进制）"><a href="#CSS-权重（156-进制）" class="headerlink" title="CSS 权重（156 进制）"></a>CSS 权重（156 进制）</h4><pre><code>1. ！import  权值：infinite 无穷大

2. 内联样式， 权值1000

3. ID选择器， 权值： 100

4. 类、伪类、属性选择器， 权值： 10

5.标签、伪元素选择器， 权值： 1

6.通配符选择器 *，子选择器 &gt;,相邻选择器 +，权值： 0

权值相等，后来居上
</code></pre>
<h4 id="html5-的新特性"><a href="#html5-的新特性" class="headerlink" title="html5 的新特性"></a>html5 的新特性</h4><pre><code>1. 添加了video、radio标签
2. 添加了canvas画布和svg渲染矢量图片
3. 添加了一些语义化的标签 header、footer、main、section...
4. input的type值新添加了很多属性（email，search，color，number...）
5. 添加了地理位置定位功能 Geolocation API
6. 添加了web Storage存储功能，localStorage和sessionStorage
7. 使用html5，通过创建cache manifest文件，可以轻松地创建web应用的离线版本
8. web worker创造多线程环境，是运行在后台的javaScript。
9。 服务端推送（EventSource用于接受服务端发送事件通知）
</code></pre>
<h4 id="CSS3-新添加的特性？"><a href="#CSS3-新添加的特性？" class="headerlink" title="CSS3 新添加的特性？"></a>CSS3 新添加的特性？</h4><pre><code>1. 媒体查询
2. transform，transition，translate，scale，rotate等相关动画效果
3. box-shadow，text-shadow等特效
4. CSS3 @font-face规则，可以引入任意字体
5. CSS3 @keyframes规则，创建动画(配合animation使用)
6. 2D、3D转化
7. 添加了border-radius、border-image、column-count、resize、box-sizing
、outline-offset等属性
</code></pre>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><pre><code>基本数据类型：Null、Undefined、String、Boolean、Number
ES6：Symbol
ES10：Bigint（可以突破安全整数限制，安全的存储和操作最大整数之外的整数，不会损失精度）
</code></pre>
<h2 id="牛客学习"><a href="#牛客学习" class="headerlink" title="牛客学习"></a>牛客学习</h2><ul>
<li><p>超链接</p>
<ul>
<li>a 标签的 href 的属性值是 url，里面必须包含协议，没有协议就会解析成相对路径。</li>
</ul>
</li>
<li><p>HTTP 状态码分类：</p>
<ul>
<li>1** 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2** 成功，操作被成功接受并处理。<ul>
<li>200 服务端成功处理了请求并返回内容</li>
</ul>
</li>
<li>3** 重定向，需要进一步的操作以完成请求<ul>
<li>301 永久重定向</li>
<li>302 临时重定向</li>
<li>304 资源未被修改，返回一个 304 状态吗然后从本地缓存中加载请求的资源</li>
</ul>
</li>
<li>4** 客户端错误，请求包含语法错误或无法完成请求。<ul>
<li>404 （页面丢失）未找到资源</li>
<li>403 服务器拒绝请求</li>
<li>408 （请求超时） 服务器等候请求时发生超时</li>
</ul>
</li>
<li>5** 服务器错误，服务器在处理请求的过程中发生错误 + 503 服务器暂时不可用 + 504 服务器内部错误<!--more--></li>
</ul>
</li>
<li><p>HTTP 协议的特征：</p>
<ul>
<li>C/S(客户端/服务器)模式：只要客户端和服务器知道如何处理数据内容，任何类型的数据<br>都可以通过 HTTP 来发送，客户端和服务器指定合适的 MIME-type 内容类型。</li>
<li>简单快速</li>
<li>灵活</li>
<li>无连接：限制每次连接只处理一个请求，收到客户的应答后即断开连接，可以节省传输时间。</li>
<li>无状态：对于事物处理没有记忆能力，意味着如果后续处理需要前面的信息，则必须重传，<br>这样就会导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就会很快。</li>
</ul>
</li>
<li><p>get 和 post 的请求区别？</p>
<ul>
<li>区别一：<ul>
<li>get 重点是从服务器上获取资源</li>
<li>post 重点是向服务器发送数据</li>
</ul>
</li>
<li>区别二：<ul>
<li>get 传输数据通过 url 请求，以 field（字段）=value 的形式放在 url 后，用“？”连接，<br>多个请求数据间用“&amp;”连接，过程用户可见。</li>
<li>post 传输数据放在请求体（request body）中发送给服务器，用户不可见。</li>
</ul>
</li>
<li>区别三：<ul>
<li>get 传输数据大小有限制，但效率较高</li>
<li>post 可以传输大量数据，所以上传文件用 post 方式</li>
</ul>
</li>
<li>区别四：<ul>
<li>get 请求不安全，因为参数直接暴露在 url 上，不能用来传递敏感信息。</li>
<li>post 较 get 安全性较高。</li>
</ul>
</li>
<li>区别五：<ul>
<li>get 方式只能支持 ASCII 字符，向服务传的中文字符可能会乱码。</li>
<li>post 支持标准字符集，可以正确传递中文字符。</li>
</ul>
</li>
<li>区别六：<ul>
<li>get 在浏览器回退是无害的，而 post 会再次提交请求。</li>
</ul>
</li>
<li>区别七<ul>
<li>get 请求会被浏览器主动 cache（缓存），而 post 不会除非手动设置。</li>
</ul>
</li>
</ul>
</li>
<li><p>iframe 有哪些缺点？</p>
<ul>
<li><p>iframe 会阻塞主页面的 onload 事件</p>
</li>
<li><p>通过 oIframe.contentWindow 寻找子 window 对象</p>
</li>
<li><p>通过 window.parent 寻找父级窗体</p>
</li>
<li><p>通过 window.top 寻找顶级窗体</p>
</li>
<li><p>window.location.hash 解决父页面向子页面传值</p>
</li>
<li><p>window.name 解决子页面向父页面传值</p>
</li>
<li><p>不利于 SEO，搜索引擎的检索程序无法解读这种页面（百度 spider 不收录，浏览器对 iframe 框架的兼容问题）</p>
</li>
<li><p>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</p>
</li>
<li><p>如果需要使用 iframe，最好通过 javascript 动态给 iframe 添加 src 属性值。</p>
</li>
</ul>
</li>
<li><p>xhtml 和 html 有什么区别？</p>
<ul>
<li><p>性能方面</p>
<ul>
<li>XHTML 兼容性好，兼容各大浏览器、手机以及 PDA，使浏览器可以快速正确编译网页</li>
</ul>
</li>
<li><p>书写习惯方面</p>
<ul>
<li><p>HTML 标签不区分大小写，XHTML 所有标签必须小写</p>
</li>
<li><p>XHTML 必须成双成对</p>
</li>
<li><p>HTML 对标签顺序要求不严格，XHTML 标签顺序必须正确</p>
</li>
<li><p>等等</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>html 和 xml 的区别？</p>
<ul>
<li><p>xml 被设计用来传输和存储数据，其焦点是数据的内容</p>
</li>
<li><p>html 被设计用来显示数据，其焦点是数据的外观</p>
</li>
<li><p>html 旨在显示信息，而 xml 旨在传输信息</p>
</li>
<li><p>xml 在定义标记时区分大小写，而 html 不区分大小写</p>
</li>
</ul>
</li>
<li><p>link 和@import 的区别：<br><strong>两者都是外部引用 CSS 的方式，但有一定的区别</strong></p>
<pre><code>+ link是XHTML标签，除了加载CSS外，还可以加载其他文件；@import只能加载CSS。

+ 解析到link时，页面会同步加载Css；@import在页面加载完后加载Css。

+ link是XHTML标签，无兼容问题；@import是在**CSS2.1**之后提出的，只有再IE5以上才能识别。

+ link可以js动态引入，@import不行

+ @import的最佳写法： @import url(style.css),其他写法：@import &#39;style.css&#39;、
@import &quot;style.css&quot;、@import url(&#39;style.css&#39;)、@import url(&quot;style.css&quot;)
</code></pre>
</li>
<li><p>viewport</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  // width            设置viewport宽度，为一个正整数，或字符串‘device-width’</span><br><span class="line">  // device-width     设备宽度</span><br><span class="line">  // height           设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置</span><br><span class="line">  // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数</span><br><span class="line">  // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数</span><br><span class="line">  // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数</span><br><span class="line">  // user-scalable    是否允许手动缩放</span><br></pre></td></tr></table></figure>

<ul>
<li><p>单行文本溢出省略号</p>
<p>overflow: hidden;</p>
<p>text-overflow:ellipsis;</p>
<p>white-space: nowrap;</p>
</li>
<li><p>多行文本溢出省略号</p>
<p>display: -webkit-box;</p>
<p>-webkit-box-orient: vertical;</p>
<p>-webkit-line-clamp: 3;</p>
<p>overflow: hidden;</p>
</li>
<li><p>换行标签</p>
<p>word-wrap: break-word</p>
</li>
</ul>
<h2 id="深度封装-typeof-判断"><a href="#深度封装-typeof-判断" class="headerlink" title="深度封装 typeof 判断"></a>深度封装 typeof 判断</h2><pre><code>function myTypeof(val) &#123;
    var type = typeof(val)
    var res = &#123;
        &#39;[object Object]&#39; : &#39;object&#39;,
        &#39;[object Array]&#39; : &#39;array&#39;,
        &#39;[object Number]&#39; : &#39;object number&#39;,
        &#39;[object String]&#39; : &#39;object string&#39;,
        &#39;[object Boolean]&#39; : &#39;object boolean&#39;
    &#125;
    if (val === null) &#123;
        return &#39;null&#39;
    &#125; else if (type == &#39;object&#39;) &#123;
        var str = Object.prototype.toString.call(val)
        return res[str]
    &#125; else &#123;
        return type
    &#125;
&#125;
</code></pre>
<h2 id="浏览器的-reflow-和-repaint"><a href="#浏览器的-reflow-和-repaint" class="headerlink" title="浏览器的 reflow 和 repaint"></a>浏览器的 reflow 和 repaint</h2><ul>
<li>reflow（回流||重排）：当浏览器上某一个位置的布局发生了改变，浏览器会重新从根部开始计算该节点的</li>
</ul>
<p>布局。比如：向页面中添加、删除某一元素等，dom 节点的宽高位置改变，只要这些操作影响了</p>
<p>页面的元素位置或大小的变化，都会引起 reflow。</p>
<ul>
<li>repaint（重绘）：如果只改变页面元素的颜色、字体等不影响布局的属性时，浏览器会进行 repaint。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由上可见，相比repaint操作，reflow的耗时要更多。只要是动态的对页面进行修改，浏览器的reflow</span><br><span class="line"></span><br><span class="line">和repaint的操作就不可避免，我们要做的就是尽可能的减少浏览器的reflow和repaint的次数。</span><br></pre></td></tr></table></figure>

<h2 id="浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？"><a href="#浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？" class="headerlink" title="浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？"></a>浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？</h2><ul>
<li><p>在线的情况下：浏览器发现 html 头部有 manifest 属性，会请求 manifest 文件，如果是<br>第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并进行离线缓存。如果<br>已经离线存储了，浏览器会使用离线的资源加载页面，然后浏览器会比对新的 manifest 文件<br>与旧的 manifest 文件，如果文件没有发生改变，就不要做任何操作，如果文件改变，就会重新<br>下载文件中的资源并进行离线存储。</p>
</li>
<li><p>离线的情况下：浏览器就直接使用离线存储的资源。</p>
</li>
</ul>
<h2 id="如何清除-token"><a href="#如何清除-token" class="headerlink" title="如何清除 token"></a>如何清除 token</h2><ul>
<li><p>浏览器关闭会出发 <strong>beforeunload</strong> ，<strong>unload</strong> 这两个事件。</p>
</li>
<li><p>浏览器刷新也会触发，还会触发<strong>load</strong>事件</p>
</li>
<li><p>方案一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onbeforeunload = function () &#123;</span><br><span class="line">    localStorage.removeItem(&quot;token&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点： 刷新也会清空 token</p>
</li>
<li><p>方案二</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.onunload = function() &#123;</span><br><span class="line">    localStorage.setItem(&quot;lastTime&quot;,new Date().getTime())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">    let lastTime = localStorage.getItem(&quot;lastTime&quot;);</span><br><span class="line">    const interval = 3 * 1000;</span><br><span class="line">    // 如果时间间隔大于3s，则清除token</span><br><span class="line">    if (!lastTime || new Date().getTime() - lastTime &gt; interval) &#123;</span><br><span class="line">        localStorage.remove(&quot;token&quot;);</span><br><span class="line">        console.log(&quot;remove token&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;time is less than not remove token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>补充<br>可以使用 sessionStorage 代替 localStorage 来存储 token，当关闭浏览器时会自动清除 token，sessionStorage 不是持久化的本地存储，而是会话级别的存储，而 localStorage 是持久化的本地存储，除非主动删除数据，否则数据是不会过期的。</p>
</li>
</ul>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><!--more-->

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举个例子：</span></span><br><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;^13.4.6&quot;</span>, <span class="comment">// 只锁定主版本号 major</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;~13.4.6&quot;</span>, <span class="comment">// 锁定主版本号和次版本号 major + minor</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;13.4.6&quot;</span>,  <span class="comment">// 锁定版本</span></span><br><span class="line">  <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;*&quot;</span>,       <span class="comment">// 最新版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// major: 13, minor: 4, patch: 6</span></span><br><span class="line"></span><br><span class="line">$ npm info jquery <span class="comment">// 查看 jquery 信息</span></span><br><span class="line">$ npm view jquery versions <span class="comment">// 查看 jquery 所有版本</span></span><br><span class="line">$ npm list | grep gulp <span class="comment">// 过滤 gulp</span></span><br><span class="line">$ npm outdated <span class="comment">// 查看过期版本</span></span><br><span class="line">$ npm update <span class="comment">//更新版本</span></span><br><span class="line">$ npm cache clean --force <span class="comment">// 清楚缓存</span></span><br><span class="line">$ npm ls <span class="comment">// 查看项目引用了哪些包</span></span><br><span class="line">$ npm unpublish --force <span class="comment">// 从npm卸载包</span></span><br><span class="line"><span class="comment">// 执行顺序</span></span><br><span class="line">$ npm run script1 &amp; npm run script2 <span class="comment">//并行执行</span></span><br><span class="line">$ npm run script1 &amp;&amp; npm run script2 <span class="comment">// 继发执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cross-env: 运行跨平台设置和使用环境变量的脚本</span></span><br><span class="line"><span class="comment">// cross-env可以设置NODE_ENV环境变量，process.env.NODE_ENV === &#x27;production&#x27;</span></span><br><span class="line">$ npm install --save-dev cross-env</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;scripts&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">$ npm config get registry <span class="comment">// 查看当前源</span></span><br><span class="line">$ npm config set registry <span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org //切换镜像源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// npx</span></span><br><span class="line"><span class="comment">// --no-install: 让npx强制使用本地模块，不下载远程模块，如果本地不存在，就会报错</span></span><br><span class="line">$ npx --no-install http-server</span><br><span class="line"><span class="comment">// --ignore-existing: 忽略本地的同名模块，强制安装远程模块</span></span><br><span class="line">$ npx --ignore-existing http-server</span><br></pre></td></tr></table></figure>

<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><ul>
<li><p>客户端的本地存储：</p>
<ul>
<li><p>localStorage - 生命周期永久生效，除非手动删除，否则关闭页面也会存在 - 可以在同一浏览器多窗口共享 - 以键值对的形式存储使用 - 方法： + 存储数据：localStorage.setItem(key, value) + 获取数据：localStorage.getItem(key) + 删除数据：localStorage.removeItem(key) + 删除所有数据：localStorage.clear()</p>
</li>
<li><p>sessionStorage</p>
<ul>
<li><p>声明周期为关闭浏览器窗口</p>
</li>
<li><p>在同一个窗口中数据可以共享</p>
</li>
<li><p>以键值对的形式存储</p>
</li>
<li><p>方法：</p>
<ul>
<li>存储数据：sessionStorage.setItem(key, value)</li>
<li>获取数据：sessionStorage.getItem(key)</li>
<li>删除数据：sessionStorage.removeItem(key)</li>
<li>删除所有数据：sessionStorage.clear()</li>
</ul>
<p><a target="_blank" rel="noopener" href='https://www.cnblogs.com/pengc/p/8714475.html'>localStorage 和 sessionStorage</a></p>
<p><a target="_blank" rel="noopener" href='https://www.cnblogs.com/8023-CHD/p/11067141.html'>cookie 和 session</a></p>
</li>
</ul>
</li>
<li><p>IndexDB 离线存储，当网络断开，可以从浏览器中读取数据，用来做一些离线应用</p>
</li>
<li><p>Cookie</p>
<ul>
<li>包含字段<ul>
<li>name: cookie 名称</li>
<li>value: 值</li>
<li>domain: cookie 生效的域名</li>
<li>path: cookie 生效的路径</li>
<li>expires/max-age: cookie 过期时间</li>
<li>size: 大小</li>
<li>HttpOnly: 用户端不可更改</li>
</ul>
</li>
<li>存储用户信息，通过在客户端记录信息确定用户身份，最大为 4kb</li>
<li>会话 Cookie，若不设置过期时间，表示这个 cookie 的生命周期为浏览器会话期间，浏览器<br>关闭，cookie 就消失，会话 cookie 会保存在内存中而不是硬盘上。</li>
<li>持久 Cookie，若设置了过期时间，浏览器会把 cookie 保存在硬盘上，关闭浏览器仍然有效直到<br>超过设定的过期时间。</li>
<li>cookie 数据始终在同源的 http 请求中携带(即使不需要)，即会在浏览器和服务器之间来回传递。</li>
<li>Cookie 具有不可跨域名性，例如浏览器访问百度不会带上谷歌的 cookie</li>
</ul>
</li>
</ul>
</li>
<li><p>服务端的存储：</p>
<ul>
<li>Session<ul>
<li>Session 服务器端一种记录客户端状态的机制</li>
<li>cookie 数据存放在客户的浏览器上，session 将数据存放在服务器端</li>
<li>Session 相对 Cookie 来说比较安全，别人可以分析本地存放的 cookie 进行 cookie 欺骗</li>
<li>Session 会在一定时间内保存在服务器上，访问量较多的时候会比较占用服务器的性能，<br>考虑到减轻服务器性能方面的时候，应当使用 cookie</li>
<li>可以将登陆等重要信息保存在 session，其他信息放在 cookie 中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><!--more-->

<pre><code>Date.now()  //获取当前时间毫秒数
var dt = new Date() //构造一个实例对象
dt.getTime()    //获取毫秒数
dt.getFullYear() //年
dt.getMonth()   //月（0-11）
dt.getDate()    //日 （0-31）
dt.getHours()   //小时（0-23）
dt.getMinutes() //分钟（0-59）
dt.getSeconds() //秒（0-59）
dt.getDay()     //星期几（0-6）
</code></pre>
<h3 id="如何监听未处理的异常"><a href="#如何监听未处理的异常" class="headerlink" title="如何监听未处理的异常"></a>如何监听未处理的异常</h3><ul>
<li>try…catch<ul>
<li>无法捕捉到语法错误，只能捕捉运行时错误</li>
<li>可以拿到出错的信息(出错的文件，行号，列号)</li>
</ul>
</li>
<li>window.onerror<ul>
<li>由于 try…catch 只能捕获块里面的错误，全局的一些错误可以用 window.onerror</li>
</ul>
</li>
<li>window.addEventListener(‘error’,callback):捕获资源错误</li>
<li>window.addEventListener(‘unhandledrejection’,callback):捕获 promise 类型错误</li>
<li>vue.config.errorHandler: vue 错误</li>
<li>componentDidCatch：错误边界函数</li>
</ul>
<h3 id="http-和-https-的区别-1"><a href="#http-和-https-的区别-1" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h3><ul>
<li>http 是一种一种广泛使用的网络协议，是一个客户端和服务器请求和应答的标准。</li>
<li>http 工作在 TCP 协议的 80 端口，https 工作在 TCP 协议的 443 端口</li>
<li>http 协议运行在 TCP 协议之上，所有的传输内容都是明文，https 运行在 SSL/TLS 之上，<br>SSL/TLS 运行在 TCP 之上，所有的传输内容都是经过加密的。</li>
<li>https 是以安全为目标的 http 通道，是 http 的安全版。是 http 加上 SSL 层对传输的信息和 url 做了一些加密处理，更加安全</li>
</ul>
<h3 id="为什么-https-不会被截取信息"><a href="#为什么-https-不会被截取信息" class="headerlink" title="为什么 https 不会被截取信息"></a>为什么 https 不会被截取信息</h3><ul>
<li>完成 TCP 三次同步握手</li>
<li>客户端验证服务器数字证书，通过，进入步骤 3</li>
<li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li>
<li>SSL 安全加密隧道协商完成</li>
<li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；<br>用协商的 hash 算法进行数据完整性保护，保证数据不被篡改</li>
</ul>
<h3 id="浏览器如何缓存"><a href="#浏览器如何缓存" class="headerlink" title="浏览器如何缓存"></a>浏览器如何缓存</h3><ul>
<li>html meta 标签控制缓存<ul>
<li><code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cahce&quot;&gt;</code> //告诉浏览器当前页面不被缓存</li>
</ul>
</li>
<li>http 头信息控制缓存<ul>
<li>Expires ——&gt; 过期时间</li>
<li>Cache-Control 响应头信息(no-cache、no-store、max-age、public)</li>
</ul>
</li>
</ul>
<h3 id="TCP-协议如何保证传输的可靠性"><a href="#TCP-协议如何保证传输的可靠性" class="headerlink" title="TCP 协议如何保证传输的可靠性"></a>TCP 协议如何保证传输的可靠性</h3><ul>
<li>校验和</li>
<li>确认应答 + 序列号</li>
<li>超时重传</li>
<li>流浪控制</li>
<li>拥塞控制</li>
<li>TCP 的连接管理</li>
<li>滑动窗口</li>
</ul>
<h3 id="UDP-amp-TCP-的区别"><a href="#UDP-amp-TCP-的区别" class="headerlink" title="UDP &amp; TCP 的区别"></a>UDP &amp; TCP 的区别</h3><ul>
<li><p>相同点：</p>
<ul>
<li>UDP 协议 和 TCP 协议 都是运输层协议</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li><p>UDP 特点：</p>
<ul>
<li>无连接 —— 知道对端的 IP 和端口号就直接进行传输，不需要建立连接</li>
<li>不可靠 —— 没有确认机制，没有重传机制，即使因为网络故障无法发送到<br>对方，UDP 协议也不会给应用层返回任何错误信息</li>
<li>面向数据报</li>
<li>传输速 度块</li>
</ul>
</li>
<li><p>TCP 特点：</p>
<ul>
<li>面向连接，在客户端和服务器进行交换数据前，必须先在双方之间建立一个<br>TCP 连接</li>
<li>可靠传输，具有确认应答机制、超时重传机制、拥塞控制、流量控制、<br>滑动窗口机制、延迟应答等。</li>
<li>面向字节流</li>
</ul>
</li>
</ul>
</li>
<li><p>UDP 的响应速度优于 TCP，安全性和数据可靠性不如 TCP</p>
</li>
<li><p>UDP 一般用在网络负担非常重，但对响应速度要求高，数据类型都是短消息的情况下</p>
</li>
</ul>
<h3 id="样式导入方式及优先级？"><a href="#样式导入方式及优先级？" class="headerlink" title="样式导入方式及优先级？"></a>样式导入方式及优先级？</h3><ul>
<li><p>引入方式</p>
<ul>
<li>行内样式</li>
<li>内联式</li>
<li>外链式</li>
<li>导入式: @import url(reset.css)</li>
</ul>
</li>
<li><p>各种方式的优先级</p>
<ul>
<li>行内样式 &gt; 外链式 &gt; 内联式 &gt; @import 导入式</li>
</ul>
</li>
<li><p>选择器优先原则：!important &gt; 行间样式 &gt; ID 选择器 &gt;class 选择器｜伪类选择器｜属性选择器 &gt;元素选择器｜伪元素选择器 &gt; 通配符选择器｜子选择器选择器｜相邻兄弟选择器</p>
</li>
</ul>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC(block formatting context)翻译为“块级格式化上下文”，它会生成独立的渲染区域<br>(不影响外面的元素，同时也不受外部元素的影响)，它有一下规则：</p>
<ul>
<li>内部的 box 会在垂直方向上一个接一个的放置。</li>
<li>内部 box 在垂直方向上的距离由 margin 决定，同属一个 BFC 内的相邻 box 会发生 margin 重叠。</li>
<li>BFC 的区域不会与 float box 发生重叠。</li>
<li>计算 BFC 的高度时，浮动元素也参与计算(清除浮动)</li>
</ul>
<p>触发 BFC 的条件：</p>
<ul>
<li>float 属性不为 none</li>
<li>position 为 absolute 或者 fixed</li>
<li>display 为 inline-block、table-cell、table-caption、flex、inline-flex</li>
<li>overflow 不为 visible</li>
</ul>
<h2 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h2><h4 id="for-遍历"><a href="#for-遍历" class="headerlink" title="for 遍历"></a>for 遍历</h4><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var flag;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        flag = 1;
        var newLen = newStr.length;
        for(var j=0; j&lt;newLen; j++)&#123;
            if(str[i] == newStr[j])&#123;
                flag = 0;
                break;
            &#125;
        &#125;
        if(flag)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h4 id="indexOf-方法"><a href="#indexOf-方法" class="headerlink" title="indexOf 方法"></a>indexOf 方法</h4><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(newStr.indexOf(str[i])==-1)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h4 id="search-方法"><a href="#search-方法" class="headerlink" title="search 方法"></a>search 方法</h4><pre><code>function removeRepeatStr(str)&#123;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(newStr.search(str[i])==-1)&#123;
            newStr = newStr + str[i];
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h4 id="对象属性法"><a href="#对象属性法" class="headerlink" title="对象属性法"></a>对象属性法</h4><pre><code>function removeRepeatStr(str)&#123;
    var obj = &#123;&#125;;
    var newStr = &#39;&#39;;
    var len = str.length;
    for(var i=0; i&lt;len; i++)&#123;
        if(!obj[str[i]])&#123;
            newStr = newStr + str[i];
            obj[str[i]] = 1;//注意，这里的1是给对象属性赋值，这个值可以任意取。意思是把每个遍历的字符作为对象属性并赋值保存，保证该属性的唯一性
        &#125;
    &#125;
    return newStr;
&#125;
</code></pre>
<h2 id="同步和异步的区别，怎么异步加载-javascript"><a href="#同步和异步的区别，怎么异步加载-javascript" class="headerlink" title="同步和异步的区别，怎么异步加载 javascript?"></a>同步和异步的区别，怎么异步加载 javascript?</h2><!--more-->

<ul>
<li><p>同步模式<br>同步模式，又称阻塞模式，javascript 在默认情况下是会阻塞加载的，当前面的</p>
<p>javascript 请求没有处理和执行完时，会阻止浏览器的后续处理</p>
</li>
<li><p>异步模式<br>异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理</p>
</li>
<li><p>异步加载 JavaScript</p>
<ul>
<li><p>动态添加 script 标签</p>
</li>
<li><p>defer</p>
</li>
<li><p>async</p>
</li>
</ul>
<p>defer 属性和 async 都是属于 script 标签上面的属性，两者都能实现 JavaScript 的</p>
<p>异步加载。不同之处在于：async 在异步加载完成的时候就马上开始执行了，defer 会等到</p>
<p>html 加载完毕之后再执行。</p>
</li>
</ul>
<h2 id="有哪些常见的-meta-标签？"><a href="#有哪些常见的-meta-标签？" class="headerlink" title="有哪些常见的 meta 标签？"></a>有哪些常见的 meta 标签？</h2><!--more-->

<ul>
<li><p>指定文档编码</p>
<ul>
<li><code>&lt;meta charset = &quot;UTF-8&quot;&gt;</code></li>
</ul>
</li>
<li><p>name 属性</p>
<ul>
<li><p><code>1.&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;：在移动设备浏览器上，禁用缩放（zooming） 功能，用户只能滚动屏幕。</code></p>
</li>
<li><p><code>2.&lt;meta name=”description” content=””&gt;：告诉搜索引擎，当前页面的主要内容是xxx。</code></p>
</li>
<li><p><code>3.&lt;meta name=”keywords” content=””&gt;：告诉搜索引擎，当前页面的关键字。</code></p>
</li>
<li><p><code>4.&lt;meta name=”author” content=””&gt;：告诉搜索引擎，标注网站作者是谁。</code></p>
</li>
<li><p><code>5.&lt;meta name=”copyright” content=””&gt;：标注网站的版权信息。</code></p>
</li>
</ul>
</li>
<li><p>http-equiv 属性(http 协议的响应头报文)</p>
<ul>
<li><p><code>1.&lt;meta http-equiv=”Set-Cookie” content=”cookievalue=xxx; expires=Friday,12-Jan-2001 18:18:18 GMT; path=/”&gt;:如果网页过期， 那么存盘的cookie将被删除。必须使用GMT的时间格式。</code></p>
</li>
<li><p><code>2.&lt;meta http-equiv=&#39;expires&#39; content=&#39;时间&#39; &gt;：用于设定网页的到期时间。 一旦网页过期，必须到服务器上重新传输。</code></p>
</li>
<li><p><code>3.&lt;meta http-equiv=”Refresh” content=”5;URL”&gt;：告诉浏览器在 【数字】秒后跳转到【一个网址】</code></p>
</li>
<li><p><code>4.&lt;meta http-equiv=”content-Type” content=”text/html; charset=utf-8″&gt;： 设定页面使用的字符集。</code></p>
</li>
</ul>
<p>-<code>5.&lt;meta http-equiv=”Pragma” content=”no-cache”&gt;：禁止浏览器从本地 计算机的缓存中访问页面内容。访问者将无法脱机浏览。</code></p>
<ul>
<li><p><code>6.&lt;meta http-equiv=”Window-target” content=”_top”&gt;：用来防止 别人在iframe(框架)里调用自己的页面，这也算是一个非常实用的属性。</code></p>
</li>
<li><p><code>7.&lt;meta http-equiv=&#39;X-UA-Compatible&#39; content=&#39;IE=edge,chrome=1&#39;&gt; :强制浏览器按照特定的版本标准进行渲染。但不支持IE7及以下版本。如果是 ie浏览器就用最新的ie渲染，如果是双核浏览器就用chrome内核。</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="什么是-FOUC？如何避免？"><a href="#什么是-FOUC？如何避免？" class="headerlink" title="什么是 FOUC？如何避免？"></a>什么是 FOUC？如何避免？</h2><!--more-->

<h4 id="一、为什么会有白屏和-FOUC-呢？"><a href="#一、为什么会有白屏和-FOUC-呢？" class="headerlink" title="一、为什么会有白屏和 FOUC 呢？"></a>一、为什么会有白屏和 FOUC 呢？</h4><blockquote>
<p>浏览器再渲染的时候没有请求到或请求时间过长造成的，那么浏览器怎么应对的呢？</p>
<ul>
<li>白屏：CSS 全部载入解析完成后渲染展示页面，如果没有加载完，就会出现白屏。</li>
<li>FOUC(Flash of Unstyled Content)无样式内容闪烁：用户定义样式表加载之前浏览器<br>使用默认样式显示文档，用户样式表加载渲染之后，再重新显示文档，造成页面闪烁。</li>
</ul>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><blockquote>
<ul>
<li>使用 link 标签将样式表放在顶部<head>标签中，防止白屏问题出现。</li>
<li>将 JS 放在<body>标签底部，原因如下：<ul>
<li>脚本会阻塞后面内容的呈现</li>
<li>脚本会阻塞其后组件的下载</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="什么是-DOCTYPE-及其作用？"><a href="#什么是-DOCTYPE-及其作用？" class="headerlink" title="什么是 DOCTYPE 及其作用？"></a>什么是 DOCTYPE 及其作用？</h2><ul>
<li><p>DOCTYPE 是 document type（文档类型）的缩写。</p>
<!--more--></li>
<li><p>写法：<!DOCTYPE html>(声明了浏览器就会进入标准模式，按照 W3C 标准渲染页面)</p>
</li>
<li><p>DOCTYPE 的作用：</p>
<ul>
<li>DOCTYPE 是用来声明文档类型和 DTD 规范的，校验文件和代码的合法性。</li>
<li>告诉浏览器通过哪种规范（文档类型，DTD）来解析文档。</li>
</ul>
</li>
<li><p>DTD（document type definition）文档类型定义是一系列的语法规则，用来定义 XML<br>或 HTML 的文件类型。浏览器会根据它来判断文档类型，决定使用哪种协议来解析，以及切换<br>浏览器的模式。</p>
</li>
<li><p>浏览器模式</p>
<p>为了能够很好的显示满足标准的页面，又能最大程度兼容不合法的 HTML，浏览器厂商会提供两种<br>浏览器模式。</p>
<ul>
<li>标准模式：根据 W3C 标准来渲染页面。</li>
<li>混杂模式（兼容模式、怪异模式）：浏览器采用更加宽松、向后兼容的方式来渲染页面。</li>
</ul>
</li>
</ul>
<h2 id="CSS-清除浮动"><a href="#CSS-清除浮动" class="headerlink" title="CSS-清除浮动"></a>CSS-清除浮动</h2><!--more-->

<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004865198">原文链接</a></p>
<h3 id="什么是-CSS-清除浮动"><a href="#什么是-CSS-清除浮动" class="headerlink" title="什么是 CSS 清除浮动?"></a>什么是 CSS 清除浮动?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left</span><br><span class="line">或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到</span><br><span class="line">容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行</span><br><span class="line">的CSS处理，就叫CSS清除浮动。</span><br></pre></td></tr></table></figure>

<!--more-->

<h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ul>
<li>方法一：使用带 clear 属性的空元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在浮动元素后使用一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，并在CSS中赋予</span><br><span class="line">.clear&#123;clear:both;&#125;属性即可清理浮动。亦可使用&lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt;</span><br><span class="line">来进行清理。</span><br><span class="line">优点：简单，代码少，浏览器兼容好。</span><br><span class="line">缺点：需要添加大量的无语义的html元素，代码不够优雅，后期不容易维护。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：使用 CSS 的 overflow 属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法三：给浮动的元素的容器添加浮动（不太推荐）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，</span><br><span class="line">不推荐使用。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法四：使用邻接元素处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">什么都不做，给浮动元素后面的元素添加clear:both属性。</span><br></pre></td></tr></table></figure>

<ul>
<li>方法五：使用 CSS 的：after 伪元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现</span><br><span class="line">元素末尾添加一个看不见的块元素（Block element）清理浮动。</span><br><span class="line"></span><br><span class="line">.clearfix::after&#123;</span><br><span class="line">  content: &quot;020&quot;;</span><br><span class="line">  display: block;</span><br><span class="line">  height: 0;</span><br><span class="line">  clear: both;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Chrome-打开一个页面需要启动多少线程？分别有哪些线程？"><a href="#Chrome-打开一个页面需要启动多少线程？分别有哪些线程？" class="headerlink" title="Chrome 打开一个页面需要启动多少线程？分别有哪些线程？"></a>Chrome 打开一个页面需要启动多少线程？分别有哪些线程？</h2><!--more-->

<pre><code>最新Chrome浏览器包括：一个浏览器(Browser)主线程、一个GPU进程、一个网络(NetWork)
进程、多个渲染进程和多个插件进程
</code></pre>
<ul>
<li><p>线程：</p>
<ul>
<li><p>浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。</p>
</li>
<li><p>渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，<br>排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个<br>Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
</li>
<li><p>GPU 进程：Chrome 刚开始的时候是没有 GPU 进程的，而 GPU 使用的使用初衷是为了实现<br>3D CSS 效果，之后随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 称为<br>浏览器普遍的需求，最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
</li>
<li><p>网络进程：主要负责网页的网络资源加载，之前是作为一个模块运行在浏览器进程里面<br>的，最近才独立出来，称为一个单独的进程。</p>
</li>
<li><p>插件进程：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以<br>保证插件进程崩溃不会对浏览器和页面造成影响。</p>
</li>
</ul>
</li>
</ul>
<h2 id="CommonJS、AMD、CMD-是什么及区别？"><a href="#CommonJS、AMD、CMD-是什么及区别？" class="headerlink" title="CommonJS、AMD、CMD 是什么及区别？"></a>CommonJS、AMD、CMD 是什么及区别？</h2><!--more-->

<ul>
<li>CommonJS 是服务器端 js 模块化的规范，NodeJS 是这种规范的实现，加载模块使用 require 方法，</li>
</ul>
<p>导出使用 exports</p>
<ul>
<li>AMD 和 CMD 都是为了解决浏览器端模块化问题而产生的，AMD 规范对应的库 Require.js,</li>
</ul>
<p>CMD 规范对应的库 Sea.js</p>
<ul>
<li><p>AMD 和 CMD 的区别:</p>
<ul>
<li><p>AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</p>
</li>
<li><p>CMD 推崇就近依赖，只有在用到的某个模块的时候再去 require</p>
</li>
<li><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行，但 RequireJS(AMD)从 2.0 开始，也改为延迟执行</p>
</li>
<li><p>AMD 的 API 默认是一个当多个，CMD 的 API 严格区分，推崇职责单一</p>
</li>
</ul>
</li>
</ul>
<h2 id="js-加载-浏览器加载-时间线"><a href="#js-加载-浏览器加载-时间线" class="headerlink" title="js 加载(浏览器加载)时间线"></a>js 加载(浏览器加载)时间线</h2><pre><code>理论：它是根据js出生的那一刻开始记录的一系列浏览器按照顺序做的事，

就是加载顺序及一些优化
</code></pre>
 <!--more-->

<ul>
<li><p>创建 Document 对象，开始解析 web 页面，这个阶段 document.readyState = ‘loading’</p>
</li>
<li><p>遇见 link 外部 css，css 资源异步下载，并继续解析文档，下载和解析都不会阻塞构建 dom 树</p>
</li>
<li><p>遇见 script 外部 js，并且没有设置 async、defer，浏览器同步加载，并阻塞构建 dom 树，等待 js 加载完成并执行该脚本，然后继续解析文档</p>
</li>
<li><p>遇见 script 外部 js，并且设置了 async、defer，浏览器创建线程 加载，并继续解析文档，对于 async 属性的脚本，加载完成后立即执行。（异步加载禁止使用 document.write(),它会清除文档流）</p>
</li>
<li><p>遇见 img 等，先正常解析 dom 结构，然后浏览器异步加载 src，并继续解析文档</p>
</li>
<li><p>文档解析完成，document.readyState = ‘interactive’</p>
</li>
<li><p>文档解析完成后，所有设置 defer 的脚本会按照顺序执行。（也禁止使用 document.write()）</p>
</li>
<li><p>之后 document 对象触发 DOMContentLoaded 事件，标志程序执行从同步脚本执行阶段，转化为事件驱动阶段</p>
</li>
<li><p>当所有 async 的脚本加载并执行后、img 等加载完成后，document.readyState = ‘complete’,这是 window 对象触发 load 事件。</p>
</li>
<li><p>…</p>
</li>
</ul>
<h2 id="异步加载-js"><a href="#异步加载-js" class="headerlink" title="异步加载 js"></a>异步加载 js</h2><pre><code>javascript 异步加载的三种方案:
</code></pre>
<ul>
<li><p>defer 异步加载，但要等到 dom 文档全部解析完成才会被执行，只有 IE 能用(w3cSchool 错误，主流浏览器都可以使用)</p>
</li>
<li><p>async 异步加载，加载完就执行，async 只能加载 外部脚本，不能把 js 写在 script 标签中，执行时也不会阻塞页面</p>
</li>
<li><p>动态创建 script，插入到 dom 中，加载完毕后 callback。<br>简单实例：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var script = document.createElement(&#x27;script&#x27;)</span><br><span class="line"></span><br><span class="line">script.type = &#x27;text/javascript&#x27;</span><br><span class="line"></span><br><span class="line">script.src = demo.js</span><br><span class="line"></span><br><span class="line">script.onload = function() &#123; //兼容性很好，除了IE</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.head.appendChild(script)</span><br></pre></td></tr></table></figure>

<p>动态加载函数封装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function asyncLoaded(url,callback)&#123;</span><br><span class="line">    var script = document.createElement(&quot;script&quot;);</span><br><span class="line">//  script.src = url;   假如说网速非常好，直接执行完成了，后面就监听不到状态的改变了</span><br><span class="line">    if(script.readyState)&#123;</span><br><span class="line">        script.onreadystatechange = function()&#123;</span><br><span class="line">            if(script.readyState == &quot;complete&quot; || script.readyState ==&quot;loaded&quot;)&#123;</span><br><span class="line">//  执行某个函数</span><br><span class="line">                callback()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        script.onload = function()&#123;</span><br><span class="line">//  执行某个函数</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = url;    //异步的过程</span><br><span class="line">    document.head.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncLoaded(&#x27;demo.js&#x27;, function()&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="getomputedstyle-和-style-的区别？"><a href="#getomputedstyle-和-style-的区别？" class="headerlink" title="getomputedstyle 和 style 的区别？"></a>getomputedstyle 和 style 的区别？</h2><!--more-->

<ul>
<li><p>getComputedStyle 方法是只读的，只能获取样式，不能设置；而 element.style 能读写。</p>
</li>
<li><p>getComputedStyle 方法获取的是最终应用在元素上的所有 Css 属性样式(即使没有 css 代码)，<br>而 element.style 只能获取元素 style 属性中的 css 样式。</p>
</li>
<li><p>getComputedStyle 可以获取伪元素的样式。</p>
</li>
<li><p>兼容性：getComputedStyle 方法在 IE6~IE8 是不支持的。</p>
</li>
</ul>
<h2 id="什么是-HTML-语义化？"><a href="#什么是-HTML-语义化？" class="headerlink" title="什么是 HTML 语义化？"></a>什么是 HTML 语义化？</h2><!--more-->

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据内容的结构化，选择合适的标签，便于开发者阅读和写出更优雅的代码的同时利于SEO的优化。</span><br></pre></td></tr></table></figure>

<h2 id="为什么要语义化？"><a href="#为什么要语义化？" class="headerlink" title="为什么要语义化？"></a>为什么要语义化？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；</span><br><span class="line">- 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；</span><br><span class="line">- 有利于SEO ：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息： 爬虫依赖于</span><br><span class="line">标签来确定上下文和各个关键字的权重；</span><br><span class="line">- 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页</span><br><span class="line">- 便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的</span><br><span class="line">团队都遵循这个标准，可以减少差异化。</span><br></pre></td></tr></table></figure>

<h2 id="构建打包优化（webpack-bundle-analyzer-分析各个打包文件）"><a href="#构建打包优化（webpack-bundle-analyzer-分析各个打包文件）" class="headerlink" title="构建打包优化（webpack-bundle-analyzer 分析各个打包文件）"></a>构建打包优化（webpack-bundle-analyzer 分析各个打包文件）</h2><p>速度优化:</p>
<ul>
<li><p>exclude/include</p>
<p>通过 exclude、include 配置来确保转译尽可能少的文件</p>
</li>
<li><p>cache</p>
</li>
<li><p>thread-loader</p>
</li>
<li><p>resolve.alias</p>
<p>webpack 直接根据对应别名的目录查找模块，减少搜索时间</p>
</li>
<li><p>模块懒加载</p>
</li>
<li><p>externals + CDN</p>
</li>
</ul>
<h2 id="V8-垃圾回收机制"><a href="#V8-垃圾回收机制" class="headerlink" title="V8 垃圾回收机制"></a>V8 垃圾回收机制</h2><ul>
<li><p>V8 会把堆分为新生代和老生代</p>
</li>
<li><p>新生代（副垃圾回收器）</p>
<ul>
<li>存放生存时间短的对象</li>
<li>通常只支持 1 ～ 8M 的容量</li>
<li>分为对象区和空闲区<ul>
<li>对对象区域中的垃圾做标记，标记完成进入垃圾清理阶段，把存活的对象复制到空闲区域，把这些对象有序的排列起来</li>
<li>完成复制后，对象区和空闲区进行角色翻转</li>
</ul>
</li>
</ul>
</li>
<li><p>老生代（主垃圾回收器）</p>
<ul>
<li>对象存放生存时间久</li>
<li>对象占用空间大</li>
</ul>
</li>
<li><p>副垃圾回收器采用对象晋升策略：移动那些经过两次垃圾回收依然还存活的对象到老生代中</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">V8实现了精准式GC，GC算法采用了分代式垃圾回收机制。因此，V8将内存（堆）分为新生代和老生代两部分。</span><br><span class="line"></span><br><span class="line">新生代算法</span><br><span class="line">新生代中的对象一般存活时间较短，使用Scavenge GC算法。</span><br><span class="line">在新生代空间中，内存空间分为两部分，分别为From空间和To空间。</span><br><span class="line">在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。</span><br><span class="line">新分配的对象会被放入From空间中，当From空间被占满时，新生代GC就会启动。</span><br><span class="line">算法会检查From空间中存活的对象并复制到To空间中，如果失活的对象就会销毁。</span><br><span class="line">当复制完成后将From空间和To空间互换，这样GC就结束了。</span><br><span class="line"></span><br><span class="line">老生代算法</span><br><span class="line">老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是 标记清除算法 和 标记压缩算法。</span><br><span class="line">在将算法前，先来说下什么情况下对象会出现在老生代空间中：</span><br><span class="line">● 新生代中的对象是否已经经历过一次Scavenge算法，如果经历过的话，会将对象从新生代空间移到老生代空间。</span><br><span class="line">● To空间的对象占比大于25%。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</span><br><span class="line"></span><br><span class="line">以下情况会启动 标记清除算法：</span><br><span class="line">● 某一空间没有分块的时候</span><br><span class="line">● 空间中对象超过一定限制</span><br><span class="line">● 空间不能保证新生代中的对象移动时</span><br><span class="line"></span><br><span class="line">清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动 压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清除不需要的内存。</span><br></pre></td></tr></table></figure>

<h2 id="浏览器在渲染时遇到-javascript-文件要怎么处理？"><a href="#浏览器在渲染时遇到-javascript-文件要怎么处理？" class="headerlink" title="浏览器在渲染时遇到 javascript 文件要怎么处理？"></a>浏览器在渲染时遇到 javascript 文件要怎么处理？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; 中没有 defer 或 async ，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</span><br><span class="line">&lt;script&gt; 中有 async 属性表示异步执行引入的 JavaScript ，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</span><br><span class="line">&lt;script&gt; 中有 defer 属性表示延迟执行引入的 JavaScript ，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</span><br><span class="line">有 defer 属性的 &lt;script&gt; 相比普通 &lt;script&gt; ，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。 在加载多个JS脚本的时候， async 是无顺序的加载，而 defer 是有顺序的加载。</span><br></pre></td></tr></table></figure>

<h2 id="如何处理-TCP-的粘包"><a href="#如何处理-TCP-的粘包" class="headerlink" title="如何处理 TCP 的粘包?"></a>如何处理 TCP 的粘包?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">发生TCP粘包或拆包有很多原因，现列出常见的几点：</span><br><span class="line"></span><br><span class="line">要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</span><br><span class="line">待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</span><br><span class="line">要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</span><br><span class="line">接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关键点：如何给每个数据包添加边界信息</span><br><span class="line"></span><br><span class="line">发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</span><br><span class="line"></span><br><span class="line">发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</span><br><span class="line"></span><br><span class="line">可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</span><br></pre></td></tr></table></figure>

<h2 id="请说说-HTTPS-的握手过程？"><a href="#请说说-HTTPS-的握手过程？" class="headerlink" title="请说说 HTTPS 的握手过程？"></a>请说说 HTTPS 的握手过程？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTPS的握手过程主要包括以下步骤：</span><br><span class="line"></span><br><span class="line">  客户端向服务端发送一个加密过的客户端随机数和客户端支持的加密算法列表，同时请求建立SSL/TLS连接。</span><br><span class="line"></span><br><span class="line">  服务端在接收到请求后，向客户端发送一个包含服务端随机数、服务器支持的加密算法列表以及服务器的数字证书的报文。</span><br><span class="line"></span><br><span class="line">  客户端在接收到服务器的响应后，会对证书进行校验。如果证书被认为是合法的，那么客户端将使用证书中包含的公钥对一个随机数进行加密，并将加密后的随机数发送给服务端。</span><br><span class="line"></span><br><span class="line">  服务端在接收到客户端的响应后，使用私钥对加密的随机数进行解密，得到客户端生成的随机数。同时，服务端也会生成一个加密的会话密钥，并使用客户端和服务端的随机数以及协商出的加密算法对该密钥进行加密，最后将加密后的密钥发送给客户端。</span><br><span class="line"></span><br><span class="line">  客户端接收到服务端发送的加密的会话密钥后，使用服务端公布的公钥进行解密，得到原始的会话密钥。</span><br><span class="line"></span><br><span class="line">  客户端和服务端都会使用会话密钥进行加密和解密，从而实现安全的通信。</span><br><span class="line"></span><br><span class="line">  这个过程中，客户端和服务端会进行多次来回的通信，以建立安全的SSL/TLS连接。其中数字证书的校验和会话密钥的生成都是关键步骤，它们保证了通信的安全性。</span><br></pre></td></tr></table></figure>

<h2 id="请说说什么是数字证书？它有什么作用"><a href="#请说说什么是数字证书？它有什么作用" class="headerlink" title="请说说什么是数字证书？它有什么作用?"></a>请说说什么是数字证书？它有什么作用?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数字证书是一种加密技术，用于验证在线交互中的身份和信息安全性。它是由可信任的第三方机构（例如数字证书颁发机构）颁发的一份电子文档，其中包含了一些加密信息，如公钥、数字签名等。数字证书的作用是确保通信双方的身份和数据的完整性和保密性。</span><br><span class="line"></span><br><span class="line">在使用数字证书进行加密通信时，服务端会向证书颁发机构申请一份数字证书。数字证书包含了服务端的公钥，以及一些描述服务端身份的信息，例如域名、组织名称等。客户端在与服务端建立连接时，会向服务端请求数字证书，并验证证书的真实性和合法性。如果验证成功，客户端就可以使用服务端的公钥加密数据并发送给服务端了。同时，服务端也可以使用客户端的公钥进行数据的加密和验证。这样就可以确保通信过程中的数据不被窃听或篡改。</span><br><span class="line"></span><br><span class="line">数字证书的使用广泛，特别是在网站安全和电子商务领域。它可以用来验证网站的真实性和合法性，确保网站访问过程中的信息安全。此外，数字证书还可以用于文件签名、电子邮件加密等其他领域。</span><br></pre></td></tr></table></figure>

<h2 id="使用-git-commit-后，如何修改-commit-的信息？"><a href="#使用-git-commit-后，如何修改-commit-的信息？" class="headerlink" title="使用 git commit 后，如何修改 commit 的信息？"></a>使用 git commit 后，如何修改 commit 的信息？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<h2 id="在-less-中如何将-px-转换为-vw？"><a href="#在-less-中如何将-px-转换为-vw？" class="headerlink" title="在 less 中如何将 px 转换为 vw？"></a>在 less 中如何将 px 转换为 vw？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pxToVW</span> (<span class="keyword">@px</span>, @<span class="attribute">attr</span>: <span class="attribute">width</span>) &#123;</span><br><span class="line">  <span class="keyword">@vw</span>: (@px / <span class="number">750</span>) * <span class="number">100</span>;</span><br><span class="line">  @&#123;attr&#125;:~<span class="string">&quot;@&#123;vw&#125;vw&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.title</span>&#123;</span><br><span class="line">	<span class="selector-class">.pxToVW</span>(<span class="number">300</span>,<span class="attribute">width</span>)</span><br><span class="line">	<span class="selector-class">.pxToVW</span>(<span class="number">32</span>,<span class="attribute">font-size</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里是指，设计图是按照<span class="number">750px</span>的宽度进行设计的,</span><br><span class="line">title 中所有的值都是直接取的设计图的值，通过函数进行统一换算</span><br></pre></td></tr></table></figure>

<h2 id="js-请说说写一个拖拽组件的思路及注意事项"><a href="#js-请说说写一个拖拽组件的思路及注意事项" class="headerlink" title="[js] 请说说写一个拖拽组件的思路及注意事项?"></a>[js] 请说说写一个拖拽组件的思路及注意事项?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先，其实拖拽效果的思路是很简单的。主要就是三个步骤：</span><br><span class="line"></span><br><span class="line">1.onmousedown的时候，启动可拖拽事件，记录被拖拽元素的原始坐标参数。</span><br><span class="line"></span><br><span class="line">2.onmousemove的时候，实时记录鼠标移动的距离，结合被拖拽元素第一阶段的坐标参数，计算并设置新的坐标值。</span><br><span class="line"></span><br><span class="line">3.onmouseup的时候，关闭可拖拽事件，记录新的坐标值。</span><br><span class="line"></span><br><span class="line">注意：这里主要是通过绝对定位的top和left来确定元素的位置的，因此被拖拽元素的css一定要设置绝对定位。</span><br></pre></td></tr></table></figure>

<h2 id="为什么-try-catch-不能捕获到-promise-的错误？"><a href="#为什么-try-catch-不能捕获到-promise-的错误？" class="headerlink" title="为什么 try/catch 不能捕获到 promise 的错误？"></a>为什么 try/catch 不能捕获到 promise 的错误？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try-catch 主要用于捕获同步函数的异常，如果 try 里面的异步方法出现了异常，此时catch 是无法捕获到异常的。ES6 中 Promise 对象的实例提供了 catch() 方法，表示异步捕获异常。</span><br><span class="line"></span><br><span class="line">原因：当异步函数抛出异常时，对于宏任务而言，执行函数时已经将该函数推入栈，此时并不在 try-catch 所在的栈，所以 try-catch 并不能捕获到错误。对于微任务而言，比如 promise，promise 的构造函数的异常只能被自带的 reject 也就是.catch 函数捕获到。</span><br></pre></td></tr></table></figure>

<h2 id="gitlab-CI-CD-流程"><a href="#gitlab-CI-CD-流程" class="headerlink" title="gitlab CI/CD 流程"></a>gitlab CI/CD 流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">生产环境</span><br><span class="line">1、推送代码-&gt;编译-&gt;生成的jar包发布到私服-&gt;打包为docker镜像-&gt;推送到Harbor镜像仓库（成功，微信通知，c结束返回成功|失败，微信通知，ci结束返回失败）</span><br><span class="line">2、运维人员 触发部署到k8s集群-&gt;健康检查（成功，微信通知，c结束返回成功|失败，微信通知，ci结束返回失败）</span><br></pre></td></tr></table></figure>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/05/React%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">React深入浅出知识链路</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/05/Jquery%E5%AD%A6%E4%B9%A0/"><span class="level-item">jQuery学习</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "dvbU6cs8mO4tpam28kfkNFaI-gzGzoHsz",
            appKey: "tfoqOv7jT6pDSo3Abm9K4Jok",
            
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/avatar.jpeg" alt="foolishmax"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">foolishmax</p><p class="is-size-6 is-block">Web Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">38</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">24</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#从浏览器地址栏输入-url-到显示页面的步骤"><span class="level-left"><span class="level-item">1</span><span class="level-item">从浏览器地址栏输入 url 到显示页面的步骤</span></span></a></li><li><a class="level is-mobile" href="#DNS-负载均衡"><span class="level-left"><span class="level-item">2</span><span class="level-item">DNS 负载均衡</span></span></a></li><li><a class="level is-mobile" href="#强缓存和协商缓存"><span class="level-left"><span class="level-item">3</span><span class="level-item">强缓存和协商缓存</span></span></a></li><li><a class="level is-mobile" href="#http-协议的特点"><span class="level-left"><span class="level-item">4</span><span class="level-item">http 协议的特点</span></span></a></li><li><a class="level is-mobile" href="#cookie-和-session-的区别"><span class="level-left"><span class="level-item">5</span><span class="level-item">cookie 和 session 的区别</span></span></a></li><li><a class="level is-mobile" href="#权限身份验证"><span class="level-left"><span class="level-item">6</span><span class="level-item">权限身份验证</span></span></a></li><li><a class="level is-mobile" href="#禁用-cookie-之后-session-还能用吗？"><span class="level-left"><span class="level-item">7</span><span class="level-item">禁用 cookie 之后 session 还能用吗？</span></span></a></li><li><a class="level is-mobile" href="#get-和-post-的区别"><span class="level-left"><span class="level-item">8</span><span class="level-item">get 和 post 的区别</span></span></a></li><li><a class="level is-mobile" href="#http-常见的请求头字段"><span class="level-left"><span class="level-item">9</span><span class="level-item">http 常见的请求头字段</span></span></a></li><li><a class="level is-mobile" href="#http-和-https-的区别"><span class="level-left"><span class="level-item">10</span><span class="level-item">http 和 https 的区别</span></span></a></li><li><a class="level is-mobile" href="#xss（跨域脚本攻击）csrf（跨站请求伪造）"><span class="level-left"><span class="level-item">11</span><span class="level-item">xss（跨域脚本攻击）csrf（跨站请求伪造）</span></span></a></li><li><a class="level is-mobile" href="#什么是跨域？解决跨域的方法有哪些"><span class="level-left"><span class="level-item">12</span><span class="level-item">什么是跨域？解决跨域的方法有哪些?</span></span></a></li><li><a class="level is-mobile" href="#http1-0、http1-1-和-http2-0-的区别"><span class="level-left"><span class="level-item">13</span><span class="level-item">http1.0、http1.1 和 http2.0 的区别</span></span></a></li><li><a class="level is-mobile" href="#设计模式"><span class="level-left"><span class="level-item">14</span><span class="level-item">设计模式</span></span></a></li><li><a class="level is-mobile" href="#TCP-与-UDP-区别"><span class="level-left"><span class="level-item">15</span><span class="level-item">TCP 与 UDP 区别</span></span></a></li><li><a class="level is-mobile" href="#TCP-IP-模型"><span class="level-left"><span class="level-item">16</span><span class="level-item">TCP/IP 模型</span></span></a></li><li><a class="level is-mobile" href="#正向代理和反向代理"><span class="level-left"><span class="level-item">17</span><span class="level-item">正向代理和反向代理</span></span></a></li><li><a class="level is-mobile" href="#OSI-模型"><span class="level-left"><span class="level-item">18</span><span class="level-item">OSI 模型</span></span></a></li><li><a class="level is-mobile" href="#三次握手"><span class="level-left"><span class="level-item">19</span><span class="level-item">三次握手</span></span></a></li><li><a class="level is-mobile" href="#四次挥手"><span class="level-left"><span class="level-item">20</span><span class="level-item">四次挥手</span></span></a></li><li><a class="level is-mobile" href="#301-和-302-的区别"><span class="level-left"><span class="level-item">21</span><span class="level-item">301 和 302 的区别</span></span></a></li><li><a class="level is-mobile" href="#cookie"><span class="level-left"><span class="level-item">22</span><span class="level-item">cookie</span></span></a></li><li><a class="level is-mobile" href="#localStorage-会话存储-和-sessionStorage-本地存储"><span class="level-left"><span class="level-item">23</span><span class="level-item">localStorage 会话存储 和 sessionStorage 本地存储</span></span></a></li><li><a class="level is-mobile" href="#html5-的几种存储形式"><span class="level-left"><span class="level-item">24</span><span class="level-item">html5 的几种存储形式</span></span></a></li><li><a class="level is-mobile" href="#性能优化"><span class="level-left"><span class="level-item">25</span><span class="level-item">性能优化</span></span></a></li><li><a class="level is-mobile" href="#fetch-和-axios"><span class="level-left"><span class="level-item">26</span><span class="level-item">fetch 和 axios</span></span></a></li><li><a class="level is-mobile" href="#flex-常用属性，grid-布局"><span class="level-left"><span class="level-item">27</span><span class="level-item">flex 常用属性，grid 布局</span></span></a></li><li><a class="level is-mobile" href="#padding-bottom-实现子元素高度等于父元素宽度问题"><span class="level-left"><span class="level-item">28</span><span class="level-item">padding-bottom 实现子元素高度等于父元素宽度问题</span></span></a></li><li><a class="level is-mobile" href="#预编译"><span class="level-left"><span class="level-item">29</span><span class="level-item">预编译</span></span></a></li><li><a class="level is-mobile" href="#箭头函数中的-this"><span class="level-left"><span class="level-item">30</span><span class="level-item">箭头函数中的 this</span></span></a></li><li><a class="level is-mobile" href="#Map-和-Set-两种新的数据结构的区别？"><span class="level-left"><span class="level-item">31</span><span class="level-item">Map 和 Set 两种新的数据结构的区别？</span></span></a></li><li><a class="level is-mobile" href="#你对闭包了解多少？"><span class="level-left"><span class="level-item">32</span><span class="level-item">你对闭包了解多少？</span></span></a></li><li><a class="level is-mobile" href="#原型"><span class="level-left"><span class="level-item">33</span><span class="level-item">原型</span></span></a></li><li><a class="level is-mobile" href="#简单说下原型链"><span class="level-left"><span class="level-item">34</span><span class="level-item">简单说下原型链</span></span></a></li><li><a class="level is-mobile" href="#js-的-new-操作符都做了些什么？"><span class="level-left"><span class="level-item">35</span><span class="level-item">js 的 new 操作符都做了些什么？</span></span></a></li><li><a class="level is-mobile" href="#calc-support-media-各自的含义及用法？"><span class="level-left"><span class="level-item">36</span><span class="level-item">calc, support, media 各自的含义及用法？</span></span></a></li><li><a class="level is-mobile" href="#什么是会话-cookie-什么是持久-cookie"><span class="level-left"><span class="level-item">37</span><span class="level-item">什么是会话 cookie,什么是持久 cookie?</span></span></a></li><li><a class="level is-mobile" href="#img-标签-title-和-alt-属性"><span class="level-left"><span class="level-item">38</span><span class="level-item">img 标签 title 和 alt 属性</span></span></a></li><li><a class="level is-mobile" href="#es6-新特性"><span class="level-left"><span class="level-item">39</span><span class="level-item">es6 新特性</span></span></a></li><li><a class="level is-mobile" href="#图片懒加载原理"><span class="level-left"><span class="level-item">40</span><span class="level-item">图片懒加载原理</span></span></a></li><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">41</span><span class="level-item"> </span></span></a></li><li><a class="level is-mobile" href="#H5-新增了哪些标签？"><span class="level-left"><span class="level-item">42</span><span class="level-item">H5 新增了哪些标签？</span></span></a></li><li><a class="level is-mobile" href="#SVG-和-Canvas-的区别？"><span class="level-left"><span class="level-item">43</span><span class="level-item">SVG 和 Canvas 的区别？</span></span></a></li><li><a class="level is-mobile" href="#AMD-和-CMD-的区别"><span class="level-left"><span class="level-item">44</span><span class="level-item">AMD 和 CMD 的区别</span></span></a></li><li><a class="level is-mobile" href="#如何实现-js-倒计时的纠偏？"><span class="level-left"><span class="level-item">45</span><span class="level-item">如何实现 js 倒计时的纠偏？</span></span></a></li><li><a class="level is-mobile" href="#js-的执行机制"><span class="level-left"><span class="level-item">46</span><span class="level-item">js 的执行机制</span></span></a></li><li><a class="level is-mobile" href="#请说一下你对-React-的理解？"><span class="level-left"><span class="level-item">47</span><span class="level-item">请说一下你对 React 的理解？</span></span></a></li><li><a class="level is-mobile" href="#React-lazy-懒加载"><span class="level-left"><span class="level-item">48</span><span class="level-item">React.lazy 懒加载</span></span></a></li><li><a class="level is-mobile" href="#类组件和函数组件之间的区别？"><span class="level-left"><span class="level-item">49</span><span class="level-item">类组件和函数组件之间的区别？</span></span></a></li><li><a class="level is-mobile" href="#当调用-setState-的时候，发生了什么事？"><span class="level-left"><span class="level-item">50</span><span class="level-item">当调用 setState 的时候，发生了什么事？</span></span></a></li><li><a class="level is-mobile" href="#为什么-setState-的参数是一个-callback-而不是一个对象"><span class="level-left"><span class="level-item">51</span><span class="level-item">为什么 setState 的参数是一个 callback 而不是一个对象</span></span></a></li><li><a class="level is-mobile" href="#setState-什么时候同步什么时候异步？"><span class="level-left"><span class="level-item">52</span><span class="level-item">setState 什么时候同步什么时候异步？</span></span></a></li><li><a class="level is-mobile" href="#react-渲染机制"><span class="level-left"><span class="level-item">53</span><span class="level-item">react 渲染机制</span></span></a></li><li><a class="level is-mobile" href="#React-StrictMode-目前有助于："><span class="level-left"><span class="level-item">54</span><span class="level-item">React.StrictMode 目前有助于：</span></span></a></li><li><a class="level is-mobile" href="#虚拟-DOM-优点"><span class="level-left"><span class="level-item">55</span><span class="level-item">虚拟 DOM 优点</span></span></a></li><li><a class="level is-mobile" href="#diff-策略"><span class="level-left"><span class="level-item">56</span><span class="level-item">diff 策略</span></span></a></li><li><a class="level is-mobile" href="#shouldComponentUpdate-nextProps-nextState-是做什么的，（react-性能优化是哪个周期函数？）"><span class="level-left"><span class="level-item">57</span><span class="level-item">shouldComponentUpdate(nextProps, nextState)是做什么的，（react 性能优化是哪个周期函数？）</span></span></a></li><li><a class="level is-mobile" href="#createElement-和-cloneElement-有什么区别？"><span class="level-left"><span class="level-item">58</span><span class="level-item">createElement 和 cloneElement 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#虚拟-DOM-的优缺点？"><span class="level-left"><span class="level-item">59</span><span class="level-item">虚拟 DOM 的优缺点？</span></span></a></li><li><a class="level is-mobile" href="#React-中创建组件的方式"><span class="level-left"><span class="level-item">60</span><span class="level-item">React 中创建组件的方式</span></span></a></li><li><a class="level is-mobile" href="#-1"><span class="level-left"><span class="level-item">61</span><span class="level-item"> </span></span></a></li><li><a class="level is-mobile" href="#react-中-key-的作用"><span class="level-left"><span class="level-item">62</span><span class="level-item">react 中 key 的作用</span></span></a></li><li><a class="level is-mobile" href="#react-优势"><span class="level-left"><span class="level-item">63</span><span class="level-item">react 优势</span></span></a></li><li><a class="level is-mobile" href="#react-事件机制"><span class="level-left"><span class="level-item">64</span><span class="level-item">react 事件机制</span></span></a></li><li><a class="level is-mobile" href="#异步回调中怎么使用-syntheticEvent？"><span class="level-left"><span class="level-item">65</span><span class="level-item">异步回调中怎么使用 syntheticEvent？</span></span></a></li><li><a class="level is-mobile" href="#React-生命周期"><span class="level-left"><span class="level-item">66</span><span class="level-item">React 生命周期</span></span></a></li><li><a class="level is-mobile" href="#Redux"><span class="level-left"><span class="level-item">67</span><span class="level-item">Redux</span></span></a></li><li><a class="level is-mobile" href="#ts-中-type-和-interface-的区别"><span class="level-left"><span class="level-item">68</span><span class="level-item">ts 中 type 和 interface 的区别</span></span></a></li><li><a class="level is-mobile" href="#ts-中如何实现一个函数的重载"><span class="level-left"><span class="level-item">69</span><span class="level-item">ts 中如何实现一个函数的重载</span></span></a></li><li><a class="level is-mobile" href="#mobx"><span class="level-left"><span class="level-item">70</span><span class="level-item">mobx</span></span></a></li><li><a class="level is-mobile" href="#webpack-常用-loader"><span class="level-left"><span class="level-item">71</span><span class="level-item">webpack 常用 loader</span></span></a></li><li><a class="level is-mobile" href="#垃圾回收机制"><span class="level-left"><span class="level-item">72</span><span class="level-item">垃圾回收机制</span></span></a></li><li><a class="level is-mobile" href="#谈谈你对-webpack-的理解？"><span class="level-left"><span class="level-item">73</span><span class="level-item">谈谈你对 webpack 的理解？</span></span></a></li><li><a class="level is-mobile" href="#说说-webpack-与-grunt、gulp-的不同？"><span class="level-left"><span class="level-item">74</span><span class="level-item">说说 webpack 与 grunt、gulp 的不同？</span></span></a></li><li><a class="level is-mobile" href="#什么是-bundle-什么是-chunk，什么是-module"><span class="level-left"><span class="level-item">75</span><span class="level-item">什么是 bundle,什么是 chunk，什么是 module?</span></span></a></li><li><a class="level is-mobile" href="#什么是-Loader-什么是-Plugin"><span class="level-left"><span class="level-item">76</span><span class="level-item">什么是 Loader?什么是 Plugin?</span></span></a></li><li><a class="level is-mobile" href="#有哪些常见的-Loader？他们是解决什么问题的？"><span class="level-left"><span class="level-item">77</span><span class="level-item">有哪些常见的 Loader？他们是解决什么问题的？</span></span></a></li><li><a class="level is-mobile" href="#有哪些常见的-Plugin？他们是解决什么问题的？"><span class="level-left"><span class="level-item">78</span><span class="level-item">有哪些常见的 Plugin？他们是解决什么问题的？</span></span></a></li><li><a class="level is-mobile" href="#Loader-和-Plugin-的不同？"><span class="level-left"><span class="level-item">79</span><span class="level-item">Loader 和 Plugin 的不同？</span></span></a></li><li><a class="level is-mobile" href="#webpack-的构建流程是什么"><span class="level-left"><span class="level-item">80</span><span class="level-item">webpack 的构建流程是什么?</span></span></a></li><li><a class="level is-mobile" href="#描述一下编写-loader-或-plugin-的思路？"><span class="level-left"><span class="level-item">81</span><span class="level-item">描述一下编写 loader 或 plugin 的思路？</span></span></a></li><li><a class="level is-mobile" href="#如何利用-webpack-来优化前端性能？"><span class="level-left"><span class="level-item">82</span><span class="level-item">如何利用 webpack 来优化前端性能？</span></span></a></li><li><a class="level is-mobile" href="#如何提高-webpack-的构建速度？"><span class="level-left"><span class="level-item">83</span><span class="level-item">如何提高 webpack 的构建速度？</span></span></a></li><li><a class="level is-mobile" href="#怎么配置单页应用？怎么配置多页应用？"><span class="level-left"><span class="level-item">84</span><span class="level-item">怎么配置单页应用？怎么配置多页应用？</span></span></a></li><li><a class="level is-mobile" href="#vue-项目中实现按需加载？"><span class="level-left"><span class="level-item">85</span><span class="level-item">vue 项目中实现按需加载？</span></span></a></li><li><a class="level is-mobile" href="#如何阻止冒泡"><span class="level-left"><span class="level-item">86</span><span class="level-item">如何阻止冒泡?</span></span></a></li><li><a class="level is-mobile" href="#如何阻止默认事件？"><span class="level-left"><span class="level-item">87</span><span class="level-item">如何阻止默认事件？</span></span></a></li><li><a class="level is-mobile" href="#补充：事件绑定的封装"><span class="level-left"><span class="level-item">88</span><span class="level-item">补充：事件绑定的封装</span></span></a></li><li><a class="level is-mobile" href="#JS-如何设置获取盒子模型对应的宽和高？"><span class="level-left"><span class="level-item">89</span><span class="level-item">JS 如何设置获取盒子模型对应的宽和高？</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#如何判断一个对象是否为数组"><span class="level-left"><span class="level-item">89.1.1</span><span class="level-item">如何判断一个对象是否为数组</span></span></a></li><li><a class="level is-mobile" href="#宏任务和微任务"><span class="level-left"><span class="level-item">89.1.2</span><span class="level-item">宏任务和微任务</span></span></a></li><li><a class="level is-mobile" href="#Http-的持久连接和管线化"><span class="level-left"><span class="level-item">89.1.3</span><span class="level-item">Http 的持久连接和管线化</span></span></a></li><li><a class="level is-mobile" href="#为什么利用多个域名来存储网站资源会更有效？"><span class="level-left"><span class="level-item">89.1.4</span><span class="level-item">为什么利用多个域名来存储网站资源会更有效？</span></span></a></li><li><a class="level is-mobile" href="#CSS-权重（156-进制）"><span class="level-left"><span class="level-item">89.1.5</span><span class="level-item">CSS 权重（156 进制）</span></span></a></li><li><a class="level is-mobile" href="#html5-的新特性"><span class="level-left"><span class="level-item">89.1.6</span><span class="level-item">html5 的新特性</span></span></a></li><li><a class="level is-mobile" href="#CSS3-新添加的特性？"><span class="level-left"><span class="level-item">89.1.7</span><span class="level-item">CSS3 新添加的特性？</span></span></a></li><li><a class="level is-mobile" href="#基本数据类型"><span class="level-left"><span class="level-item">89.1.8</span><span class="level-item">基本数据类型</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#牛客学习"><span class="level-left"><span class="level-item">90</span><span class="level-item">牛客学习</span></span></a></li><li><a class="level is-mobile" href="#深度封装-typeof-判断"><span class="level-left"><span class="level-item">91</span><span class="level-item">深度封装 typeof 判断</span></span></a></li><li><a class="level is-mobile" href="#浏览器的-reflow-和-repaint"><span class="level-left"><span class="level-item">92</span><span class="level-item">浏览器的 reflow 和 repaint</span></span></a></li><li><a class="level is-mobile" href="#浏览器是怎么对-HTML5-的离线存储资源进行管理和加载的？"><span class="level-left"><span class="level-item">93</span><span class="level-item">浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？</span></span></a></li><li><a class="level is-mobile" href="#如何清除-token"><span class="level-left"><span class="level-item">94</span><span class="level-item">如何清除 token</span></span></a></li><li><a class="level is-mobile" href="#npm"><span class="level-left"><span class="level-item">95</span><span class="level-item">npm</span></span></a></li><li><a class="level is-mobile" href="#本地存储"><span class="level-left"><span class="level-item">96</span><span class="level-item">本地存储</span></span></a></li><li><a class="level is-mobile" href="#日期"><span class="level-left"><span class="level-item">97</span><span class="level-item">日期</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#如何监听未处理的异常"><span class="level-left"><span class="level-item">97.1</span><span class="level-item">如何监听未处理的异常</span></span></a></li><li><a class="level is-mobile" href="#http-和-https-的区别-1"><span class="level-left"><span class="level-item">97.2</span><span class="level-item">http 和 https 的区别</span></span></a></li><li><a class="level is-mobile" href="#为什么-https-不会被截取信息"><span class="level-left"><span class="level-item">97.3</span><span class="level-item">为什么 https 不会被截取信息</span></span></a></li><li><a class="level is-mobile" href="#浏览器如何缓存"><span class="level-left"><span class="level-item">97.4</span><span class="level-item">浏览器如何缓存</span></span></a></li><li><a class="level is-mobile" href="#TCP-协议如何保证传输的可靠性"><span class="level-left"><span class="level-item">97.5</span><span class="level-item">TCP 协议如何保证传输的可靠性</span></span></a></li><li><a class="level is-mobile" href="#UDP-amp-TCP-的区别"><span class="level-left"><span class="level-item">97.6</span><span class="level-item">UDP &amp; TCP 的区别</span></span></a></li><li><a class="level is-mobile" href="#样式导入方式及优先级？"><span class="level-left"><span class="level-item">97.7</span><span class="level-item">样式导入方式及优先级？</span></span></a></li><li><a class="level is-mobile" href="#BFC"><span class="level-left"><span class="level-item">97.8</span><span class="level-item">BFC</span></span></a></li></ul></li><li><a class="level is-mobile" href="#字符串去重"><span class="level-left"><span class="level-item">98</span><span class="level-item">字符串去重</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#for-遍历"><span class="level-left"><span class="level-item">98.1.1</span><span class="level-item">for 遍历</span></span></a></li><li><a class="level is-mobile" href="#indexOf-方法"><span class="level-left"><span class="level-item">98.1.2</span><span class="level-item">indexOf 方法</span></span></a></li><li><a class="level is-mobile" href="#search-方法"><span class="level-left"><span class="level-item">98.1.3</span><span class="level-item">search 方法</span></span></a></li><li><a class="level is-mobile" href="#对象属性法"><span class="level-left"><span class="level-item">98.1.4</span><span class="level-item">对象属性法</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#同步和异步的区别，怎么异步加载-javascript"><span class="level-left"><span class="level-item">99</span><span class="level-item">同步和异步的区别，怎么异步加载 javascript?</span></span></a></li><li><a class="level is-mobile" href="#有哪些常见的-meta-标签？"><span class="level-left"><span class="level-item">100</span><span class="level-item">有哪些常见的 meta 标签？</span></span></a></li><li><a class="level is-mobile" href="#什么是-FOUC？如何避免？"><span class="level-left"><span class="level-item">101</span><span class="level-item">什么是 FOUC？如何避免？</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#一、为什么会有白屏和-FOUC-呢？"><span class="level-left"><span class="level-item">101.1.1</span><span class="level-item">一、为什么会有白屏和 FOUC 呢？</span></span></a></li><li><a class="level is-mobile" href="#解决方法"><span class="level-left"><span class="level-item">101.1.2</span><span class="level-item">解决方法</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#什么是-DOCTYPE-及其作用？"><span class="level-left"><span class="level-item">102</span><span class="level-item">什么是 DOCTYPE 及其作用？</span></span></a></li><li><a class="level is-mobile" href="#CSS-清除浮动"><span class="level-left"><span class="level-item">103</span><span class="level-item">CSS-清除浮动</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是-CSS-清除浮动"><span class="level-left"><span class="level-item">103.1</span><span class="level-item">什么是 CSS 清除浮动?</span></span></a></li><li><a class="level is-mobile" href="#清除浮动的方法"><span class="level-left"><span class="level-item">103.2</span><span class="level-item">清除浮动的方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Chrome-打开一个页面需要启动多少线程？分别有哪些线程？"><span class="level-left"><span class="level-item">104</span><span class="level-item">Chrome 打开一个页面需要启动多少线程？分别有哪些线程？</span></span></a></li><li><a class="level is-mobile" href="#CommonJS、AMD、CMD-是什么及区别？"><span class="level-left"><span class="level-item">105</span><span class="level-item">CommonJS、AMD、CMD 是什么及区别？</span></span></a></li><li><a class="level is-mobile" href="#js-加载-浏览器加载-时间线"><span class="level-left"><span class="level-item">106</span><span class="level-item">js 加载(浏览器加载)时间线</span></span></a></li><li><a class="level is-mobile" href="#异步加载-js"><span class="level-left"><span class="level-item">107</span><span class="level-item">异步加载 js</span></span></a></li><li><a class="level is-mobile" href="#getomputedstyle-和-style-的区别？"><span class="level-left"><span class="level-item">108</span><span class="level-item">getomputedstyle 和 style 的区别？</span></span></a></li><li><a class="level is-mobile" href="#什么是-HTML-语义化？"><span class="level-left"><span class="level-item">109</span><span class="level-item">什么是 HTML 语义化？</span></span></a></li><li><a class="level is-mobile" href="#为什么要语义化？"><span class="level-left"><span class="level-item">110</span><span class="level-item">为什么要语义化？</span></span></a></li><li><a class="level is-mobile" href="#构建打包优化（webpack-bundle-analyzer-分析各个打包文件）"><span class="level-left"><span class="level-item">111</span><span class="level-item">构建打包优化（webpack-bundle-analyzer 分析各个打包文件）</span></span></a></li><li><a class="level is-mobile" href="#V8-垃圾回收机制"><span class="level-left"><span class="level-item">112</span><span class="level-item">V8 垃圾回收机制</span></span></a></li><li><a class="level is-mobile" href="#浏览器在渲染时遇到-javascript-文件要怎么处理？"><span class="level-left"><span class="level-item">113</span><span class="level-item">浏览器在渲染时遇到 javascript 文件要怎么处理？</span></span></a></li><li><a class="level is-mobile" href="#如何处理-TCP-的粘包"><span class="level-left"><span class="level-item">114</span><span class="level-item">如何处理 TCP 的粘包?</span></span></a></li><li><a class="level is-mobile" href="#请说说-HTTPS-的握手过程？"><span class="level-left"><span class="level-item">115</span><span class="level-item">请说说 HTTPS 的握手过程？</span></span></a></li><li><a class="level is-mobile" href="#请说说什么是数字证书？它有什么作用"><span class="level-left"><span class="level-item">116</span><span class="level-item">请说说什么是数字证书？它有什么作用?</span></span></a></li><li><a class="level is-mobile" href="#使用-git-commit-后，如何修改-commit-的信息？"><span class="level-left"><span class="level-item">117</span><span class="level-item">使用 git commit 后，如何修改 commit 的信息？</span></span></a></li><li><a class="level is-mobile" href="#在-less-中如何将-px-转换为-vw？"><span class="level-left"><span class="level-item">118</span><span class="level-item">在 less 中如何将 px 转换为 vw？</span></span></a></li><li><a class="level is-mobile" href="#js-请说说写一个拖拽组件的思路及注意事项"><span class="level-left"><span class="level-item">119</span><span class="level-item">[js] 请说说写一个拖拽组件的思路及注意事项?</span></span></a></li><li><a class="level is-mobile" href="#为什么-try-catch-不能捕获到-promise-的错误？"><span class="level-left"><span class="level-item">120</span><span class="level-item">为什么 try/catch 不能捕获到 promise 的错误？</span></span></a></li><li><a class="level is-mobile" href="#gitlab-CI-CD-流程"><span class="level-left"><span class="level-item">121</span><span class="level-item">gitlab CI/CD 流程</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/favicon.svg" alt="foolishmax" height="28"></a><p class="is-size-7"><span>&copy; 2023 foolishmax</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>