<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>foolishmax</title>
  
  <subtitle>仅作为个人学习记录</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-01-18T03:35:56.167Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>foolishmax</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TS进阶题目</title>
    <link href="http://yoursite.com/2022/01/17/TS%E8%BF%9B%E9%98%B6%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2022/01/17/TS%E8%BF%9B%E9%98%B6%E9%A2%98%E7%9B%AE/</id>
    <published>2022-01-17T07:50:20.000Z</published>
    <updated>2022-01-18T03:35:56.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在线-TS-地址-typescript"><a href="#在线-TS-地址-typescript" class="headerlink" title="在线 TS 地址 typescript"></a>在线 TS 地址 <a href="https://www.typescriptlang.org/">typescript</a></h2><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><ul><li>以下代码为什么会提示错误，应该如何解决上述问题？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  kind: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCustomer&lt;T extends User&gt;(u: T): T &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    id: u.id,</span><br><span class="line">    kind: &#x27;customer&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一种解决方案</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  kind: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCustomer&lt;T extends User&gt;(u: T): User &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    id: u.id,</span><br><span class="line">    kind: &#x27;customer&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种解决方案</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  kind: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCustomer&lt;t extends User&gt;(u: T): T &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...u,</span><br><span class="line">    id: u.id,</span><br><span class="line">    kind: &#x27;customer&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><ul><li>以下函数我们希望参数<em>a</em>和<em>b</em>的类型都是一致的，即<em>a</em>和<em>b</em>同时为<em>number</em>或<em>string</em>类型，当它们的类型不一致时，ts 类型检查器能自动提示对应的错误信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f(a: string | number,b: string | number) &#123;</span><br><span class="line">  if (typeof a === &#x27;string&#x27;) &#123;</span><br><span class="line">    return a + &#x27;:&#x27; + b;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2); // OK</span><br><span class="line">f(&#x27;a&#x27;, &#x27;b&#x27;); // OK</span><br><span class="line">f(&#x27;a&#x27;, 2); // Error</span><br><span class="line">f(1, &#x27;b&#x27;); //Error</span><br></pre></td></tr></table></figure><p><strong>第一种解决方案</strong></p><ul><li>函数重载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function f(a: string, b: string): string;</span><br><span class="line">function f(a: number, b: number): number;</span><br><span class="line">function f(a: string | number, b: string | number): string | number &#123;</span><br><span class="line">  if (typeof a === &#x27;string&#x27;) &#123;</span><br><span class="line">    return a + &#x27;:&#x27; + b;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (a as number) + (b as number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2); // OK</span><br><span class="line">f(&#x27;a&#x27;, &#x27;b&#x27;); // OK</span><br><span class="line">f(1, &#x27;b&#x27;); // Error</span><br><span class="line">f(&#x27;a&#x27;, 2); // Error</span><br></pre></td></tr></table></figure><p><strong>第二种解决方案</strong></p><ul><li>自定义路由守卫</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const isStringArray = (params: string[] | number[]): params is string[] =&gt; typeof params[0] === &#x27;string&#x27;;</span><br><span class="line"></span><br><span class="line">function f(...args: string[] | number[]) &#123;</span><br><span class="line">  if (isStringArray(args)) &#123;</span><br><span class="line">    return args[0] + &#x27;:&#x27; + args[1];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return args[0] + args[1];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2); // OK</span><br><span class="line">f(&#x27;a&#x27;, &#x27;b&#x27;); // OK</span><br><span class="line">f(1, &#x27;b&#x27;); // Error</span><br><span class="line">f(&#x27;a&#x27;, 2); // Error</span><br></pre></td></tr></table></figure><p><strong>第三种解决方案</strong></p><ul><li>范型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f&lt;T extends string | number&gt;(a: T, b: T) &#123;</span><br><span class="line">  if (typeof a === &#x27;string&#x27;) &#123;</span><br><span class="line">    return a + &#x27;:&#x27; + b;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (a as number) + (b as number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2); // OK</span><br><span class="line">f(&#x27;a&#x27;, &#x27;b&#x27;); // OK</span><br><span class="line">f(1, &#x27;b&#x27;); // Error</span><br><span class="line">f(&#x27;a&#x27;, 2); // Error</span><br></pre></td></tr></table></figure><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><ul><li>实现 SetOptional 工具类型，支持把给定的 keys 对应的属性变为可选，参考<em>Partial<T></em></li><li>实现 SetRequired 工具类型，支持把给定的 keys 对应的属性变成必填，参考 <em>Require<T></em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SetOptional 测试用例</span><br><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b?: string;</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SomeOptional = SetOptional&lt;Foo, &#x27;a&#x27; | &#x27;b&#x27;&gt;</span><br><span class="line"></span><br><span class="line">type SomeOptional = &#123;</span><br><span class="line">  a?: number; //该属性变为可选的</span><br><span class="line">  b?: string; //保持不变</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SetRequired 测试用例</span><br><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b?: string;</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SomeRequired = SetRequired&lt;Foo, &#x27;a&#x27; | &#x27;b&#x27;&gt;</span><br><span class="line"></span><br><span class="line">type SomeRequired = &#123;</span><br><span class="line">  a: number; //保持不变</span><br><span class="line">  b: string; //该属性变为必选的</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案 1</strong></p><ul><li>SetOptional</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b?: string;</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对交叉类型进行扁平化处理</span><br><span class="line">type Simplify&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SetOptional&lt;T, K extends keyof T&gt; = Simplify&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">type SomeOptional = SetOptional&lt;Foo, &#x27;a&#x27; | &#x27;b&#x27;&gt;</span><br></pre></td></tr></table></figure><ul><li>SetRequired</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b?: string;</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Simplify&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SetRequired&lt;T, K extends keyof T&gt; = Simplify&lt;Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt; &amp; Required&lt;Pick&lt;T, K&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">type SomeRequired = SetRequired&lt;Foo, &#x27;b&#x27; | &#x27;c&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>解决方案 2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type Foo = &#123;</span><br><span class="line">  a: number;</span><br><span class="line">  b?: string;</span><br><span class="line">  c: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Simplely&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SetOptional&lt;T, K extends keyof T&gt; = Simplely&lt;&#123; [X in keyof Omit&lt;T, K&gt;]: T[X]; &#125; &amp; &#123; [P in K]?: T[P] &#125;&gt;;</span><br><span class="line">type SetRequired&lt;T, K extends keyof T&gt; = Simplely&lt;&#123; [X in keyof Omit&lt;T, K&gt;]: T[X]; &#125; &amp; &#123; [P in K]-?: T[P] &#125;&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type SomeOptional = SetOptional&lt;Foo, &#x27;a&#x27; | &#x27;b&#x27;&gt;;</span><br><span class="line">type SomeRequired = SetRequired&lt;Foo, &#x27;b&#x27; | &#x27;c&#x27;&gt;;</span><br></pre></td></tr></table></figure><p><strong>解决方案 3</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Simplify&lt;T&gt; = &#123;</span><br><span class="line">    [P in keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SetOptional&lt;T, K extends keyof T&gt; = Simplify&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt;;</span><br><span class="line"></span><br><span class="line">type SetRequired&lt;T, K extends keyof T&gt; = Simplify&lt;Required&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><ul><li><em>Pick&lt;T, K extends keyof T&gt;</em> 的作用是将某个类型中的字属性挑出来，得到包含这个类型部分属性的字类型。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">  completed: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;</span><br><span class="line"></span><br><span class="line">const todo: TodoPreview = &#123;</span><br><span class="line">  title: &quot;clean room&quot;,</span><br><span class="line">  completed: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题：如何定义一个<em>ConditionalPick</em>工具类型，支持根据指定的<em>Condition</em>条件来生成新的类型，对应的使用示例如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Example &#123;</span><br><span class="line">  a: string;</span><br><span class="line">  b: string | number;</span><br><span class="line">  c: () =&gt; void;</span><br><span class="line">  d: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type StringKeyOnly = ConditionalPick&lt;Example, string&gt;;</span><br><span class="line">// =&gt; &#123;a: string&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong></p><ul><li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types">神奇的 as</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Example &#123;</span><br><span class="line">  a: string;</span><br><span class="line">  b: string | number;</span><br><span class="line">  c: () =&gt; void;</span><br><span class="line">  d: &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ConditionalPick&lt;T, K&gt; = &#123;</span><br><span class="line">  [P in keyof T as (T[P] extends K ? P : never)]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type StringKeysOnly = ConditionalPick&lt;Example, string&gt;;</span><br><span class="line">// =&gt; &#123;a: string&#125;</span><br></pre></td></tr></table></figure><h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><ul><li>定义一个工具类型<em>AppendArgument</em>,为已有函数累心增加指定类型的参数，新增的参数名是<em>x</em>，将作为新函数类型的第一个参数，示例如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Fn = (a: number, b: string) =&gt; number;</span><br><span class="line">type AppendArgument&lt;F, A&gt; = // 你的实现代码</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type FinalFn = AppendArgument&lt;Fn, boolean&gt;</span><br><span class="line">// (x: boolean, a: number, b: string) =&gt; number;</span><br></pre></td></tr></table></figure><p><strong>解决方案 1</strong></p><ul><li>延伸阅读 <a href="https://mp.weixin.qq.com/s/mkvnJh3fBmL86Vnrv9xAyQ">掌握 TS 这些工具类型，让你开发事半功倍</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type AppendArgument&lt;F extends (...args: any) =&gt; any, A&gt; = (x: A, ...args: Parameters&lt;F&gt;) =&gt; ReturnType&lt;F&gt;</span><br><span class="line"></span><br><span class="line">type Fn = (a: number, b: string) =&gt; number;</span><br><span class="line"></span><br><span class="line">type FinalFn = AppendArgument&lt;Fn, boolean&gt;;</span><br><span class="line">// (x: boolean, a: number, b: string) =&gt; number;</span><br></pre></td></tr></table></figure><p><strong>解决方案 2</strong></p><ul><li>延伸阅读 <a href="https://mp.weixin.qq.com/s/JT2N2K5hvQAXN45B2DEbQw">用上这几招，轻松实现 TS 类型提取</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type AppendArgument&lt;F, T&gt; = F extends (...args: infer Args) =&gt; infer Return ? (x: T, ...args: Args) =&gt; Return : never;</span><br><span class="line"></span><br><span class="line">type Fn = (a: number, b: string) =&gt; number;</span><br><span class="line"></span><br><span class="line">type FinalFn = AppendArgument&lt;Fn, boolean&gt;;</span><br><span class="line">// (x: boolean, a: number, b: string) =&gt; number</span><br></pre></td></tr></table></figure><h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><ul><li>定义一个 NativeFlat 工具类型，支持把数组类型拍平(扁平化),示例如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type NativeFlat&lt;T extends any[]&gt; = // 实现代码</span><br><span class="line"></span><br><span class="line">//测试用例</span><br><span class="line">type NativeResult = NativeFlat&lt;[[&#x27;a&#x27;],[&#x27;b&#x27;,&#x27;c&#x27;],[&#x27;d&#x27;]]&gt;;</span><br><span class="line">// =&gt; &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;</span><br></pre></td></tr></table></figure><ul><li>在完成<em>NativeFlat</em>工具类型之后，继续实现<em>DeepFlat</em>工具类型，以支持多维数组类型：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type DeepFlat&lt;T extends any[]&gt; = unknown // 你的实现代码</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">type Deep = [[&#x27;a&#x27;], [&#x27;b&#x27;, &#x27;c&#x27;], [[&#x27;d&#x27;]], [[[[&#x27;e&#x27;]]]]];</span><br><span class="line">type DeepTestResult = DeepFlat&lt;Deep&gt;</span><br><span class="line">// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong></p><ul><li>NativeFlat</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type NaiveFlat&lt;T extends any[]&gt; = &#123;</span><br><span class="line">  [P in keyof T]: T[P] extends any[] ? T[P][number] : T[P]</span><br><span class="line">&#125;[number]</span><br><span class="line"></span><br><span class="line">type NaiveResult = NaiveFlat&lt;[[&#x27;a&#x27;], [&#x27;b&#x27;, &#x27;c&#x27;], [&#x27;d&#x27;]]&gt;</span><br><span class="line">// NaiveResult的结果： &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;</span><br></pre></td></tr></table></figure><ul><li>DeepFlat</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Deep = [[&#x27;a&#x27;], [&#x27;b&#x27;, &#x27;c&#x27;], [[&#x27;d&#x27;]], [[[[&#x27;e&#x27;]]]]];</span><br><span class="line"></span><br><span class="line">type DeepFlat&lt;T extends any[]&gt; = &#123;</span><br><span class="line">  [K in keyof T]: T[K] extends any[] ? DeepFlat&lt;T[K]&gt; : T[K]</span><br><span class="line">&#125;[number]</span><br><span class="line"></span><br><span class="line">type DeepTestResult = DeepFlat&lt;Deep&gt;</span><br><span class="line">// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;在线-TS-地址-typescript&quot;&gt;&lt;a href=&quot;#在线-TS-地址-typescript&quot; class=&quot;headerlink&quot; title=&quot;在线 TS 地址 typescript&quot;&gt;&lt;/a&gt;在线 TS 地址 &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;typescript&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;以下代码为什么会提示错误，应该如何解决上述问题？&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type User = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  id: number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  kind: string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function createCustomer&amp;lt;T extends User&amp;gt;(u: T): T &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id: u.id,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kind: &amp;#x27;customer&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;第一种解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type User = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  id: number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  kind: string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function createCustomer&amp;lt;T extends User&amp;gt;(u: T): User &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id: u.id,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kind: &amp;#x27;customer&amp;#x27;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;第二种解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type User = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  id: number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  kind: string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function createCustomer&amp;lt;t extends User&amp;gt;(u: T): T &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...u,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id: u.id,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kind: &amp;#x27;customer&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="typescript" scheme="http://yoursite.com/categories/typescript/"/>
    
    
    <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>获取唯一id的三种方法</title>
    <link href="http://yoursite.com/2022/01/04/%E8%8E%B7%E5%8F%96%E5%94%AF%E4%B8%80id%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2022/01/04/%E8%8E%B7%E5%8F%96%E5%94%AF%E4%B8%80id%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2022-01-04T03:19:53.000Z</published>
    <updated>2022-01-04T03:22:21.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const UUID = (len = 32) =&gt; &#123;</span><br><span class="line">  return &quot;xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx&quot;</span><br><span class="line">    .replace(/[xy]/g, function replace(c) &#123;</span><br><span class="line">      /* eslint-disable no-bitwise */</span><br><span class="line">      const r = (Math.random() * 16) | 0;</span><br><span class="line">      const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8;</span><br><span class="line"></span><br><span class="line">      return v.toString(16);</span><br><span class="line">    &#125;)</span><br><span class="line">    .substring(0, len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="nanoid"><a href="#nanoid" class="headerlink" title="nanoid"></a>nanoid</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const nanoid = (t = 21) =&gt; &#123;</span><br><span class="line">  let e = &quot;&quot;,</span><br><span class="line">    r = crypto.getRandomValues(new Uint8Array(t));</span><br><span class="line">  for (; t--; ) &#123;</span><br><span class="line">    let n = 63 &amp; r[t];</span><br><span class="line">    e +=</span><br><span class="line">      n &lt; 36</span><br><span class="line">        ? n.toString(36)</span><br><span class="line">        : n &lt; 62</span><br><span class="line">        ? (n - 26).toString(36).toUpperCase()</span><br><span class="line">        : n &lt; 63</span><br><span class="line">        ? &quot;_&quot;</span><br><span class="line">        : &quot;-&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原生方法"><a href="#原生方法" class="headerlink" title="原生方法"></a>原生方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const id = URL.createObjectURL(new Blob()).substr(-36)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;uuid&quot;&gt;&lt;a href=&quot;#uuid&quot; class=&quot;headerlink&quot; title=&quot;uuid&quot;&gt;&lt;/a&gt;uuid&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
    <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>vue3源码调试</title>
    <link href="http://yoursite.com/2022/01/02/vue3%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2022/01/02/vue3%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/</id>
    <published>2022-01-02T07:11:11.000Z</published>
    <updated>2022-01-02T07:38:44.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue3-源码调试步骤"><a href="#vue3-源码调试步骤" class="headerlink" title="vue3 源码调试步骤"></a>vue3 源码调试步骤</h2><h3 id="clone-项目"><a href="#clone-项目" class="headerlink" title="clone 项目"></a>clone 项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vuejs/vue-next.git</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn --ignore-scripts</span><br></pre></td></tr></table></figure><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改<strong>package.json</strong>中的 scripts 下 dev 的配置，后面添加 <em>–sourcemap</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;node scripts/dev.js&quot;</span><br><span class="line">// ⬇</span><br><span class="line">&quot;dev&quot;: &quot;node scripts/dev.js --sourcemap&quot;</span><br></pre></td></tr></table></figure><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run dev</span><br></pre></td></tr></table></figure><p>当终端出现<strong>waiting for changes…<strong>表示编译成功，可以</strong>ctrl+c</strong>结束进程查看源码了</p><p>打包完成之后，examples 下面的文件会引用 dist 文件下的文件（dist 文件是我们刚才编译后生成的文件）<br><img src="../images/vue3-dist.jpg" alt="vue3-dist"></p><h3 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h3><p>我们直接在<strong>package/vue/examples</strong>目录下添加<strong>demo/test.html</strong>文件，并引用**../../dist/vue.global.js**文件就可以使用 vue3 了，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;../../dist/vue.global.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;template id=&quot;foo&quot;&gt;</span><br><span class="line">      &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      const App = &#123;</span><br><span class="line">        template: &#x27;#foo&#x27;,</span><br><span class="line">        data: function () &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            name: &#x27;foolishmax&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Vue.createApp(App).mount(&#x27;#app&#x27;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来在浏览器中打开就可以进行 vue3 的代码调试了。</p><p><img src="../images/vue3-debugger.jpg" alt="vue3-debugger"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue3-源码调试步骤&quot;&gt;&lt;a href=&quot;#vue3-源码调试步骤&quot; class=&quot;headerlink&quot; title=&quot;vue3 源码调试步骤&quot;&gt;&lt;/a&gt;vue3 源码调试步骤&lt;/h2&gt;&lt;h3 id=&quot;clone-项目&quot;&gt;&lt;a href=&quot;#clone-项目&quot;</summary>
      
    
    
    
    <category term="vue3" scheme="http://yoursite.com/categories/vue3/"/>
    
    
    <category term="vue3" scheme="http://yoursite.com/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>lerna开发</title>
    <link href="http://yoursite.com/2021/11/01/lerna%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2021/11/01/lerna%E5%BC%80%E5%8F%91/</id>
    <published>2021-11-01T10:19:30.000Z</published>
    <updated>2021-11-08T11:00:12.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建-npm-私服"><a href="#创建-npm-私服" class="headerlink" title="创建 npm 私服"></a>创建 npm 私服</h2><ul><li>verdaccio 是一个简单、零配置的本地私有化 npm 仓库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cnpm install verdaccio -g</span><br><span class="line"></span><br><span class="line">verdaccio</span><br><span class="line">http://localhost:4873</span><br><span class="line">npm adduser --registry http://localhost:4873/</span><br><span class="line">npm publish --registry http://localhost: 4873/</span><br></pre></td></tr></table></figure><h2 id="lerna-常用命令"><a href="#lerna-常用命令" class="headerlink" title="lerna 常用命令"></a>lerna 常用命令</h2><p>项目初始化<br>| 命令 | 说明 |<br>| — | — |<br>| lerna init –independent | 初始化项目 |</p><p>创建包<br>| 命令 | 说明 |<br>| — | — |<br>| lerna create module-1 | 创建 package |<br>| lerna add | 安装依赖 |<br>| lerna link | 链接依赖 |</p><p>开发和测试<br>| 命令 | 说明 |<br>| — | — |<br>| lerna exec | 执行 shell 脚本 |<br>| lerna run | 执行 npm 命令 |<br>| lerna clean | 清空依赖|<br>| lerna bootstrap | 重新安装依赖 |</p><p>package 依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.给指定package安装依赖</span><br><span class="line">$ lerna add lodash packages/module-1</span><br><span class="line">$ lerna add lodash --scope=module-1</span><br><span class="line">$ lerna add lodash **/module-1</span><br><span class="line">$yarn workspace module-1 add lodash</span><br><span class="line"></span><br><span class="line">2.给所有package安装依赖</span><br><span class="line">$ lerna add lodash</span><br><span class="line"></span><br><span class="line">3.workspace之间的依赖</span><br><span class="line">$ lerna add module-2 packages/module-1</span><br><span class="line">$ lerna add module-2 --scope module-1</span><br></pre></td></tr></table></figure><p>发布</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lerna publish</span><br></pre></td></tr></table></figure><h2 id="lerna-json"><a href="#lerna-json" class="headerlink" title="lerna.json"></a>lerna.json</h2><ul><li>version: 当前仓库的版本，independent mode 请设置为 <strong>independent</strong>.<ul><li>lerna 对于包的管理有两种模式：固定模式 fixed、独立模式 independent。</li><li>固定模式所有包是统一的版本号，每次升级所有包统一更新，无论这个包内容是否改变。 *具体体现在 lerna 的配置文件中 lerna.json 中永远会存在一个确定版本号：{“version”: “0.0.1”}</li><li>独立模式，每个包都是单独的版本号，每次 lerna 触发发布命令，每个包的版本都会单独变化，具体体现在 lerna 的配置文件 lerna.json 中没有一个确定的版本号，而是{“version”:”independent”}</li></ul></li><li>npmClient: 指定运行的客户端程序 默认为 npm</li><li>ignoreChanges: 一个不包含在<strong>lerna changed/publish</strong>的 glob 数组，使用这个阻止发布不必要的更新，比如修复<strong>README.md</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;useWorkspaces&quot;: true, // 使用 workspaces 配置。此项为 true 的话，将使用 package.json 的 &quot;workspaces&quot;，下面的 &quot;packages&quot; 字段将不生效</span><br><span class="line">    &quot;version&quot;: &quot;0.1.0&quot;, // 所有包版本号，独立模式-&quot;independent&quot;</span><br><span class="line">    &quot;npmClient&quot;: &quot;cnpm&quot;, // npm client，可设置为 cnpm、yarn 等</span><br><span class="line">    &quot;packages&quot;: [ // 包所在目录，可指定多个</span><br><span class="line">        &quot;packages/*&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;command&quot;: &#123; // lerna 命令相关配置</span><br><span class="line">        &quot;publish&quot;: &#123; // 发布相关</span><br><span class="line">            &quot;ignoreChanges&quot;: [ // 指定文件或目录的变更，不触发 publish</span><br><span class="line">                &quot;.gitignore&quot;,</span><br><span class="line">                &quot;*.log&quot;,</span><br><span class="line">                &quot;*.md&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;bootstrap&quot;: &#123; // bootstrap 相关</span><br><span class="line">            &quot;ignore&quot;: &quot;npm-*&quot;,  // 不受 bootstrap 影响的包</span><br><span class="line">            &quot;npmClientArgs&quot;: [ // bootstr 执行参数</span><br><span class="line">                &quot;--no-package-lock&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="CRA-lerna-react-typescript-项目搭建"><a href="#CRA-lerna-react-typescript-项目搭建" class="headerlink" title="CRA + lerna + react + typescript 项目搭建"></a>CRA + lerna + react + typescript 项目搭建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.create-react-app demo --template typescript</span><br><span class="line"></span><br><span class="line">2.cd demo</span><br><span class="line"></span><br><span class="line">3.npm run eject</span><br><span class="line"></span><br><span class="line">4.lerna init</span><br><span class="line"></span><br><span class="line">5.lerna create builder-script</span><br><span class="line"></span><br><span class="line">6.自定义builder-scripts脚本命令</span><br><span class="line"></span><br><span class="line">7.自定义 eslintrc、tsconfig、webpack等配置项</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建-npm-私服&quot;&gt;&lt;a href=&quot;#创建-npm-私服&quot; class=&quot;headerlink&quot; title=&quot;创建 npm 私服&quot;&gt;&lt;/a&gt;创建 npm 私服&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;verdaccio 是一个简单、零配置的本地私有化 npm 仓库&lt;/li</summary>
      
    
    
    
    <category term="lerna" scheme="http://yoursite.com/categories/lerna/"/>
    
    
    <category term="lerna" scheme="http://yoursite.com/tags/lerna/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置工程师</title>
    <link href="http://yoursite.com/2021/10/27/webpack%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <id>http://yoursite.com/2021/10/27/webpack%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E5%B8%88/</id>
    <published>2021-10-27T02:48:00.000Z</published>
    <updated>2021-10-27T07:27:38.625Z</updated>
    
    <content type="html"><![CDATA[<p>构建webpack知识体系分为下面三个层级：<br>1.基础–会配置<br>2.进阶–能优化<br>3.深入–懂原理</p><h2 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h2><h3 id="1-简单配置"><a href="#1-简单配置" class="headerlink" title="1.简单配置"></a>1.简单配置</h3><p>  该部分需掌握：<br>  1.Webpack常规配置项有哪些？<br>  2.常用loader有哪些？如何配置？<br>  3.常用插件plugin有哪些？如何配置？<br>  4.Babel如何配置？Babel插件如何使用？</p><h4 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h4><p>需要现在本地安装<strong>webpack</strong>及<strong>webpack-cli</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure><h4 id="1-2-开始工作"><a href="#1-2-开始工作" class="headerlink" title="1.2 开始工作"></a>1.2 开始工作</h4><p>webpack在4以后就支持0配置打包，我们可以测试一下<br>1.新建webpack-work项目，新建 <code>./src/index.js</code>文件，写一段简单的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a = &#x27;hello foolishmax&#x27;;</span><br><span class="line">console.log(a);</span><br><span class="line">module.exports = a;</span><br></pre></td></tr></table></figure><p>2.直接运行<code>npx webpack</code>，启动打包<br><img src="../images/webpack-mode-error.png" alt="webpack-mode-error">)</p><p>打包完成，会有一个提示：<code>The &#39;mode&#39; option has not been set,...</code></p><p>意思就是我们没有配置mode（告知webpack使用相应模式的内置优化，默认为<code>production</code>，另外还有<code>development</code>、<code>none</code>）</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>development</td><td>开发模式，打包更加快速，省了代码优化步骤</td></tr><tr><td>production</td><td>生产模式，打包比较慢，开启tree-shaking和压缩代码</td></tr><tr><td>none</td><td>不使用任何默认优化选项</td></tr></tbody></table><p>webpack.config.js中配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3配置文件"><a href="#1-3配置文件" class="headerlink" title="1.3配置文件"></a>1.3配置文件</h4><p>虽然可以零配置打包，但是实际工作中，还是需要使用配置文件的方式来满足不同项目的需求。<br>1.跟路径下创建配置文件<code>webpack.config.js</code><br>2.新增基本配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;, // 模式</span><br><span class="line">  entry: &#x27;./src/index.js&#x27;, // 打包入口地址</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;, // 输出文件名</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;) // 输出文件目录</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-4-loader"><a href="#1-4-loader" class="headerlink" title="1.4 loader"></a>1.4 loader</h4><p>这里我们把入口文件改成css文件，看下打包结果如何<br>1.新增<code>./src/main.css</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding: 0 20px;</span><br><span class="line">  max-width: 800px;</span><br><span class="line">  background: #f4f8fb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.修改entry配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./src/main.css&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.运行打包命令： <code>npx webpack</code><br><img src="../images/webpack-loader.png" alt="loader"><br>这里的报错信息是因为：webpack默认支持处理js文件，其他类型都处理不了，需要借助loader来对不同类型的文件进行处理。</p><p>4.安装<code>css-loader</code>来处理CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader -D</span><br></pre></td></tr></table></figure><p>5.配置资源加载模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./src/main.css&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.css&#x27;,</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [ // 转换规则</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.css$/, // 匹配所有css文件</span><br><span class="line">        use: &#x27;css-loader&#x27;, //对应的loader名称</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6.重新运行打包命令<code>npx webpack</code>,就可以打包成功了</p><p>总结：loader就是将webpack不认识的内容转化为认识的内容</p><h4 id="插件（plugin）"><a href="#插件（plugin）" class="headerlink" title="插件（plugin）"></a>插件（plugin）</h4><p>插件可以贯穿webpack打包的生命周期，执行不同的任务</p><p>1.新建<code>./src/index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如果想要打包后的资源文件，例如js或者css文件可以自动引入到html中，就需要使用插件<code>html-webpack-plugin</code>来做这件事情。</p><p>2.本地安装 <code>html-webpack-plugin</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>3.配置插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.join(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [ // 转换规则</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.css$/, // 匹配所有css文件</span><br><span class="line">        use: &#x27;css-loader&#x27;, //对应的loader名称</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/index.html&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行一下打包，打开dist目录下的index.html文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到它自动引入打包好的bundle.js</p><h4 id="1-6自动清空打包目录"><a href="#1-6自动清空打包目录" class="headerlink" title="1.6自动清空打包目录"></a>1.6自动清空打包目录</h4><p>每次打包的时候，打包目录都会遗留上次打包的文件，为了保持打包目录的纯净，打包前需将上次打包目录清空。</p><p>1.安装 <code>clean-webpack-plugin</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>2.配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">const &#123;CleanWebpackPlugin&#125; = require(&#x27;clean-webpack-plugin&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/index.html&#x27;,</span><br><span class="line">    &#125;),</span><br><span class="line">    new CleanWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7区分环境"><a href="#1-7区分环境" class="headerlink" title="1.7区分环境"></a>1.7区分环境</h4><p>本底环境</p><ul><li>需要更快的构建速度</li><li>需要打印debug信息</li><li>需要live reload或者hot reload功能</li><li>需要sourcemap方便定位问题</li><li>…</li></ul><p>生产环境：</p><ul><li>需要更小的包体积，代码压缩+tree-shaking</li><li>需要进行代码分割</li><li>需要压缩图片体积</li><li>…</li></ul><p><a href="https://juejin.cn/post/7023242274876162084#heading-6">掘金</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;构建webpack知识体系分为下面三个层级：&lt;br&gt;1.基础–会配置&lt;br&gt;2.进阶–能优化&lt;br&gt;3.深入–懂原理&lt;/p&gt;
&lt;h2 id=&quot;一、基础篇&quot;&gt;&lt;a href=&quot;#一、基础篇&quot; class=&quot;headerlink&quot; title=&quot;一、基础篇&quot;&gt;&lt;/a&gt;一、基础篇</summary>
      
    
    
    
    <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
    <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>React深入浅出知识链路</title>
    <link href="http://yoursite.com/2021/10/05/React%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF/"/>
    <id>http://yoursite.com/2021/10/05/React%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF/</id>
    <published>2021-10-05T03:07:11.000Z</published>
    <updated>2021-10-07T08:24:17.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React框架的关键设计思想：“组件”、“虚拟DOM”"><a href="#React框架的关键设计思想：“组件”、“虚拟DOM”" class="headerlink" title="React框架的关键设计思想：“组件”、“虚拟DOM”"></a>React框架的关键设计思想：“组件”、“虚拟DOM”</h3><h3 id="组件化-工程化思想在框架中的落地"><a href="#组件化-工程化思想在框架中的落地" class="headerlink" title="组件化: 工程化思想在框架中的落地"></a>组件化: 工程化思想在框架中的落地</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“封闭”：在组件自身的渲染工作流中，每个组件都只处理它的内部的渲染逻辑。</span><br><span class="line">“开放”：针对组件间通信来说，React基于“单向数据流”的原则完成组件间的通信。</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="虚拟DOM：核心算法的基石："><a href="#虚拟DOM：核心算法的基石：" class="headerlink" title="虚拟DOM：核心算法的基石："></a>虚拟DOM：核心算法的基石：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">组件初始化-&gt;render方法-&gt;生成虚拟DOM-&gt;ReactDOM.render方法-&gt;生成真实DOM</span><br><span class="line"></span><br><span class="line">组件更新-&gt;render方法-&gt;生成新的虚拟DOM-&gt;diff算法-&gt;定位两次虚拟DOM的差异-&gt;批量更新</span><br></pre></td></tr></table></figure><h3 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps(nextProps)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果父组件导致子组件重新渲染，即使props没有更改，也会调用此方法，如果只想处理更改，请确保当前值和变更值的比较。---React官方</span><br></pre></td></tr></table></figure><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React组件会根据shouldComponentUpdate的返回值来决定是否执行后面的生命周期进而决定是否对组件进行re-render(重渲染)</span><br></pre></td></tr></table></figure><h3 id="getDerivedStateFromProps-新增-不是componentWillMount-废弃-的替代品"><a href="#getDerivedStateFromProps-新增-不是componentWillMount-废弃-的替代品" class="headerlink" title="getDerivedStateFromProps(新增)不是componentWillMount(废弃)的替代品"></a>getDerivedStateFromProps(新增)不是componentWillMount(废弃)的替代品</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getDerivedStateFromProps有且仅有一个用途：使用props来派生/更新state</span><br><span class="line"></span><br><span class="line">static getDerivedStateFromProps(props, state)</span><br><span class="line">1.静态方法，访问不到this</span><br><span class="line">2.参数 props(父组件)和state(自身)</span><br><span class="line">3.对象格式的返回值，用来更新自身state（更新并非覆盖式，而是替换式更新）</span><br><span class="line">4.挂载和更新都会触发此钩子</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">getDerivedStateFromProps是作为一个试图代替componentWillReceiveProps的API出现的。</span><br><span class="line">getDerivedStateFromProps不能完全和componentWillReceiveProps画等号</span><br><span class="line"></span><br><span class="line">原因：getDerivedStateFromProps仅可以代替componentWillReceiveProps来实现基于props派生state，原则来说能且只能做这一件事。</span><br></pre></td></tr></table></figure><h3 id="getSnapshotBeforeUpdate-新增-与componentWillUpdate-废弃"><a href="#getSnapshotBeforeUpdate-新增-与componentWillUpdate-废弃" class="headerlink" title="getSnapshotBeforeUpdate(新增)与componentWillUpdate(废弃)"></a>getSnapshotBeforeUpdate(新增)与componentWillUpdate(废弃)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)&#123;&#125;</span><br><span class="line">1. 执行时机在render方法之后，真实DOM更新之前</span><br><span class="line">2.返回值会作为第三个参数传递给componentDidUpdate</span><br></pre></td></tr></table></figure><h3 id="Fiber架构（核心：可中断、可恢复、优先级）"><a href="#Fiber架构（核心：可中断、可恢复、优先级）" class="headerlink" title="Fiber架构（核心：可中断、可恢复、优先级）"></a>Fiber架构（核心：可中断、可恢复、优先级）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.Fiber是React16对React核心算法的一次重写</span><br><span class="line">2.Fiber会使原本同步的渲染过程变成异步的</span><br><span class="line">3.Fiber会将一个大的更新任务拆解为许多个小任务(工作单元)，这些工作单元有着不同的优先级，react可以根据优先级的高低去实现工作单元的打断和恢复 </span><br><span class="line"></span><br><span class="line">Fiber架构的重要特征就是可以被打断的异步渲染模式，根据能否被打断这一标准，React16的生命周期被划分为render和commit两个阶段</span><br><span class="line">render阶段在执行过程中允许被打断（因为此阶段用户不可见，打断也无影响）</span><br><span class="line">commit阶段总是同步执行（涉及到同步渲染，会影响用户直观体验）</span><br><span class="line"></span><br><span class="line">render阶段是允许暂停、终止和重启的，这就导致render阶段的生命周期都是有可能被重复执行，所以要废弃处于render阶段的一些生命周期：componentWillMount、componenntUpdate、componentWillReceiveProps、shouldComponentUpdate(一般不会在这个生命周期中进行副作用操作，所以相对风险不大，没有被废弃)</span><br><span class="line"></span><br><span class="line">每个更新任务都会被赋予一个优先级</span><br><span class="line">若B任务的优先级高于当前任务A，那么当前处于Reconciler层的A任务就会被中断，当B任务完成后，A任务就会被重新推入Reconciler层，继续它的渲染，这便是所谓的“可恢复”</span><br><span class="line"></span><br><span class="line">Fiber架构对生命周期的影响</span><br><span class="line">react15: render开始-&gt;停不下来的递归计算(同步)-&gt;commit提交渲染</span><br><span class="line">react16: render开始-&gt;工作单元｜工作单元｜工作单元...(异步)-&gt;commit提交渲染</span><br></pre></td></tr></table></figure><h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UI = render(data) 或 UI = f(data)</span><br><span class="line">React的视图会随着数据的变化而变化</span><br></pre></td></tr></table></figure><h3 id="React-Hooks的使用原则"><a href="#React-Hooks的使用原则" class="headerlink" title="React-Hooks的使用原则"></a>React-Hooks的使用原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.只在React函数中调用Hook</span><br><span class="line">2.不要在循环、条件和嵌套函数中调用Hook(要确保hooks在每次渲染时都保持同样的执行顺序)</span><br><span class="line"></span><br><span class="line">从源码调用流程看原理：Hooks的正常运作，在底层依赖于顺序链表。</span><br><span class="line">mountState首次渲染构建链表并渲染，updateState依次遍历链表并渲染</span><br><span class="line"></span><br><span class="line">hooks的渲染就是通过依次遍历来定位每个hooks的内容，如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然就是不可控的</span><br></pre></td></tr></table></figure><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟DOM本质上是JS和DOM之间的一个映射缓存，在形态上表现为一个能够描述DOM结构及其属性信息的JS对象。</span><br></pre></td></tr></table></figure><h3 id="Diff逻辑的拆分与解读"><a href="#Diff逻辑的拆分与解读" class="headerlink" title="Diff逻辑的拆分与解读"></a>Diff逻辑的拆分与解读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Diff算法性能突破的关键点在于 分层对比</span><br><span class="line">2.类型一致的节点才有继续Diff的必要性</span><br><span class="line">3.key属性的设置，可以帮我们尽可能重用同一层级内的节点</span><br></pre></td></tr></table></figure><h3 id="setState异步"><a href="#setState异步" class="headerlink" title="setState异步"></a>setState异步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setState-&gt;shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate</span><br><span class="line"></span><br><span class="line">批量更新：每来一个setState，就把它塞进一个队列里面存起来，等时机成熟，再把存起来的state结果做合并，最后只针对最后一次最新的state值走一次更新流程</span><br><span class="line"></span><br><span class="line">setState的表现会因为调用的场景不同而不同：</span><br><span class="line">1.在React钩子函数及合成事件中，表现为异步</span><br><span class="line">2.在setTimeout、setInterval等函数中，包括DOM原生事件中，表现为同步。</span><br></pre></td></tr></table></figure><h3 id="ReactDOM-render调用栈的逻辑分层"><a href="#ReactDOM-render调用栈的逻辑分层" class="headerlink" title="ReactDOM.render调用栈的逻辑分层"></a>ReactDOM.render调用栈的逻辑分层</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure><h3 id="React事件系统"><a href="#React事件系统" class="headerlink" title="React事件系统"></a>React事件系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当事件在具体的DOM节点上被触发后，最终都会冒泡到document上，document上所绑定的统一事件处理程序会将事件分发到具体的组件实例</span><br><span class="line"></span><br><span class="line">react合成事件：在底层抹平了不同浏览器的差异，在上层面向开发者暴漏统一的、稳定的、与DOM原生事件相同的事件接口（原生DOM事件可以通过e.nativeEvent查看）</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;React框架的关键设计思想：“组件”、“虚拟DOM”&quot;&gt;&lt;a href=&quot;#React框架的关键设计思想：“组件”、“虚拟DOM”&quot; class=&quot;headerlink&quot; title=&quot;React框架的关键设计思想：“组件”、“虚拟DOM”&quot;&gt;&lt;/a&gt;React框架的关键设计思想：“组件”、“虚拟DOM”&lt;/h3&gt;&lt;h3 id=&quot;组件化-工程化思想在框架中的落地&quot;&gt;&lt;a href=&quot;#组件化-工程化思想在框架中的落地&quot; class=&quot;headerlink&quot; title=&quot;组件化: 工程化思想在框架中的落地&quot;&gt;&lt;/a&gt;组件化: 工程化思想在框架中的落地&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;“封闭”：在组件自身的渲染工作流中，每个组件都只处理它的内部的渲染逻辑。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;“开放”：针对组件间通信来说，React基于“单向数据流”的原则完成组件间的通信。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
    <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>面试题目手写部分</title>
    <link href="http://yoursite.com/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%89%8B%E5%86%99%E9%83%A8%E5%88%86/"/>
    <id>http://yoursite.com/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%89%8B%E5%86%99%E9%83%A8%E5%88%86/</id>
    <published>2021-10-04T13:57:04.000Z</published>
    <updated>2021-10-05T04:08:20.960Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="手写部分"><a href="#手写部分" class="headerlink" title="手写部分"></a>手写部分</h1><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// indexOf</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    let res = [];</span><br><span class="line">    </span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if(res.indexOf(arr[i]) &lt; 0) &#123;</span><br><span class="line">            res.push(arrp[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// includes</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    let res = [];</span><br><span class="line">    </span><br><span class="line">    for (let item of arr) &#123;</span><br><span class="line">        if(!res.includes(item)) &#123;</span><br><span class="line">            res.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 利用filter</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    const res  = arr.filter(function(item, index, array)&#123;</span><br><span class="line">        return array.indexOf(item) === index;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 利用Es6中的Set数据结构(扩展运算符)</span><br><span class="line">const unique = arr =&gt; [...new Set(arr)];</span><br><span class="line"></span><br><span class="line">// Array.form 方法将set结构转换为数组</span><br><span class="line">const unique = arr =&gt; Array.from(new Set(arr));</span><br></pre></td></tr></table></figure><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,[2,[3]]]</span><br><span class="line"></span><br><span class="line">// let res = arr.flat(Infinity)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// let res = JSON.parse(&quot;[&quot;+JSON.stringify(arr).replace(/\[|\]/g,&quot;&quot;) + &quot;]&quot;)</span><br><span class="line"></span><br><span class="line">function flatArr(arr) &#123;</span><br><span class="line">    let res = arr.reduce((accu, curr) =&gt; &#123;</span><br><span class="line">        return accu.concat(Array.isArray(curr) ? flatArr(curr) : curr)</span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatArr(arr))</span><br></pre></td></tr></table></figure><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 只考虑对象类型</span><br><span class="line">function shallowCopy(obj) &#123;</span><br><span class="line">    if (typeof obj !== &#x27;object&#x27;) return;</span><br><span class="line">    let newObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    if(obj === null) return obj;</span><br><span class="line">    if(obj instanceof Date) return new Date(obj);</span><br><span class="line">    if(obj instanceof RegExp) return new RegExp(obj); </span><br><span class="line">    </span><br><span class="line">    for (let key in obj) &#123;</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Object.assign()</span><br><span class="line">// arr.slice(0)</span><br><span class="line">// arr.concat()</span><br><span class="line">// 扩展运算符</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 只考虑普通对象属性，不考虑内置对象和函数</span><br><span class="line">function deepCone(obj) &#123;</span><br><span class="line">    if (typeof obj !== &#x27;object&#x27;) return;</span><br><span class="line">    let newObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    if(obj === null) return obj;</span><br><span class="line">    if(obj instanceof Date) return new Date(obj);</span><br><span class="line">    if(obj instanceof RegExp) return new RegExp(obj); </span><br><span class="line">    </span><br><span class="line">    for(let key in obj) &#123;</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = typeof obj[key] === &#x27;object&#x27; ? deepClone(obj[key]) : obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JSON.parse(JSON.stringify())</span><br><span class="line">// lodash: _.cloneDeep()</span><br></pre></td></tr></table></figure><h2 id="实现一个compose-组合-函数"><a href="#实现一个compose-组合-函数" class="headerlink" title="实现一个compose(组合)函数"></a>实现一个compose(组合)函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function compose(...fn) &#123;</span><br><span class="line">    if(!fn.length) return (v) =&gt; v;</span><br><span class="line">    if(fn.length === 1) return fn[0];</span><br><span class="line">    </span><br><span class="line">    return fn.reduce((accu, curr) =&gt; (...args) =&gt; accu(curr(...args)) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">function fn1(x) &#123;</span><br><span class="line">  return x + 1;</span><br><span class="line">&#125;</span><br><span class="line">function fn2(x) &#123;</span><br><span class="line">  return x + 2;</span><br><span class="line">&#125;</span><br><span class="line">function fn3(x) &#123;</span><br><span class="line">  return x + 3;</span><br><span class="line">&#125;</span><br><span class="line">function fn4(x) &#123;</span><br><span class="line">  return x + 4;</span><br><span class="line">&#125;</span><br><span class="line">const res = compose(fn1, fn2, fn3, fn4);</span><br><span class="line">console.log(res(5)); // 5+4+3+2+1=15</span><br></pre></td></tr></table></figure><h2 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Object.assign = function(target, ...source) &#123;</span><br><span class="line">    if (target === null || target === undefined) &#123;</span><br><span class="line">        throw new TypeError(&quot;Cannot convert undefined or null to object&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let result = Object(target);</span><br><span class="line">    </span><br><span class="line">    source.forEach(function(obj)&#123;</span><br><span class="line">        if (obj !== null) &#123;</span><br><span class="line">            for (let key in obj) &#123;</span><br><span class="line">                if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                    result[key] = obj[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function debounce (func, wait) &#123;</span><br><span class="line">    let timeout;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        </span><br><span class="line">        timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">            func.apply(this, arguments)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 搜索联想，用户在不断输入时，用防抖来节约请求资源</span><br><span class="line">// window触发resize的时候</span><br></pre></td></tr></table></figure><h2 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    const previous = 0;</span><br><span class="line">    </span><br><span class="line">    return function() &#123;</span><br><span class="line">        const now = +new Date();</span><br><span class="line">        if(now - previous  &gt; wait) &#123;</span><br><span class="line">            func.apply(this, arguments);</span><br><span class="line">            </span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 鼠标不断点击触发，可以使其单位时间内只触发以此</span><br><span class="line">// 监听滚动事件</span><br><span class="line">// 防止高频点击提交</span><br></pre></td></tr></table></figure><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">    // 需要柯里化的函数fn，也可以支持初始参数的传入</span><br><span class="line">    </span><br><span class="line">    return function() &#123;</span><br><span class="line">        //参数缓存在args里面,合并上次参数和本次参数</span><br><span class="line">        args = [...args, ...arguments]</span><br><span class="line">        </span><br><span class="line">        // 判断参数个数，不够继续递归</span><br><span class="line">        if (args.length &lt; fn.length) &#123;</span><br><span class="line">            return curry(fn, ...args)   </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //参数足够返回函数执行结果</span><br><span class="line">            return fn.apply(null, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar(a, b, c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const f = curry(bar)</span><br><span class="line"></span><br><span class="line">console.log(f(1)(2)(3),f(1,2)(3),f(1,2,3))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何把字符串中大小写取反"><a href="#如何把字符串中大小写取反" class="headerlink" title="如何把字符串中大小写取反"></a>如何把字符串中大小写取反</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;LiBoShi&quot;;</span><br><span class="line"></span><br><span class="line">str = str.replace(/[a-zA-Z]/g, content =&gt; &#123;</span><br><span class="line">    return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="从S中查找T字符串，找到返回索引值，没有则返回-1，类似indexOf"><a href="#从S中查找T字符串，找到返回索引值，没有则返回-1，类似indexOf" class="headerlink" title="从S中查找T字符串，找到返回索引值，没有则返回-1，类似indexOf"></a>从S中查找T字符串，找到返回索引值，没有则返回-1，类似indexOf</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 普通方法</span><br><span class="line">function myIndexOf(T) &#123;</span><br><span class="line">    let index = -1;</span><br><span class="line">    for(let i = 0; i &lt;= this.length - T.length; i++) &#123;</span><br><span class="line">        if (this.substr(i, T.length) === T) &#123;</span><br><span class="line">             return index = i;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String.prototype.myIndexOf = myIndexOf;</span><br><span class="line">// 正则方法</span><br><span class="line">function myIndexOf(T) &#123;</span><br><span class="line">    let reg = new RegExp(T);</span><br><span class="line">    let res = reg.exec(this);</span><br><span class="line">    </span><br><span class="line">    return res === null ? -1 : res.index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context, ...args) &#123;</span><br><span class="line">    const ctx = context || window;</span><br><span class="line">    const fn = Symbol();</span><br><span class="line">    </span><br><span class="line">    ctx[fn] = this;</span><br><span class="line">    </span><br><span class="line">    const res = ctx[fn](...args);</span><br><span class="line">    </span><br><span class="line">    delete ctx[fn];</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">let obj = &#123;</span><br><span class="line">    desc: function(from, to) &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125;来自$&#123;from&#125;去往$&#123;to&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person = &#123;</span><br><span class="line">    name: &#x27;lbs&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.desc.myCall(person, &quot;北京&quot;,&quot;上海&quot;)</span><br></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(context, args=[]) &#123;</span><br><span class="line">    const ctx = context || window;</span><br><span class="line">    const fn = Symbol();</span><br><span class="line">    </span><br><span class="line">    ctx[fn] = this;</span><br><span class="line">    const res = ctx[fn](...args);</span><br><span class="line">    </span><br><span class="line">    delete ctx[fn];</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function(content, ...args) &#123;</span><br><span class="line">    const fn = this;</span><br><span class="line">    </span><br><span class="line">    return function newFn(...newFnArgs) &#123;</span><br><span class="line">        // 检测 New</span><br><span class="line">        // 如果当前函数的this指向的是构造函数中的this 则判定为new 操作</span><br><span class="line">        if (this instanceof newFn) &#123;</span><br><span class="line">            return new fn(...args, ...newFnArgs);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        return fn.myApply(context, [...args, ...newFnArgs]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 通过left.__proto__.__proto__这种方式从下往上的获取原型对象</span><br><span class="line">2. 通过Object.create(null)的实例是没有原型链</span><br><span class="line">3. 有原型链的实例的尽头都是Object</span><br><span class="line"></span><br><span class="line">function instanceof(left, right) &#123;</span><br><span class="line">    if(!left.__proto__) return false;</span><br><span class="line">    if(right === Object || left.__proto__ === right.prototype) return true;</span><br><span class="line">    </span><br><span class="line">    return instanceof(left.__proto__, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写Object-is"><a href="#手写Object-is" class="headerlink" title="手写Object.is"></a>手写Object.is</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function is(x, y) &#123;</span><br><span class="line">    if (x===y) &#123;</span><br><span class="line">        // x,y都为0，但是1 / +0 = +Infinity,1 / -0 = -Infinity 是不一样的</span><br><span class="line">        return x !== 0 || y !== 0 || 1 / x === 1 / y;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //NaN === NaN = false是不对的，做一个拦截操作</span><br><span class="line">        return x !== x &amp;&amp; y !== y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function ajax(method, url, headers, body) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let req = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            req = new XMLHttpRequest();</span><br><span class="line">        &#125; catch&#123;</span><br><span class="line">            req = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        req.open(method, url);</span><br><span class="line">        </span><br><span class="line">        for(let key in headers) &#123;</span><br><span class="line">            req.setRequestHeader(key, headers[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        req.onreadystatechange(() =&gt; &#123;</span><br><span class="line">            if(req.readystate ===4) &#123;</span><br><span class="line">                if(req.status &gt;= 200 &amp;&amp; req.status &lt;= 300) &#123;</span><br><span class="line">                    resolve(req.responseText);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    reject(req);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        req.send(body)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 执行async函数，返回的都是Promise对象</span><br><span class="line">async function test1 () &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">async function test2() &#123;</span><br><span class="line">    return Promise.resolve(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(test1(),test2());</span><br><span class="line"></span><br><span class="line">// Promise.then 成功的情况对应的就是await</span><br><span class="line">async function test3() &#123;</span><br><span class="line">    const p = Promise.resolve(3);</span><br><span class="line">    p.then((data) =&gt; console.log(data));</span><br><span class="line">    </span><br><span class="line">    const data = await p;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test3();</span><br><span class="line"></span><br><span class="line">// Promise.catch 异常对应 try...catch</span><br><span class="line">async function test4() &#123;</span><br><span class="line">    const p = Promise.reject(&quot;异常了&quot;);</span><br><span class="line">    </span><br><span class="line">    try&#123;</span><br><span class="line">        const data = await p;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test4();</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.map = function(fn, toThis) &#123;</span><br><span class="line">    const arr = this;</span><br><span class="line">    const result = [];</span><br><span class="line">    const _this = toThis || Object.create(null);</span><br><span class="line">    </span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        const item = fn.call(_this, arr[i], i, arr);</span><br><span class="line">        result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">class Promise1&#123;</span><br><span class="line">    static PENDING = &#x27;pending&#x27;;</span><br><span class="line">    static FULFILLED = &#x27;fulfilled&#x27;;</span><br><span class="line">    static REJECTED = &#x27;rejected&#x27;;</span><br><span class="line"></span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this.status = Promise.PENDING; //默认状态，进行中</span><br><span class="line">        this.value = null; //成功值</span><br><span class="line">        this.reason = null;  // 失败原因</span><br><span class="line">        // 解决异步问题</span><br><span class="line">        this.onFulfilledCallbacks = [];</span><br><span class="line">        this.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            executor(this.resolve.bind(this), this.reject.bind(this))    </span><br><span class="line">        &#125; catch(e) &#123;</span><br><span class="line">            this.reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        if (this.status === Promise.PENDING) &#123;</span><br><span class="line">            this.status = Promise.FULFILLED;</span><br><span class="line">            this.value = value;</span><br><span class="line"></span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                this.onFulfilledCallbacks.forEach((cb) =&gt; cb((this.value)))    </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        if (this.status === Promise.PENDING) &#123;</span><br><span class="line">            this.status = Promise.REJECTED;</span><br><span class="line">            this.reason = reason;</span><br><span class="line"></span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                this.onRejectedCallbacks.forEach((cb) =&gt; cb(this.reason))    </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        if (typeof onFulfilled !== &#x27;function&#x27;) &#123;</span><br><span class="line">            onFulfilled = () =&gt; this.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (typeof onRejected !== &#x27;function&#x27;) &#123;</span><br><span class="line">            onRejected = () =&gt; this.reason;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">            if (this.status === Promise.PENDING) &#123;</span><br><span class="line">                return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">                    this.onFulfilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">                        this.parse(onFulfilled(this.value), resolve, reject)                        </span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">                return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">                    this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">                        this.parse(onRejected(this.value),resolve,reject)                       </span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;) </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (this.status === Promise.FULFILLED) &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">                        this.parse(onFulfilled(this.value), resolve, reject)                        </span><br><span class="line">                    &#125;)</span><br><span class="line">                    </span><br><span class="line">                &#125;)              </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (this.status === Promise.REJECTED) &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">                        this.parse(onRejected(this.reason), resolve, reject)                        </span><br><span class="line">                    &#125;)</span><br><span class="line"></span><br><span class="line">                &#125;)               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parse(result, resolve, reject) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (result instanceof Promise1) &#123;</span><br><span class="line">                result.then(resolve, reject)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static resolve(value) &#123;</span><br><span class="line">        return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">            if (value instanceof Promise1) &#123;</span><br><span class="line">                value.then(resolve, reject)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static reject(reason) &#123;</span><br><span class="line">        return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static all(promises) &#123;</span><br><span class="line">        const result = [];</span><br><span class="line"></span><br><span class="line">        return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">            promises.forEach((promise) =&gt; &#123;</span><br><span class="line">                promise.then((value) =&gt; &#123;</span><br><span class="line">                    result.push(value);</span><br><span class="line"></span><br><span class="line">                    if (result.length === promises.length) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,reason =&gt; &#123;</span><br><span class="line">                    reject(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static race(promises) &#123;</span><br><span class="line">        return new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">            promises.forEach((promise) =&gt; &#123;</span><br><span class="line">                promise.then((value) =&gt; &#123;</span><br><span class="line">                    resolve(value)</span><br><span class="line">                &#125;,(reason) =&gt; &#123;</span><br><span class="line">                    reject(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let aaa = new Promise1((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;lbs&quot;)</span><br><span class="line">//     reject(&#x27;error&#x27;)</span><br><span class="line">&#125;).then((value) =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">    return &#x27;666&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">aaa.then(() =&gt; &#123;</span><br><span class="line">    console.log(123)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(aaa) </span><br></pre></td></tr></table></figure><h2 id="手写event-bus"><a href="#手写event-bus" class="headerlink" title="手写event bus"></a>手写event bus</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class EventEmitter &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.events = &#123;&#125;</span><br><span class="line">        this.maxListeners = maxListeners || Infinity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit(event, ...args) &#123;</span><br><span class="line">        const cbs = this.events[event];</span><br><span class="line"></span><br><span class="line">        if(!cbs) &#123;</span><br><span class="line">            console.log(&quot;没有这个事件函数&quot;);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cbs.forEach(cb =&gt; cb.apply(this, args))</span><br><span class="line"></span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    on(event, cb) &#123;</span><br><span class="line">        if (!this.events[event]) &#123;</span><br><span class="line">            this.events[event] = []</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.maxListeners !== Infinity &amp;&amp; this.events[event].length &gt;= this.maxListeners) &#123;</span><br><span class="line">            console.log(&quot;当事件超过了最大监听数&quot;)</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.events[event].push(cb)</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    once(event, cb) &#123;</span><br><span class="line">        const func = (...args) =&gt; &#123;</span><br><span class="line">            this.off(event, fn);</span><br><span class="line">            cb.apply(this, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.on(event, func)</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    off(event, cb) &#123;</span><br><span class="line">        if (!cb) &#123;</span><br><span class="line">            this.events[event] = null</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.events[event] = this.events[event].filter(item=&gt;item !==cb)</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数继承</span><br><span class="line">function Person() &#123;</span><br><span class="line">    this.name = &#x27;lbs&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student() &#123;</span><br><span class="line">    Person.call(this)</span><br><span class="line">    this.age = 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const s = new Student()</span><br><span class="line"></span><br><span class="line">// 原型链继承</span><br><span class="line">function Person() &#123;</span><br><span class="line">    this.name = &#x27;lbs&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student() &#123;</span><br><span class="line">    this.age = 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = new Person()</span><br><span class="line"></span><br><span class="line">const s = new Student()</span><br><span class="line">//寄生式组合继承</span><br><span class="line">function Person(obj)&#123;</span><br><span class="line">    this.name = obj.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(obj)&#123;</span><br><span class="line">    Person.call(this, obj);</span><br><span class="line">    this.age = obj.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// object.create()</span><br><span class="line">// 方法创建一个新对象，使用现有的对象来提供新创建对象的__proto__</span><br><span class="line">Student.prototype = Object.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">// 或者：</span><br><span class="line">Student.prototype = Object.create(Person.prototype, &#123;</span><br><span class="line">    constructor: &#123;</span><br><span class="line">        value: Student,</span><br><span class="line">        enumerable: false,</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const student = new Student(&#123;name: &quot;lbs&quot;, age: 18&#125;);</span><br><span class="line"></span><br><span class="line">console.log(student);</span><br></pre></td></tr></table></figure><h2 id="createElement手写"><a href="#createElement手写" class="headerlink" title="createElement手写"></a>createElement手写</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">const symbolFor = Symbol.for;</span><br><span class="line">const REACT_ELEMENT_TYPE = symbolFor(&#x27;react.element&#x27;);</span><br><span class="line"></span><br><span class="line">const RESERVED_PROPS = &#123;</span><br><span class="line">    key: true,</span><br><span class="line">    ref: true,</span><br><span class="line">    __self: true,</span><br><span class="line">    __source: true,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createElement(type, config, children) &#123;</span><br><span class="line">    const props = &#123;&#125;;</span><br><span class="line">    let key = null;</span><br><span class="line">    </span><br><span class="line">    if (config !== null) &#123;</span><br><span class="line">        key = config.key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (let propName in config) &#123;</span><br><span class="line">        if (!RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">            props[propName] = config[propName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const childrenLength = arguments.length -2;</span><br><span class="line">    if(childrenLength === 1) &#123;</span><br><span class="line">        props.children = children;</span><br><span class="line">    &#125; else if(childrenLength &gt; 1) &#123;</span><br><span class="line">        const childArray = Array(childrenLength);</span><br><span class="line">        </span><br><span class="line">        for(let i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">            childArray[i] = arguments[i + 2];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        props.children = childArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const element = &#123;</span><br><span class="line">        $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line">        type,</span><br><span class="line">        key,</span><br><span class="line">        props</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写正则，验证一个6～16位的字符串，必须同时包含大小写字母和数字"><a href="#编写正则，验证一个6～16位的字符串，必须同时包含大小写字母和数字" class="headerlink" title="编写正则，验证一个6～16位的字符串，必须同时包含大小写字母和数字"></a>编写正则，验证一个6～16位的字符串，必须同时包含大小写字母和数字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">正向预查 ？= 必须</span><br><span class="line">反向预查 ？！必须不</span><br><span class="line">let reg = /(?!^[a-zA-Z]+$)(?!^[0-9]+$)(?!^[a-z0-9]+$)(?!^[A-Z0-9]+$)^[a-zA-Z0-9]&#123;6,16&#125;$/;</span><br><span class="line"></span><br><span class="line">补充：数字、字母、下划线组成字符串，必须有_</span><br><span class="line">let reg = /(?=_)\w/;</span><br><span class="line">let reg = /(?!^[a-zA-Z0-9]+$)^\w&#123;1,10&#125;$/; 限制1-10位</span><br></pre></td></tr></table></figure><h2 id="获取所有属性为name，值为value的元素集合"><a href="#获取所有属性为name，值为value的元素集合" class="headerlink" title="获取所有属性为name，值为value的元素集合"></a>获取所有属性为name，值为value的元素集合</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 正则\b单词边界</span><br><span class="line">function getElements(property, value) &#123;</span><br><span class="line">    let elements = document.getElementsByTagName(&#x27;*&#x27;);</span><br><span class="line">    let arr = [];</span><br><span class="line">    </span><br><span class="line">    elements = Array.from(elements);</span><br><span class="line">    elements.forEach(item =&gt; &#123;</span><br><span class="line">        // 当前元素property对应的值</span><br><span class="line">        let itemValue = item.getAttribute(propertype);</span><br><span class="line">        </span><br><span class="line">        if (property === &quot;class&quot;) &#123;</span><br><span class="line">            const reg = new RegExp(`\b$&#123;value&#125;\b`);</span><br><span class="line">            </span><br><span class="line">            if (reg.test(itemValue)) &#123;</span><br><span class="line">                arr.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(itemValue === value) &#123;</span><br><span class="line">            arr.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="英文字母汉字组成的字符串，用正则给英文单词前后加空格"><a href="#英文字母汉字组成的字符串，用正则给英文单词前后加空格" class="headerlink" title="英文字母汉字组成的字符串，用正则给英文单词前后加空格"></a>英文字母汉字组成的字符串，用正则给英文单词前后加空格</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;中国hello你好&quot;</span><br><span class="line">let reg = /\b[a-z]+\b/ig;</span><br><span class="line"></span><br><span class="line">str = str.replace(reg, value =&gt; &#123;</span><br><span class="line">    return ` $&#123;value&#125; `;</span><br><span class="line">&#125;).trim(); // 去除首尾空格</span><br></pre></td></tr></table></figure><h2 id="js实现斐波那契数列的几种方法"><a href="#js实现斐波那契数列的几种方法" class="headerlink" title="js实现斐波那契数列的几种方法"></a>js实现斐波那契数列的几种方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 1.递归</span><br><span class="line">function fibonacci(n) &#123;</span><br><span class="line">    if (n === 1 || n === 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.尾递归(每次调用都在收集结果，避免了线性递归不收集结果只依次展开消耗内存的坏处)</span><br><span class="line">function fibonacci(n, res1 = 1, res2 = 1) &#123;</span><br><span class="line">    if (n &lt;= 2) return res2;</span><br><span class="line">    </span><br><span class="line">    return fibonacci(n - 1, res2, res1 + res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 循环</span><br><span class="line">function fibonacci(n) &#123;</span><br><span class="line">    let num1 = 1;</span><br><span class="line">    let num2 = 2;</span><br><span class="line">    let sum = 1;</span><br><span class="line">    </span><br><span class="line">    for(let i = 3; i &lt; n; i++) &#123;</span><br><span class="line">        sum = num1 + num2;</span><br><span class="line">        num1 = num2;</span><br><span class="line">        num2 = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组</span><br><span class="line">function fibonacci(n) &#123;</span><br><span class="line">    const arr = [0,1,1];</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        throw new Error(&#x27;输入的数字不能小于0&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (n &gt;= 3) &#123;</span><br><span class="line">        for(let i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            arr[i] = arr[i - 1] + arr[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return arr[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并发加载"><a href="#并发加载" class="headerlink" title="并发加载"></a>并发加载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function limitLoad(urls, handler, limit) &#123;</span><br><span class="line">    const sequence = [].concat(urls);</span><br><span class="line">    let promises = [];</span><br><span class="line"></span><br><span class="line">    promises = sequence.splice(0, limit).map((url, index) =&gt; &#123;</span><br><span class="line">        return handler(url).then(() =&gt; &#123;</span><br><span class="line">            return index</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    let p = Promise.race(promises);</span><br><span class="line"></span><br><span class="line">    for(let i = 0; i &lt; sequence.length; i++) &#123;</span><br><span class="line">        p = p.then((res) =&gt; &#123;</span><br><span class="line">            promises[res] = handler(sequence[i]).then(() =&gt; &#123;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">                console.log(promises)</span><br><span class="line">            return Promise.race(promises)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loadImg(url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">//             console.log(url.info + &#x27;---OK!!!&#x27;)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;,url.time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let urls = [</span><br><span class="line">&#123;info: 1,time: 2000&#125;,</span><br><span class="line">&#123;info: 2,time: 1000&#125;,</span><br><span class="line">&#123;info: 3,time: 3000&#125;,</span><br><span class="line">&#123;info: 4,time: 4000&#125;,</span><br><span class="line">&#123;info: 5,time: 5000&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">limitLoad(urls, loadImg, 3)</span><br></pre></td></tr></table></figure><h2 id="前端内存处理"><a href="#前端内存处理" class="headerlink" title="前端内存处理"></a>前端内存处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">1. 内存的生命周期</span><br><span class="line">    内存分配：声明变量、函数对象的时候，js会自动分配内存</span><br><span class="line">    内存使用</span><br><span class="line">    内存回收</span><br><span class="line"></span><br><span class="line">2. js中的垃圾回收机制</span><br><span class="line">    引用计数：缺点循环引用无法清除</span><br><span class="line">    标记清除</span><br><span class="line"></span><br><span class="line">3. 常见内存泄漏</span><br><span class="line">    全局变量（记得手动回收）</span><br><span class="line">    未被清除的定时器</span><br><span class="line">    闭包</span><br><span class="line">    dom的引用</span><br><span class="line"></span><br><span class="line">4. 怎么避免内存泄漏</span><br><span class="line">    减少不必要的全局变量</span><br><span class="line">    使用完数据，及时解除引用</span><br><span class="line"></span><br><span class="line">实现sizeOf，传入object，计算其所占字节大小</span><br><span class="line">number: 8 字节</span><br><span class="line">string: 2 字节</span><br><span class="line">boolean; 4 字节</span><br><span class="line"></span><br><span class="line">const seen = new WeakSet();</span><br><span class="line"></span><br><span class="line">function sizeOfObject(obj) &#123;</span><br><span class="line">    if (obj === null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let bytes = 0;</span><br><span class="line">    const keys = Object.keys(obj);</span><br><span class="line"></span><br><span class="line">    for(let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">        const key = keys[i];</span><br><span class="line">        bytes += calculator(key);</span><br><span class="line"></span><br><span class="line">        if (typeof obj[key] === &#x27;object&#x27; &amp;&amp; obj[key] !== null) &#123;</span><br><span class="line">            if (seen.has(obj[key])) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            seen.add(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes += calculator(obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function calculator(obj) &#123;</span><br><span class="line">    const objType = typeof obj;</span><br><span class="line"></span><br><span class="line">    switch(objType) &#123;</span><br><span class="line">        case &#x27;string&#x27;: &#123;</span><br><span class="line">            return obj.length * 2</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;boolean&#x27;: &#123;</span><br><span class="line">            return 4</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;number&#x27;: &#123;</span><br><span class="line">            return 8</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;object&#x27;: &#123;</span><br><span class="line">            if (Array.isArray(obj)) &#123;</span><br><span class="line">                return obj.map(calculator).reduce((accu, curr) =&gt; &#123;</span><br><span class="line">                    return accu + curr</span><br><span class="line">                &#125;, 0)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return sizeOfObject(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        default: &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据结构就是在计算机中存储和组织数据的方式。</p><p>算法（Algorithm）解决问题的逻辑或步骤</p><h2 id="栈-封装"><a href="#栈-封装" class="headerlink" title="栈(封装)"></a>栈(封装)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function Stack() &#123;</span><br><span class="line">    this.items = [];</span><br><span class="line">    // 1. 将元素压入栈</span><br><span class="line">    Stack.prototype.push = function (element) &#123;</span><br><span class="line">        this.items.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.从栈中取出元素</span><br><span class="line">    Stack.prototype.pop = function() &#123;</span><br><span class="line">        return this.items.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.查看一下栈顶元素</span><br><span class="line">    Stack.prototype.peek = function() &#123;</span><br><span class="line">        return this.items[this.items.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">    // 4.判断栈是否为空</span><br><span class="line">    Stack.prototype.isEmpty = function() &#123;</span><br><span class="line">        return !this.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    // 5.获取栈中元素个数</span><br><span class="line">    Stack.prototype.size = function () &#123;</span><br><span class="line">        return this.item.length;</span><br><span class="line">    &#125;</span><br><span class="line">    // 6. toString方法</span><br><span class="line">    Stack.prototype.toString = function() &#123;</span><br><span class="line">        let res = &quot;&quot;;</span><br><span class="line">        for(let i = 0;i &lt; this.items.length;i++) &#123;</span><br><span class="line">            res += `$&#123;this.items[i]&#125; `;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const stack = new Stack();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 实例：将十进制转换成二进制</span><br><span class="line">function dec2bin(decimalNumber) &#123;</span><br><span class="line">    let stack = new Stack();</span><br><span class="line">    let binary = &#x27;&#x27;;</span><br><span class="line">    </span><br><span class="line">    while(decimalNumber &gt; 0) &#123;</span><br><span class="line">        stack.push(decimalNumber % 2);</span><br><span class="line">        </span><br><span class="line">        decimalNumber = Math.floor(decimalNumber / 2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(!stack.isEmpty()) &#123;</span><br><span class="line">        binary += stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return binary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡括号问题"><a href="#平衡括号问题" class="headerlink" title="平衡括号问题"></a>平衡括号问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function check(str) &#123;</span><br><span class="line">    const stack = new Stack()</span><br><span class="line">    const open = &quot;&#123;[(&quot;</span><br><span class="line">    const close = &quot;&#125;])&quot;</span><br><span class="line">    let index = 0</span><br><span class="line">    let balanced = true</span><br><span class="line">    </span><br><span class="line">    while(index &lt; str.length &amp;&amp; balanced) &#123;</span><br><span class="line">        if (open.includes(str[index])) &#123;</span><br><span class="line">            stack.push(str[index])</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            const top = stack.pop()</span><br><span class="line">            if (open.indexOf(top) === close.indexOf(str[index])) &#123;</span><br><span class="line">                balanced = true</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                balanced = false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (balanced &amp;&amp; stack.isEmpty()) &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(&quot;&#123;([][])&#125;&quot;)</span><br><span class="line">check(&quot;&#123;[(])&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function reverseList(head) &#123;</span><br><span class="line">    if (head === null || head.next === null) return head;</span><br><span class="line"></span><br><span class="line">    let result = reverseList(head.next)</span><br><span class="line"></span><br><span class="line">    head.next.nexd = head</span><br><span class="line">    head.next = null</span><br><span class="line"></span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function binarySearch(elements,value,_start,_end) &#123;</span><br><span class="line">    let end = _end || elements.length - 1;</span><br><span class="line">    let start = _start || 0;</span><br><span class="line">    let povitIndex = Math.floor((start + end) / 2);</span><br><span class="line"></span><br><span class="line">    if (elements[povitIndex] === value) &#123;</span><br><span class="line">        return povitIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (value &lt; elements[povitIndex]) &#123;</span><br><span class="line">        return binarySearch(elements, value, 0, povitIndex - 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return binarySearch(elements, value, povitIndex + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(elements) &#123;</span><br><span class="line">    if(elements.length &lt;= 1) &#123;</span><br><span class="line">        return elements</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let pivotIndex = Math.floor(elements.length / 2)</span><br><span class="line">    let [pivot] = elements.splice(pivotIndex,1)</span><br><span class="line">    let left = [];</span><br><span class="line">    let right = [];</span><br><span class="line"></span><br><span class="line">    for(let i = 0; i &lt; elements.length; i++) &#123;</span><br><span class="line">        if (elements[i] &lt; pivot) &#123;</span><br><span class="line">            left.push(elements[i])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(elements[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return quickSort(left).concat([pivot], quickSort(right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let elements = [2,4,3,7,5]</span><br><span class="line"></span><br><span class="line">console.log(quickSort(elements))</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(elements) &#123;</span><br><span class="line">    let elementLength = elements.length;</span><br><span class="line">    </span><br><span class="line">    for(let i = 0; i &lt; elementLength - 1; i++ ) &#123;</span><br><span class="line">        for(let j = 0; j &lt; elementLength - i - 1; j++) &#123;</span><br><span class="line">            if(elements[j] &gt; elements[j + 1]) &#123;</span><br><span class="line">                let temp = elements[j];</span><br><span class="line">                elements[j] = elements[j + 1]</span><br><span class="line">                elements[j + 1] = temp </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(elements)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let elements = [2,4,3,7,5]</span><br><span class="line"></span><br><span class="line">bubbleSort(elements)</span><br><span class="line"></span><br><span class="line">// console.log(elements)</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">//满二叉树：每层节点数都达到最大值，第n层节点数为2^(n - 1),总节点数为2^n -1(2的n次方减一)</span><br><span class="line">//完全二叉树：除最后一层外，其他各层节点数都达到最大个数，最后一层所有节点集中在最左边</span><br><span class="line">class Node &#123;</span><br><span class="line">    constructor(value) &#123;</span><br><span class="line">        this.value = value</span><br><span class="line">        this.left = null</span><br><span class="line">        this.right = null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BinarySearchTree &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.root = null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入前比较</span><br><span class="line">    insertNode(node, newNode) &#123;</span><br><span class="line">        // 右侧插入</span><br><span class="line">        if (newNode.value &gt; node.value) &#123;</span><br><span class="line">            if (node.right === null) &#123;</span><br><span class="line">                node.right = newNode                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.insertNode(node.right, newNode)   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (newNode.value &lt; node.value) &#123;</span><br><span class="line">            // 左侧插入</span><br><span class="line">            if (node.left === null) &#123;</span><br><span class="line">                node.left = newNode</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.insertNode(node.left, newNode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入</span><br><span class="line">    insert(value) &#123;</span><br><span class="line">        let newNode = new Node(value);</span><br><span class="line">        if (this.root === null) &#123;</span><br><span class="line">            this.root = newNode</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.insertNode(this.root, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    preOrderTraversalNode(node,callback) &#123;</span><br><span class="line">        if (node === null) return</span><br><span class="line"></span><br><span class="line">        callback(node.value)</span><br><span class="line"></span><br><span class="line">        this.preOrderTraversalNode(node.left, callback)</span><br><span class="line"></span><br><span class="line">        this.preOrderTraversalNode(node.right, callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 先序遍历</span><br><span class="line">    preOrderTraversal(callback) &#123;</span><br><span class="line">        this.preOrderTraversalNode(this.root, callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrderTraversalNode(node, callback) &#123;</span><br><span class="line">        if (node === null) return;</span><br><span class="line"></span><br><span class="line">        this.inOrderTraversalNode(node.left, callback)</span><br><span class="line"></span><br><span class="line">        callback(node.value)</span><br><span class="line"></span><br><span class="line">        this.inOrderTraversalNode(node.right, callback)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 中序遍历</span><br><span class="line">    inOrderTraversal(callback) &#123;</span><br><span class="line">        this.inOrderTraversalNode(this.root, callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    postOrderTraversalNode(node, callback) &#123;</span><br><span class="line">        if (node === null) return;</span><br><span class="line"></span><br><span class="line">        this.postOrderTraversalNode(node.left, callback)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        this.postOrderTraversalNode(node.right, callback)</span><br><span class="line"></span><br><span class="line">        callback(node.value)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 中序遍历</span><br><span class="line">    postOrderTraversal(callback) &#123;</span><br><span class="line">        this.postOrderTraversalNode(this.root, callback)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最大值</span><br><span class="line">    max() &#123;</span><br><span class="line">        let node = this.root;</span><br><span class="line">        while(node.right !== null) &#123;</span><br><span class="line">            node = node.right</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return node.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 最小值</span><br><span class="line">    min() &#123;</span><br><span class="line">        let node = this.root</span><br><span class="line">        while(node.left !== null) &#123;</span><br><span class="line">            node = node.left</span><br><span class="line">        &#125;</span><br><span class="line">        return node.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 寻找指定值是否存在</span><br><span class="line">    search(val)&#123;</span><br><span class="line">        let node = this.root</span><br><span class="line">        while(node !== null) &#123;</span><br><span class="line">            if(val &lt; node.value) &#123;</span><br><span class="line">                node = node.left</span><br><span class="line">            &#125; else if(val &gt; node.value) &#123;</span><br><span class="line">                node = node.right</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bst = new BinarySearchTree()</span><br><span class="line"></span><br><span class="line">bst.insert(3)</span><br><span class="line">bst.insert(2)</span><br><span class="line">bst.insert(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// bst.preOrderTraversal((nodeValue) =&gt; &#123;</span><br><span class="line">//     console.log(nodeValue)</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// bst.inOrderTraversal((nodeValue) =&gt;&#123;</span><br><span class="line">//     console.log(nodeValue)</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// bst.postOrderTraversal((nodeValue) =&gt;&#123;</span><br><span class="line">//     console.log(nodeValue)</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">// console.log(bst.max())</span><br><span class="line">console.log(bst.search(5))</span><br><span class="line"></span><br><span class="line">console.log(bst)</span><br></pre></td></tr></table></figure><h2 id="翻转链表-1"><a href="#翻转链表-1" class="headerlink" title="翻转链表"></a>翻转链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">var reverseList = function (head) &#123;</span><br><span class="line">  if (head === null || head.next === null) return head;</span><br><span class="line"></span><br><span class="line">  let res = reverseList(head.next)</span><br><span class="line"></span><br><span class="line">  head.next.next = head</span><br><span class="line">  head.next = null</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 循环</span><br><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">  let pre = null</span><br><span class="line">  let cur = head;</span><br><span class="line"></span><br><span class="line">  if(cur === null || cur.next === null) &#123;</span><br><span class="line">    return cur</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while(cur) &#123;</span><br><span class="line">    const t = cur.next</span><br><span class="line">    cur.next = pre</span><br><span class="line">    pre = cur</span><br><span class="line">    cur = t</span><br><span class="line">    </span><br><span class="line">    // cur.next = null</span><br><span class="line">    // cur.next.next = cur</span><br><span class="line">    // cur = cur.nexxt</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法1-Two-Sum"><a href="#算法1-Two-Sum" class="headerlink" title="算法1: Two Sum"></a>算法1: Two Sum</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">example:</span><br><span class="line">given nums = [2, 7, 11, 15], target = 9</span><br><span class="line">because num[0] + num[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1]</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">function twoSum(nums, target) &#123;</span><br><span class="line">    const map = new Map();</span><br><span class="line">    </span><br><span class="line">    for(let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        const complement = target - nums[i];</span><br><span class="line">        </span><br><span class="line">        if (map.has(complement)) &#123;</span><br><span class="line">            return [map.get(complement), i]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.set(nums[i], i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>装箱：基本类型到引用类型的一个转换<br>拆箱：将引用类型到基本类型的转换（toPrimitive）</p><p>编码和解码：<br>escape(str)  unescape(str)<br>encodeURI()  decodeURI()<br>encodeURIComponent()  decodeURIComponent()<br>btoa() atob()</p><p>回流：相当与刷新页面<br>重绘： 不刷新，动态更新内容<br>重绘不一定引起回流，回流一定引起重绘</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;手写部分&quot;&gt;&lt;a href=&quot;#手写部分&quot; class=&quot;headerlink&quot; title=&quot;手写部分&quot;&gt;&lt;/a&gt;手写部分&lt;/h1&gt;&lt;h2 id=&quot;数组去重&quot;&gt;&lt;a href=&quot;#数组去重&quot; class=&quot;headerlink&quot; title=&quot;数组去重&quot;&gt;&lt;/a&gt;数组去重&lt;/h2&gt;</summary>
    
    
    
    <category term="面经" scheme="http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试题目总结</title>
    <link href="http://yoursite.com/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-04T13:54:55.000Z</published>
    <updated>2021-10-04T13:56:31.462Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="从浏览器地址栏输入url到显示页面的步骤"><a href="#从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤"></a>从浏览器地址栏输入url到显示页面的步骤</h2><pre><code>1. 浏览器查看缓存(浏览器对应的都会有cache文件)。若请求有缓存且未过期，则取缓存资源提供给客户端，否则发起请求与服务器进行验证。检验是否过期通常有两个HTTP头：Expires、Cache-control2.浏览器需要获取域名对应的ip地址，过程如下：1.本地host文件查找- 浏览器解析URL获取协议、域名、端口、path路径，然后查看本地硬盘中hosts文件，看是否存在与这个域名对应的规则，如果有就直接使用hosts文件里面的ip地址。2.路由器缓存3.ISP DNS(Domain Name System域名系统)(情报局)缓存（互联网提供服务商）-本地DNS服务器以递归方式进行查询缓存记录，若没有就向跟DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器，本地DNS服务器把对应关系草存在缓存中（一边下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。3.客户端发送HTTP请求。4.TCP传输报文（三次握手四次挥手）5.向客户端返回资源6.解析HTML文档，构建DOM树，CSSOM树，下载资源，执行js脚本等。</code></pre><span id="more"></span><h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个域名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</span><br></pre></td></tr></table></figure><h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">强缓存：（expires、Cache-Control）在过期时间内，浏览器再次加载资源时，不会向服务器发起请求，直接从缓存中读取资源</span><br><span class="line"></span><br><span class="line">协商缓存：向服务器发送请求，服务器会根据请求头（request header）的一些参数（Etag、last-modified）来判断是否命中协商缓存，首先根据Etag的值判断请求的文件有没有被修改，如果Etag一致则没有被修改，命中协商缓存返回304，如果不一致则返回新的资源并带上新的Etag返回200状态码。如果没有Etag值，则对比If-Modified-Since和请求文件的最后修改时间，一致则命中协商缓存返回304，不一致则返回新的last-modified和200状态码</span><br></pre></td></tr></table></figure><h2 id="http协议的特点"><a href="#http协议的特点" class="headerlink" title="http协议的特点"></a>http协议的特点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.支持客户/服务器模式</span><br><span class="line">2.简单快速：客户向服务器发送请求时，只需传送请求方法和路径。</span><br><span class="line">3.灵活：http允许传输任意类型的数据对象（Content-Type内容编码类型）</span><br><span class="line"></span><br><span class="line">application/x-www-form-urlencoded 常见post提交数据格式（key-value格式）</span><br><span class="line">application/json</span><br><span class="line"></span><br><span class="line">4.无连接：限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。（原因是早期服务器需要同时面对全世界数十万、上百万的客户端的网页访问，但是每次客户端与服务端传输的数据关联性很低，就会导致大部分通过会很空闲，无端占用资源）</span><br><span class="line"></span><br><span class="line">（解决无连接）Keep-Alive：使客户端到服务端之间的Http连接保持，不会断开，当再次对服务器发送请求时，keep-Alive功能避免了重新建立连接</span><br><span class="line"></span><br><span class="line">5.无状态：Http是一个无状态协议，就是每个请求都是独立的，数据传输完毕不会记录任何信息。缺点就是如果后续处理需要前面的信息，就必须重传，就会导致每次连接传送的数据量增加，如果服务器不需要前面信息的时候应答就会很快。</span><br><span class="line"></span><br><span class="line">（解决无状态）怎样保持http连接状态呢</span><br><span class="line">Cookie（每次http请求的时候，客户端都需要发送响应的cookie信息到服务端，服务端根据cookie判断来自哪个客户端）</span><br><span class="line">服务端生成cookie，客户端保存</span><br><span class="line"></span><br><span class="line">Session</span><br><span class="line">服务端生成一个sessionid，在客户端下次请求的时候在cookie里面记录这个sessionid，然后发送给服务端，服务端再根据cookie中的sessionid来识别客户端返回资源数据。</span><br><span class="line"></span><br><span class="line">禁用cookie怎么办？</span><br><span class="line">url重写，每次http请求的时候，在url后面拼接sid=**参数</span><br><span class="line"></span><br><span class="line">withCredentials:指定在涉及到跨域请求时，是否携带cookie信息，默认为false</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.存取方式不同： cookie只能保存ASCII字符串，session能够存储任意类型的数据</span><br><span class="line">2.隐私策略不同</span><br><span class="line">3.cookie是存在客户端，session是存在服务器的</span><br><span class="line">4.浏览器的支持不同，浏览器可以禁用cookie</span><br></pre></td></tr></table></figure><h2 id="权限身份验证"><a href="#权限身份验证" class="headerlink" title="权限身份验证"></a>权限身份验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">一般都是通过sessionid来进行用户身份验证，sessionid一般会存放在redis中。</span><br><span class="line">1.用户向服务端发送用户名和密码进行登陆</span><br><span class="line">2.服务器验证通过后，服务器为用户创建一个session，并将session信息存储起来</span><br><span class="line">3.服务器向用户返回一个sessionid，写入用户的cookie</span><br><span class="line">4.当用户保持登陆状态时，每次后续请求都会一起发送给后端</span><br><span class="line">5.服务器将存储在cookie中的sessionid和存储在内存或者数据库中的sessin信息进行一个比较，验证用户身份，然后返回响应信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.依赖session的关键业务一定要确保客户端开启了cookie</span><br><span class="line">2.注意session的过期时间</span><br><span class="line"></span><br><span class="line">一般在http header的Authorization字段中添加token</span><br></pre></td></tr></table></figure><h2 id="禁用cookie之后session还能用吗？"><a href="#禁用cookie之后session还能用吗？" class="headerlink" title="禁用cookie之后session还能用吗？"></a>禁用cookie之后session还能用吗？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url重写，例如 https://javascript.cn/?session_id=xxx</span><br><span class="line">缺点是安全性降低，可以对sessionid进行一次加密后传输</span><br></pre></td></tr></table></figure><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.url可见性：get参数url可见，post参数url不可见</span><br><span class="line">2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数</span><br><span class="line">3.缓存性：get请求可以缓存，post请求不可以缓存</span><br><span class="line">4.get请求网页回退时，不产生影响，post请求网页回退会重新发请求</span><br><span class="line">5.传输数据：get一般传输数据大小不超过4k，post可以传输大量数据</span><br><span class="line">6.post较get安全性较高，get是不安全的因为url可见，可能会泄漏私密信息</span><br></pre></td></tr></table></figure><h2 id="http常见的请求头字段"><a href="#http常见的请求头字段" class="headerlink" title="http常见的请求头字段"></a>http常见的请求头字段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Accept: 浏览器可接受的数据类型</span><br><span class="line">Accept-Charset: 浏览器可接受的字符集</span><br><span class="line">Accept-Encoding：浏览器能够进行解码的数据编码方式</span><br><span class="line">Accept-Language： 浏览器所希望的语言种类</span><br><span class="line">Connection：是否需要持久连接，值“Keep-Alive”，HTTP1.1默认进行持久连接</span><br><span class="line">Cookie：cookie信息</span><br><span class="line">content-type</span><br><span class="line">If-Modified-Since：内容被修改才会返回</span><br><span class="line">User-Agent：浏览器类型</span><br><span class="line"></span><br><span class="line">响应头：</span><br><span class="line">content-Length: 表示内容长度</span><br><span class="line">content-type：文档类型</span><br><span class="line">Date：当前时间</span><br><span class="line">Expires：指定缓存过期时间</span><br><span class="line">Last-Modified：文档过期时间</span><br></pre></td></tr></table></figure><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http是超文本传输协议，信息是明文传输，https是更加安全的ssl加密传输协议</span><br><span class="line">http默认是80端口，https默认是443端口</span><br><span class="line">https需要申请CA证书</span><br><span class="line">https是http + ssl/tls（数字证书）进行组合的更加安全的传输协议</span><br><span class="line"></span><br><span class="line">https工作原理（非对称加密）</span><br><span class="line">1.服务端向客户端传递证书作为公钥</span><br><span class="line">2.客户端对证书进行解析，判断证书的办法机构和过期时间等，如果都没有问题，生成一个随机值作为私钥，然后使用证书进行加密发送给服务端</span><br><span class="line">3.服务端解密得到客户端私钥</span><br><span class="line">4.之后双方利用私钥进行加密解密，完成信息的通信</span><br></pre></td></tr></table></figure><h2 id="xss（跨域脚本攻击）csrf（跨站请求伪造）"><a href="#xss（跨域脚本攻击）csrf（跨站请求伪造）" class="headerlink" title="xss（跨域脚本攻击）csrf（跨站请求伪造）"></a>xss（跨域脚本攻击）csrf（跨站请求伪造）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">csrf: 需要用户先登陆网站A，获取cookie，利用的是网站A本身的漏洞，去请求网站A的api，---进行token验证，referer验证，只接收本站的请求</span><br><span class="line"></span><br><span class="line">xss：向网站A注入js代码，然后执行js代码，篡改网站A的内容，破坏页面正常结构，插入恶意广告。---编码转换</span><br></pre></td></tr></table></figure><h2 id="http1-0、http1-1和http2-0的区别"><a href="#http1-0、http1-1和http2-0的区别" class="headerlink" title="http1.0、http1.1和http2.0的区别"></a>http1.0、http1.1和http2.0的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http/1.0 每个请求都要建立一个连接</span><br><span class="line">http/1.1 多了长连接keep-alive，若干个请求需要排队串行化单线程处理，会发生网络请求阻塞问题。</span><br><span class="line">http/2.0 同一个连接可以有多个请求，各个请求直接互不影响（进行了头部压缩和多路复用的优化）</span><br></pre></td></tr></table></figure><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单例模式 （class组件中new store创建store实例）</span><br><span class="line">工厂模式 （mobx store中creatLayoutStore）</span><br><span class="line">观察者模式 </span><br><span class="line">发布订阅模式</span><br><span class="line">装饰器模式 （移动、pc配置同步@sync）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* TCP是面向连接的协议，发送数据前先要建立连接，TCP提供可靠的服务，通过TCP建立连接传输的数据不会丢失，没有重复，并且按照顺序到达。</span><br><span class="line">* UDP是无连接的协议，发送数据前不需要建立连接，是不可靠的</span><br><span class="line">* TCP只支持点对点通信，而UDP支持一对一，多对多</span><br><span class="line">* TCP是面向字节流的，UDP是面向报文的</span><br><span class="line">* TCP通信类似打电话，接通后需要确认身份，才可以开始通信</span><br><span class="line">* UDP类似广播直接进行通信</span><br></pre></td></tr></table></figure><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">应用层（应用层就是向用户提供通信服务的活动，提供用户程序接口HTTP、DNS）</span><br><span class="line">传输层（传输层为两台主机上的应用程序提供端到端的通信TCP，UDP）</span><br><span class="line">网络层（网络层实现数据包的选路和转发）</span><br><span class="line">数据链路层（ARP地址解析协议、RARP逆地址解析协议，使用物理地址寻找一台机器）</span><br></pre></td></tr></table></figure><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正向代理是客户端代理，服务端不知道是哪个客户端发起的请求</span><br><span class="line">反向代理是服务端代理，客户端不知道是哪个服务端提供的资源</span><br></pre></td></tr></table></figure><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应用层</span><br><span class="line">表示层</span><br><span class="line">会话层</span><br><span class="line"></span><br><span class="line">传输层</span><br><span class="line"></span><br><span class="line">网络层</span><br><span class="line"></span><br><span class="line">数据链路层</span><br><span class="line">物理层</span><br></pre></td></tr></table></figure><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>为什么需要三次握手？<br>两次握手第二次结束后，服务端并不能保证客户端已经接收到了第二次的应答信息，如此一来服务器会一直保持通信过程，因为TCP通信会占用端口，造成资源浪费。</p><p>防止已失效的连接请求报文段突然又传送到服务端，产生错误。<br>如上述情况，如果client没有再次向server发出确认，server收不到确认就不会建立连接，可以避免server端一直等待浪费资源。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul><li><a href="https://blog.csdn.net/rememberyf/article/details/80309148">https://blog.csdn.net/rememberyf/article/details/80309148</a></li></ul><h2 id="301和302的区别"><a href="#301和302的区别" class="headerlink" title="301和302的区别"></a>301和302的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">301 表示资源被永久移除，浏览器在拿到状态码后跳转到一个新的URL地址，可从相应头的location首部中获取，搜索引擎在抓取新内容的同时也将就地址交换为重定向之后的网址。</span><br><span class="line"></span><br><span class="line">302 表示地址资源还在，仍可以访问，搜索引擎会抓取新的内容而保存旧的地址，seo 302 优于301.</span><br><span class="line"></span><br><span class="line">重定向的原因：</span><br><span class="line">网站调整（改变网页目录结构）</span><br><span class="line">页面被移到一个新地址</span><br><span class="line">页面扩展名改变 .php -&gt;.html</span><br><span class="line">如果不做重定向会返回404页面，会白白流失用户访问量。</span><br><span class="line"></span><br><span class="line">1XX 信息性状态码，表示接受的请求正在处理</span><br><span class="line">2XX 成功状态码，表示请求被正常处理完毕</span><br><span class="line">3XX 重定向状态码，表示需要进行附加操作以完成请求</span><br><span class="line">4XX 客户端错误状态码，表示服务器无法处理请求</span><br><span class="line">    400 Bad Request请求出现语法错误</span><br><span class="line">    401 被请求的页面需要用户名和密码</span><br><span class="line">    403 forbidden 请求页面的访问被禁止</span><br><span class="line">    404 资源未找到</span><br><span class="line">5XX 服务器错误状态码，表示服务器处理请求出错</span><br><span class="line">    502 网关错误</span><br><span class="line">    503 服务器超负载或者停机维护，无法处理请求</span><br><span class="line">    504 网关超时</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li>cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据cookie追踪用户在不同页面的访问信息。</li><li>cookie特点<ul><li>1.大小限制，cookie大小限制在4KB以内</li><li>2.宽带限制，cookie数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。</li><li>3.安全风险，cookie会频繁的在网络中传送，不加密的情况下是有安全风险的。</li><li>4.操作复杂<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name: string, value: string) &#123;</span><br><span class="line">    const exp = new Date();    </span><br><span class="line">    //过期时间设置为一天</span><br><span class="line">    exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000);</span><br><span class="line">    document.cookie = `$&#123;name&#125;=$&#123;escape(value);expires=$&#123;exp.toString()&#125;&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="localStorage会话存储-和-sessionStorage本地存储"><a href="#localStorage会话存储-和-sessionStorage本地存储" class="headerlink" title="localStorage会话存储 和 sessionStorage本地存储"></a>localStorage会话存储 和 sessionStorage本地存储</h2><ul><li>1.存储容量大</li><li>2.零宽带，仅存储在本地，不会和服务器发生任何交互行为，不存在网络宽带占用问题。</li><li>3.编程接口，提供一套丰富的接口，操作数据更加方便。</li><li>4.独立的存储空间，不会造成数据的混乱。</li></ul><ul><li><p>主要区别在于数据存储的 <code>时间范围</code>和<code>页面范围</code></p><ul><li>sessionStorage: 数据只存储到窗口或标签关闭时，只在当前窗口的当前标签内可见,5M左右，不同浏览器不同大小。</li><li>localStorage: 数据会一直存在除非手动清除，数据可被同源(协议、域名、端口号一致)的每个窗口或标签共享,5M左右，不同浏览器不同大小。</li></ul></li><li><p>监测是否支持web Storage</p><ul><li>1.通过window.sessionStorage,window.localStorage判断浏览器是否支持</li><li>2.通过try{}catch{} 执行一下storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。</li></ul></li></ul><h2 id="html5的几种存储形式"><a href="#html5的几种存储形式" class="headerlink" title="html5的几种存储形式"></a>html5的几种存储形式</h2><ul><li>1.本地存储 localStorage,sessionStorage</li><li>2.离线缓存 application cache</li><li><ol start="3"><li>indexedDb,webSQL</li></ol></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.负载均衡、CDN加速、设置缓存、</span><br><span class="line">2.业务逻辑优化</span><br><span class="line">3.代码程序优化（组件按需加载、图片懒加载，代码压缩）</span><br><span class="line">4.避免重绘回流</span><br><span class="line">重绘：页面元素的样式改变不会影响它在文档流中的位置时发生重绘</span><br><span class="line">回流：DOM尺寸大小结构发生变化时</span><br><span class="line">回流一定会导致重绘</span><br><span class="line">如何避免：</span><br><span class="line">1.避免频繁操作dom，通过创建document.createDocumentFragment()一次性插入需要操作的dom</span><br><span class="line">2.具有复杂动画的Dom元素使用绝对定位，使其脱离文档流</span><br><span class="line">3.合并对于Dom中style样式的操作</span><br><span class="line">4.避免使用css表达式 calc()</span><br></pre></td></tr></table></figure><h2 id="fetch和axios"><a href="#fetch和axios" class="headerlink" title="fetch和axios"></a>fetch和axios</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch取消发送</span><br><span class="line">1.创建一个AbortController实例</span><br><span class="line">2.该实例具有signal属性</span><br><span class="line">3.将signal传递给fetch option</span><br><span class="line">4.调用AbortController的abort属性来取消所有使用该信号的fetch</span><br><span class="line"></span><br><span class="line">axios取消发送</span><br><span class="line">1.const cancelToken = axios.CancelToken</span><br><span class="line">2.const source = CancelToken.source()</span><br><span class="line">3.axios.get(&#x27;/xxx&#x27;,&#123;cancelToken: source.token&#125;)</span><br></pre></td></tr></table></figure><h2 id="flex常用属性，grid布局"><a href="#flex常用属性，grid布局" class="headerlink" title="flex常用属性，grid布局"></a>flex常用属性，grid布局</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flex属性：</span><br><span class="line">1.flex-direction属性，决定主轴方向</span><br><span class="line">2.flex-wrap属性，控制换行</span><br><span class="line">3.flex-flow属性，flex-direction和flex-wrap的简写形式，默认值flex-flow: row  nowrap;</span><br><span class="line">4.justify-content属性，项目主轴上的对齐方式</span><br><span class="line">5.align-item属性，项目在交叉轴上的对齐方式</span><br><span class="line">6.align-content属性，多个轴线的时候在元素在交叉轴的对齐方式，只有一根轴线时不起作用</span><br><span class="line">flex（子元素的属性）：</span><br><span class="line">1.order属性,定义项目的排列顺序，数值越小，排列越靠前，默认为0.</span><br><span class="line">2.align-self属性，允许单个项目与其他项目不一样的对齐方式，会覆盖align-items属性.</span><br><span class="line">3.flex属性，flex-grow、flex-shrink、flex-basis简写，默认为0 1 auto</span><br><span class="line">    auto(1 1 auto)       none(0 0 auto)</span><br><span class="line">4.flex-grow属性，定义项目的放大比例，默认为0，即如果存在剩余空间也不放大，1等分，一个项目为2，其他为1，则前者占据空间是其他的两倍。</span><br><span class="line">5.flex-shrink属性，定义项目的缩小比例，默认为1，空间不足则缩小，如果所有项目都为1，则等比例缩小，如果有的项目为0，则空间不足时为0的不缩小，负值无效</span><br><span class="line">6.flex-basis属性，项目占据的固定空间</span><br></pre></td></tr></table></figure><h2 id="padding-bottom实现子元素高度等于父元素宽度问题"><a href="#padding-bottom实现子元素高度等于父元素宽度问题" class="headerlink" title="padding-bottom实现子元素高度等于父元素宽度问题"></a>padding-bottom实现子元素高度等于父元素宽度问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当margin或者padding取值是百分比的时候，无论是left，right或者top，bottom，都是以父元素的width为参考物，进行提前占位</span><br></pre></td></tr></table></figure><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在作用域的创建阶段（预编译阶段），会生成js的变量对象（VO对象）供js引擎去访问。</span><br><span class="line">1.创建ao对象</span><br><span class="line">2.找形参和变量声明，作为ao对象的属性名，值为undefined</span><br><span class="line">3.实参和形参相统一</span><br><span class="line">4.找函数声明，如果名字和变量相同则覆盖变量声明</span><br><span class="line">5.解释执行</span><br></pre></td></tr></table></figure><h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.箭头函数中的this是在定义函数的时候绑定的（继承自父执行上下文中的this），而不是执行函数时绑定。</span><br><span class="line">2.箭头函数没有this，所以不能用作构造函数。</span><br></pre></td></tr></table></figure><h2 id="Map和Set两种新的数据结构的区别？"><a href="#Map和Set两种新的数据结构的区别？" class="headerlink" title="Map和Set两种新的数据结构的区别？"></a>Map和Set两种新的数据结构的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Map类似Object是一种键值对集合，区别在于Map的键不仅限于字符串，其他各种类型的值都可以作为Map的键</span><br><span class="line"></span><br><span class="line">2.Set是类似数组的一种数据结构，不点在于Set中没有重复的值</span><br></pre></td></tr></table></figure><h2 id="你对闭包了解多少？"><a href="#你对闭包了解多少？" class="headerlink" title="你对闭包了解多少？"></a>你对闭包了解多少？</h2><pre><code>解释一下作用域链是如何产生的解释一下js执行山下文的创建、执行过程解释一下闭包所产生的变量放在哪里</code></pre><ul><li>闭包的定义：闭包就是能够读取其他函数内部变量的函数。</li><li>闭包的底层实现原理</li><li>js执行上下文：</li><li><img src="https://img-blog.csdnimg.cn/20190527213618675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTg4NDIx,size_16,color_FFFFFF,t_70" alt="image"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">js运行三部曲</span><br><span class="line">1.语法分析</span><br><span class="line">2.预编译</span><br><span class="line">3.解释执行</span><br><span class="line"></span><br><span class="line">js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。</span><br><span class="line">预编译的环境需要个环境，这个环境就是执行上下文。</span><br><span class="line"></span><br><span class="line">js执行上下文分为三种：</span><br><span class="line">1.全局执行上下文：代码开始执行时首先进入的环境</span><br><span class="line">2.函数执行上下文：函数调用时，会开始执行函数中的代码</span><br><span class="line">3.eval执行上下文：不建议使用</span><br><span class="line"></span><br><span class="line">执行上下文的周期，分为两个阶段</span><br><span class="line">1.创建阶段</span><br><span class="line">    创建词法环境</span><br><span class="line">    生成变量对象VO，建立作用域链</span><br><span class="line">    确认this指向，并绑定this</span><br><span class="line">2.执行阶段</span><br><span class="line">    进行变量赋值，函数引用以及执行代码</span><br><span class="line">    </span><br><span class="line">预编译发生在函数执行前，预编译四部曲：</span><br><span class="line">1.创建AO对象</span><br><span class="line">2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined</span><br><span class="line">3.将形参和实参相统一</span><br><span class="line">4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）</span><br><span class="line">5.最后程序输出变量值的时候，就是从AO对象中拿</span><br><span class="line">（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，</span><br><span class="line">就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包）</span><br></pre></td></tr></table></figure></li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student.__proto__ === Student.prototype</span><br><span class="line">1.每个函数function都由一个prototype，即显式原型。是在定义函数的时候自动添加的，默认是一个空的Object对象</span><br><span class="line">2.每个引用类型都有一个__proto__,即隐式原型。是创建对象时自动添加的，默认值为构造函数的prototype属性值</span><br><span class="line">实例对象的隐式原型 等于 对应构造函数或类的显式原型</span><br><span class="line">能直接操作显式原型，不能直接操作隐式原型</span><br></pre></td></tr></table></figure><h2 id="js的new操作符都做了些什么？"><a href="#js的new操作符都做了些什么？" class="headerlink" title="js的new操作符都做了些什么？"></a>js的new操作符都做了些什么？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个空的js对象&#123;&#125;</span><br><span class="line">2. 将空对象的隐式原型__proto__指向构造函数的原型</span><br><span class="line">3. 将空对象作为构造函数的上下文（改变this指向）</span><br><span class="line">4. 对构造函数返回值做判断</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line">function create(fn, ...args) &#123;</span><br><span class="line">    let obj = Object.create(&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">    // obj.__proto__ = fn.prototype;</span><br><span class="line">    Object.setPrototypeOf(obj, fn.prototype);</span><br><span class="line">    </span><br><span class="line">    let result = fn.apply(obj, args);</span><br><span class="line">    </span><br><span class="line">    return result instanceof Object ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">在new的时候，会对构造函数的返回值做一些判断</span><br><span class="line">1. 如果返回值是基础类型数据，则忽略返回值</span><br><span class="line">2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效</span><br></pre></td></tr></table></figure><h2 id="calc-support-media各自的含义及用法？"><a href="#calc-support-media各自的含义及用法？" class="headerlink" title="calc, support, media各自的含义及用法？"></a>calc, support, media各自的含义及用法？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@support 主要用于检测浏览器是否支持css的某个属性，相当于条件语句，支持的话写一套样式，</span><br><span class="line">不支持写另外一套样式，例如</span><br><span class="line">    @supports (display: grid) &#123;</span><br><span class="line">      div &#123;</span><br><span class="line">        display: grid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @supports not (display: grid) &#123;</span><br><span class="line">      div &#123;</span><br><span class="line">        float: right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">calc(): 用于动态计算值，支持 + - * / 运算。</span><br><span class="line"></span><br><span class="line">@media查询：可以针对不同的媒体类型定义不同的样式。</span><br></pre></td></tr></table></figure><h2 id="什么是会话cookie-什么是持久cookie"><a href="#什么是会话cookie-什么是持久cookie" class="headerlink" title="什么是会话cookie,什么是持久cookie?"></a>什么是会话cookie,什么是持久cookie?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie是服务器返回的，指定了expire（有效期）的是持久cookie,没有指定的是会话cookie</span><br></pre></td></tr></table></figure><h2 id="img标签title和alt属性"><a href="#img标签title和alt属性" class="headerlink" title="img标签title和alt属性"></a>img标签title和alt属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alt: 图片加载失败时，显示在网页上的替代文字</span><br><span class="line">title: 鼠标放在图片上的提示文字</span><br><span class="line"></span><br><span class="line">alt是必须属性，可以为空；title为非必须</span><br></pre></td></tr></table></figure><h2 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.let和const</span><br><span class="line">2.模版字符串</span><br><span class="line">3.箭头函数</span><br><span class="line">4.函数可以设置默认参数值</span><br><span class="line">5.扩展运算符</span><br><span class="line">6.对象和数组的解构</span><br><span class="line">7.class</span><br></pre></td></tr></table></figure><h2 id="图片懒加载原理"><a href="#图片懒加载原理" class="headerlink" title="图片懒加载原理"></a>图片懒加载原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器是否发起请求是根据&lt;img /&gt;标签的src属性</span><br><span class="line">2. 所以懒加载的关键是：在图片没有进入可视区域时，</span><br><span class="line">先不给&lt;img /&gt;的src属性赋值，等到图片进入可是区域再给src赋值。</span><br><span class="line"></span><br><span class="line">当图片底边距离页面的偏移（图片高度+图片距离顶部偏移高度）</span><br><span class="line">小于等于</span><br><span class="line">浏览器底边距离页面顶部高度（浏览器一屏高度 + 滚动区域）</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="H5新增了哪些标签？"><a href="#H5新增了哪些标签？" class="headerlink" title="H5新增了哪些标签？"></a>H5新增了哪些标签？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article、aside、audio、video、footer、header、nav、section</span><br></pre></td></tr></table></figure><h2 id="SVG和Canvas的区别？"><a href="#SVG和Canvas的区别？" class="headerlink" title="SVG和Canvas的区别？"></a>SVG和Canvas的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.svg:表示以XML格式定义图像的可伸缩矢量图形。</span><br><span class="line">2.canvas：通过js来绘制2D图形</span><br><span class="line"></span><br><span class="line">svg通过标签fill属性可以调整颜色</span><br></pre></td></tr></table></figure><h2 id="AMD-和-CMD的区别"><a href="#AMD-和-CMD的区别" class="headerlink" title="AMD 和 CMD的区别"></a>AMD 和 CMD的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">共同点：</span><br><span class="line">1.两者都是框架在推广过程中对模块定义的规范产出</span><br><span class="line">2.都是异步加载模块</span><br><span class="line">不同点：</span><br><span class="line">1.AMD是RequireJs在推广过程中对模块定义的规范产出，CMD是SeaJs在推广过程中对模块定义的规范化产出</span><br><span class="line">2.AMD推崇依赖前置，CMD推崇依赖就近</span><br><span class="line">3.AMD的应用体验好，因为模块提前执行了，CMD性能好，因为只有用户需要的时候才执行</span><br></pre></td></tr></table></figure><h2 id="如何实现js倒计时的纠偏？"><a href="#如何实现js倒计时的纠偏？" class="headerlink" title="如何实现js倒计时的纠偏？"></a>如何实现js倒计时的纠偏？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 第一种通过前端定时向服务端发送请求获取最新的时间差，以此来校准倒计时时间。</span><br><span class="line">2. 通过前端根据偏差时间来自动调整下次间隔的时间来实现，首先以setTimeout递归的方式来实现倒计时，</span><br><span class="line">通过一个变量记录倒计时的秒数，根据秒数和间隔时间计算出此时无偏差时应该显示的时间，</span><br><span class="line">然后拿当前真实时间与这个时间相减，就可以得到时间的偏差大小，因此在设置下一个定时器的时候，</span><br><span class="line">间隔时间减去这个偏差大小就可以纠正时间误差。</span><br></pre></td></tr></table></figure><h2 id="js的执行机制"><a href="#js的执行机制" class="headerlink" title="js的执行机制"></a>js的执行机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">js是单线程的，处理js任务只能一个一个顺序执行，js中把任务分为了同步任务和异步任务，</span><br><span class="line">同步任务进入主线程先执行，异步任务进入Event Table并注册函数，指定事情完成后，Event Table就会将函数移入到事件队列Event Queque中，等待主线程任务执行完毕，</span><br><span class="line">就会从事件队列中取出对应事件进入主线程执行。</span><br><span class="line"></span><br><span class="line">macro-task（宏任务）：包括整体代码script、setTimeout、setInterval</span><br><span class="line">micro-task（微任务）：Promise.then、process.nextTick</span><br><span class="line">微任务先于宏任务先执行（除了script）执行过程不同任务进入不同的event quue</span><br><span class="line"></span><br><span class="line">js先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，</span><br><span class="line">遇到宏任务放到宏任务事件队列中。</span><br><span class="line"></span><br><span class="line">然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，</span><br><span class="line">等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，</span><br><span class="line">执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，</span><br><span class="line">就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，</span><br><span class="line">以此类推。</span><br></pre></td></tr></table></figure><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="请说一下你对React的理解？"><a href="#请说一下你对React的理解？" class="headerlink" title="请说一下你对React的理解？"></a>请说一下你对React的理解？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. react是一个网页的UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</span><br><span class="line">2. react的核心设计思路有三个：</span><br><span class="line">声明式</span><br><span class="line">    命令式：命令程序一步一步的执行操作</span><br><span class="line">    声明式：只需告诉程序我们想要的结果，其他的交给程序去做。</span><br><span class="line">组件化</span><br><span class="line">    将视图拆分和模块复用，做到高内聚低耦合</span><br><span class="line"></span><br><span class="line">通用性</span><br><span class="line">    一次学习，随处编写。RN，react360等，跨平台底层靠虚拟DOM实现</span><br><span class="line">    </span><br><span class="line">3. 缺点</span><br><span class="line">1.没有官方系统解决方案，在开发大型应用时需要向社区寻找并整合解决方案。</span><br><span class="line">2.过于灵活，需要注意代码规范</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="React-lazy懒加载"><a href="#React-lazy懒加载" class="headerlink" title="React.lazy懒加载"></a>React.lazy懒加载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// React.lazy方法可以异步加载组件</span><br><span class="line">const Foo = React.lazy(() =&gt; import(&#x27;../components/Foo&#x27;)</span><br><span class="line"></span><br><span class="line">// React.lazy不能单独使用，需要配合React.suspense,用来包裹异步组件，添加loading效果等。</span><br><span class="line">&lt;React.Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">    &lt;Foo /&gt;</span><br><span class="line">&lt;/React.Suspense&gt;</span><br><span class="line"></span><br><span class="line">React.lazy原理</span><br><span class="line">React.lazy使用import来懒加载组件，import在webpack中最终会调用requireEnsure方法，动态插入script来请求js文件，类似jsonp的形式。</span><br></pre></td></tr></table></figure><h2 id="类组件和函数组件之间的区别？"><a href="#类组件和函数组件之间的区别？" class="headerlink" title="类组件和函数组件之间的区别？"></a>类组件和函数组件之间的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">接受属性返回React元素</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line">    1.编程思想不同：类组件需要创建实例，基于面向对象的方式编程。函数式组件接受输入返回输出，属于函数式编程的思想。</span><br><span class="line">    2.内存占用：类组件需要创建实例，会占用内存，函数组件不需要创建实例，可以节约内存</span><br><span class="line">    3.捕获特性：函数组件具有捕获特性</span><br><span class="line">    4.可测试性：函数组件更方便编写单元测试</span><br><span class="line">    5.状态：类组件有实例可以维护自己的状态，函数组件可以使用useState维护自己的状态</span><br><span class="line">    6.声明周期：类组件有生命周期，可以在生命周期内写逻辑，函数组件可以在useEffect中</span><br><span class="line">    7.逻辑复用：函数组件通过继承实现逻辑复用，函数组件可以通过自定义hooks实现逻辑复用</span><br><span class="line">    8.性能优化：类组件通过shouldComponentUpdate和PureComponent来跳过更新，函数组件通过React.memo</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="当调用setState的时候，发生了什么事？"><a href="#当调用setState的时候，发生了什么事？" class="headerlink" title="当调用setState的时候，发生了什么事？"></a>当调用setState的时候，发生了什么事？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将传递给setState的参数对象合并到组件的当前的状态，react遍历dom节点，计算差异，更新UI。</span><br><span class="line">https://segmentfault.com/a/1190000018250127</span><br></pre></td></tr></table></figure><h2 id="为什么setState的参数是一个callback而不是一个对象"><a href="#为什么setState的参数是一个callback而不是一个对象" class="headerlink" title="为什么setState的参数是一个callback而不是一个对象"></a>为什么setState的参数是一个callback而不是一个对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因为this.props和this.state的更新可能是异步的，不能依赖它们的值去计算下一个state</span><br><span class="line">(更新状态不要直接修改this.state，虽然状态可以改变，但不会触发组件的更新)</span><br><span class="line"></span><br><span class="line">setState何时同步何时异步？</span><br><span class="line">异步：由React控制的事件处理程序以及生命周期函数中调用setState为异步</span><br><span class="line">同步：React控制之外的原生js绑定的事件、setTimeout/setInterval等。</span><br></pre></td></tr></table></figure><h2 id="setState-什么时候同步什么时候异步？"><a href="#setState-什么时候同步什么时候异步？" class="headerlink" title="setState 什么时候同步什么时候异步？"></a>setState 什么时候同步什么时候异步？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">react三个模式：</span><br><span class="line">1.legacy模式： 通过ReactDOM.render(&lt;App /&gt;, rootNode)创建的，当前react的使用方式</span><br><span class="line">2.blocking模式：通过ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;),实验阶段，作为迁移到concurrent模式的第一个步骤</span><br><span class="line">3.concurrent模式，通过ReactDOM.createRoot(rootNode).render(&lt;App /&gt;),实验阶段，未来react的默认开发模式</span><br><span class="line"></span><br><span class="line">setState 只在合成事件（react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件）和钩子函数（生命周期中）是异步的，在原生事件和setTimeout中都是同步的。</span><br><span class="line"></span><br><span class="line">不同模式执行结果不同，legacy模式命中batchedUpadates（批处理）时异步，为命中时同步</span><br><span class="line">concurrent模式都是异步的</span><br><span class="line"></span><br><span class="line">setState异步并不是说内部由异步代码实现，其本身执行过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了“异步”</span><br><span class="line"></span><br><span class="line">可以通过第二个参数的callback回调函数中拿到最新的值，在异步中如果对同一个值进行多次setState，那么setState的批量更新策略会将其覆盖，去最后一次的执行，如果同时setState多个值，会在更新时对其进行合并批量更新。</span><br></pre></td></tr></table></figure><h2 id="react渲染机制"><a href="#react渲染机制" class="headerlink" title="react渲染机制"></a>react渲染机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">首先打开页面会渲染出一颗DOM树，更新数据会生成一颗虚拟DOM树，通过diff算法，</span><br><span class="line">比较两颗DOM树的差异，找到更新的地方进行批量改动。</span><br><span class="line"></span><br><span class="line">diff：计算一棵树形结构到另一颗树形结构的最少操作。</span><br><span class="line"></span><br><span class="line">1.把树形结构按照层级分解，只比较同级元素</span><br><span class="line">2.给列表结构的每个单元添加唯一的 key 属性，方便比较</span><br><span class="line">3.diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。（官方也不推荐）</span><br></pre></td></tr></table></figure><h2 id="React-StrictMode-目前有助于："><a href="#React-StrictMode-目前有助于：" class="headerlink" title="React.StrictMode 目前有助于："></a>React.StrictMode 目前有助于：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">识别不安全的生命周期</span><br><span class="line">关于使用过时字符串 ref API 的警告</span><br><span class="line">关于使用废弃的 findDOMNode 方法的警告</span><br><span class="line">检测意外的副作用</span><br><span class="line">检测过时的 context API</span><br></pre></td></tr></table></figure><h2 id="虚拟DOM优点"><a href="#虚拟DOM优点" class="headerlink" title="虚拟DOM优点"></a>虚拟DOM优点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 减少不必要的DOM操作</span><br><span class="line">    1.1虚拟dom可以将多次操作合并为一次操作，比如添加100个节点，确是一个一个操作的</span><br><span class="line">    1.2虚拟dom借助dom diff可以将多余的操作省略掉，比如添加100个节点，其中10个是新增的</span><br><span class="line">    </span><br><span class="line">2. 跨平台渲染</span><br><span class="line">    1.因为虚拟dom本质上是一个js对象</span><br><span class="line">    </span><br><span class="line">react虚拟dom结构:</span><br><span class="line"></span><br><span class="line">const vNode = &#123;</span><br><span class="line">    key: null,</span><br><span class="line">    props:&#123;</span><br><span class="line">        children: [</span><br><span class="line">            &#123;type: &#x27;span&#x27;, ....&#125;,</span><br><span class="line">        ],</span><br><span class="line">        className: &#x27;red&#x27;,</span><br><span class="line">        onClick: () =&gt; &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ref: null,</span><br><span class="line">    type: &#x27;div&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建虚拟dom：React.createElement</span><br></pre></td></tr></table></figure><h2 id="diff-策略"><a href="#diff-策略" class="headerlink" title="diff 策略"></a>diff 策略</h2><p>`<br>策略一： tree diff<br>1.React对树进行分层比较，两颗虚拟DOM树只会对同一层级的DOM节点进行比较。<br>如果存在跨层级的操作，只会进行创建和删除<br>2.如果节点是组件就进行Component diff<br>3.如果节点是标签就进行Element diff</p><p>策略二：component diff<br>如果为非同类型组件的话标记组件为dirty component，替换组件下所有子节点，<br>类型相同更新属性，然后深入组件进行Tree diff（递归遍历对比）</p><p>策略三：element diff<br>如果节点是原生标签，则看标签名<br>标签名不同直接替换，相同更新属性，然后进入标签进行Tree diff（递归遍历对比）<br>`</p><h2 id="shouldComponentUpdate-nextProps-nextState-是做什么的，（react性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-nextProps-nextState-是做什么的，（react性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)是做什么的，（react性能优化是哪个周期函数？）"></a>shouldComponentUpdate(nextProps, nextState)是做什么的，（react性能优化是哪个周期函数？）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新绘制dom,</span><br><span class="line">由于渲染dom非常消耗性能，合理的调用shouldComponentUpdate方法可以极大的提高性能。</span><br></pre></td></tr></table></figure><h2 id="createElement-和-cloneElement有什么区别？"><a href="#createElement-和-cloneElement有什么区别？" class="headerlink" title="createElement 和 cloneElement有什么区别？"></a>createElement 和 cloneElement有什么区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">React.createElement()构建React元素。</span><br><span class="line">接受三个参数，第一个参数为标签名，如div、span等，或者react组件，第二个参数为传入的属性，第三个为组件的子组件。</span><br><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">React.cloneElement(),第一个参数传入react元素不是标签名，第二个参数传入属性，新添加的属性会并入原有的属性，第三个参数为子组件</span><br><span class="line">React.cloneElement(</span><br><span class="line">    element,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="虚拟DOM的优缺点？"><a href="#虚拟DOM的优缺点？" class="headerlink" title="虚拟DOM的优缺点？"></a>虚拟DOM的优缺点？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">1. 处理了浏览器兼容性问题，避免了用户操作真实DOM</span><br><span class="line">2.内容经过xss处理，可以防范xss攻击</span><br><span class="line">3.跨平台开发</span><br><span class="line">4.更新的时候可以实现差异化更新，减少更新DOM的操作</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1.虚拟DOM需要消耗额外的内存</span><br><span class="line">2.首次渲染不一定会更快</span><br></pre></td></tr></table></figure><h2 id="React中创建组件的方式"><a href="#React中创建组件的方式" class="headerlink" title="React中创建组件的方式"></a>React中创建组件的方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createClass()、ES6 class组件 无无状态函数式组件</span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="react中key的作用"><a href="#react中key的作用" class="headerlink" title="react中key的作用"></a>react中key的作用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key在react中用于追踪哪些列表中元素被修改、添加或者移除的辅助标识。</span><br><span class="line"></span><br><span class="line">在开发中，需要保证某个元素的key在同级元素中具有唯一性。</span><br><span class="line"></span><br><span class="line">diff算法会借助元素的key值来判断元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染</span><br></pre></td></tr></table></figure><h2 id="react优势"><a href="#react优势" class="headerlink" title="react优势"></a>react优势</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 速度快：不直接操作dom，采用虚拟dom的概念</span><br><span class="line">2.跨浏览器兼容，兼容性好</span><br><span class="line">3.一切都是component，代码更加模块化，可维护性高</span><br><span class="line">4.单向数据流，采用Flux单向数据层架构</span><br></pre></td></tr></table></figure><h2 id="react事件机制"><a href="#react事件机制" class="headerlink" title="react事件机制"></a>react事件机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">react的事件机制利用了事件委托机制，事件并没有真正的绑定在真实的dom节点上，</span><br><span class="line">而是把事件绑定在结构的最外层document，使用统一的事件监听器，所有事件都由这个监听器统一分发。</span><br><span class="line"></span><br><span class="line">组件挂载和更新时，会将绑定的事件分门别类的放进一个叫EvnentPluginHub的事件池中。</span><br><span class="line"></span><br><span class="line">事件触发时，根据事件产生的Event对象找到触发事件的组件，再通过组件标识和事件类型</span><br><span class="line">从事件池中找到对应的事件监听回调，然后执行相关的监听函数。</span><br></pre></td></tr></table></figure><h2 id="异步回调中怎么使用syntheticEvent？"><a href="#异步回调中怎么使用syntheticEvent？" class="headerlink" title="异步回调中怎么使用syntheticEvent？"></a>异步回调中怎么使用syntheticEvent？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在合成事件机制里，一旦事件监听回调执行，合成事件对象就会被销毁，异步回调执行的时候</span><br><span class="line">合成事件对象早就被销毁了。</span><br><span class="line">解决方法：执行event.persist(),通知react不需要回收。</span><br></pre></td></tr></table></figure><h2 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">React 16推出Fiber之后，如果要开启async rendering，那么在render函数之前的所有函数都有可能被执行多次</span><br><span class="line"></span><br><span class="line">废弃：</span><br><span class="line">componentWillMount</span><br><span class="line">componentWillReceiveProps(nextProps)</span><br><span class="line">componentWillUpdate(nextProps, nextState)</span><br><span class="line">代替：</span><br><span class="line">静态函数：static getDerivedStateFromProps(nextProps, prevState)</span><br><span class="line"></span><br><span class="line">静态函数：static getDerivedStateFromError(error) // 渲染备用UI</span><br><span class="line">此生命周期return的值会自动调用setState，将值和state合并</span><br><span class="line">运行事件节点：子组件被渲染发生错误后且在页面更新前</span><br><span class="line"></span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) 此生命周期的返回值将作为参数传递给componentDidUpdate()</span><br><span class="line"></span><br><span class="line">componentDidCatch(error, info) // 打印错误信息</span><br><span class="line"></span><br><span class="line">错误边界无法捕获的错误：</span><br><span class="line">1.组件自身的错误</span><br><span class="line">2.异步错误，setTimeout</span><br><span class="line">3.事件中的错误，比如click事件中发生错误</span><br></pre></td></tr></table></figure><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 构建action，通过创建一个函数，返回一个对象，需要携带type属性</span><br><span class="line"></span><br><span class="line">2. 构建reducer，用来响应action，然后通过return把数据传回store</span><br><span class="line"></span><br><span class="line">3. 利用createStore来构建store，把reducer作为参数传入</span><br><span class="line"></span><br><span class="line">4. 利用store.subscribe()注册监听</span><br><span class="line"></span><br><span class="line">5. 利用store.dispatch()发送action</span><br><span class="line"></span><br><span class="line">6. 利用store.getState()拿到值</span><br></pre></td></tr></table></figure><h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><h2 id="ts中type和interface的区别"><a href="#ts中type和interface的区别" class="headerlink" title="ts中type和interface的区别"></a>ts中type和interface的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">1.都可以描述一个对象和函数</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface SetUser &#123;</span><br><span class="line">    (name: string): void;</span><br><span class="line">&#125;</span><br><span class="line">type User = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">type SetUser = (name: string): void;</span><br><span class="line"></span><br><span class="line">2.扩展与交叉类型</span><br><span class="line">interface可以extends进行类型扩展，type可以通过交叉类型实现interface的extend行为。</span><br><span class="line">interface可以exteds  type，type也可以与interface类型交叉（&amp;符号）</span><br><span class="line">不同点：</span><br><span class="line">1.type可以声明基本类型别名，联合类型，元祖等类型</span><br><span class="line">基本类型别名</span><br><span class="line">type Name = string;</span><br><span class="line">联合类型</span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wang();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line">type Pet = Dog | Cat;</span><br><span class="line">元祖类型</span><br><span class="line">type PetList = [Dog, Cat];</span><br><span class="line"></span><br><span class="line">2. interface能够声明合并</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface User &#123;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">=</span><br><span class="line">/**</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="ts中如何实现一个函数的重载"><a href="#ts中如何实现一个函数的重载" class="headerlink" title="ts中如何实现一个函数的重载"></a>ts中如何实现一个函数的重载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js是动态类型语言，所以是没有overload的，但js可以在运行的时候判断类型</span><br><span class="line">ts的重载只是重载函数声明，函数的实现还是只有一个</span><br></pre></td></tr></table></figure><h2 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable //被观察者</span><br><span class="line">Observer // 观察者</span><br><span class="line">Reaction //响应</span><br><span class="line"></span><br><span class="line">mobx底层对数据的观察是使用Object.defineProperty(mobx4)或Proxy(mobx5)</span><br><span class="line">observer这个装饰器，对react组件的render方法进行跟踪，将render方法加入到各个observable的依赖中，当observale发生变化的时候，就会调用forceUpdate更新组件</span><br><span class="line">（mobx4将Array用类数组对象来模拟的，通过包装类封装为一个对象）</span><br></pre></td></tr></table></figure><h2 id="webpack常用loader"><a href="#webpack常用loader" class="headerlink" title="webpack常用loader"></a>webpack常用loader</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">样式：style-loader、css-loader、less-loader、sass-loader</span><br><span class="line">文件：file-loader、url-loader</span><br><span class="line">编译：babel-loader、ts-loader</span><br><span class="line">校验：eslint-loader</span><br><span class="line"></span><br><span class="line">常用的plugin</span><br><span class="line">html-webpack-plugin</span><br><span class="line">webpack-bundle-analyzer 打包分析</span><br><span class="line">HotModuleReplacementPlugin 热更新</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自己写webpack插件：</span><br><span class="line">主要就是通过访问compliler和compilation拦截webpack的执行</span><br></pre></td></tr></table></figure><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">垃圾收集器会定期（周期性）的找出那些不再继续使用的变量，释放其内存，因为开销比较大，所以会按照固定的时间间隔周期性的执行</span><br><span class="line"></span><br><span class="line">最常用的两种方法：标记清除（常用）和引用计数</span><br><span class="line"></span><br><span class="line">标记清除：变量进入作用域，进行标记，离开作用域进行清除回收</span><br><span class="line"></span><br><span class="line">引用计数：就是跟踪记录每个值被引用的次数，引用一次加1，删除减1，引用计数为0时，进行回收，（循环引用可能会导致内存泄漏）</span><br><span class="line"></span><br><span class="line">常见的内存泄漏原因：</span><br><span class="line">全局变量过多引起内存泄漏</span><br><span class="line">闭包</span><br><span class="line">dom事件未清除</span><br><span class="line">循环引用</span><br></pre></td></tr></table></figure><h2 id="谈谈你对webpack的理解？"><a href="#谈谈你对webpack的理解？" class="headerlink" title="谈谈你对webpack的理解？"></a>谈谈你对webpack的理解？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">webpack是一个打包模块化js的工具，在webpack里一切文件皆模块</span><br><span class="line">，通过loader转换，通过plugin注入钩子，最后输出由多个</span><br><span class="line">模块组合成的文件，webpack专注构建模块化。WebPack可</span><br><span class="line">以看做是模块的打包机器：它做的事情是，分析你的项目</span><br><span class="line">结构，找到js模块及其它的一些浏览器不能直接运行的</span><br><span class="line">拓展语言，例如：Scss，TS等，并将其打包为合适的格式</span><br><span class="line">以供浏览器使用。</span><br></pre></td></tr></table></figure><h2 id="说说webpack与grunt、gulp的不同？"><a href="#说说webpack与grunt、gulp的不同？" class="headerlink" title="说说webpack与grunt、gulp的不同？"></a>说说webpack与grunt、gulp的不同？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">三者都是前端构建工具，grunt和gulp在早期比较流行，</span><br><span class="line">现在webpack相对来说比较主，不过一些轻量化的任务</span><br><span class="line">还是会用gulp来处理，比如单独打包CSS文件等。</span><br><span class="line"></span><br><span class="line">grunt和gulp是基于任务和流（Task、Stream）的。</span><br><span class="line">类似jQuery，找到一个（或一类）文件，对其做一</span><br><span class="line">系列链式操作，更新流上的数据，整条链式操作</span><br><span class="line">构成了一个任务，多个任务就构成了web的构建流程。</span><br><span class="line"></span><br><span class="line">webpack是基于入口的。webpack会自动地递归解析</span><br><span class="line">入口所需要加载的所有资源文件，然后用不同的</span><br><span class="line">Loader来处理不同的文件，用Plugin来扩展webpack功能。</span><br><span class="line"></span><br><span class="line">所以，从构建来说，gulp和grunt需要开发者将整个</span><br><span class="line">前端构建过程拆分成多个`Task`，并合理控制所有`Task`的</span><br><span class="line">调用关系；webpack需要开发者找到入口，并需要清楚对</span><br><span class="line">于不同的资源应该使什么Loader做何种解析和加工对</span><br><span class="line">于知识背景来说，gulp更像后端开发者的思路，</span><br><span class="line">需要对于整个流程了如指掌webpack更倾向于前端开发者的思路</span><br></pre></td></tr></table></figure><h2 id="什么是bundle-什么是chunk，什么是module"><a href="#什么是bundle-什么是chunk，什么是module" class="headerlink" title="什么是bundle,什么是chunk，什么是module?"></a>什么是bundle,什么是chunk，什么是module?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bundle：是由webpack打包出来的文件</span><br><span class="line">chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割</span><br><span class="line">module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块</span><br></pre></td></tr></table></figure><h2 id="什么是Loader-什么是Plugin"><a href="#什么是Loader-什么是Plugin" class="headerlink" title="什么是Loader?什么是Plugin?"></a>什么是Loader?什么是Plugin?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Loaders是用来告诉webpack如何转化处理某一类型的文件，</span><br><span class="line">并且引入到打包出的文中</span><br><span class="line">2）Plugin是用来自定义webpack打包过程的方式，</span><br><span class="line">一个插件是含有apply方法的一个，通过这个方法可以参与</span><br><span class="line">到整个webpack打包的各个流程(生命周期)。</span><br></pre></td></tr></table></figure><h2 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file-loader：把文件输出到一个文件夹中，在代码中通过</span><br><span class="line">相对URL去引用输出的文件</span><br><span class="line">url-loader：和file-loader类似，但是能在文件很小的情况下</span><br><span class="line">以base64的方式把文件内容注入到代码中去</span><br><span class="line">source-map-loader：加载额外的Source Map文件，以方便断点调试</span><br><span class="line">image-loader：加载并且压缩图片文件</span><br><span class="line">babel-loader：把ES6转换成ES5</span><br><span class="line">css-loader：加载CSS，支持模块化、压缩、文件导入等特性</span><br><span class="line">style-loader：把CSS代码注入到JavaScript中，通过DOM操作去加载CSS。</span><br><span class="line">eslint-loader：通过ESLint检查JavaScript代码</span><br></pre></td></tr></table></figure><h2 id="有哪些常见的Plugin？他们是解决什么问题的？"><a href="#有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Plugin？他们是解决什么问题的？"></a>有哪些常见的Plugin？他们是解决什么问题的？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define-plugin：定义环境变量</span><br><span class="line">commons-chunk-plugin：提取公共代码</span><br><span class="line">uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</span><br></pre></td></tr></table></figure><h2 id="Loader和Plugin的不同？"><a href="#Loader和Plugin的不同？" class="headerlink" title="Loader和Plugin的不同？"></a>Loader和Plugin的不同？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">不同的作用</span><br><span class="line">Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，</span><br><span class="line">但是webpack原生是只能解析js文件，如果想将其他文件</span><br><span class="line">也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</span><br><span class="line"></span><br><span class="line">Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br><span class="line"></span><br><span class="line">不同的用法</span><br><span class="line">Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么</span><br><span class="line">类型的文件（test），使用什么加载(loader)和使用的参数（options）</span><br><span class="line"></span><br><span class="line">Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</span><br></pre></td></tr></table></figure><h2 id="webpack的构建流程是什么"><a href="#webpack的构建流程是什么" class="headerlink" title="webpack的构建流程是什么?"></a>webpack的构建流程是什么?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</span><br><span class="line">初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</span><br><span class="line">开始编译：用上一步得到的参数初始化Compiler对象，</span><br><span class="line">加载所有配置的插件，执行对象的 run 方法开始执行编译；</span><br><span class="line"></span><br><span class="line">确定入口：根据配置中的 entry 找出所有的入口文件；</span><br><span class="line"></span><br><span class="line">编译模块：从入口文件出发，调用所有配置的 Loader</span><br><span class="line">对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到</span><br><span class="line">所有入口依赖的文件都经过了本步骤的处理；</span><br><span class="line"></span><br><span class="line">完成模块编译：在经过第4步使用Loader翻译完所有模块后，</span><br><span class="line">得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</span><br><span class="line"></span><br><span class="line">输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk转换成一个单独的文件加入到输</span><br><span class="line">出列表，这步是可以修改输出内容的最后机会；</span><br><span class="line"></span><br><span class="line">输出完成：在确定好输出内容后，根据配置确定输出的</span><br><span class="line">路径和文件名，把文件内容写入到文件系统。</span><br><span class="line"></span><br><span class="line">在以上过程中，Webpack会在特定的时间点广播出特定</span><br><span class="line">的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，</span><br><span class="line">并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</span><br></pre></td></tr></table></figure><h2 id="描述一下编写loader或plugin的思路？"><a href="#描述一下编写loader或plugin的思路？" class="headerlink" title="描述一下编写loader或plugin的思路？"></a>描述一下编写loader或plugin的思路？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，</span><br><span class="line">并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。</span><br><span class="line">编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。</span><br><span class="line">相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</span><br></pre></td></tr></table></figure><h2 id="如何利用webpack来优化前端性能？"><a href="#如何利用webpack来优化前端性能？" class="headerlink" title="如何利用webpack来优化前端性能？"></a>如何利用webpack来优化前端性能？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用webpack优化前端性能是指优化webpack的输出结果，</span><br><span class="line">让打包的最终结果在浏览器运行快速高效。</span><br><span class="line"></span><br><span class="line">压缩代码。删除多余的代码、注释、简化代码的写法等等方式。</span><br><span class="line">可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件</span><br><span class="line">，利用cssnano（css-loader?minimize）来压缩css</span><br><span class="line"></span><br><span class="line">利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对</span><br><span class="line">应的路径。可以利用webpack对于output参数和各loader的publicPath</span><br><span class="line">参数来修改资源路径</span><br><span class="line"></span><br><span class="line">删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。</span><br><span class="line"></span><br><span class="line">可以通过在启动webpack时追加参数--optimize-minimize来</span><br><span class="line">实现提取公共代码。</span><br></pre></td></tr></table></figure><h2 id="如何提高webpack的构建速度？"><a href="#如何提高webpack的构建速度？" class="headerlink" title="如何提高webpack的构建速度？"></a>如何提高webpack的构建速度？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">多入口情况下，使用CommonsChunkPlugin来提取公共代码</span><br><span class="line">通过externals配置来提取常用库</span><br><span class="line">利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，</span><br><span class="line">再通过DllReferencePlugin将预编译的模块加载进来。</span><br><span class="line">使用Happypack 实现多线程加速编译</span><br><span class="line">使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</span><br><span class="line">使用Tree-shaking和Scope Hoisting来剔除多余代码</span><br></pre></td></tr></table></figure><h2 id="怎么配置单页应用？怎么配置多页应用？"><a href="#怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="怎么配置单页应用？怎么配置多页应用？"></a>怎么配置单页应用？怎么配置多页应用？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用webpack的AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。</span><br><span class="line">多页应用中要注意的是：每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表,随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</span><br></pre></td></tr></table></figure><h2 id="vue项目中实现按需加载？"><a href="#vue项目中实现按需加载？" class="headerlink" title="vue项目中实现按需加载？"></a>vue项目中实现按需加载？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。</span><br><span class="line">不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。</span><br><span class="line"></span><br><span class="line">单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</span><br><span class="line"></span><br><span class="line">通过import(*)语句来控制加载时机，webpack内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个chunk。当代码执行到import(*)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill</span><br></pre></td></tr></table></figure><p>自主搭建、灵活定制、高效复用</p><p>1.单向链表的创建、插入和反转<br>2.二叉搜索树的查找、插入、删除思想，写伪代码<br>3.tcp链接和释放过程，http，https，tcp和udp比较<br>4.链表顺序翻转</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;从浏览器地址栏输入url到显示页面的步骤&quot;&gt;&lt;a href=&quot;#从浏览器地址栏输入url到显示页面的步骤&quot; class=&quot;headerlink&quot; title=&quot;从浏览器地址栏输入url到显示页面的步骤&quot;&gt;&lt;/a&gt;从浏览器地址栏输入url到显示页面的步骤&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. 浏览器查看缓存(浏览器对应的都会有cache文件)。
若请求有缓存且未过期，则取缓存资源提供给客户端，否则发起请求与服务器进行验证。
检验是否过期通常有两个HTTP头：Expires、Cache-control
2.浏览器需要获取域名对应的ip地址，过程如下：
1.本地host文件查找
- 浏览器解析URL获取协议、域名、端口、path路径，然后查看本地硬盘中hosts文件，看是否存在与这个域名对应的规则，如果有就直接使用hosts文件里面的ip地址。
2.路由器缓存
3.ISP DNS(Domain Name System域名系统)(情报局)缓存（互联网提供服务商）-本地DNS服务器以递归方式进行查询缓存记录，
若没有就向跟DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器，
本地DNS服务器把对应关系草存在缓存中（一边下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。
3.客户端发送HTTP请求。
4.TCP传输报文（三次握手四次挥手）
5.向客户端返回资源
6.解析HTML文档，构建DOM树，CSSOM树，下载资源，执行js脚本等。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="面经" scheme="http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>浏览器关闭清除token</title>
    <link href="http://yoursite.com/2021/05/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%97%AD%E6%B8%85%E9%99%A4token/"/>
    <id>http://yoursite.com/2021/05/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%97%AD%E6%B8%85%E9%99%A4token/</id>
    <published>2021-05-24T14:03:02.000Z</published>
    <updated>2021-05-24T15:05:25.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>浏览器关闭会出发 <strong>beforeunload</strong> ，<strong>unload</strong> 这两个事件。</li><li>浏览器刷新也会触发，还会触发<strong>load</strong>事件</li></ul><h2 id="如何清除token"><a href="#如何清除token" class="headerlink" title="如何清除token"></a>如何清除token</h2><ul><li><p>方案一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onbeforeunload = function () &#123;</span><br><span class="line">    localStorage.removeItem(&quot;token&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点： 刷新也会清空token</p></li><li><p>方案二</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.onunload = function() &#123;</span><br><span class="line">    localStorage.setItem(&quot;lastTime&quot;,new Date().getTime())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">    let lastTime = localStorage.getItem(&quot;lastTime&quot;);</span><br><span class="line">    const interval = 3 * 1000;</span><br><span class="line">    // 如果时间间隔大于3s，则清除token</span><br><span class="line">    if (!lastTime || new Date().getTime() - lastTime &gt; interval) &#123;</span><br><span class="line">        localStorage.remove(&quot;token&quot;);</span><br><span class="line">        console.log(&quot;remove token&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;time is less than not remove token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>补充<br>  可以使用sessionStorage代替localStorage来存储token，当关闭浏览器时会自动清除token，sessionStorage不是持久化的本地存储，而是会话级别的存储，而localStorage是持久化的本地存储，除非主动删除数据，否则数据是不会过期的。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;浏览器关闭会出发 &lt;strong&gt;beforeunload&lt;/strong&gt; ，&lt;strong&gt;unload&lt;/stro</summary>
      
    
    
    
    <category term="token" scheme="http://yoursite.com/categories/token/"/>
    
    
    <category term="token" scheme="http://yoursite.com/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>凡事预则立，不预则废</title>
    <link href="http://yoursite.com/2021/03/28/%E5%87%A1%E4%BA%8B%E9%A2%84%E5%88%99%E7%AB%8B%EF%BC%8C%E4%B8%8D%E9%A2%84%E5%88%99%E5%BA%9F/"/>
    <id>http://yoursite.com/2021/03/28/%E5%87%A1%E4%BA%8B%E9%A2%84%E5%88%99%E7%AB%8B%EF%BC%8C%E4%B8%8D%E9%A2%84%E5%88%99%E5%BA%9F/</id>
    <published>2021-03-28T15:22:16.000Z</published>
    <updated>2021-05-23T14:21:49.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="凡事预则立，不预则废"><a href="#凡事预则立，不预则废" class="headerlink" title="凡事预则立，不预则废"></a>凡事预则立，不预则废</h3><p>凡事预则立，不预则废</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;凡事预则立，不预则废&quot;&gt;&lt;a href=&quot;#凡事预则立，不预则废&quot; class=&quot;headerlink&quot; title=&quot;凡事预则立，不预则废&quot;&gt;&lt;/a&gt;凡事预则立，不预则废&lt;/h3&gt;&lt;p&gt;凡事预则立，不预则废&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>你真的了解ES6吗？</title>
    <link href="http://yoursite.com/2020/10/07/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3ES6%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/10/07/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3ES6%E5%90%97%EF%BC%9F/</id>
    <published>2020-10-07T10:22:44.000Z</published>
    <updated>2020-10-07T14:03:10.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你真的了解ES6吗？"><a href="#你真的了解ES6吗？" class="headerlink" title="你真的了解ES6吗？"></a>你真的了解ES6吗？</h2><h3 id="下面的代码输出什么？"><a href="#下面的代码输出什么？" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">       resolve(2)</span><br><span class="line">       console.log(3)</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">    reject(&#x27;error&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err =&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 1 error 3</span><br><span class="line">//要点分析：</span><br><span class="line">// + promise 创建之后会立即执行</span><br><span class="line">// + 状态一旦改变就不会在变，也就是reject与resolve只会执行其中一个</span><br><span class="line">// + 异步队列的执行顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="下面的代码输出什么？-1"><a href="#下面的代码输出什么？-1" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(2);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(3);</span><br><span class="line">            resolve(4);</span><br><span class="line">        &#125;, 0)</span><br><span class="line">        resolve(5);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(6);</span><br><span class="line">    p.then((arg) =&gt; &#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then((arg) =&gt; &#123;</span><br><span class="line">    console.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(7);</span><br><span class="line"></span><br><span class="line">// 1 2 7 5 6 3</span><br><span class="line">//要点解析：</span><br><span class="line">// + promise创建立即执行，依次输出1 2</span><br><span class="line">// + 执行同步任务，输出 7</span><br><span class="line">// + 在执行上一步的时候已经将p.then 以及 first.then 加入到微任务执行队列，所以依次输出 5 6</span><br><span class="line">// + 最后执行宏任务 setTimeout，输出 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="下面的代码输出什么？-2"><a href="#下面的代码输出什么？-2" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">.then(2)</span><br><span class="line">.then(Promise.resolve(3))</span><br><span class="line">.then(console.log)</span><br><span class="line"></span><br><span class="line">// 答案： 1</span><br><span class="line">// + 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。</span><br><span class="line">// + then方法接收的参数是函数！！！，而如果传递的并非是一个函数就会导致前一个Promise的结果穿透到下面。</span><br></pre></td></tr></table></figure><h3 id="const-和-Object-freeze-有什么区别？"><a href="#const-和-Object-freeze-有什么区别？" class="headerlink" title="const 和 Object.freeze 有什么区别？"></a>const 和 Object.freeze 有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//const 声明一个常量，一旦声明，常量的值就不能改变，对于复杂的数据类型，比如对象是可以修改其属性的。const实际保证的不是变量的值，而是变量指向的内存地址所指向的数据不能改变</span><br><span class="line"></span><br><span class="line">//Object.freeze适用于对象值，使得对象不可变，即不能改变对象属性，但是如果对象的属性值仍是复杂数据类型，那么是可以修改成功的。</span><br></pre></td></tr></table></figure><h3 id="for…in和for…of"><a href="#for…in和for…of" class="headerlink" title="for…in和for…of"></a>for…in和for…of</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//对于纯对象的遍历，for...in更合适</span><br><span class="line">const obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: [],</span><br><span class="line">    c: function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">for( let key in obj) &#123;</span><br><span class="line">    console.log(key);// a b c</span><br><span class="line">    console.log(obj[key]); //1 [] function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对于数组遍历，如果不需要知道索引，for...of迭代更合适，还可以中断</span><br><span class="line">const arr = [3, 5, 7];</span><br><span class="line">for(let i of arr)&#123;</span><br><span class="line">    console.log(i);//3 5 7</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数组遍历如果需要知道索引forEach()更合适</span><br><span class="line">arr.forEach((value, index) =&gt; &#123;</span><br><span class="line">    console.log(value);//3 5 7</span><br><span class="line">    console.log(index);//0 1 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//for...in对于数组遍历，会遍历得到索引值，可以通过数组索引取得对应得值，但是，for...in不仅可以枚举数组自身，还会枚举数组的原型(可通过arr.hasOwnProperty(i)去除)以及数组对象本身属性值。</span><br><span class="line"></span><br><span class="line">//for...of可以迭代字符串</span><br><span class="line">let str = &#x27;foo&#x27;</span><br><span class="line">for(let value of str) &#123;</span><br><span class="line">    console.log(value); // &quot;f&quot; &quot;o&quot; &quot;o&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//for...of可以直接迭代arguments类数组对象</span><br><span class="line">(function()&#123;</span><br><span class="line">    for(let arg of arguments) &#123;</span><br><span class="line">        console.log(arg);//1 2 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(1, 2, 3);</span><br><span class="line"></span><br><span class="line">//for...of 还可以迭代NodeList这类DOM集合</span><br><span class="line">let elements = document.querySelectorAll(&#x27;body&#x27;);</span><br><span class="line">for(let element of elements) &#123;</span><br><span class="line">    console.log(element.tagName); //&quot;BODY&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//for...of迭代Map</span><br><span class="line">let mapData = new Map([[&#x27;a&#x27;,1],[&#x27;b&#x27;,2]]);</span><br><span class="line">for(let [key, value] of mapData) &#123;</span><br><span class="line">    console.log(value); //1 2 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//for...of迭代Set</span><br><span class="line">let setData = new Set([1, 2, 3, 2, 1]);</span><br><span class="line">for(let value of setData) &#123;</span><br><span class="line">    console.log(value);//1 2 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;你真的了解ES6吗？&quot;&gt;&lt;a href=&quot;#你真的了解ES6吗？&quot; class=&quot;headerlink&quot; title=&quot;你真的了解ES6吗？&quot;&gt;&lt;/a&gt;你真的了解ES6吗？&lt;/h2&gt;&lt;h3 id=&quot;下面的代码输出什么？&quot;&gt;&lt;a href=&quot;#下面的代码输出什么？&quot;</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6实用技巧</title>
    <link href="http://yoursite.com/2020/10/07/ES6%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2020/10/07/ES6%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2020-10-07T00:41:28.000Z</published>
    <updated>2020-10-07T14:42:44.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6实用技巧"><a href="#ES6实用技巧" class="headerlink" title="ES6实用技巧"></a>ES6实用技巧</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//js变量命名：小驼峰，前缀应当是名词，例如 maxCount、tableTitle</span><br><span class="line"></span><br><span class="line">//js常量：全大写，单词以_分割</span><br><span class="line"></span><br><span class="line">//js函数命名：小驼峰，前缀应当是动词，例如 setCount、getTitle</span><br><span class="line">//常见动词：can has is get set load</span><br><span class="line"></span><br><span class="line">//类 &amp; 构造函数：大驼峰，首字母大写</span><br><span class="line">// class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">//类的成员</span><br><span class="line">//公共属性和方法：跟变量和函数的命名一样</span><br><span class="line">//私有属性和方法，前缀为_(下划线)，同上</span><br><span class="line">//private _name: string;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="let-amp-const"><a href="#let-amp-const" class="headerlink" title="let &amp; const"></a>let &amp; const</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ES6新增了let和const两个命令，let用来定义变量，const用于定义常量，let和const都是块级作用域。</span><br><span class="line">const对于对象类型使用的是指针式引用，常量只是指向了对象的指针，对象本身的内容却依然可以被修改。</span><br><span class="line">在使用中，建议使用let和const完全代替var命令</span><br></pre></td></tr></table></figure><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const foo = `this is a $&#123;example&#125;`;</span><br></pre></td></tr></table></figure><h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">转换</span><br><span class="line">Number.parseInt —— 将字符串或数字转换为整数</span><br><span class="line">Number.parseFloat —— 将字符串或数字转换为浮点数</span><br><span class="line"></span><br><span class="line">上述两个方法与parseInt和parseFloat功能一致，在ES6中推荐使用Number.的方法调用，目的是为了减少全局性方法，使语言逐步模块化。</span><br></pre></td></tr></table></figure><h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//合并数组</span><br><span class="line">let a = [1,2]</span><br><span class="line">let b = [3]</span><br><span class="line">let c = [...a, ...b]</span><br><span class="line"></span><br><span class="line">//Array.from() 将伪数组对象或可遍历对象转换为真数组</span><br><span class="line">//典型的伪数组有：函数的arguments对象，以及大多数DOM元素，还有字符串</span><br><span class="line"></span><br><span class="line">//快速转换为数组</span><br><span class="line">Array.of(3, 4, 5)</span><br><span class="line"></span><br><span class="line">//判断对象是否为数组</span><br><span class="line">if(Array.isArray(obj))&#123;...&#125;</span><br><span class="line"></span><br><span class="line">//检索数据中是否有5</span><br><span class="line">[1, 2, 3].includes(5) //false</span><br><span class="line"></span><br><span class="line">//找出第一个匹配表达式的结果，只要匹配到一项，函数就返回</span><br><span class="line">let a =[1, 3, 4, -89].find((value, index, arr) =&gt; &#123;</span><br><span class="line">    return value &lt; 0;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a); //-89</span><br><span class="line"></span><br><span class="line">//找出第一个匹配表达式的结果的下标</span><br><span class="line">let a = [1, 2, 3, -2].findIndex((value, index, arr) =&gt; &#123;</span><br><span class="line">    return value &lt; 0;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a); //3</span><br><span class="line"></span><br><span class="line">//内容过滤</span><br><span class="line">let a = [1, 2, 3, -4].filter((item) =&gt; &#123;</span><br><span class="line">    return item &gt; 0;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a); //[1, 2, 3]</span><br><span class="line"></span><br><span class="line">//内容实例</span><br><span class="line">.keys() —— 获得数组中所有元素的键名(索引下标)</span><br><span class="line">.values() —— 获得数组中所有元素的数据</span><br><span class="line">.entries() —— 获得数组中所有数据的键名和数据</span><br><span class="line">类似Object中的同名函数</span><br></pre></td></tr></table></figure><h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 对象内容合并</span><br><span class="line">let a = &#123;a:1,b:2&#125;, //&#123;a: 1, b: 4&#125;</span><br><span class="line">    b = &#123;b:3&#125;,</span><br><span class="line">    c = &#123;b:4,c:5&#125;</span><br><span class="line">let d = Object.assign(a, b, c) //&#123;a: 1, b: 4, c: 5&#125;</span><br><span class="line">// 合并的同时更新a对象的内容</span><br><span class="line">// a自身没有的属性不会被添加，只会更新</span><br><span class="line">// 只会影响a第一个，不会影响后面的b、c</span><br><span class="line">// 推荐使用下面这种</span><br><span class="line">let d = Object.assign(&#123;&#125;, a, b, c)</span><br><span class="line"></span><br><span class="line">//对象内容</span><br><span class="line">Object.keys() —— 获取所有键名，以数组形式返回</span><br><span class="line">Object.values() —— 获取所有值内容，以数组形式返回</span><br><span class="line">Object.entries() —— 获取所有键名和值内容，以数组形式返回，成员内容也是数组形式 例如：[[&#x27;a&#x27;, 1],[&#x27;b&#x27;, 2]]</span><br><span class="line"></span><br><span class="line">//判断对象是否为数组对象</span><br><span class="line">if(Object.isArray(obj))&#123;&#125;</span><br><span class="line"></span><br><span class="line">//判断对象是否为空对象</span><br><span class="line">if(obj &amp;&amp; Object.keys(obj).length)</span><br></pre></td></tr></table></figure><h3 id="Destructuring解构赋值"><a href="#Destructuring解构赋值" class="headerlink" title="Destructuring解构赋值"></a>Destructuring解构赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">let [a, b, c] = [1, 2, 3] //如果个数不匹配，没有对应上的为undefined</span><br><span class="line"></span><br><span class="line">let [a, b, c = &#x27;default&#x27;] = [12, 23] //指定默认值</span><br><span class="line"></span><br><span class="line">let [a, ...b] = [1, 2, 3] //b的值为[2, 3]</span><br><span class="line"></span><br><span class="line">let [a, b, c] = &#x27;yes&#x27; //a的值为y，b的值为e，c的值为s</span><br><span class="line"></span><br><span class="line">//如果名称是字符串的自带属性，则会获得属性的值</span><br><span class="line">let &#123; length &#125; = &#x27;yes&#x27; //length 为3</span><br><span class="line"></span><br><span class="line">//解构赋值使用实例，作为函数传参，使用默认值</span><br><span class="line">let obj = &#123;a: 1, b: 2&#125;</span><br><span class="line">function test(&#123;a = 10, b&#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">test(obj)</span><br><span class="line"></span><br><span class="line">// 对象结构解构赋值</span><br><span class="line">let obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let &#123; a, b &#125; = obj; //a = 1,b = 2,需要严格匹配名称，数组的模式是严格匹配下标。</span><br><span class="line"></span><br><span class="line">let obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let &#123; a = 0, b = 3 &#125; = obj; //赋值并给定默认值</span><br><span class="line"></span><br><span class="line">let obj = &#123; a: 1, b: 2&#125;;</span><br><span class="line">let &#123;a: A, b&#125; = obj; //获得内容后，将变量会从新命名</span><br><span class="line"></span><br><span class="line">let a = 0;</span><br><span class="line">(&#123;a, b&#125; = obj);//对已存在的a进行修改值，并生成新的变量b</span><br><span class="line"></span><br><span class="line">//解构的同时使用重命名和设置默认值的语法</span><br><span class="line">const person = &#123;name: &quot;zhangsan&quot;,sex: &quot;male&quot;&#125;;</span><br><span class="line">const &#123;name: middleName = &quot;zhangxiaosan&quot;&#125; = person;</span><br><span class="line">console.log(middleName); //&quot;zhangsan&quot;</span><br><span class="line">// 首先声明middleName这个变量，查询person的middle属性，如果存在则赋值给middleNmae，如果不存在使用默认值&quot;zhangxiaosan&quot;</span><br><span class="line"></span><br><span class="line">//多层解构赋值</span><br><span class="line">let obj = &#123;</span><br><span class="line">    arr: [&#x27;aaa&#x27;, &#123;a: 1&#125;]</span><br><span class="line">&#125;</span><br><span class="line">let &#123;arr: [b, &#123;a&#125;]&#125; = obj; //b为&#x27;aaa&#x27;,a为1，注意结构要对应。</span><br><span class="line"></span><br><span class="line">//数组转化为对象</span><br><span class="line">const points = [</span><br><span class="line">    [1,2],</span><br><span class="line">    [3,4]</span><br><span class="line">];</span><br><span class="line">let newPoints = points.map(item =&gt; &#123;</span><br><span class="line">    const [x,y] = item;</span><br><span class="line">    return &#123;x, y&#125;;</span><br><span class="line">&#125;)</span><br><span class="line">or</span><br><span class="line">let newPoints = points.map(([x, y]) =&gt; &#123;</span><br><span class="line">    return &#123;x, y&#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newPoints);</span><br><span class="line">//[</span><br><span class="line">//  &#123;x:1,y:2&#125;,</span><br><span class="line">//  &#123;x:3,y:4&#125;</span><br><span class="line">//]</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错</span><br><span class="line">//报错，会报SyntaxError</span><br><span class="line">let count = num =&gt; &#123;base: 50&#125;;</span><br><span class="line">//正确返回方式</span><br><span class="line">let count = num =&gt; (&#123;base: 50&#125;);</span><br><span class="line"></span><br><span class="line">//特点：更简洁的函数和封闭上下文的this指向。</span><br></pre></td></tr></table></figure><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//基本用法</span><br><span class="line">let name = Symbol(&quot;name&quot;);</span><br><span class="line">console.log(name); //Symbol(name)</span><br><span class="line">console.log(typeof name); //&quot;symbol&quot;</span><br><span class="line"></span><br><span class="line">// Symbol 函数不能用new命令，因为Symbol是原始数据类型，不是对象</span><br><span class="line">// Symbol表示独一无二的值，因此带有相同参数的两个Symbol值也不相等</span><br><span class="line">let name1 = Symbol();</span><br><span class="line">let name2 = Symbol();</span><br><span class="line">name1 === name2;// false</span><br><span class="line">let name1 = Symbol(&quot;name&quot;);</span><br><span class="line">let name2 = Symbol(&quot;name&quot;);</span><br><span class="line">name1 === name2; // false</span><br><span class="line"></span><br><span class="line">//Symbol不能进行隐式类型转换</span><br><span class="line">let name = Symbol(&#x27;foo&#x27;);</span><br><span class="line">console.log(&quot;nihao&quot; + name);</span><br><span class="line">//浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a string.</span><br><span class="line"></span><br><span class="line">//Symbol值可以显示转换为字符串</span><br><span class="line">let name = Symbol(&#x27;foo&#x27;);</span><br><span class="line">String(name); //&quot;Symbol(foo)&quot;</span><br><span class="line">name.toString(); //&quot;Symbol(foo)&quot;</span><br><span class="line"></span><br><span class="line">//Symbol值不能转换为数字</span><br><span class="line">let name = Symbol(&#x27;foo&#x27;);</span><br><span class="line">Number(name);</span><br><span class="line">//浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a number.</span><br><span class="line"></span><br><span class="line">//Symbol值可以转换为布尔值</span><br><span class="line">let name = Symbol(&#x27;foo&#x27;);</span><br><span class="line">Boolean(name); //true</span><br><span class="line">!name //false</span><br><span class="line"></span><br><span class="line">//Symbol变量不能作为webStorage的键使用</span><br><span class="line">let name = Symbol();</span><br><span class="line">localStorage.setItem(name,&quot;aaaa&quot;);</span><br><span class="line">//浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a string.</span><br><span class="line"></span><br><span class="line">//使用场景</span><br><span class="line">//作为对象属性名</span><br><span class="line">//不能用.只能用[]</span><br><span class="line">let name = Symbol();</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">obj[name] = &quot;zhangsan&quot;;</span><br><span class="line">console.log(obj); //&#123;Symbol():&quot;zhangsan&quot;&#125;</span><br><span class="line"></span><br><span class="line">//Symbol作为属性名时，该属性时公有属性不是私有属性，可以在类的外部访问，但是不会出现在for...in,for...of的循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。</span><br><span class="line">//可以通过Object.getOwnPropertySymbols()和Reflect.ownKeys()取到。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义常量，保证唯一性</span><br><span class="line">const COLOR_RED = Symbol(&quot;red&quot;);</span><br><span class="line">const MY_RED = Symbol(&quot;red&quot;);</span><br><span class="line"></span><br><span class="line">//Symbol.for() </span><br><span class="line">//作用：用于将描述相同的Symbol变量指向同一个Symbol值</span><br><span class="line">//Symbol()定义的值每次都是新建的，即使描述相同值也不同</span><br><span class="line">//Symbol.for() 会先检查给定的描述是否存在，不存在才会新建一个值，并将这个值登记在全局环境中供搜索。</span><br><span class="line">let a1 = Symbol.for(&#x27;a&#x27;);</span><br><span class="line">let a2 = Symbol.for(&#x27;a&#x27;);</span><br><span class="line">a1 === a2 //true</span><br><span class="line">typeof a1 //&quot;symbol&quot;</span><br><span class="line">typeof a2 //&quot;symbol&quot;</span><br><span class="line"></span><br><span class="line">//Symbol.keyFor()</span><br><span class="line">//检测Symbol值是否被登记过，返回一个已登记的Symbol类型值的key</span><br><span class="line">let a1 = Symbol.for(&#x27;a&#x27;);</span><br><span class="line">Symbol.keyFor(a1); //&quot;a&quot;</span><br><span class="line"></span><br><span class="line">let a2 = Symbol(&#x27;a&#x27;);</span><br><span class="line">Symbol.keyFor(a2); //undefined</span><br><span class="line"></span><br><span class="line">//Symbol的属性</span><br><span class="line">//Symbol.peorotype.description 用于返回Symbol数据的描述</span><br><span class="line">let a = Symbol(&quot;accc&quot;);</span><br><span class="line">a.description //&quot;accc&quot;</span><br></pre></td></tr></table></figure><h3 id="排除Object中不需要的键值"><a href="#排除Object中不需要的键值" class="headerlink" title="排除Object中不需要的键值"></a>排除Object中不需要的键值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;a:1,b:2,c:3&#125;;</span><br><span class="line"></span><br><span class="line">const &#123;a,...rest&#125; = obj; //获取除了a之外的所有属性</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//使用reduce对象数组的某一个属性求和</span><br><span class="line">const obj = [</span><br><span class="line">    &#123;name: &quot;lilei&quot;,score: 98&#125;,</span><br><span class="line">    &#123;name: &quot;hanmeimei&quot;,score: 90&#125;</span><br><span class="line">]</span><br><span class="line">const scoreTotal = objs.reduce((total, obj) =&gt; &#123;</span><br><span class="line">    return total + obj.score;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//使用reduce同时做到map和filter的作用</span><br><span class="line">const number = [10,20,30,40];</span><br><span class="line">const doubledOver50 = number.reduce((finalList, num) =&gt; &#123;</span><br><span class="line">    num = num * 2;</span><br><span class="line"></span><br><span class="line">    if(num &gt; 50) &#123;</span><br><span class="line">        finalList.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    return finalList;</span><br><span class="line">&#125;,[]);</span><br><span class="line">doubledOver50; //[60, 80]</span><br></pre></td></tr></table></figure><h3 id="import-动态加载"><a href="#import-动态加载" class="headerlink" title="import() 动态加载"></a>import() 动态加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//把import作为一个函数可以实现动态加载模块</span><br><span class="line">if(true) &#123;</span><br><span class="line">    import(&#x27;./module.js).then(res =&gt; &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ES6实用技巧&quot;&gt;&lt;a href=&quot;#ES6实用技巧&quot; class=&quot;headerlink&quot; title=&quot;ES6实用技巧&quot;&gt;&lt;/a&gt;ES6实用技巧&lt;/h2&gt;&lt;h3 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>jQuery学习</title>
    <link href="http://yoursite.com/2020/09/05/Jquery%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/09/05/Jquery%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-09-05T00:59:32.000Z</published>
    <updated>2020-09-06T13:50:21.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jQuery学习"><a href="#jQuery学习" class="headerlink" title="jQuery学习"></a>jQuery学习</h2><h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><ul><li>jQuery入口函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;)</span><br><span class="line">或者（简写）</span><br><span class="line">$(function()&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><span id="more"></span></li><li>javascript入口函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>jQuery的入口函数是在html的所有标签DOM都加载之后，就会执行包裹的代码，可以执行多次，并且不会覆盖上次。</li><li>javascript的window.onload事件是等到所有内容，包括外部图片之类的文件加载完成后，才会执行，只能执行一次，如果第二次会把第一次的执行覆盖。</li></ul><h3 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h3><ul><li><p>元素选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;)</span><br></pre></td></tr></table></figure></li><li><p>id选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#test&quot;)</span><br></pre></td></tr></table></figure></li><li><p>class选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.test&quot;)</span><br></pre></td></tr></table></figure></li><li><p>属性选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;[href]&quot;)</span><br></pre></td></tr></table></figure></li><li><p>:empty 选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;:empty&quot;)</span><br><span class="line">//选择空的元素，既不不含子元素也不包含文本的元素</span><br><span class="line">$(&quot;div:empty&quot;) //选择div中为空的div元素</span><br></pre></td></tr></table></figure></li><li><p>:parent选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;td:parent&quot;)</span><br><span class="line">//选取所有带有子元素或文本的&lt;td&gt;标签元素</span><br></pre></td></tr></table></figure></li><li><p>:contains 选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div:contains(&#x27;hello&#x27;)&quot;)</span><br><span class="line">//找到div中包含文本hello的指定元素</span><br></pre></td></tr></table></figure></li><li><p>:has选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div:has(p)&quot;)</span><br><span class="line">//找到包含p标签元素的div</span><br></pre></td></tr></table></figure></li><li><p>补充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;:button&quot;) //获取所有type为button的&lt;input&gt;元素和&lt;button&gt;元素，去掉冒号，只能获取&lt;button&gt;元素。</span><br></pre></td></tr></table></figure><h3 id="常用jQuery事件方法"><a href="#常用jQuery事件方法" class="headerlink" title="常用jQuery事件方法"></a>常用jQuery事件方法</h3></li><li><p>click() 点击事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).click(function()&#123;</span><br><span class="line">    $(this).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>dblclick() 双击事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).dblclick(function()&#123;</span><br><span class="line">    $(this).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>mouseenter() 鼠标指针穿过元素时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseenter(function()&#123;</span><br><span class="line">    alert(&quot;您的鼠标移到了p标签元素上！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>mouseleave() 鼠标指针离开元素时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseleave(function()&#123;</span><br><span class="line">    alert(&quot;您的鼠标离开了该p标签元素！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>mouseup() 当在元素上松开鼠标时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).mouseup(()=&gt;&#123;</span><br><span class="line">    alert(&quot;鼠标在p标签上松开！&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>hover() 模拟光标悬停事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).hover(</span><br><span class="line">    function()&#123;</span><br><span class="line">        alert(&quot;你进入了p标签！&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    function()&#123;</span><br><span class="line">        alert(&quot;你离开了p标签！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>focus()  当元素获得焦点时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;input&quot;).focus(function()&#123;</span><br><span class="line">    $(this).css(&quot;background-color&quot;,&quot;#ccc&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>blur() 当元素失去焦点时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;input&quot;).blur(function()&#123;</span><br><span class="line">    $(this).css(&quot;background-color&quot;,&quot;#fff&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>keypress,keydown,keyup</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//获取按键代码或ASCII码</span><br><span class="line">$(window).keydown(function(event)&#123;</span><br><span class="line">    //通过event.which可以拿到按键代码，如果是keypress事件中则拿到ASCII码。</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;)</span><br><span class="line">//获取事件对象</span><br><span class="line">$(window).keypress(function(event)&#123;    </span><br><span class="line">    //获取事件对象，里面包含各种有用的信息。</span><br><span class="line">    console.log(event);</span><br><span class="line">    //console.log(event.which);</span><br><span class="line">&#125;);</span><br><span class="line">//keypress事件获取键入的字符</span><br><span class="line">$(window).keypress(function(event)&#123;</span><br><span class="line">    //event.which是获取ASCII码，前面的函数是将ASCII码转换成字符，空格键和Enter键输出均为空白。</span><br><span class="line">    console.log(String.fromCharCode(event.which));</span><br><span class="line">    //从event对象中key属性获取字符，但是Enter键的key值为&quot;Enter&quot;，空白键还是空白&quot; &quot;。</span><br><span class="line">    console.log(event.key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>off() 事件移除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).off() //移除所有button元素身上绑定的事件</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).off(&quot;click&quot;) //移除所有的click事件，移除指定类型</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).off(&quot;click&quot;, test) //移除click事件中的test回调方法，移除指定类型的事件</span><br></pre></td></tr></table></figure></li><li><p>阻止事件冒泡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.son&quot;).click(function(event)&#123;</span><br><span class="line">    alert(&quot;son&quot;)</span><br><span class="line">    //return false;</span><br><span class="line">    event.stopPropagation(); //阻止事件冒泡</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;.father&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;father&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>阻止默认行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//a标签跳转、submit提交按钮等</span><br><span class="line">$(&quot;a&quot;).click(function(event)&#123;</span><br><span class="line">    alert(&quot;弹出注册框！&quot;);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>trigger()、triggerHandler() 自动触发事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//触发绑定到被选元素的所有事件</span><br><span class="line">$(&quot;.father&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;father&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.father&quot;).trigger(&quot;click&quot;);   //方法一:会触发事件冒泡</span><br><span class="line">$(&quot;.father&quot;).triggerHandler(&quot;click&quot;); //方法二:只触发事件，不会触发事件冒泡</span><br><span class="line">-------------------------------</span><br><span class="line">$(&quot;input[type=&#x27;submit&#x27;]&quot;).click(function()&#123;</span><br><span class="line">    alert(&quot;submit&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;input[type=&#x27;submit&#x27;]&quot;).trigger(&quot;click&quot;); //方法一：触发事件的同时，还会触发默认行为。</span><br><span class="line">$(&quot;input[type=&#x27;submit&#x27;]&quot;).triggerHandler(&quot;click&quot;) //方法二：只触发事件，不触发默认行为。</span><br><span class="line">//注意：这里&lt;a&gt;标签有点特殊，这两个方法都不会触发默认行为，如果想使用trigger()触发&lt;a&gt;标签的事件和默认行为的话，可以在&lt;a&gt;标签中添加一个&lt;span&gt;,例如&lt;a href =&quot;#&quot;&gt;&lt;span&gt;百度&lt;/span&gt;&lt;/a&gt; 这种写法。</span><br></pre></td></tr></table></figure></li><li><p>自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 想要自定义事件，必须满足两个条件</span><br><span class="line">* 1.事件必须是通过on绑定的</span><br><span class="line">* 2.事件必须通过trigger来触发</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).on(&quot;myClick&quot;,function()&#123;</span><br><span class="line">    alert(&quot;son&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).trigger(&quot;myClick&quot;);</span><br><span class="line">or</span><br><span class="line">$(&quot;.son&quot;).triggerHandler(&quot;myClick&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>事件命名空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 想要事件的命名空间有效，必须满足两个条件</span><br><span class="line">* 1.事件通过on来绑定(自定义事件)</span><br><span class="line">* 2.通过trigger()或者triggerHandler()来触发</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).on(&quot;eventName.zs&quot;,function()&#123;</span><br><span class="line">    alert(&quot;click zhangsan&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.son&quot;).on(&quot;eventName.ls&quot;,function()&#123;</span><br><span class="line">    alert(&quot;click lisi&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;.son&quot;).trigger(&quot;click.zs&quot;);</span><br><span class="line">or</span><br><span class="line">$(&quot;.son&quot;).triggerHandler(&quot;click.zs&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="隐藏和显示"><a href="#隐藏和显示" class="headerlink" title="隐藏和显示"></a>隐藏和显示</h3><ul><li><p>hide() 隐藏html元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#hide&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>show() 显示html元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#show&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).show();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>语法 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(selector).hide(speed,callback);</span><br><span class="line"></span><br><span class="line">$(selector).show(speed,callback);</span><br><span class="line"></span><br><span class="line">//可选的speed参数表示规定显示/隐藏的速度(slow、fast、毫秒)</span><br><span class="line">//可选的callback参数是隐藏或显示完成后所执行的函数名称</span><br><span class="line"></span><br><span class="line">$(&quot;.hidebtn&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;div&quot;).hide(1000,&quot;linear&quot;,function()&#123;</span><br><span class="line">        alert(&quot;Hide() 方法已完成!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//第二个参数是一个字符串，表示过渡使用哪种缓动函数，jQuery自身提供(linear、swing)</span><br><span class="line">//补充：callback函数名后面加上括号，会立刻执行函数体，而不是等到显示/隐藏之后才执行,如add()作为callback参数会立即执行，而add作为参数则不会，callback函数可以是匿名函数，$(selector)选中的元素个数为n个，则callback函数会执行n次。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>toggle() 切换hide()和show()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).toggle();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><ul><li><p>fadeIn() 用于淡入以隐藏的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeIn(3000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法： $(selector).fadeIn(speed, callback)</span><br><span class="line">// 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">// 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure></li><li><p>fadeOut() 用于淡出可见元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeOut(&quot;slow&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//语法： $(selector).fadeOut(speed, callback)</span><br><span class="line">// 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">// 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure></li><li><p>fadeToggle() 用于在fadeIn()与fadeOut()方法之间进行切换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeToggle();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//语法： $(selector).fadeToggle(speed, callback)</span><br><span class="line">// 可选的speed参数规定效果的时长(slow、fast、毫秒)</span><br><span class="line">// 可选的callback参数是fading完成后所执行的函数名称</span><br></pre></td></tr></table></figure></li><li><p>fadeTo() 允许渐变为给定的不透明度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.3);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).fadeTo(speed, opacity, callback)</span><br><span class="line">//必须的speed参数规定效果时长(slow、fast、毫秒)</span><br><span class="line">//必须的opacity规定不透明度(介于0-1之间)</span><br></pre></td></tr></table></figure></li></ul><h3 id="滑动方法"><a href="#滑动方法" class="headerlink" title="滑动方法"></a>滑动方法</h3><ul><li><p>slideDown() 用于元素向下滑动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideDown();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).slideDown(speed,callback)</span><br><span class="line">//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">//可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure></li><li><p>slideUp() 用于元素向上滑动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideUp();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).slideUp(speed,callback)</span><br><span class="line">//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">//可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure></li><li><p>slideToggle() 在slideDown()与slideUp()方法之间进行切换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).slideToggle();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//语法：$(selector).slideToggle(speed,callback)</span><br><span class="line">//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span><br><span class="line">//可选的 callback 参数是滑动完成后所执行的函数名称。</span><br></pre></td></tr></table></figure></li></ul><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul><li><p>animate()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下，所有html元素都有一个静态位置，且无法移动。</span><br><span class="line">//先将p标签元素设置为position:relative/absolute/fixed</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;p&quot;).animate(&#123;</span><br><span class="line">      left:&#x27;250px&#x27;,</span><br><span class="line">      opacity:&#x27;0.5&#x27;,</span><br><span class="line">      height:&#x27;400px&#x27;,</span><br><span class="line">      width: &#x27;400px&#x27;,</span><br><span class="line">      paddingLeft:&#x27;10px&#x27;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//语法： $(selector).animate(&#123;params&#125;,speed,callback)</span><br><span class="line">// params参数可以操作几乎所有的css属性，但名字要采用camel标记法</span><br></pre></td></tr></table></figure></li><li><p>stop() 停止动画</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> $(&quot;#flip&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;#panel&quot;).slideDown(5000);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">$(&quot;#stop&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;#panel&quot;).stop();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">语法: $(selector).stop(stopAll,goToEnd)</span><br><span class="line">//可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停/止活动的动画，允许任何排入队列的动画向后执行。</span><br><span class="line">//可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。</span><br></pre></td></tr></table></figure></li><li><p>jQuery方法链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;)</span><br><span class="line">  .slideUp(2000)</span><br><span class="line">  .slideDown(2000);</span><br></pre></td></tr></table></figure></li></ul><h3 id="jQuery获取内容和属性"><a href="#jQuery获取内容和属性" class="headerlink" title="jQuery获取内容和属性"></a>jQuery获取内容和属性</h3><ul><li><p>获取内容 text()、html()、val()</p><ul><li>text() 设置或返回所选元素的文本内容</li><li>html() 设置或返回所选元素的内容(包括html标记)</li><li>val() 设置或返回表单字段的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).text());</span><br><span class="line">&#125;)</span><br><span class="line">//-----------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).html())</span><br><span class="line">&#125;)</span><br><span class="line">//------------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  alert($(&quot;input&quot;).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取属性 attr()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//项目QC刚用过</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    console.log($(&quot;p&quot;).attr(&quot;data-text&quot;));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>补充：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prop()函数返回相应属性或空字符串。</span><br><span class="line">attr()函数返回相应属性或undefined</span><br><span class="line">1.对于HTML元素本身就带有的固有属性，在处理时使用prop方法</span><br><span class="line">2.对HTML元素我们自己定义的DOM属性，在处理时使用attr方法</span><br><span class="line">3.具有true和false两个属性的属性，如checked、selected或者disabled使用prop()</span><br></pre></td></tr></table></figure></li></ul><h3 id="设置内容和属性"><a href="#设置内容和属性" class="headerlink" title="设置内容和属性"></a>设置内容和属性</h3><ul><li><p>设置内容 text()、html()、val()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).text(&quot;hello&quot;));</span><br><span class="line">&#125;)</span><br><span class="line">//-----------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    alert($(&quot;p&quot;).html(&quot;hello&quot;))</span><br><span class="line">&#125;)</span><br><span class="line">//------------------------------</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  alert($(&quot;input&quot;).val(&quot;hello&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>text()、html() 以及 val() 的回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).text(function(i,orignText)&#123;</span><br><span class="line">        //i 为被选元素列表中当前元素的下标</span><br><span class="line">        //orignText 为原来的值</span><br><span class="line">        //return 为返回的新值</span><br><span class="line"></span><br><span class="line">        return &quot;hello&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>设置属性 attr()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).attr(&quot;data-text&quot;,&quot;hello world&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 允许同时设置多个属性</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;p&quot;).attr(&#123;</span><br><span class="line">        &quot;data-text&quot;,&quot;hello world&quot;,</span><br><span class="line">        &quot;title&quot;,&quot;jQuery学习！&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>attr() 也存在回调函数(同上)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;#runoob&quot;).attr(&quot;href&quot;, function(i,origValue)&#123;</span><br><span class="line">    return origValue + &quot;/jquery&quot;; </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><ul><li><p>removeAttr()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;span&quot;).removeAttr(&quot;class name&quot;);</span><br><span class="line">//表示同时删除span标签的class和name属性</span><br></pre></td></tr></table></figure></li><li><p>removeProp()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;span&quot;).removeProp(&quot;class&quot;);</span><br><span class="line">//表示删除所有span标签的class属性</span><br></pre></td></tr></table></figure></li></ul><h3 id="jQuery-添加元素"><a href="#jQuery-添加元素" class="headerlink" title="jQuery 添加元素"></a>jQuery 添加元素</h3><ul><li><p>append/prepend 是在选择元素内容嵌入(文本或标签)</p></li><li><p>after/before 实在元素外部追加(文本或标签)</p></li><li><p>参数可以是多个，可以是一个list</p></li></ul><h3 id="jQuery-删除元素"><a href="#jQuery-删除元素" class="headerlink" title="jQuery 删除元素"></a>jQuery 删除元素</h3><ul><li><p>remove() 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).remove()</span><br><span class="line"></span><br><span class="line">//remove() 方法删除被选元素及其子元素</span><br></pre></td></tr></table></figure></li><li><p>empty() 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).empty()</span><br><span class="line"></span><br><span class="line">//empty() 方法删除被选元素的子元素而不删除自身</span><br></pre></td></tr></table></figure></li><li><p>过滤被删除的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).remove(&quot;.italic&quot;)</span><br><span class="line"></span><br><span class="line">//表示删除所有&lt;p&gt;标签元素中class = &quot;italic&quot;的元素</span><br><span class="line">//过滤时，只能作用于同级元素之间</span><br></pre></td></tr></table></figure></li></ul><h3 id="jQuery-获取并设置CSS类"><a href="#jQuery-获取并设置CSS类" class="headerlink" title="jQuery 获取并设置CSS类"></a>jQuery 获取并设置CSS类</h3><ul><li><p>addClass() 向不用的元素添加class属性，在添加类时可以选取多个元素,也可以设置多个类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">$(&quot;h1, h3, p&quot;).addClass(&quot;fontColor fontSize&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>removeClass() 在不同元素中删除指定的class属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">$(&quot;h1, h3, p&quot;).removeClass(&quot;fontSize&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>toggleClass() 对被选元素进行添加/删除类的切换操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.btn2&quot;).click(function()&#123;</span><br><span class="line">$(&quot;h1, h3, p&quot;).toggleClass(&quot;fontColor2&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="css-方法"><a href="#css-方法" class="headerlink" title="css() 方法"></a>css() 方法</h3><ul><li>返回css属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).css(&quot;background-color&quot;);</span><br></pre></td></tr></table></figure></li><li>设置css属性,可以同时设置多个<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).css(&#123;&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><ul><li><p>width()、height()</p><ul><li>width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）</li><li>height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).width() //获取</span><br><span class="line">$(&quot;p&quot;).width(20) //设置</span><br></pre></td></tr></table></figure></li></ul></li><li><p>innerWidth()、innerHeight()</p><ul><li>innerWidth() 方法返回元素的宽度（包括内边距）。</li><li>innerHeight() 方法返回元素的高度（包括内边距）。</li></ul></li><li><p>outerWidth()、outerHeight()</p><ul><li>outerWidth() 方法返回元素的宽度（包括内边距和边框）。</li><li>outerHeight() 方法返回元素的高度（包括内边距和边框）。</li></ul></li><li><p>offset()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.son&quot;).offset().left //元素距离窗口的偏移距离</span><br><span class="line"></span><br><span class="line">$(&quot;.son&quot;).offset(&#123;</span><br><span class="line">    left: 20,</span><br><span class="line">&#125;) //设置元素距离窗口的偏移距离</span><br></pre></td></tr></table></figure></li><li><p>position()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.son&quot;).position().left //获取元素距离定位元素的偏移距离</span><br><span class="line"></span><br><span class="line">// 注意点：position() 方法只能获取不能设置</span><br></pre></td></tr></table></figure></li><li><p>scrollTop() </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;scroller&quot;).scrollTop() //获取元素相对滚动条顶部的偏移</span><br><span class="line"></span><br><span class="line">$(&quot;scroller&quot;).scrollTop(300) //设置元素相对滚动条顶部的偏移</span><br><span class="line"></span><br><span class="line">//获取网页滚动的偏移(考虑兼容)</span><br><span class="line">$(&quot;body&quot;).scrollTop() + $(&quot;html&quot;).scrollTop() //ie-&gt;body,chrome...-&gt;html</span><br><span class="line"></span><br><span class="line">//设置网页滚动的偏移(考虑兼容)</span><br><span class="line">$(&quot;html,body&quot;).scrollTop(300) </span><br></pre></td></tr></table></figure></li><li><p>补充：设置了box-sizing后，width()=width - padding - border</p></li></ul><h3 id="jQuery遍历"><a href="#jQuery遍历" class="headerlink" title="jQuery遍历"></a>jQuery遍历</h3><h4 id="祖先"><a href="#祖先" class="headerlink" title="祖先"></a>祖先</h4><ul><li><p>parent() 返回元素的直接父元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>parents() 返回被选元素的所有祖先元素，直到文档根元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents();</span><br><span class="line">&#125;)</span><br><span class="line">//过滤所有祖先，并且是&lt;ul&gt;元素</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parents(&quot;ul&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>parentsUntil() 返回给定的两个元素之间的所有祖先元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回&lt;span&gt;与&lt;div&gt;元素之间的所有祖先元素</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).parentsUntil(&quot;div&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="后代"><a href="#后代" class="headerlink" title="后代"></a>后代</h4><ul><li><p>children() 返回被选元素的所有直接子元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div&quot;).children();</span><br><span class="line"></span><br><span class="line">//可以使用可选参数来过滤子元素的搜索</span><br><span class="line">$(&quot;div&quot;).children(&quot;p.aaa&quot;); //返回类名为aaa的&lt;p&gt;元素，且是div的直接子元素。</span><br></pre></td></tr></table></figure></li><li><p>find() 返回被选元素的后代元素，一路向下直到最后一个后代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div&quot;).find(&quot;span&quot;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="同胞"><a href="#同胞" class="headerlink" title="同胞"></a>同胞</h4><ul><li><p>siblings() 返回被选元素的所有同胞元素，可以使用可选参数过滤搜索。</p></li><li><p>next() 返回被选元素的下一个同胞元素，只返回一个元素</p></li><li><p>nextAll() 返回被选元素的所有跟随的同胞元素</p></li><li><p>nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素</p></li><li><p>pre()、prevAll()、prevUntil() 同上，方向相反</p></li></ul><h4 id="过滤：缩小搜索元素的范围"><a href="#过滤：缩小搜索元素的范围" class="headerlink" title="过滤：缩小搜索元素的范围"></a>过滤：缩小搜索元素的范围</h4><ul><li><p>first() 返回被选元素的首个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).first();</span><br></pre></td></tr></table></figure></li><li><p>last() 返回被选元素的最后一个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).last();</span><br></pre></td></tr></table></figure></li><li><p>eq() 返回被选元素中带有指定索引号的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).eq(1);</span><br><span class="line"></span><br><span class="line">//索引号从0开始，eq(1)选择的是第二个&lt;p&gt;元素</span><br></pre></td></tr></table></figure></li><li><p>filter() 允许规定一个标准，返回匹配的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).filter(&quot;.className&quot;);</span><br><span class="line"></span><br><span class="line">//返回带有类名className的所有&lt;p&gt;元素</span><br></pre></td></tr></table></figure></li><li><p>not() 返回所有不匹配的元素，与filter()相反</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).not(&quot;.className&quot;);</span><br><span class="line"></span><br><span class="line">//返回所有不带有类名className的&lt;p&gt;元素</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;jQuery学习&quot;&gt;&lt;a href=&quot;#jQuery学习&quot; class=&quot;headerlink&quot; title=&quot;jQuery学习&quot;&gt;&lt;/a&gt;jQuery学习&lt;/h2&gt;&lt;h3 id=&quot;入口函数&quot;&gt;&lt;a href=&quot;#入口函数&quot; class=&quot;headerlink&quot; title=&quot;入口函数&quot;&gt;&lt;/a&gt;入口函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;jQuery入口函数&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(document).ready(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //执行代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者（简写）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //执行代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>13个超实用的JavaScript数组操作技巧</title>
    <link href="http://yoursite.com/2020/07/18/13%E4%B8%AA%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84JavaScript%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2020/07/18/13%E4%B8%AA%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84JavaScript%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/</id>
    <published>2020-07-18T15:26:33.000Z</published>
    <updated>2020-07-19T01:30:36.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="13个超实用的JavaScript数组操作技巧"><a href="#13个超实用的JavaScript数组操作技巧" class="headerlink" title="13个超实用的JavaScript数组操作技巧"></a>13个超实用的JavaScript数组操作技巧</h2><h3 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fruits = [&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;&quot;watermelon&quot;,&quot;apple&quot;,&quot;orrage&quot;]</span><br><span class="line">//第一种方法</span><br><span class="line">let uniqueFruits = Array.from(new Set(fruits))</span><br><span class="line">//第二种方法</span><br><span class="line">let uniqueFruits2 = [...new Set(fruits)]</span><br></pre></td></tr></table></figure><h3 id="2-替换数组中的特定值"><a href="#2-替换数组中的特定值" class="headerlink" title="2.替换数组中的特定值"></a>2.替换数组中的特定值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用.splice(start,value to remove,valueToAdd),返回删除对象，并修改原数组</span><br><span class="line">let fruits = [&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;,&quot;watermelon&quot;,&quot;apple&quot;,&quot;orrage&quot;]</span><br><span class="line">fruits.splice(0,2,&quot;potato&quot;,&quot;tomato&quot;)</span><br><span class="line">console.log(fruits)</span><br></pre></td></tr></table></figure><h3 id="3-不使用-map-映射数组"><a href="#3-不使用-map-映射数组" class="headerlink" title="3.不使用.map()映射数组"></a>3.不使用.map()映射数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let friends = [</span><br><span class="line">    &#123; name: &#x27;John&#x27;, age: 22 &#125;,</span><br><span class="line">    &#123; name: &#x27;Peter&#x27;, age: 23 &#125;,</span><br><span class="line">    &#123; name: &#x27;Mark&#x27;, age: 24 &#125;,</span><br><span class="line">    &#123; name: &#x27;Maria&#x27;, age: 22 &#125;,</span><br><span class="line">    &#123; name: &#x27;Monica&#x27;, age: 21 &#125;,</span><br><span class="line">    &#123; name: &#x27;Martha&#x27;, age: 19 &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let friendsNames = Array.from(friends, (&#123;name&#125;) =&gt; name)</span><br><span class="line"></span><br><span class="line">console.log(friendsNames)//returns [&quot;John&quot;, &quot;Peter&quot;, &quot;Mark&quot;, &quot;Maria&quot;, &quot;Monica&quot;, &quot;Martha&quot;]</span><br></pre></td></tr></table></figure><h3 id="4-清空数组"><a href="#4-清空数组" class="headerlink" title="4.清空数组"></a>4.清空数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fruits = [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;grape&quot;, &quot;apple&quot;];</span><br><span class="line">//要清空数组，仅需要将数组的长度设置为0</span><br><span class="line">fruits.length = 0;</span><br><span class="line">console.log(fruits); // returns []</span><br></pre></td></tr></table></figure><h3 id="5-数组转对象"><a href="#5-数组转对象" class="headerlink" title="5.数组转对象"></a>5.数组转对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fruits = [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;];</span><br><span class="line"></span><br><span class="line">let fruitsObj = &#123;...fruits&#125;;</span><br><span class="line"></span><br><span class="line">console.log(fruitsObj) // returns &#123;0: &quot;banana&quot;, 1: &quot;apple&quot;, 2: &quot;orange&quot;, 3: &quot;watermelon&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="6-用数据填充数组"><a href="#6-用数据填充数组" class="headerlink" title="6.用数据填充数组"></a>6.用数据填充数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let newArray = new Array(10).fill(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">console.log(newArray)</span><br></pre></td></tr></table></figure><h3 id="7-合并数组"><a href="#7-合并数组" class="headerlink" title="7.合并数组"></a>7.合并数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];</span><br><span class="line">var meat = [&quot;poultry&quot;, &quot;beef&quot;, &quot;fish&quot;];</span><br><span class="line">var vegetables = [&quot;potato&quot;, &quot;tomato&quot;, &quot;cucumber&quot;];</span><br><span class="line">//使用扩展运算符...</span><br><span class="line">var food = […fruits, …meat, …vegetables];</span><br><span class="line">console.log(food); </span><br></pre></td></tr></table></figure><h3 id="8-求数组的交集"><a href="#8-求数组的交集" class="headerlink" title="8.求数组的交集"></a>8.求数组的交集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [0,2,3,5,6,8,6]</span><br><span class="line">var arr2 = [1,2,3,4,5,6,4]</span><br><span class="line">var duplicatedValues = [...new Set(arr1)].filter(item=&gt;arr2.includes(item))</span><br><span class="line">console.log(duplicatedValues)</span><br></pre></td></tr></table></figure><h3 id="9-从数组中删除虚值"><a href="#9-从数组中删除虚值" class="headerlink" title="9.从数组中删除虚值"></a>9.从数组中删除虚值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//虚值有：false、0、null、NaN、undefined、&quot;&quot;.</span><br><span class="line">var mixedArr = [0,&quot;blue&quot;,&quot;&quot;,NaN,9,true,undefined,&quot;white&quot;,false]</span><br><span class="line">var trueArr = mixedArr.filter(Boolean)</span><br><span class="line">console.log(trueArr)</span><br></pre></td></tr></table></figure><h3 id="10-从数组中获取随机值"><a href="#10-从数组中获取随机值" class="headerlink" title="10.从数组中获取随机值"></a>10.从数组中获取随机值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;blue&quot;, &quot;white&quot;, &quot;green&quot;, &quot;navy&quot;, &quot;pink&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;];</span><br><span class="line"></span><br><span class="line">var randomColor = colors[(Math.floor(Math.random() * (color.length)))]</span><br></pre></td></tr></table></figure><h3 id="11-反转数组"><a href="#11-反转数组" class="headerlink" title="11.反转数组"></a>11.反转数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = [“blue”, “white”, “green”, “navy”, “pink”, “purple”, “orange”, “yellow”, “black”, “brown”];</span><br><span class="line">var reversedColors = colors.reverse();</span><br><span class="line">console.log(reversedColors); </span><br></pre></td></tr></table></figure><h3 id="12-lastIndexOf-方法"><a href="#12-lastIndexOf-方法" class="headerlink" title="12.lastIndexOf()方法"></a>12.lastIndexOf()方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查找给定元素的最后依次出现的索引</span><br><span class="line">var nums = [1, 5, 2, 6, 3, 5, 2, 3, 6, 5, 2, 7];</span><br><span class="line">var lastIndex = nums.lastIndexOf(5);</span><br><span class="line">console.log(lastIndex); // returns 9</span><br></pre></td></tr></table></figure><h3 id="13-对数组中所有值求和"><a href="#13-对数组中所有值求和" class="headerlink" title="13.对数组中所有值求和"></a>13.对数组中所有值求和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var nums = [1,5,4,3]</span><br><span class="line">var sum = nums.reduce((x,y)=&gt;x+y)</span><br><span class="line">console.log(sum)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;13个超实用的JavaScript数组操作技巧&quot;&gt;&lt;a href=&quot;#13个超实用的JavaScript数组操作技巧&quot; class=&quot;headerlink&quot; title=&quot;13个超实用的JavaScript数组操作技巧&quot;&gt;&lt;/a&gt;13个超实用的JavaScript</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>javascript常用api合集</title>
    <link href="http://yoursite.com/2020/07/17/javascript%E5%B8%B8%E7%94%A8api%E5%90%88%E9%9B%86/"/>
    <id>http://yoursite.com/2020/07/17/javascript%E5%B8%B8%E7%94%A8api%E5%90%88%E9%9B%86/</id>
    <published>2020-07-17T02:04:52.000Z</published>
    <updated>2020-07-17T09:13:49.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、节点"><a href="#一、节点" class="headerlink" title="一、节点"></a>一、节点</h2><h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node.nodeName //返回节点名称，只读</span><br><span class="line">Node.nodeType //返回节点类型的常数值，只读</span><br><span class="line">Node.nodeValue //返回Text或Comment节点的文本值，只读</span><br><span class="line">Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写</span><br><span class="line">Node.baseURI //返回当前网页的绝对路径</span><br><span class="line"></span><br><span class="line">Node.ownerDocument //返回当前节点所在的顶层文档对象，即document</span><br><span class="line">Node.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点</span><br><span class="line">Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点</span><br><span class="line">Node.parentNode //返回当前节点的父节点</span><br><span class="line">Node.parentElement //返回当前节点的父Element节点</span><br><span class="line">Node.childNodes //返回当前节点的所有子节点</span><br><span class="line">Node.firstChild //返回当前节点的第一个子节点</span><br><span class="line">Node.lastChild //返回当前节点的最后一个子节点</span><br><span class="line"></span><br><span class="line">Node.children //返回当前节点的所有Element子节点</span><br><span class="line">Node.firstElementChild //返回当前节点的第一个Element子节点</span><br><span class="line">Node.lastElementChild //返回当前节点的最后一个Element子节点</span><br><span class="line">Node.childElementCount //返回当前节点所有Element子节点的数目</span><br></pre></td></tr></table></figure><!--more--><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node.appendChild(node) //向节点添加最后的子节点</span><br><span class="line">Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点</span><br><span class="line">Node.cloneNode(true) //默认为false(克隆节点),true(克隆节点及其属性，以及后代)</span><br><span class="line">Node.insertBefore(newNode,oldNode) //在指定子节点前插入新的子节点</span><br><span class="line">Node.removeChild(node) //删除节点，在要删除节点的父节点上操作</span><br><span class="line">Node.replaceChild(newChild,oldChild) //替换节点</span><br><span class="line">Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点</span><br><span class="line">Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系</span><br><span class="line">Node.isEqualNode(node) //返回布尔值，用于检查两个节点是否想等，所谓的相等节点，指的的两个节点的类型、属性、子节点都相同</span><br><span class="line">Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个</span><br><span class="line"></span><br><span class="line">ChildNode.remove()  //用于删除当前节点</span><br><span class="line">ChildNode.before()  //在ChildNode前插入元素节点或者文本节点</span><br><span class="line">ChildNode.after()  //在ChildNode后插入元素或文本节点</span><br><span class="line">ChildNode.replaceWith()  //替换该节点的父节点下的子节点，可以为文本或元素对象</span><br></pre></td></tr></table></figure><h3 id="Document节点"><a href="#Document节点" class="headerlink" title="Document节点"></a>Document节点</h3><h4 id="Document节点的属性"><a href="#Document节点的属性" class="headerlink" title="Document节点的属性"></a>Document节点的属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">document.doctype //返回当前文档关联的文档类型定义(DTD)</span><br><span class="line">document.documentElement //返回当前文档的根节点(html)</span><br><span class="line">document.defaultView //返回document对象所在的window对象</span><br><span class="line">document.body //返回当前文档的&lt;body&gt;节点</span><br><span class="line">document.head //返回当前文档的&lt;head&gt;节点</span><br><span class="line">document.activeElement //返回当前文档中获得焦点的那个元素</span><br><span class="line"></span><br><span class="line">document.links //返回当前文档的所有a元素</span><br><span class="line">document.forms //返回页面中所有表单元素</span><br><span class="line">document.images //返回页面中所有图片元素</span><br><span class="line">document.embeds //返回网页中所有嵌入对象</span><br><span class="line">document.scripts //返回当前文档的所有脚本</span><br><span class="line">document.styleSheets //返回当前网页的所有样式表</span><br><span class="line"></span><br><span class="line">document.documentURI //表示当前文档的网址</span><br><span class="line">document.URI //返回当前文档的网址</span><br><span class="line">document.domain //返回当前文档的域名</span><br><span class="line">document.lastModified //返回当前文档最后修改的时间戳</span><br><span class="line">document.location //返回location对象，提供当前文档的URL信息</span><br><span class="line">document.referrer //返回当前文档的访问来源</span><br><span class="line">document.title //返回当前文档的标题</span><br><span class="line">document.characterSet //属性返回渲染当前文档的字符集，比如UTF-8</span><br><span class="line">document.readyState //返回当前文档的状态</span><br><span class="line">document.designMode //控制当前文档是否可编辑，可读写</span><br><span class="line">document.compatMode //返回浏览器处理文档的模式</span><br><span class="line">document.cookie //用来操作Cookie</span><br></pre></td></tr></table></figure><h3 id="Document节点的方法"><a href="#Document节点的方法" class="headerlink" title="Document节点的方法"></a>Document节点的方法</h3><h4 id="读写方法"><a href="#读写方法" class="headerlink" title="读写方法"></a>读写方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.open() //用于新建并打开一个文档</span><br><span class="line">document.close() //关闭open方法所新建的文档</span><br><span class="line">document.write() //用于向当前文档写入内容</span><br><span class="line">document.writeIn() //用于向当前文档写入内容，尾部添加换行符</span><br></pre></td></tr></table></figure><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(selectors) //接收一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点</span><br><span class="line">document.querySelectorAll(selectors) //接收一个CSS选择器作为参数，返回所有匹配该选择器的元素节点</span><br><span class="line">document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素</span><br><span class="line">document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素</span><br><span class="line">document.getElementsByName(name) //用于选择拥有name属性的HTML元素(比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;object&gt;等)</span><br><span class="line">document.getElementById(id) //返回匹配指定id属性的元素节点</span><br><span class="line">document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点</span><br></pre></td></tr></table></figure><h4 id="生成节点"><a href="#生成节点" class="headerlink" title="生成节点"></a>生成节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.createElement(tagName) //用来生成HTML元素节点</span><br><span class="line">document.createTextNode(text) //用来生成文本节点</span><br><span class="line">document.createAttribute(name) //生成一个新的属性对象节点，并返回</span><br><span class="line">document.createDocumentFragment() //生成一个DocumentFragment对象</span><br></pre></td></tr></table></figure><h4 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用</span><br><span class="line">document.addEventListener(type,listener,capture) //注册事件</span><br><span class="line">document.removeEventListener(type,listener,capture) //注销事件</span><br><span class="line">document.dispatchEvent(event) //触发事件</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点</span><br><span class="line">document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点</span><br><span class="line">document.importNode(externalNode,deep) //从外部文档拷贝指定节点，插入当前文档</span><br></pre></td></tr></table></figure><h3 id="Element节点"><a href="#Element节点" class="headerlink" title="Element节点"></a>Element节点</h3><h4 id="Element节点的属性"><a href="#Element节点的属性" class="headerlink" title="Element节点的属性"></a>Element节点的属性</h4><h5 id="特性属性"><a href="#特性属性" class="headerlink" title="特性属性"></a>特性属性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Element.attributes //返回当前元素节点的所有属性节点</span><br><span class="line">Element.id //返回指定元素的id属性，可读写</span><br><span class="line">Element.tagName //返回指定元素的大写标签名</span><br><span class="line">Element.innerHTML //返回该元素包含的HTML代码，可读写</span><br><span class="line">Element.outerHTML //返回该元素节点的所有HTML代码，包括自身和所有子元素，可读写</span><br><span class="line">Element.className //返回当前元素的class属性，可读写</span><br><span class="line">Element.classList //返回当前元素节点的所有class集合</span><br><span class="line">Element.dataset //返回元素节点中所有data-*属性</span><br></pre></td></tr></table></figure><h5 id="尺寸属性"><a href="#尺寸属性" class="headerlink" title="尺寸属性"></a>尺寸属性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Element.clientHeight //返回元素节点可见部分的高度</span><br><span class="line">Element.clientWidth //返回元素节点可见部分的宽度</span><br><span class="line">Element.clientLeft //返回元素节点左边框的宽度</span><br><span class="line">Element.clientTop //返回元素节点顶部边框的宽度</span><br><span class="line"></span><br><span class="line">Element.scrollHeight //返回元素节点的总高度</span><br><span class="line">Element.scrollWidth //返回元素节点的总宽度</span><br><span class="line">Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值，通过设置这个属性可以改变元素滚动的位置</span><br><span class="line">Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值</span><br><span class="line"></span><br><span class="line">Element.offsetHeight //返回元素的垂直高度(包含border，padding)</span><br><span class="line">Element.offsetWidth //返回元素的水平宽度(包含border，padding)</span><br><span class="line">Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移</span><br><span class="line">Element.offsetTop //返回水平位移</span><br><span class="line"></span><br><span class="line">Element.style //返回元素节点的行内样式</span><br></pre></td></tr></table></figure><h5 id="节点相关属性"><a href="#节点相关属性" class="headerlink" title="节点相关属性"></a>节点相关属性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Element.children //包括当前元素节点的所有子元素</span><br><span class="line">Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数</span><br><span class="line">Element.firstElementChild //返回当前节点的第一个Element子节点</span><br><span class="line">Element.lastElementChild //返回当前节点的最后一个Element子节点</span><br><span class="line">Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点</span><br><span class="line">Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML元素节点</span><br><span class="line">Element.offsetParent //返回当前元素节点的最靠近、并且CSS的position属性不等于static的父元素</span><br></pre></td></tr></table></figure><h4 id="Element节点的方法"><a href="#Element节点的方法" class="headerlink" title="Element节点的方法"></a>Element节点的方法</h4><h5 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getBoundingClientRect() //获取元素位置</span><br><span class="line">getClientRects() //返回当前元素在页面上的矩形区域</span><br></pre></td></tr></table></figure><h5 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element.getAttribute() //读取指定属性</span><br><span class="line">Element.setAttribute() //设置指定属性</span><br><span class="line">Element.hasAttribute() //返回一个布尔值，表示当前元素节点是否有指定属性</span><br><span class="line">Element.removeAttribute() //移除指定属性</span><br></pre></td></tr></table></figure><h5 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element.querySelector() </span><br><span class="line">Element.querySelectorAll()</span><br><span class="line">Element.getElementByTagName()</span><br><span class="line">Element.getElementByClassName()</span><br></pre></td></tr></table></figure><h5 id="事件方法-1"><a href="#事件方法-1" class="headerlink" title="事件方法"></a>事件方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Element.addEventListener() //添加事件的回调函数</span><br><span class="line">Element.removeEventListener() //移除事件监听函数</span><br><span class="line">Element.dispatchEvent() //触发事件</span><br><span class="line"></span><br><span class="line">//ie8</span><br><span class="line">Element.attachEvent(oneventName,listener)</span><br><span class="line">Element.detachEvent(oneventName,listener)</span><br><span class="line"></span><br><span class="line">//event对象</span><br><span class="line">var event = window.event||event</span><br><span class="line"></span><br><span class="line">//事件的目标节点</span><br><span class="line">var target = event.target || event.srcElement</span><br><span class="line"></span><br><span class="line">//事件代理</span><br><span class="line">ul.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">    if(event.target.tagName.toLowerCase() === &#x27;li&#x27;)&#123;</span><br><span class="line">        console.log(event.target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Element.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域</span><br><span class="line"></span><br><span class="line">//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。</span><br><span class="line">Element.insertAdjacentHTML(where, htmlString); </span><br><span class="line">Element.insertAdjacentHTML(&#x27;beforeBegin&#x27;, htmlString); // 在该元素前插入  </span><br><span class="line">Element.insertAdjacentHTML(&#x27;afterBegin&#x27;, htmlString); // 在该元素第一个子元素前插入 </span><br><span class="line">Element.insertAdjacentHTML(&#x27;beforeEnd&#x27;, htmlString); // 在该元素最后一个子元素后面插入 </span><br><span class="line">Element.insertAdjacentHTML(&#x27;afterEnd&#x27;, htmlString); // 在该元素后插入</span><br><span class="line"></span><br><span class="line">Element.remove()  //用于将当前元素节点从DOM中移除</span><br><span class="line">Element.focus()   //用于将当前页面的焦点，转移到指定元素上</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、CSS操作"><a href="#二、CSS操作" class="headerlink" title="二、CSS操作"></a>二、CSS操作</h2><h3 id="类名操作"><a href="#类名操作" class="headerlink" title="类名操作"></a>类名操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//ie8以下</span><br><span class="line">Element.className  //获取元素节点的类名</span><br><span class="line">Element.className += &#x27; &#x27; + newClassName  //新增一个类名</span><br><span class="line"></span><br><span class="line">//判断是否有某个类名</span><br><span class="line">function hasClass(element,className)&#123;</span><br><span class="line">  return new RegExp(className,&#x27;gi&#x27;).test(element.className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除class</span><br><span class="line">function removeClass(element,className)&#123;</span><br><span class="line">  element.className = element.className.replace(new RegExp(&#x27;(^|\\b)&#x27; + className.split(&#x27; &#x27;).join(&#x27;|&#x27;) + &#x27;(\\b|$)&#x27;, &#x27;gi&#x27;),&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ie10 </span><br><span class="line">element.classList.add(className)  //新增</span><br><span class="line">element.classList.remove(className)  //删除</span><br><span class="line">element.classList.contains(className)  //是否包含</span><br><span class="line">element.classList.toggle(className)  //toggle class</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="style操作"><a href="#style操作" class="headerlink" title="style操作"></a>style操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(&#x27;style&#x27;,&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">element.style.backgroundColor = &#x27;red&#x27;</span><br><span class="line"></span><br><span class="line">element.style.cssText //用来读写或删除整个style属性</span><br><span class="line"></span><br><span class="line">element.style.setProperty(propertyName,value)  //设置css属性</span><br><span class="line">element.style.getPropertyValue(property)  //获取css属性</span><br><span class="line">element.style.removeProperty(property)  //删除css属性</span><br><span class="line">操作非内联样式</span><br><span class="line">//ie8</span><br><span class="line">element.currentStyle[attrName]</span><br><span class="line">//ie9+</span><br><span class="line">window.getComputedStyle(el,null)[attrName] </span><br><span class="line">window.getComputedStyle(el,null).getPropertyValue(attrName)</span><br><span class="line">//伪类</span><br><span class="line">window.getComputedStyle(el,&#x27;:after&#x27;)[attrName]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><h4 id="生成实例对象"><a href="#生成实例对象" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var o = new Object()</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><pre><code>Object.prototype //返回原型对象</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>Object.keys(o) //遍历对象的可枚举属性Object.getOwnPropertyName(o) //遍历对象不可枚举的属性</code></pre><h4 id="对象实例的方法"><a href="#对象实例的方法" class="headerlink" title="对象实例的方法"></a>对象实例的方法</h4><pre><code>valueOf() //返回当前对象对应的值toString() //返回当前对象对应的字符串形式toLocaleString() //返回当前对象对应的本地字符串形式hasOwnProperty() //判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性isPrototypeof() //判断当前对象是否为另一个对象的原型propertyIsEnumerable() //判断某个属性是否可枚举</code></pre><h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><h4 id="生成实例对象-1"><a href="#生成实例对象-1" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var a = new Array()</code></pre><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><pre><code>a.length //长度</code></pre><h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h4><pre><code>Array.isArray(a) //用来判断一个值是否为数组</code></pre><h4 id="Array实例的方法"><a href="#Array实例的方法" class="headerlink" title="Array实例的方法"></a>Array实例的方法</h4><pre><code>a.valueof()   //返回数组本身a.toString()  //返回数组的字符串形式a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。pop()   //用于删除数组的最后一个元素，并返回该元素join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift()  //用于删除数组的第一个元素，并返回该元素。unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</code></pre><h3 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h3><h4 id="生成对象"><a href="#生成对象" class="headerlink" title="生成对象"></a>生成对象</h4><pre><code>var n = new Number()</code></pre><h4 id="Number对象的属性"><a href="#Number对象的属性" class="headerlink" title="Number对象的属性"></a>Number对象的属性</h4><pre><code>Number.POSITIVE_INFINITY：正的无限，指向Infinity。Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。Number.NaN：表示非数值，指向NaN。Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。</code></pre><h4 id="Number对象实例的方法"><a href="#Number对象实例的方法" class="headerlink" title="Number对象实例的方法"></a>Number对象实例的方法</h4><pre><code>toString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。toPrecision()  //用于将一个数转为指定位数的有效数字。</code></pre><h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><h4 id="生成实例对象-2"><a href="#生成实例对象-2" class="headerlink" title="生成实例对象"></a>生成实例对象</h4><pre><code>var s = new String()</code></pre><h4 id="String对象的属性"><a href="#String对象的属性" class="headerlink" title="String对象的属性"></a>String对象的属性</h4><pre><code>s.length //返回字符串的长度</code></pre><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><pre><code>s.chatAt(index)   //返回指定位置的字符s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）s.concat(s2)  //用于连接两个字符串s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim()  //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase()  //全部转为大写s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。</code></pre><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><pre><code>Math.E：常数e。Math.LN2：2的自然对数。Math.LN10：10的自然对数。Math.LOG2E：以2为底的e的对数。Math.LOG10E：以10为底的e的对数。Math.PI：常数Pi。Math.SQRT1_2：0.5的平方根。Math.SQRT2：2的平方根。</code></pre><h4 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h4><pre><code>Math.abs()：返回参数的绝对值  Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。Math.floor()：向下取整  Math.max(n,n1,...)：可接受多个参数，返回最大值  Math.min(n,n1,..)：可接受多个参数，返回最小值  Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。Math.log()：返回以e为底的自然对数值。Math.exp()：返回e的指数，也就是常数e的参数次方。Math.round()：四舍五入  Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</code></pre><h4 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h4><pre><code>Math.sin()：返回参数的正弦  Math.cos()：返回参数的余弦  Math.tan()：返回参数的正切  Math.asin()：返回参数的反正弦（弧度值）  Math.acos()：返回参数的反余弦（弧度值）  Math.atan()：返回参数的反正切（弧度值）</code></pre><h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><pre><code>JSON.stringify()   //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.parse()   //用于将JSON字符串转化成对象。</code></pre><h3 id="console对象"><a href="#console对象" class="headerlink" title="console对象"></a>console对象</h3><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><pre><code>console.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈console.table()  //可以将复合类型的数据转为表格显示。console.count()  //用于计数，输出它被调用了多少次。console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。console.dirxml()  //用于以目录树的形式，显示DOM节点。console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。//这两个方法用于计时，可以算出一个操作所花费的准确时间。console.time()console.timeEnd()//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。console.profileEnd()  //用来结束正在运行的性能测试器。console.group()console.groupend()//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。console.trace()  //显示当前执行的代码在堆栈中的调用路径。console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、节点&quot;&gt;&lt;a href=&quot;#一、节点&quot; class=&quot;headerlink&quot; title=&quot;一、节点&quot;&gt;&lt;/a&gt;一、节点&lt;/h2&gt;&lt;h3 id=&quot;节点属性&quot;&gt;&lt;a href=&quot;#节点属性&quot; class=&quot;headerlink&quot; title=&quot;节点属性&quot;&gt;&lt;/a&gt;节点属性&lt;/h3&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS垃圾回收机制</title>
    <link href="http://yoursite.com/2019/10/19/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/10/19/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2019-10-19T09:24:19.000Z</published>
    <updated>2020-07-16T15:47:03.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谈谈JS垃圾回收机制？"><a href="#谈谈JS垃圾回收机制？" class="headerlink" title="谈谈JS垃圾回收机制？"></a>谈谈JS垃圾回收机制？</h2> <span id="more"></span><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><pre><code>Javascript中的内存管理是自动执行的，而且是不可见的。在我们创建基本类型、对象、函数时，这些都需要内存，当不需要某样东西时，JavaScript引擎会利用垃圾回收机制清除它。在局部作用域中，当函数执行完毕，局部变量也就没必要存在了，因此垃圾收集器很容易做出判断回收。但是全局变量什么时候需要自动释放内存空间很难判断，因此在开发中，需要尽量避免使用全局变量。</code></pre><h4 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h4><p>JavaScript中内存管理的主要概念是可达性。</p><p>当一些值以某种方式可访问或可用，它们会被存储在内存中，叫做可达值。</p><ul><li>一些固有可达值，由于显而易见的原因无法删除。例如：<ul><li>本地函数的局部变量或参数</li><li>当前嵌套调用链上的其他函数的变量和参数</li><li>全局变量等</li></ul></li></ul><p>这些值 称为 根</p><ul><li>如果引用或引用链 可以从根访问任何其他值，则认为该值是可访问的。<ul><li>一个对象引用另一个对象的属性，则该对象是为可达性。</li></ul></li></ul><p>JavaScript引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除哪些不可访问的对象。</p><h4 id="内部算法"><a href="#内部算法" class="headerlink" title="内部算法"></a>内部算法</h4><p>v8的垃圾回收策略基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同<br>的算法。</p><p>新生代采用Scavenge算法(赋值算法)</p><ul><li><p>Scavenge为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分<br>为from和to两个空间。每次gc,会将from空间的存活对象复制到to空间。然后两个空间角色<br>对换(又称反转)。</p></li><li><p>该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。</p></li></ul><p>老生代采用Mark-Sweep(标记清除)和Mark-Compact(标记整理)</p><ul><li>标记-清除算法，定期执行一下“垃圾回收”步骤：<ul><li>垃圾回收器获取根并“标记”它们</li><li>然后访问并标记所有来自它们的引用</li><li>然后访问标记的对象 并 标记它们的引用</li><li>以此类推，知道有为访问的引用为止</li><li>除了标记的对象外，所有对象都被删除。</li></ul></li></ul><p>Mark-Compact算法(标记整理)</p><ul><li>标记清除存在一个问题，清除死亡对象后会造成内存空间不连续，这时候v8会使用<br>Mark-Compact算法(标记整理)，它会在标记完成之后将活着的对象往一端移动，移动完成<br>后直接清理掉边界外的内存。</li></ul><p>Reference Counting(引用计数算法)</p><ul><li>引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时<br>更新计数器，如果计数器值为0则直接回收内存。 很明显，引用计数最大的优势是暂停时间短</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li><p>增量回收：如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费<br>一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分，然后<br>各个部分分别执行，这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。</p></li><li><p>空闲时间收集：垃圾回收器只在CPU空闲时运行，以减少对执行的可能影响。</p></li></ul><h4 id="v8的内存限制"><a href="#v8的内存限制" class="headerlink" title="v8的内存限制"></a>v8的内存限制</h4><ul><li>64位系统最大约为1.4G</li><li>32位系统最大约为0.7G</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;谈谈JS垃圾回收机制？&quot;&gt;&lt;a href=&quot;#谈谈JS垃圾回收机制？&quot; class=&quot;headerlink&quot; title=&quot;谈谈JS垃圾回收机制？&quot;&gt;&lt;/a&gt;谈谈JS垃圾回收机制？&lt;/h2&gt;</summary>
    
    
    
    <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序</title>
    <link href="http://yoursite.com/2019/10/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/10/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</id>
    <published>2019-10-18T16:28:59.000Z</published>
    <updated>2020-07-16T15:47:08.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><h4 id="文件主要目录及文件作用"><a href="#文件主要目录及文件作用" class="headerlink" title="文件主要目录及文件作用"></a>文件主要目录及文件作用</h4> <span id="more"></span><ul><li>component 组件文件夹<ul><li>navBar 底部组件<ul><li>navBar.js 底部组件的js代码</li><li>navBar.json 底部组件的配置文件</li><li>navBar.wxml 底部组件的html代码</li><li>navBar.wxss 底部组件的css代码</li></ul></li></ul></li><li>pages 页面文件夹<ul><li>index 首页<ul><li>index.js 首页的js代码</li><li>index.json 首页的配置文件</li><li>index.wxml 首页的html代码</li><li>index.wxss 首页的css代码</li></ul></li></ul></li><li>public 图片文件夹</li><li>utils 工具文件夹<ul><li>api.js 控制api的文件</li><li>md5.js 工具：MD5加密文件</li><li>timestamp.js 工具：事件戳文件</li></ul></li><li>app.json 设置全局的基础数据等</li><li>app.wxss 公共样式，可通过import导入更多</li><li>project.config.json 项目配置文件</li></ul><h4 id="微信小程序生命周期"><a href="#微信小程序生命周期" class="headerlink" title="微信小程序生命周期"></a>微信小程序生命周期</h4><ul><li>onLoad(): 页面加载时触发，一个页面只会调用一次，可以在onLoad中获取打开当前页面<br>所调用的query参数。</li><li>onShow(): 页面显示/切入前台时触发，每次打开页面都会调用一次。</li><li>onReady(): 页面初次渲染完成时触发，一个页面只会调用一次。</li><li>onHide(): 页面隐藏/切入后台时触发，当navigateTo或底部tab切换时调用。</li><li>onUnload(): 页面卸载时触发。</li></ul><h4 id="app-json是对当前小程序的全局配置，讲述三个配置各个项的含义"><a href="#app-json是对当前小程序的全局配置，讲述三个配置各个项的含义" class="headerlink" title="app.json是对当前小程序的全局配置，讲述三个配置各个项的含义?"></a>app.json是对当前小程序的全局配置，讲述三个配置各个项的含义?</h4><ul><li>pages字段：用于描述当前小程序所有页面路径，为了让微信客户端知道当前小程序页面<br>定义在那个目录。</li><li>window字段：小程序所有页面的顶部背景颜色，文字颜色定义等。</li><li>tab字段：小程序全局顶部tab或底部tab。</li></ul><h4 id="小程序的wxss和css有哪些不一样的地方？"><a href="#小程序的wxss和css有哪些不一样的地方？" class="headerlink" title="小程序的wxss和css有哪些不一样的地方？"></a>小程序的wxss和css有哪些不一样的地方？</h4><ul><li>新像素单位rpx</li><li>样式可直接使用import导入</li></ul><h4 id="小程序wxml和标准的html的异同？"><a href="#小程序wxml和标准的html的异同？" class="headerlink" title="小程序wxml和标准的html的异同？"></a>小程序wxml和标准的html的异同？</h4><p>都是用来描述页面的结构，都是由标签、属性等构成。</p><ul><li>标签名字不一样，且小程序标签更少，单一标签更多。</li><li>多了一些wx:if这样的属性和双大括号这样的表达式。</li><li>wxml只能在微信小程序开发者工具中预览，html可以在浏览器内预览。</li><li>组件封装不同，wxml对组件进行了重新封装。</li><li>小程序运行在JS Core内，没有DOM树和window对象，小程序无法使用window对象和document<br>对象。</li></ul><h4 id="小程序wxss和css的异同？"><a href="#小程序wxss和css的异同？" class="headerlink" title="小程序wxss和css的异同？"></a>小程序wxss和css的异同？</h4><p>都是用来描述页面的样子</p><ul><li>wxss具有css大部分的特性，也做了一些扩充和修改。</li><li>wxss新增了尺寸单位，wxss在底层支持新的尺寸单位rpx。</li><li>wxss仅支持部分css选择器。</li><li>wxss提供全局样式和局部样式。</li></ul><h4 id="小程序页面间有哪些传递数据的方法？"><a href="#小程序页面间有哪些传递数据的方法？" class="headerlink" title="小程序页面间有哪些传递数据的方法？"></a>小程序页面间有哪些传递数据的方法？</h4><ul><li>使用全局变量实现数据传递</li><li>页面跳转或重定向时，使用url带参数传递数据</li><li>使用组件模板template传递参数</li><li>使用数据库传递数据</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;微信小程序&quot;&gt;&lt;a href=&quot;#微信小程序&quot; class=&quot;headerlink&quot; title=&quot;微信小程序&quot;&gt;&lt;/a&gt;微信小程序&lt;/h2&gt;&lt;h4 id=&quot;文件主要目录及文件作用&quot;&gt;&lt;a href=&quot;#文件主要目录及文件作用&quot; class=&quot;headerlink&quot; title=&quot;文件主要目录及文件作用&quot;&gt;&lt;/a&gt;文件主要目录及文件作用&lt;/h4&gt;</summary>
    
    
    
    <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Chrome打开一个页面需要启动多少线程？分别有哪些线程？</title>
    <link href="http://yoursite.com/2019/10/14/Chrome%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E9%9C%80%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/10/14/Chrome%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E9%9C%80%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%EF%BC%9F/</id>
    <published>2019-10-14T06:37:34.000Z</published>
    <updated>2019-10-19T17:50:46.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chrome打开一个页面需要启动多少线程？分别有哪些线程？"><a href="#Chrome打开一个页面需要启动多少线程？分别有哪些线程？" class="headerlink" title="Chrome打开一个页面需要启动多少线程？分别有哪些线程？"></a>Chrome打开一个页面需要启动多少线程？分别有哪些线程？</h2><pre><code>最新Chrome浏览器包括：一个浏览器(Browser)主线程、一个GPU进程、一个网络(NetWork)进程、多个渲染进程和多个插件进程</code></pre><ul><li><p>线程：</p><ul><li>浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。</li><li>渲染进程：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，<br>排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个<br>Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li>GPU进程：Chrome刚开始的时候是没有GPU进程的，而GPU使用的使用初衷是为了实现<br>3D CSS效果，之后随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU称为<br>浏览器普遍的需求，最后，Chrome在其多进程架构上也引入了GPU进程。</li><li>网络进程：主要负责网页的网络资源加载，之前是作为一个模块运行在浏览器进程里面<br>的，最近才独立出来，称为一个单独的进程。</li><li>插件进程：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以<br>保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chrome打开一个页面需要启动多少线程？分别有哪些线程？&quot;&gt;&lt;a href=&quot;#Chrome打开一个页面需要启动多少线程？分别有哪些线程？&quot; class=&quot;headerlink&quot; title=&quot;Chrome打开一个页面需要启动多少线程？分别有哪些线程？&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>内存泄漏</title>
    <link href="http://yoursite.com/2019/10/11/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2019/10/11/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2019-10-11T01:34:26.000Z</published>
    <updated>2019-10-11T01:40:32.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="造成内存泄漏的原因？"><a href="#造成内存泄漏的原因？" class="headerlink" title="造成内存泄漏的原因？"></a>造成内存泄漏的原因？</h2><ul><li>意外的全局变量<ul><li>无法被回收</li></ul></li><li>定时器<ul><li>未被正确关闭，导致所引用的外部变量无法被释放</li></ul></li><li>事件监听<ul><li>没有正确销毁</li></ul></li><li>闭包<ul><li>会导致父级中的变量无法被释放</li></ul></li><li>DOM引用<ul><li>DOM被删除时，内存中的引用未被正确清空</li></ul></li></ul><h2 id="如何查看内存变化情况？"><a href="#如何查看内存变化情况？" class="headerlink" title="如何查看内存变化情况？"></a>如何查看内存变化情况？</h2><ul><li>使用Chrome的Performance面板进行内存标记，可视化查看内存变化情况，找出异常点。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;造成内存泄漏的原因？&quot;&gt;&lt;a href=&quot;#造成内存泄漏的原因？&quot; class=&quot;headerlink&quot; title=&quot;造成内存泄漏的原因？&quot;&gt;&lt;/a&gt;造成内存泄漏的原因？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;意外的全局变量&lt;ul&gt;
&lt;li&gt;无法被回收&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端安全</title>
    <link href="http://yoursite.com/2019/10/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2019/10/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</id>
    <published>2019-10-10T05:50:51.000Z</published>
    <updated>2019-10-10T15:21:26.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><ul><li>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，<br>最终达到欺骗服务器执行恶意的SQL命令</li></ul><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ul><li>xss：跨站脚本攻击(Cross Site Scripting),攻击者通过注入非法的html标签<br>或者JavaScript代码，从而当用户浏览该网页时，控制用户浏览器。</li><li>xss主要分为三类：<ul><li>DOM xss<ul><li>DOM即文本对象模型，DOM通常代表在html、xhtml和xml中的对象，使用DOM<br>可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器<br>解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端<br>的事情。</li></ul></li><li>反射型 xss<ul><li>反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请<br>求时，XSS代码出现在URL中 ，最后输入提交到服务器，服务器解析后在响应内容<br>中出现这段XSS代码，最后浏览器解析执行。</li></ul></li><li>存储型 xss<ul><li>存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS<br>和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。<br>允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS<br>代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中<br>最典型的例子就是留言板。</li></ul></li></ul></li><li>主要影响：<ul><li>利用虚假输入表单骗取用户个人信息</li><li>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li><li>显示伪造的文章或者图片</li></ul></li><li>防御措施：<ul><li>设置httpOnly：在cookie中设置HttpOnly属性后，js脚本将无法读取到cookie的信息。</li><li>输入检查，对于用户输入进行格式检查。<ul><li>移除用户上传的DOM属性，如onerror事件等。</li><li>移除用户上传的style节点、script节点、iframe节点。</li></ul></li></ul></li></ul><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><ul><li><p>csrf：跨站请求伪造(Cross-Site Request Forgeries)，冒充用户发起请求，完成<br>一些违背用户意愿的事情。</p></li><li><p>防御措施</p><ul><li>Token验证：<ul><li>第一步：后端随机产生一个token，把这个token保存在session状态中，同时<br>后端把token交给前端页面；</li><li>第二步：前端页面提交请求时，把token加入到请求数据或者头信息中，一起<br>传给后端；</li><li>后端验证前端传来的token与session是否一致，一致则合法，否则非法请求。</li></ul></li><li>Referer check：请求来源验证，但是不能保证100%有效，因为服务器并不是什么<br>时候都能取到Referer，而且低版本浏览器存在伪造Referer的风险。</li><li>验证码：强制用户必须和应用进行交互，完成最终请求，但用户体验比较差。</li></ul></li></ul><h4 id="clickjacking"><a href="#clickjacking" class="headerlink" title="clickjacking"></a>clickjacking</h4><ul><li><p>clickjacking: 点击劫持，利用透明的按钮或连接做成陷阱，覆盖在web页面之上，然后<br>诱使用户在不知的情况下，点击那个链接访问内容的一种攻击手段。又称为界面伪装。</p></li><li><p>大概有两种方式：</p><ul><li>攻击者使用一个透明iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，<br>此时用将在不知情的情况下点击透明的iframe页面。</li><li>攻击者使用一张图片覆盖在网页，遮挡网页原有的位置含义。</li></ul></li><li><p>防御措施：</p><ul><li>X-FRAME-OPTIONS 响应头是用来给浏览器指示允许一个页面可否在<code>&lt;frame&gt;</code>,<br><code>&lt;iframe&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记。网站可以使用此功能，来确保自己网站<br>内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。</li></ul></li></ul><h5 id="控制台注入代码"><a href="#控制台注入代码" class="headerlink" title="控制台注入代码"></a>控制台注入代码</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前端安全&quot;&gt;&lt;a href=&quot;#前端安全&quot; class=&quot;headerlink&quot; title=&quot;前端安全&quot;&gt;&lt;/a&gt;前端安全&lt;/h2&gt;&lt;h4 id=&quot;sql注入&quot;&gt;&lt;a href=&quot;#sql注入&quot; class=&quot;headerlink&quot; title=&quot;sql注入&quot;&gt;</summary>
      
    
    
    
    <category term="前端安全" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
