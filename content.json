{"posts":[{"title":"aliyun服务器实践","text":"创建新的账号默认使用 root 登录，由于 root 权限太高，出于安全考虑，创建 foolishmax（自定义）账号 123456789101112131415161718192021222324252627282930# 新增账号foolishmaxadduser foolishmax# 修改foolishmax的密码passwd foolishmax# 为foolishmax账号添加sudo权限# 找到文件位置 /etc/sudoerswhereis sudoers# 修改权限# u 标识所有者、w 表示写权限 + 表示添加chmod u+w /etc/sudoers# 编辑 /etc/sudoers# 找到 `root ALL=(ALL) ALL`# 再加一行 `work ALL=(ALL) ALL`vim /etc/sudoers# 还原权限chmod u-w /etc/sudoers# 切换foolishmax用户su foolishmax# 切换回rootsu# 输入密码# 切换成功 下载常用工具12345678910111213141516171819// gityum -y install gitgit --version// 安装dockeryum -y install dockerdocker --version// 安装docker-compose// 1. 下载二进制文件wget https://github.com/docker/compose/releases/download/1.24.0/docker-compose-Linux-x86_64// 2.移动文件mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose// 3.赋予可执行权限chmod +x /usr/local/bin/docker-compose// 4.创建软链ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose// 5.测试是否安装成功docker-compose --version 开放端口aliyun 控制台服务 发布测试机思路： 使用 github actions 监听 dev 分支 push 登录测试机，获取最新 dev 分支代码 重建构建镜像 docker-compose build project-name 重启所有容器 docker-compose up -d github actions代码在项目 .github/workflows 目录下面的 .yml 格式文件deplop-dev.yml示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions# github actions 中文文档 https://docs.github.com/cn/actions/getting-started-with-github-actionsname: deploy for devon: push: branches: - 'dev' # 只针对 dev 分支 paths: - '.github/workflows/*' # - '__test__/**' # dev 不需要立即测试 - 'src/**' - 'Dockerfile' - 'docker-compose.yml' - 'bin/*'jobs: deploy-dev: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: set ssh key # 临时设置 ssh key run: | mkdir -p ~/.ssh/ echo &quot;${{secrets.WFP_ID_RSA}}&quot; &gt; ~/.ssh/id_rsa # secret 在这里配置 https://github.com/imooc-lego/biz-editor-server/settings/secrets chmod 600 ~/.ssh/id_rsa ssh-keyscan &quot;182.92.xxx.xxx&quot; &gt;&gt; ~/.ssh/known_hosts - name: deploy # 部署 run: | ssh work@182.92.xxx.xxx &quot; # 【注意】用 work 账号登录，手动创建 /home/work/imooc-lego 目录 # 然后 git clone https://username:password@github.com/imooc-lego/biz-editor-server.git -b dev （私有仓库，使用 github 用户名和密码） # 记得删除 origin ，否则会暴露 github 密码 cd /home/work/imooc-lego/biz-editor-server; git remote add origin https://wangfupeng1988:${{secrets.WFP_PASSWORD}}@github.com/imooc-lego/biz-editor-server.git; git checkout dev; git pull origin dev; # 重新下载最新代码 git remote remove origin; # 删除 origin ，否则会暴露 github 密码 # 启动 docker docker-compose build editor-server; # 和 docker-compose.yml service 名字一致 docker-compose up -d; &quot; - name: delete ssh key # 删除 ssh key run: rm -rf ~/.ssh/id_rsa","link":"/2022/08/02/aliyun%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E8%B7%B5/"},{"title":"docker实践指南","text":"镜像操作 获取镜像 docker pull12# docker pull 从镜像仓库中拉取或者更新指定镜像docker pull ubuntu:18.04 列出已经下载的镜像 docker images123docker images# 列出某一个镜像docker images ubuntu 删除镜像 docker rmi1234567891011121314151617docker rmi 501# ordocker rmi centos# docker prune命令# 删除所有未被tag标记或者未被容器使用的镜像docker image prune# 删除所有未被容器使用的镜像docker image prune -a# 删除所有停止运行的容器docker container prune# 删除所有未被挂载的卷docker volume prune# 删除所有网络docker network prune# 删除docker所有资源docker system prune 上传镜像 docker push12# docker push:将本地的镜像上传到镜像仓库，先登录镜像仓库docker push mynode:v1 容器操作列出容器 docker ps12# -a :显示所有的容器，包括未运行的docker ps 停止容器 docker stop12# 停止运行中的容器myrunoobdocker stop myrunoob 启动容器 docker start12# 启动已被停止的容器myrunoobdocker start myrunoob 重启容器 docker restart12# 重启容器myrunoobdocker restart myrunoob 删除容器 docker rm12# 强制删除容器 db01、db02docker rm -f db01 db02 查看容器信息 docker inspect123# 获取容器/镜像的元数据# 获取镜像mysql:5.6的元信息docker inspect mysql:5.6 查看容器日志 docker logs12# 跟踪查看容器mynginx的日志输出docker logs -f mynginx 进入容器控制台 docker exec1234567// 在运行的容器中执行命令// -d:分离模式，在后台运行// -i: 即使没有附加也保持STDIN打开// -t: 分配一个伪终端// docker exec -it &lt;container-id&gt; /bin/sh// 执行 exit 退出 启动 docker 1open /Applications/Docker.app docker runeg1: 1docker run ubuntu:15.10 /bin/echo 'hello world' 各个参数解析： docker：Docker 的二进制执行文件 run：与 docker 组合来运行一个容器 ubuntu:15.10 指定要运行的景象，docker 先从本地主机查找景象是否存在，如不存在，docker 就会从 Docker hub镜像仓库下载公共镜像 /bin/echo ‘hello world’：在启动的容器中执行的命令 注意： 不存在时会出现错误信息： Unable to find image ‘ubuntu:15.10’ locally 之后便会从镜像仓库下载公共镜像 打印 hello world M1-Mac 可能会出现如下警告：WARNING: The requested image’s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested 解决方法：docker run –platform linux/amd64 ubuntu:15.10 /bin/echo ‘hello world’ eg2: 123456// 启动容器 docker run -p xxx:xxx -v=hostPath:containerPath -d --name &lt;container-name&gt; &lt;image-name&gt;// -p 端口映射// -v 数据卷，文件映射// -d 后台运行// --name 定义容器名称docker run -p 81:80 -d --name nginx1 nginx DockerfileDockerfile 是一个用来构建镜像的文本文件，文件内容包含一条条构建镜像所需的指令和说明 12345678910111213#DockerfileFROM node:latestWORKDIR /appCOPY . /appRUN npm set registry https://registry.npm.taobao.orgRUN npm installRUN npm install pm2 -gCMD echo $SERVER_NAME &amp;&amp; echo $AUTHOR_NAME &amp;&amp; npm run start &amp;&amp; npx npm2 logENV SERVER_NAME = 'react-demo'ENV AUTHOR_NAME = 'foolishmax' .dockerignore12.gitnode_modules 始构建镜像在 Dockerfile 文件的存放目录下，执行构建动作 1docker bild -t react-demo-image . docker images 查看1234REPOSITORY TAG IMAGE ID CREATED SIZEreact-demo-image latest 35c499bddac6 3 minutes ago 1.22GBnode-test latest 028a51c6e54d 8 months ago 945MBnginx latest f1325989da19 8 months ago 134MB 运行容器1docker run -p 8081:3000 -d --name react-demo-server react-demo-image 查看容器12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf71ef1480035 react-demo-image &quot;docker-entrypoint.s…&quot; 4 seconds ago Up 3 seconds 0.0.0.0:8081-&gt;3000/tcp react-demo-server 查看日志docker logs f71ef1480035 1234567891011121314151617181920212223242526# 这两行对应Dockerfile中的CMD变量打印= react-demo= foolishmax&gt; react-demo@0.1.0 start&gt; react-scripts start(node:27) [DEP_WEBPACK_DEV_SERVER_ON_AFTER_SETUP_MIDDLEWARE] DeprecationWarning: 'onAfterSetupMiddleware' option is deprecated. Please use the 'setupMiddlewares' option.(Use `node --trace-deprecation ...` to show where the warning was created)(node:27) [DEP_WEBPACK_DEV_SERVER_ON_BEFORE_SETUP_MIDDLEWARE] DeprecationWarning: 'onBeforeSetupMiddleware' option is deprecated. Please use the 'setupMiddlewares' option.Starting the development server...Compiled successfully!You can now view react-demo in the browser. Local: http://localhost:3000 On Your Network: http://172.17.0.2:3000Note that the development build is not optimized.To create a production build, use npm run build.webpack compiled successfullyCompiling...Compiled successfully!webpack compiled successfully 停止容器docker stop f71ef1480035 删除容器docker rm f71ef1480035 删除镜像docker rmi 35c499bddac6 12Untagged: react-demo-image:latestDeleted: sha256:35c499bddac6675ff20a7d951fc1c1f6770a10430278fec6f2b8d1c866037624 docker-compose.yml 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344version: '3'services: edditor-server: # service name build: context: . #当前目录 dockerfile: Dockerfile # 基于Dockerfile构建 image: editor-server #依赖当前dockerfile创建出来的镜像 container_name: editor-server ports: - 8081:3000 #宿主机通过8081访问 editor-redis: image: redis #引用官方redis镜像 container_name: editor-redis ports: - 6378:6379 environment: - TZ=Asia/Shanghai # 设置时区 editor-mysql: image: mysql # 引用官网 mysql 镜像 container_name: editor-mysql restart: always # 出错则重启 privileged: true # 高权限，执行下面的 mysql/init command: --default-authentication-plugin=mysql_native_password # 远程访问 ports: - 3305:3306 # 宿主机可以用 127.0.0.1:3305 即可连接容器中的数据库，和 redis 一样 volumes: - .docker-volumes/mysql/log:/var/log/mysql # 记录日志 - .docker-volumes/mysql/data:/var/lib/mysql # 数据持久化 - ./mysql/init:/docker-entrypoint-initdb.d/ # 初始化 sql environment: - MYSQL_DATABASE=imooc_lego_course # 初始化容器时创建数据库 - MYSQL_ROOT_PASSWORD=Mysql_2019 - TZ=Asia/Shanghai # 设置时区 editor-mongo: image: mongo # 引用官网 mongo 镜像 container_name: editor-mongo restart: always volumes: - '.docker-volumes/mongo/data:/data/db' # 数据持久化,映射本地文件 environment: - MONGO_INITDB_DATABASE=imooc_lego_course - TZ=Asia/Shanghai # 设置时区 ports: - '27016:27017' # 宿主机可以用 127.0.0.1:27016 即可连接容器中的数据库 构建容器 docker-compose build 启动所有服务器 docker-compose up -d,后台启动 查看服务 docker-compose ps (相比较 docker ps 等于多了层作用域) 停止所有服务 docker-compose down 注意：经过以上操作之后需修改.gitignore 文件，增加一行 .docker-volumes/","link":"/2022/07/31/docker%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"},{"title":"jQuery学习","text":"jQuery 学习 入口函数 jQuery 入口函数 1234567$(document).ready(function(){ //执行代码})或者（简写）$(function(){ //执行代码}) javascript 入口函数 123window.onload = function(){ //执行代码} jQuery 的入口函数是在 html 的所有标签 DOM 都加载之后，就会执行包裹的代码，可以执行多次，并且不会覆盖上次。 javascript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完成后，才会执行，只能执行一次，如果第二次会把第一次的执行覆盖。 jQuery 选择器 元素选择器 1$(&quot;p&quot;) id 选择器 1$(&quot;#test&quot;) class 选择器 1$(&quot;.test&quot;) 属性选择器 1$(&quot;[href]&quot;) :empty 选择器 123$(&quot;:empty&quot;)//选择空的元素，既不不含子元素也不包含文本的元素$(&quot;div:empty&quot;) //选择div中为空的div元素 :parent 选择器 12$(&quot;td:parent&quot;)//选取所有带有子元素或文本的&lt;td&gt;标签元素 :contains 选择器 12$(&quot;div:contains('hello')&quot;)//找到div中包含文本hello的指定元素 :has 选择器 12$(&quot;div:has(p)&quot;)//找到包含p标签元素的div 补充 1$(&quot;:button&quot;) //获取所有type为button的&lt;input&gt;元素和&lt;button&gt;元素，去掉冒号，只能获取&lt;button&gt;元素。 常用 jQuery 事件方法 click() 点击事件 123$(&quot;p&quot;).click(function(){ $(this).hide();}) dblclick() 双击事件 123$(&quot;p&quot;).dblclick(function(){ $(this).hide();}) mouseenter() 鼠标指针穿过元素时 123$(&quot;p&quot;).mouseenter(function(){ alert(&quot;您的鼠标移到了p标签元素上！&quot;)}) mouseleave() 鼠标指针离开元素时 123$(&quot;p&quot;).mouseleave(function(){ alert(&quot;您的鼠标离开了该p标签元素！&quot;)}) mouseup() 当在元素上松开鼠标时 123$(&quot;p&quot;).mouseup(()=&gt;{ alert(&quot;鼠标在p标签上松开！&quot;)}) hover() 模拟光标悬停事件 12345678$(&quot;p&quot;).hover( function(){ alert(&quot;你进入了p标签！&quot;); }, function(){ alert(&quot;你离开了p标签！&quot;); }) focus() 当元素获得焦点时 123$(&quot;input&quot;).focus(function(){ $(this).css(&quot;background-color&quot;,&quot;#ccc&quot;);}) blur() 当元素失去焦点时 123$(&quot;input&quot;).blur(function(){ $(this).css(&quot;background-color&quot;,&quot;#fff&quot;);}) keypress,keydown,keyup 123456789101112131415161718//获取按键代码或ASCII码$(window).keydown(function(event){ //通过event.which可以拿到按键代码，如果是keypress事件中则拿到ASCII码。 console.log(event);})//获取事件对象$(window).keypress(function(event){ //获取事件对象，里面包含各种有用的信息。 console.log(event); //console.log(event.which);});//keypress事件获取键入的字符$(window).keypress(function(event){ //event.which是获取ASCII码，前面的函数是将ASCII码转换成字符，空格键和Enter键输出均为空白。 console.log(String.fromCharCode(event.which)); //从event对象中key属性获取字符，但是Enter键的key值为&quot;Enter&quot;，空白键还是空白&quot; &quot;。 console.log(event.key);}); off() 事件移除 12345$(&quot;button&quot;).off() //移除所有button元素身上绑定的事件$(&quot;button&quot;).off(&quot;click&quot;) //移除所有的click事件，移除指定类型$(&quot;button&quot;).off(&quot;click&quot;, test) //移除click事件中的test回调方法，移除指定类型的事件 阻止事件冒泡 123456789$(&quot;.son&quot;).click(function(event){ alert(&quot;son&quot;) //return false; event.stopPropagation(); //阻止事件冒泡})$(&quot;.father&quot;).click(function(){ alert(&quot;father&quot;)}) 阻止默认行为 12345//a标签跳转、submit提交按钮等$(&quot;a&quot;).click(function(event){ alert(&quot;弹出注册框！&quot;); event.preventDefault();}) trigger()、triggerHandler() 自动触发事件 12345678910111213//触发绑定到被选元素的所有事件$(&quot;.father&quot;).click(function(){ alert(&quot;father&quot;);})$(&quot;.father&quot;).trigger(&quot;click&quot;); //方法一:会触发事件冒泡$(&quot;.father&quot;).triggerHandler(&quot;click&quot;); //方法二:只触发事件，不会触发事件冒泡-------------------------------$(&quot;input[type='submit']&quot;).click(function(){ alert(&quot;submit&quot;);})$(&quot;input[type='submit']&quot;).trigger(&quot;click&quot;); //方法一：触发事件的同时，还会触发默认行为。$(&quot;input[type='submit']&quot;).triggerHandler(&quot;click&quot;) //方法二：只触发事件，不触发默认行为。//注意：这里&lt;a&gt;标签有点特殊，这两个方法都不会触发默认行为，如果想使用trigger()触发&lt;a&gt;标签的事件和默认行为的话，可以在&lt;a&gt;标签中添加一个&lt;span&gt;,例如&lt;a href =&quot;#&quot;&gt;&lt;span&gt;百度&lt;/span&gt;&lt;/a&gt; 这种写法。 自定义事件 1234567891011121314/** 想要自定义事件，必须满足两个条件* 1.事件必须是通过on绑定的* 2.事件必须通过trigger来触发*/$(&quot;.son&quot;).on(&quot;myClick&quot;,function(){ alert(&quot;son&quot;);})$(&quot;.son&quot;).trigger(&quot;myClick&quot;);or$(&quot;.son&quot;).triggerHandler(&quot;myClick&quot;); 事件命名空间 12345678910111213141516/** 想要事件的命名空间有效，必须满足两个条件* 1.事件通过on来绑定(自定义事件)* 2.通过trigger()或者triggerHandler()来触发*/$(&quot;.son&quot;).on(&quot;eventName.zs&quot;,function(){ alert(&quot;click zhangsan&quot;);})$(&quot;.son&quot;).on(&quot;eventName.ls&quot;,function(){ alert(&quot;click lisi&quot;);})$(&quot;.son&quot;).trigger(&quot;click.zs&quot;);or$(&quot;.son&quot;).triggerHandler(&quot;click.zs&quot;); 隐藏和显示 hide() 隐藏 html 元素 123$(&quot;#hide&quot;).click(function(){ $(&quot;p&quot;).hide();}) show() 显示 html 元素 123$(&quot;#show&quot;).click(function(){ $(&quot;p&quot;).show();}) 语法 12345678910111213141516$(selector).hide(speed,callback);$(selector).show(speed,callback);//可选的speed参数表示规定显示/隐藏的速度(slow、fast、毫秒)//可选的callback参数是隐藏或显示完成后所执行的函数名称$(&quot;.hidebtn&quot;).click(function(){ $(&quot;div&quot;).hide(1000,&quot;linear&quot;,function(){ alert(&quot;Hide() 方法已完成!&quot;); });});//第二个参数是一个字符串，表示过渡使用哪种缓动函数，jQuery自身提供(linear、swing)//补充：callback函数名后面加上括号，会立刻执行函数体，而不是等到显示/隐藏之后才执行,如add()作为callback参数会立即执行，而add作为参数则不会，callback函数可以是匿名函数，$(selector)选中的元素个数为n个，则callback函数会执行n次。 toggle() 切换 hide()和 show()方法 123$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).toggle();}) 淡入淡出 fadeIn() 用于淡入以隐藏的元素 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeIn(3000);})//语法： $(selector).fadeIn(speed, callback)// 可选的speed参数规定效果的时长(slow、fast、毫秒)// 可选的callback参数是fading完成后所执行的函数名称 fadeOut() 用于淡出可见元素 12345678$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeOut(&quot;slow&quot;);})//语法： $(selector).fadeOut(speed, callback)// 可选的speed参数规定效果的时长(slow、fast、毫秒)// 可选的callback参数是fading完成后所执行的函数名称 fadeToggle() 用于在 fadeIn()与 fadeOut()方法之间进行切换 12345678$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeToggle();})//语法： $(selector).fadeToggle(speed, callback)// 可选的speed参数规定效果的时长(slow、fast、毫秒)// 可选的callback参数是fading完成后所执行的函数名称 fadeTo() 允许渐变为给定的不透明度 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.3);})//语法：$(selector).fadeTo(speed, opacity, callback)//必须的speed参数规定效果时长(slow、fast、毫秒)//必须的opacity规定不透明度(介于0-1之间) 滑动方法 slideDown() 用于元素向下滑动 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).slideDown();})//语法：$(selector).slideDown(speed,callback)//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。//可选的 callback 参数是滑动完成后所执行的函数名称。 slideUp() 用于元素向上滑动 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).slideUp();})//语法：$(selector).slideUp(speed,callback)//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。//可选的 callback 参数是滑动完成后所执行的函数名称。 slideToggle() 在 slideDown()与 slideUp()方法之间进行切换 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).slideToggle();})//语法：$(selector).slideToggle(speed,callback)//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。//可选的 callback 参数是滑动完成后所执行的函数名称。 动画 animate()方法 123456789101112131415//默认情况下，所有html元素都有一个静态位置，且无法移动。//先将p标签元素设置为position:relative/absolute/fixed$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).animate({ left:'250px', opacity:'0.5', height:'400px', width: '400px', paddingLeft:'10px' });});//语法： $(selector).animate({params},speed,callback)// params参数可以操作几乎所有的css属性，但名字要采用camel标记法 stop() 停止动画 1234567891011 $(&quot;#flip&quot;).click(function(){ $(&quot;#panel&quot;).slideDown(5000); });$(&quot;#stop&quot;).click(function(){ $(&quot;#panel&quot;).stop();});语法: $(selector).stop(stopAll,goToEnd)//可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停/止活动的动画，允许任何排入队列的动画向后执行。//可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 jQuery 方法链接 123$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;) .slideUp(2000) .slideDown(2000); jQuery 获取内容和属性 获取内容 text()、html()、val() text() 设置或返回所选元素的文本内容 html() 设置或返回所选元素的内容(包括 html 标记) val() 设置或返回表单字段的值 1234567891011$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).text());})//-----------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).html())})//------------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;input&quot;).val());}); 获取属性 attr() 12345//项目QC刚用过$(&quot;button&quot;).click(function(){ console.log($(&quot;p&quot;).attr(&quot;data-text&quot;));}) 补充： 12345prop()函数返回相应属性或空字符串。attr()函数返回相应属性或undefined1.对于HTML元素本身就带有的固有属性，在处理时使用prop方法2.对HTML元素我们自己定义的DOM属性，在处理时使用attr方法3.具有true和false两个属性的属性，如checked、selected或者disabled使用prop() 设置内容和属性 设置内容 text()、html()、val() 1234567891011$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).text(&quot;hello&quot;));})//-----------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).html(&quot;hello&quot;))})//------------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;input&quot;).val(&quot;hello&quot;));}); text()、html() 以及 val() 的回调函数 123456789$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).text(function(i,orignText){ //i 为被选元素列表中当前元素的下标 //orignText 为原来的值 //return 为返回的新值 return &quot;hello&quot; })}) 设置属性 attr() 12345678910$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).attr(&quot;data-text&quot;,&quot;hello world&quot;);})// 允许同时设置多个属性$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).attr({ &quot;data-text&quot;,&quot;hello world&quot;, &quot;title&quot;,&quot;jQuery学习！&quot; });}) attr() 也存在回调函数(同上) 12345$(&quot;button&quot;).click(function(){ $(&quot;#runoob&quot;).attr(&quot;href&quot;, function(i,origValue){ return origValue + &quot;/jquery&quot;; });}); 删除属性 removeAttr() 12$(&quot;span&quot;).removeAttr(&quot;class name&quot;);//表示同时删除span标签的class和name属性 removeProp() 12$(&quot;span&quot;).removeProp(&quot;class&quot;);//表示删除所有span标签的class属性 jQuery 添加元素 append/prepend 是在选择元素内容嵌入(文本或标签) after/before 实在元素外部追加(文本或标签) 参数可以是多个，可以是一个 list jQuery 删除元素 remove() 方法 123$(&quot;p&quot;).remove()//remove() 方法删除被选元素及其子元素 empty() 方法 123$(&quot;p&quot;).empty()//empty() 方法删除被选元素的子元素而不删除自身 过滤被删除的元素 1234$(&quot;p&quot;).remove(&quot;.italic&quot;)//表示删除所有&lt;p&gt;标签元素中class = &quot;italic&quot;的元素//过滤时，只能作用于同级元素之间 jQuery 获取并设置 CSS 类 addClass() 向不用的元素添加 class 属性，在添加类时可以选取多个元素,也可以设置多个类。 123$(&quot;button&quot;).click(function(){ $(&quot;h1, h3, p&quot;).addClass(&quot;fontColor fontSize&quot;);}) removeClass() 在不同元素中删除指定的 class 属性 123$(&quot;button&quot;).click(function(){ $(&quot;h1, h3, p&quot;).removeClass(&quot;fontSize&quot;);}) toggleClass() 对被选元素进行添加/删除类的切换操作 123$(&quot;.btn2&quot;).click(function(){ $(&quot;h1, h3, p&quot;).toggleClass(&quot;fontColor2&quot;);}) css() 方法 返回 css 属性 1$(&quot;p&quot;).css(&quot;background-color&quot;); 设置 css 属性,可以同时设置多个 1$(&quot;p&quot;).css({&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;}); 尺寸 width()、height() width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距） height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 12$(&quot;p&quot;).width() //获取$(&quot;p&quot;).width(20) //设置 innerWidth()、innerHeight() innerWidth() 方法返回元素的宽度（包括内边距）。 innerHeight() 方法返回元素的高度（包括内边距）。 outerWidth()、outerHeight() outerWidth() 方法返回元素的宽度（包括内边距和边框）。 outerHeight() 方法返回元素的高度（包括内边距和边框）。 offset() 12345$(&quot;.son&quot;).offset().left //元素距离窗口的偏移距离$(&quot;.son&quot;).offset({ left: 20,}) //设置元素距离窗口的偏移距离 position() 123$(&quot;.son&quot;).position().left //获取元素距离定位元素的偏移距离// 注意点：position() 方法只能获取不能设置 scrollTop() 123456789$(&quot;scroller&quot;).scrollTop() //获取元素相对滚动条顶部的偏移$(&quot;scroller&quot;).scrollTop(300) //设置元素相对滚动条顶部的偏移//获取网页滚动的偏移(考虑兼容)$(&quot;body&quot;).scrollTop() + $(&quot;html&quot;).scrollTop() //ie-&gt;body,chrome...-&gt;html//设置网页滚动的偏移(考虑兼容)$(&quot;html,body&quot;).scrollTop(300) 补充：设置了 box-sizing 后，width()=width - padding - border jQuery 遍历祖先 parent() 返回元素的直接父元素 123$(document).ready(function(){ $(&quot;span&quot;).parents();}) parents() 返回被选元素的所有祖先元素，直到文档根元素 1234567$(document).ready(function(){ $(&quot;span&quot;).parents();})//过滤所有祖先，并且是&lt;ul&gt;元素$(document).ready(function(){ $(&quot;span&quot;).parents(&quot;ul&quot;);}) parentsUntil() 返回给定的两个元素之间的所有祖先元素 1234//返回&lt;span&gt;与&lt;div&gt;元素之间的所有祖先元素$(document).ready(function(){ $(&quot;span&quot;).parentsUntil(&quot;div&quot;);}) 后代 children() 返回被选元素的所有直接子元素 1234$(&quot;div&quot;).children();//可以使用可选参数来过滤子元素的搜索$(&quot;div&quot;).children(&quot;p.aaa&quot;); //返回类名为aaa的&lt;p&gt;元素，且是div的直接子元素。 find() 返回被选元素的后代元素，一路向下直到最后一个后代 1$(&quot;div&quot;).find(&quot;span&quot;); 同胞 siblings() 返回被选元素的所有同胞元素，可以使用可选参数过滤搜索。 next() 返回被选元素的下一个同胞元素，只返回一个元素 nextAll() 返回被选元素的所有跟随的同胞元素 nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素 pre()、prevAll()、prevUntil() 同上，方向相反 过滤：缩小搜索元素的范围 first() 返回被选元素的首个元素 1$(&quot;p&quot;).first(); last() 返回被选元素的最后一个元素 1$(&quot;p&quot;).last(); eq() 返回被选元素中带有指定索引号的元素 123$(&quot;p&quot;).eq(1);//索引号从0开始，eq(1)选择的是第二个&lt;p&gt;元素 filter() 允许规定一个标准，返回匹配的元素 123$(&quot;p&quot;).filter(&quot;.className&quot;);//返回带有类名className的所有&lt;p&gt;元素 not() 返回所有不匹配的元素，与 filter()相反 123$(&quot;p&quot;).not(&quot;.className&quot;);//返回所有不带有类名className的&lt;p&gt;元素","link":"/2020/09/05/jquery%E5%AD%A6%E4%B9%A0/"},{"title":"Node.js之express","text":"Node.js 之 express 123456789101112131415161718192021222324//引包var express = require('express');//相当于原来的http.createServervar app = express();//公开指定目录app.use('/puclic/', express.static('./public/'));//当省略第一个参数的时候，可以通过省略/public的方式访问//app.use(express.static('./public/'))//当服务器收到get请求 / 的时候，执行回调函数app.get('/', function (req, res) { res.send('hello exporess');});app.get('/about', function (req, res) { res.send('hello world');});//相当于server.listenapp.listen(3000, function () { console.log('app is running at port 3000');}); Express 使用 art-template Express&amp;art-template 官网 Install 12npm install --save art-templatesnpm install --save express-art-template Example 1234567891011121314151617181920var express = require('express');var app = express();// view engine setupapp.engine('art', require('express-art-template'));app.set('view', { debug: process.env.NODE_ENV !== 'production'});app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'art');// routesapp.get('/', function (req, res) { res.render('index.art', { user: { name: 'aui', tags: ['art', 'template', 'nodejs'] } });}); body-parser 在 Express 中没有内置获取表单 POST 请求体的 API，需要引入一个第三方包：body-parser Install 1npm install --save body-parser config 1234567var express = require('express')var bodyParser = require('body-parser')var app = express()//配置 body-parser,req对象上就会多出来一个 body 属性app.use(bodyParser.urlencoded({extended: false}))app.use(bodyParser.json()) use 12345app.use(function(req, res){ res.setHeader('Content-Type', 'text/plain') res.write('hello') res.end()})","link":"/2019/09/08/express%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/"},{"title":"JS垃圾回收机制","text":"谈谈 JS 垃圾回收机制？ 垃圾回收Javascript中的内存管理是自动执行的，而且是不可见的。在我们创建基本类型、对象、函数 时，这些都需要内存，当不需要某样东西时，JavaScript引擎会利用垃圾回收机制清除它。 在局部作用域中，当函数执行完毕，局部变量也就没必要存在了，因此垃圾收集器很容易 做出判断回收。但是全局变量什么时候需要自动释放内存空间很难判断，因此在开发中， 需要尽量避免使用全局变量。 可达性JavaScript 中内存管理的主要概念是可达性。 当一些值以某种方式可访问或可用，它们会被存储在内存中，叫做可达值。 一些固有可达值，由于显而易见的原因无法删除。例如： 本地函数的局部变量或参数 当前嵌套调用链上的其他函数的变量和参数 全局变量等 这些值 称为 根 如果引用或引用链 可以从根访问任何其他值，则认为该值是可访问的。 一个对象引用另一个对象的属性，则该对象是为可达性。 JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除哪些不可访问的对象。 内部算法v8 的垃圾回收策略基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同的算法。 新生代采用 Scavenge 算法(赋值算法) Scavenge 为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分为 from 和 to 两个空间。每次 gc,会将 from 空间的存活对象复制到 to 空间。然后两个空间角色对换(又称反转)。 该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。 老生代采用 Mark-Sweep(标记清除)和 Mark-Compact(标记整理) 标记-清除算法，定期执行一下“垃圾回收”步骤： 垃圾回收器获取根并“标记”它们 然后访问并标记所有来自它们的引用 然后访问标记的对象 并 标记它们的引用 以此类推，知道有为访问的引用为止 除了标记的对象外，所有对象都被删除。 Mark-Compact 算法(标记整理) 标记清除存在一个问题，清除死亡对象后会造成内存空间不连续，这时候 v8 会使用Mark-Compact 算法(标记整理)，它会在标记完成之后将活着的对象往一端移动，移动完成后直接清理掉边界外的内存。 Reference Counting(引用计数算法) 引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为 0 则直接回收内存。 很明显，引用计数最大的优势是暂停时间短 优化 增量回收：如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分，然后各个部分分别执行，这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。 空闲时间收集：垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。 v8 的内存限制 64 位系统最大约为 1.4G 32 位系统最大约为 0.7G","link":"/2019/10/19/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"title":"http深入浅出","text":"HTTP 简介 HTTP(HyperText Transfer Protocol)超文本传输协议，是万维网(World Wide Web)的基础协议 HTTP/0.9 (1991) 仅仅支持 GET 请求 不包含 HTTP 头，只能传输 HTML 文件 没有状态码和错误代码 HTTP/1.0 (1996) 发送时添加 协议版本信息 (/HTTP/1.1) 添加响应状态码，如 200，404 等 引入 HTTP 头，多了传递信息的手段，更加灵活和方便拓展 HTTP 头引入 content-type 属性，具备了传输除纯文本 HTML 文件以外其他类型文档的能力 HTTP/1.1 (1997) 连接复用，长链接。多个请求复用同一个 tcp 连接，1.0 每次请求都需要重新建立连接(Connection: keep-alive Keep-Alive:timeout=5) 管道化技术：多个连续的请求不用等待返回就可以被发送，减少网络延迟的耗时 响应分块：单个请求返回部分内容(状态码 206) 新的缓存控制机制，引入 cache-control,eTag 新增 host 请求头，能够使不同域名配置在同一个 IP 地址服务器上 12345GET / HTTP/1.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-alive HTTPS https(Hypertext Transfer Protocal Secure):超文本传输安全协议，在 http 基础上加了 secure 安全 https 是 http 协议的一种扩展，使用传输层安全性TLS或安全套接字层SSL对通信协议进行加密 HTTP2 二进制帧 多路复用 头部压缩 服务端推送 HTTP3 基于 UDP 的传输层下协议，特点快 创建一个简单的 http 服务123456789101112131415//加载http核心模块var http = require('http')var server = http.createServer()//服务器要做的处理事情server.on('request', function() { console.log('收到客户端的请求了')})//绑定端口号，启动服务器server.listen(3000, function(){ console.log('server start.....')}) 请求处理123456789101112131415161718192021222324252627var http = require('http')var server = http.createServer()//request 请求处理函数，需要接受两个参数server.on('request', function(request, response) {// request 请求对象// 请求对象可以获取客户端的一些请求信息，如请求路径 console.log('收到客户端的请求了,路径是：'+ request.url)// response 响应对象// 响应数据只能是二进制数据或者字符串// 响应对象可以用开给客户端发送响应消息// response对象中：write给客户端发送响应数据，最后使用end结束 response.write('hello') response.write(' nodejs ') response.end(request.url)// 或者直接end的同时发送响应数据：// response.end('hello nodejs')})server.listen(3000, function(){ console.log('server start.....')}) Content-Type 设置编码123456789101112var http = require('http')var server = http.createServer()server.on('request',function (req,res) { //设置服务器响应内容的编码 res.setHeader('Content-Type','text/plain;charset=utf-8') res.end('hello 世界')})server.listen(3000, function () { console.log('server is running...')})","link":"/2019/09/06/http%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/"},{"title":"js引擎的预编译和执行","text":"var 的变量提升底层原理 JavaScript引擎，不是逐条解释执行javascript代码，而是按照代码块一段段解释执行， 所谓代码块就是script标签分割的代码块。 js引擎的工作方式分为：预编译和执行代码两个阶段。 1）常见的编译型语言编译阶段：词法分析（生成词法单元）——&gt;语法分析（抽象语法树）——&gt;(语义检查，代码优化)——&gt;代码生成 2）对于解释型语言来说，通过词法分析和语法分析得到抽象语法树之后就开始执行了，在JavaScript 解释器在构造语法树的时候，如果无法构造，就会报语法错误，并结束整个代码块的执行。 而在整个编译阶段，会把“一等公民”function和var创建的变量进行提升。（其中函数提升在变量 提成之前） 3）JavaScript语法采用的是词法作用域，也就是javascript的变量和函数作用域是在定义时 决定的，函数调用时决定的是执行期上下文和作用域链，所以js解释器只需要静态分析就能确定每个 变量、函数的作用域，这种作用域也称为静态作用域。 执行上下文 全局执行上下文：默认的上下文，任何不再函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象(浏览器的情况下)，并且设置 this 的值等于这个全局对象。一个程序只会有一个全局执行上下文。 函数执行上下文：每当函数被调用时，都会为该函数创建一个新的上下文。 Eval 函数执行上下文：执行在 eval 函数内部的代码也会有属于它自己的执行上下文。 执行栈：JavaScript 引擎会以栈的方式来处理多个执行期上下文其他语言叫“调用栈”，类似于数据结构的栈 LIFO(后进先出)，用来存储代码运行时创建的所有执行上下文。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当 JavaScript 引擎第一次遇见脚本时，它会创建一个全局的执行上下文并且压入当前执行栈，每当引擎遇到一个函数调用，会为该函数创建一个新的执行上下文并压入栈的顶部。 引擎会执行那些执行上下文位于栈顶的函数，当函数执行结束时，执行上下文从栈顶弹出，控制流程到达当前栈中的下一个上下文。 当函数执行时，会创建一个成为 执行期上下文的内部对象。 执行期上下文就是 js 代码被解析和执行时的运行环境，函数每次执行都会创建一个独一无二的执行上下文，所以多次调用会产生多个执行上下文，当函数执行完毕，所产生的执行上下文被销毁。 执行上下文的生命周期包括三个阶段：创建阶段-&gt;执行阶段-&gt;挥手阶段 创建阶段会创建变量对象(Variable Object)，建立作用域链，确定 this 指向 1. 创建 Scope chain 2. 创建 AO 3. 设置 this 的值创建 AO 主要做了以下事情： 1. 创建 AO 对象 2. 形参和变量声明存储到 AO 对象 //赋值为 undefined 3. 将形参和实参相统一 4. 函数声明的函数名作为 AO 对象的 key，函数体作为 value 执行阶段会完成变量赋值，函数引用，以及执行其他代码。 AO(Active Object) &amp; VO(Variable Object)的区别？ VO：未进入执行上下文执行阶段之前，变量对象中的属性都不能访问。 AO：进入执行阶段之后，变量对象转变为活动对象，里面的属性都能访问了。 它们都是同一个对象，只是处于执行上下文的不同生命周期，而且只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。 如果函数引用了外部变量的值，则 JavaScript 引擎会为改函数创建一个闭包体（closure），闭包体是一个完全封闭和独立的作用域，他不会在函数调用完毕后就被 js 引擎当作垃圾进行回收，闭包体可以长期存在。 执行上下文总结： 单线程 同步执行，只有栈顶的上下文处于执行中，而其他上下文需要等待 全局上下文只有唯一的一个，它在浏览器关闭时出栈，而且其他所有上下文环境都可以直接访问全局上下文的属性 函数的执行上下文的个数没有限制 每次某个函数被调用，就会有新的执行上下文为其创建，即使是调用的自身函数，也是如此。 JS 执行机制同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入Event Table 并注册函数。 当指定的事情完成时（例如定时器执行完毕，获取数据结束等），Event Table会将这个函数移入Event Queue 主线程内的任务执行完毕为空，会去Event Queue（事件队列）读取对应的函数，进入主线程执行。 上述过程不断重复，称为Event Loop（事件轮询）","link":"/2019/08/13/js%E5%BC%95%E6%93%8E%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"title":"lerna开发","text":"创建 npm 私服 verdaccio 是一个简单、零配置的本地私有化 npm 仓库 123456cnpm install verdaccio -gverdacciohttp://localhost:4873npm adduser --registry http://localhost:4873/npm publish --registry http://localhost: 4873/ lerna 常用命令项目初始化| 命令 | 说明 || — | — || lerna init –independent | 初始化项目 | 创建包| 命令 | 说明 || — | — || lerna create module-1 | 创建 package || lerna add | 安装依赖 || lerna link | 链接依赖 | 开发和测试| 命令 | 说明 || — | — || lerna exec | 执行 shell 脚本 || lerna run | 执行 npm 命令 || lerna clean | 清空依赖|| lerna bootstrap | 重新安装依赖 | package 依赖 1234567891011121.给指定package安装依赖$ lerna add lodash packages/module-1$ lerna add lodash --scope=module-1$ lerna add lodash **/module-1$yarn workspace module-1 add lodash2.给所有package安装依赖$ lerna add lodash3.workspace之间的依赖$ lerna add module-2 packages/module-1$ lerna add module-2 --scope module-1 发布 1$ lerna publish lerna.json version: 当前仓库的版本，independent mode 请设置为 independent. lerna 对于包的管理有两种模式：固定模式 fixed、独立模式 independent。 固定模式所有包是统一的版本号，每次升级所有包统一更新，无论这个包内容是否改变。 *具体体现在 lerna 的配置文件中 lerna.json 中永远会存在一个确定版本号：{“version”: “0.0.1”} 独立模式，每个包都是单独的版本号，每次 lerna 触发发布命令，每个包的版本都会单独变化，具体体现在 lerna 的配置文件 lerna.json 中没有一个确定的版本号，而是{“version”:”independent”} npmClient: 指定运行的客户端程序 默认为 npm ignoreChanges: 一个不包含在lerna changed/publish的 glob 数组，使用这个阻止发布不必要的更新，比如修复README.md 123456789101112131415161718192021222324{ &quot;useWorkspaces&quot;: true, // 使用 workspaces 配置。此项为 true 的话，将使用 package.json 的 &quot;workspaces&quot;，下面的 &quot;packages&quot; 字段将不生效 &quot;version&quot;: &quot;0.1.0&quot;, // 所有包版本号，独立模式-&quot;independent&quot; &quot;npmClient&quot;: &quot;cnpm&quot;, // npm client，可设置为 cnpm、yarn 等 &quot;packages&quot;: [ // 包所在目录，可指定多个 &quot;packages/*&quot; ], &quot;command&quot;: { // lerna 命令相关配置 &quot;publish&quot;: { // 发布相关 &quot;ignoreChanges&quot;: [ // 指定文件或目录的变更，不触发 publish &quot;.gitignore&quot;, &quot;*.log&quot;, &quot;*.md&quot; ] }, &quot;bootstrap&quot;: { // bootstrap 相关 &quot;ignore&quot;: &quot;npm-*&quot;, // 不受 bootstrap 影响的包 &quot;npmClientArgs&quot;: [ // bootstr 执行参数 &quot;--no-package-lock&quot; ] } }} CRA + lerna + react + typescript 项目搭建12345678910111213141.create-react-app demo --template typescript2.cd demo3.npm run eject4.lerna init5.lerna create builder-script6.自定义builder-scripts脚本命令7.自定义 eslintrc、tsconfig、webpack等配置项","link":"/2021/11/01/lerna%E5%BC%80%E5%8F%91/"},{"title":"Node.js之mongoDB","text":"开启 MongoDB 服务器 1mongod 连接 MongoDB 服务器1mongo 退出 MongoDB 服务器1exit 基本命令 show dbs 查看显示所有数据库 db 产看当前操作的数据库 use 数据库名称 切换到指定的数据库（没有会新建） show collections 显示集合 db.cats.find() 查看并显示内容 node 中使用 mongodb 使用第三方 mongoose 来操作 MongoDB 数据库 mongoose 安装npm install mongoose 123456789101112131415//引入包const mongoose = require('mongoose');//连接数据库（数据库不需要存在，在插入第一条语句，就会自动创建）mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});//设计数据库集合结构//创建一个Cat表const Cat = mongoose.model('Cat', { name: String });//实例化一个Cat，实例对象为kittyconst kitty = new Cat({ name: 'Zildjian' });//持久化保存kitty实例kitty.save().then(() =&gt; console.log('meow')); mongoose 的基本使用 生成模型构造函数 1234567891011121314151617181920212223242526272829303132333435var mongoose = require('mongoose');var Schema = mongoose.Schema;//设计集合结构（表结构）schema---&gt;提要，纲要//字段名称就是表结构中的属性名称//值类型//约束的目的：为了保证数的完整性var blogSchema = new Schema({ title: String, author: String, body: String, username: { type: String, required: true }, password: { typte: String, required: true } comments: [{ body: String, date: Date }], date: { type: Date, default: Date.now }, hidden: Boolean, meta: { votes: Number, favs: Number }});//将文档结构发布为模型// 参数一：大写单数表示数据库名称// mongoose会自动将大写单数改为小写复数// 参数二： 架构 Schema// 返回值： 模型构造函数var User = mongoose.model('User', blogSchema)// module.exports = mongoose.model('Student', blogSchema) 基于模型构造函数 生成添加一条数据 123456789101112var admin = new User({ username: 'admin', password: '1245435', ....})admin.save(function(err, ret){ if(err){ console.log('保存失败') } else { console.log('保存成功') }}) 基于模型构造函数 查询数据 12345678910111213141516171819202122232425262728293031323334353637//查询所有数据User.find(function(err, ret){ if(err){ console.log('查询失败') } else { console.log(ret) }})//promise 查询所有User.find() .then(function(data){ console.log(data) })//按条件查询 User.find({ username: 'xx' }, function(err, ret){ if(err){ console.log('查询失败') } else { console.log(ret) }})//查找符合条件的第一个（可以写多个条件）,没有条件的话，为第一条数据 User.findOne({ username: 'xx' }, function(err, ret){ if(err){ console.log('查询失败') } else { console.log(ret) }}) 基于模型构造函数 按条件更新数据 1234567891011//Model.update(conditions, doc, [options], [callback])//Model.findOneAndUpdate([conditions], [update], [options], [callback])User.findByIdAndUpdate('5a7d8f2sd78ag6g',{ username: 'zs'}, function(err, ret){ if(err){ console.log('更新失败') else { console.log('更新成功') }}) 基于模型构造函数 删除数据 123456789User.remove({ username: 'zs'}, function(err, ret){ if(err){ console.log('查询失败') else { console.log(ret) }}) 补充（node 使用 mysql）123456789101112131415161718192021222324252627//引包var mysql = require('mysql');//创建连接var connection = mysql.createConnection({ host : 'localhost', user : 'me', password : 'secret', database : 'my_db'}); //连接数据库connection.connect(); //执行数据操作,可以直接使用 SQL 语句 //查找connection.query('SELECT * FROM `users`', function (error, results, fields) { if (error) throw error; console.log('The solution is: ', results[0].solution);});//添加 connection.query('INSERT INTO users VALUES(NULL, &quot;admin&quot;:&quot;123&quot;)', function (error, results, fields) { if (error) throw error; console.log('The solution is: ', results[0].solution); }); //关闭数据库connection.end();","link":"/2019/09/09/mongodb%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/"},{"title":"Node.js之特性","text":"Node.js 是什么? Node.js 是一个 JavaScript 运行时环境，可以解析和执行 js 代码。 构建于 Chrome 的 V8 引擎之上 没有 BOM、DOM，有 EcmaScript 语法。 node 中有很多具名的核心模块 fs 文件操作模块 http 服务器构建模块 path 路径模块 os 操作系统信息模块 在核心模块中提供了一些服务器级别的操作 API - 文件读写 - 网络服务的构建 - 网络通信 - http 服务器 node 都有哪些特性？ 单线程 不会为每个用户连接创建一个新的线程，仅仅使用一个线程，减少了操作系统的线程创建和销毁的时间开销。缺点就是一个用户造成线程的崩溃会导致整个服务的崩溃。 减少内存的开销 事件驱动 event-driven node 中一个时刻只能执行一个事件回调函数，但是执行过程中，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。 非阻塞 I/O I/O 数据传输操作会阻塞代码的执行，极大降低了程序的执行效率,因为一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。非阻塞 I/O 机制，可以将异步操作的处理代码放在回调函数中，从而提高了程序的执行效率。 浏览器的进程和线程 一个程序可以有多个进程 一个进程可以有多个线程 进程在执行 u 欧城中拥有独立的内存单元，而多个线程共享内存。 多个线程之间可以相互通信 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口 线程不能独立执行，必须依存在应用程序中 Node.js 适合开发什么？ 善于 I/O,不善于计算，因为 Node.js 最擅长的就是任务调度，不适合于利用 CPU 进行过多的运算的程序。 当应用程序需要处理大量并发的 I/O,而在向客户端发出响应之前，应用程序内部不需要进行非常复杂处理的时候，Node.js 非常合适。 Node.js 也非常适合与 web socket 配合，开发长连接的实时交互应用程序。 用户表单 考试系统 聊天室 图文直播 nodejs 能做什么？ Node.js 可以生成动态页面内容 Node.js 可以创建，打开，读取，写入，删除和关闭服务器上的文件 Node.js 可以收集表单数据 Node.js 可以添加，删除，修改数据库中的数据 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务器渲染可以被爬虫抓取 例如：京东商品列表是服务端渲染，用户评论是客户端渲染（提高用户体验） 小补充：使用 cnpm 方法一 安装 cnpm npm install --global cnpm 方法二 改变 registry npm install jquery --registry=https://registry.npm.taobao.org 方法三 加入配置选项 npm config set registry https://registry.npm.taobao.org npm config list 用 nodejs 实现读取文件操作 const fs = require(&quot;fs&quot;) //fs 核心模块提供了一个fs.readFile方法，用来读取指定目录下的文件 //fs.readFile有三个参数 // 1. 读取文件的路径 // 2. 读取文件的编码格式 // 3. 当文件读取完成，调用这个callback回调函数来读取文件的结果 fs.readFile('./data/hello.txt','utf-8',function(err,data){ if(err){ console.log(err) //第一个参数是err对象 return } else { console.log(data) //第二个参数才是data数据 } }) 用 nodejs 实现写入文件操作const fs = require('fs') let msg = 'hello world' //fs.writeFile有三个参数 // 1. 第一个参数为写入的文件路径 // 2. 第二个参数为写入的内容 // 3. 第三个参数为可选参数，表示写文件的编码格式 // 4. 第四个参数为回调函数，回调函数只有一个参数err，判断是否写入成功。 fs.writeFile('./data/hello.txt',msg,'utf-8',function(err){ if(err){ console.log('写入错误' + err) } else { console.log('ok') } })","link":"/2019/08/29/node.js%E4%B9%8B%E7%89%B9%E6%80%A7/"},{"title":"React深入浅出知识链路","text":"React 的基本认识 Fecebook 开源的一个 js 库 一个用来动态构建用户界面的 js 库 React 的特点： 声明式编程 组件化编程 高效 单向数据流 支持客户端与服务端渲染 React 高效的原因 虚拟 DOM，不直接操作 DOM(批量更新，减少更新的次数) 高效的 DOM Diff 算法，最小化页面重绘(减小页面更新的区域) React 中的生命周期函数生命周期函数是指组件在某一时刻自动执行的函数 初始化过程（Initialization） 在 constructor()里面初始化 Props 和 State 属性。 getDefaultProps()可以设置组件的默认属性值。 挂载过程（Mounting） componentWillMount(): 在组件即将被挂载到页面的时刻自动执行。 render(): 将组件挂载到页面。 componentDidMount(): 组件被挂载到页面之后立即执行。 更新过程（Updation） componentWillReceiveProps()（在 16.4 版本中废弃，不推荐使用）：一个组件从父组件接受参数，如果这个组件第一次存在父组件中不会执行，已经存在才会执行，如果没有 Props 属性则直接跳过。 shouldComponentUpdate():组件更新前检查是否需要更新组件，返回布尔类型。此生命周期函数可以强制关闭不需要更新的子组件来提高渲染性能。 componentWillUpdate():组件更新之前自动执行。前提是 shouldComponentUpdate()执行并返回 true-render():将组件更新到页面-componentDidUpdate():组件更新完成之后立即执行。 移除过程（Unmounting） componentWillUnmount():当组件即将从页面中移除时执行。 注意事项 React 中的 render() 也是生命周期函数，而 constructor()并不是生命周期函数。 所有的组件都有生命周期函数。 除了 render()函数，其他函数都可以不写，因为除了 render()函数其他函数都是继承自React 中内置的。 AJAX 请求一般都是放在 componentDidMount()里面。 React 状态提升 所谓状态提升，就是将 各个子组件的公共 state 提升到它们的父组件进行统一存储、处理(单一数据源)，然后将父组件处理后的数据或者函数 props 到各个子组件中。 如果子组件要修改父组件中 state 该怎么办？ 做法就是将父组件中负责 setState 的函数，以 props 的形式传给子组件，然后子组件需要改变 state 时调用即可。 React Router React Router 包装了 BrowserRouter 和 HashRouter 两个组件。 BrowserRouter 使用 HTML5 的 history API(pushState、replaceState 等)实现UI 和 URL 的同步 HashRouter 使用 URL 的 hash 实现应用的 UI 和 URL 同步 React Hooks useState 123456789101112131415161718192021222324252627282930313233343536//用法：//useState唯一的参数就是初始state//返回一个数组，第一项state，第二项更新state的函数const [number, setNumber] = useState(0);//函数式更新//如果新的state需要通过使用以前的state计算得出，可以将函数传递给setState。//例如：setCount((count) =&gt; { return count + 1})//惰性初始化state，对复杂初始数据，initialState可以是一个函数//函数或initialState参数只会在组件的初始渲染中起作用function Counter() { const [{name, number},setValue] = useState(() =&gt; { return {name:'计数器',number:0}; }) return ( &lt;div&gt; &lt;p&gt;{name}:{number}&lt;/p&gt; &lt;button onClick={() =&gt; setValue({number: number + 1})}&gt;+&lt;/button&gt; &lt;/div&gt; )}--------------//官网例子const [state, setState] = useState(() =&gt; { const initialState = someExpensiveComputation(props); return initialState;})//useState的初始值，只在第一次有效//按照有序的方式使用useState不得在循环判断等条件语句中使用//useState不会自动合并更新对象，需使用扩展符{...obj,name:'lisi'} useEffect 123456789101112131415161718192021//基本使用//useEffect有两个参数：function(执行项)，array(依赖项)useEffect(() =&gt; {},[name]);//如果依赖项为空数组，只会在第一次挂载后执行，类似componentDidMountuseEffect(() =&gt; {},[]);//清除副作用，模拟componentUnMount//通过返回一个函数来指定如何清除副作用，防止内存泄漏，函数会在组件卸载前执行useEffect(() =&gt; { let timer = setInterVal(() =&gt; { console.log(&quot;定时器&quot;); },1000) return () =&gt; { clearInterval(timer) }},[name])//注意：可以在组件中多次使用useEffect//Hook 允许我们按照代码的用途分离他们，react将按照effect声明的顺序依次调用组件中的每一个effect useContext 1234567891011121314//父组件创建上下文const Context = createContext();//并将数据传递给子组件const [num, setNum] = useState(0);&lt;Context.Provider value={{num, setNum}}&gt; &lt;Children /&gt;&lt;/Context.Provider&gt;//子组件接收const {num, setNum} = useContext(Context);useEffect(() =&gt; { setNum(num + 1);},[])&lt;p&gt;{num}&lt;/p&gt; useReducer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//基础使用const initialState = { count: 0 };function reducer(state, action){ switch(action.type) { case 'increment': return {count:state.count + 1}; case 'decrement': return {count:state.count - 1}; default: throw new Error(); }}function MyUseReducer() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; count: {state.count} &lt;button onClick={() =&gt; dispatch({type:'decrement'})}&gt;+&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type:'increment'})}&gt;+&lt;/button&gt; &lt;/&gt; )}//惰性初始化//稍加改造const initialCount = 0;function init(initialCount) { return {count: initialCount};}function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1}; case 'decrement': return {count: state.count - 1}; case 'reset': return init(action.payload); default: throw new Error(); }}function MyUseReducer() { const [state, dispatch] = useReducer(reducer, initialCount , init); return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({type: 'reset', payload: initialCount})}&gt; Reset &lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt; &lt;/&gt;》》 );} React 框架的关键设计思想：“组件”、“虚拟 DOM” 组件化: 工程化思想在框架中的落地12“封闭”：在组件自身的渲染工作流中，每个组件都只处理它的内部的渲染逻辑。“开放”：针对组件间通信来说，React基于“单向数据流”的原则完成组件间的通信。 虚拟 DOM：核心算法的基石：123组件初始化-&gt;render方法-&gt;生成虚拟DOM-&gt;ReactDOM.render方法-&gt;生成真实DOM组件更新-&gt;render方法-&gt;生成新的虚拟DOM-&gt;diff算法-&gt;定位两次虚拟DOM的差异-&gt;批量更新 componentWillReceiveProps(nextProps)1如果父组件导致子组件重新渲染，即使props没有更改，也会调用此方法，如果只想处理更改，请确保当前值和变更值的比较。---React官方 shouldComponentUpdate1React组件会根据shouldComponentUpdate的返回值来决定是否执行后面的生命周期进而决定是否对组件进行re-render(重渲染) getDerivedStateFromProps(新增)不是 componentWillMount(废弃)的替代品12345678910111213getDerivedStateFromProps有且仅有一个用途：使用props来派生/更新statestatic getDerivedStateFromProps(props, state)1.静态方法，访问不到this2.参数 props(父组件)和state(自身)3.对象格式的返回值，用来更新自身state（更新并非覆盖式，而是替换式更新）4.挂载和更新都会触发此钩子其他：getDerivedStateFromProps是作为一个试图代替componentWillReceiveProps的API出现的。getDerivedStateFromProps不能完全和componentWillReceiveProps画等号原因：getDerivedStateFromProps仅可以代替componentWillReceiveProps来实现基于props派生state，原则来说能且只能做这一件事。 getSnapshotBeforeUpdate(新增)与 componentWillUpdate(废弃)123getSnapshotBeforeUpdate(prevProps, prevState){}1. 执行时机在render方法之后，真实DOM更新之前2.返回值会作为第三个参数传递给componentDidUpdate Fiber 架构（核心：可中断、可恢复、优先级）123456789101112131415161.Fiber是React16对React核心算法的一次重写2.Fiber会使原本同步的渲染过程变成异步的3.Fiber会将一个大的更新任务拆解为许多个小任务(工作单元)，这些工作单元有着不同的优先级，react可以根据优先级的高低去实现工作单元的打断和恢复Fiber架构的重要特征就是可以被打断的异步渲染模式，根据能否被打断这一标准，React16的生命周期被划分为render和commit两个阶段render阶段在执行过程中允许被打断（因为此阶段用户不可见，打断也无影响）commit阶段总是同步执行（涉及到同步渲染，会影响用户直观体验）render阶段是允许暂停、终止和重启的，这就导致render阶段的生命周期都是有可能被重复执行，所以要废弃处于render阶段的一些生命周期：componentWillMount、componenntUpdate、componentWillReceiveProps、shouldComponentUpdate(一般不会在这个生命周期中进行副作用操作，所以相对风险不大，没有被废弃)每个更新任务都会被赋予一个优先级若B任务的优先级高于当前任务A，那么当前处于Reconciler层的A任务就会被中断，当B任务完成后，A任务就会被重新推入Reconciler层，继续它的渲染，这便是所谓的“可恢复”Fiber架构对生命周期的影响react15: render开始-&gt;停不下来的递归计算(同步)-&gt;commit提交渲染react16: render开始-&gt;工作单元｜工作单元｜工作单元...(异步)-&gt;commit提交渲染 组件间通信12UI = render(data) 或 UI = f(data)React的视图会随着数据的变化而变化 React-Hooks 的使用原则12345671.只在React函数中调用Hook2.不要在循环、条件和嵌套函数中调用Hook(要确保hooks在每次渲染时都保持同样的执行顺序)从源码调用流程看原理：Hooks的正常运作，在底层依赖于顺序链表。mountState首次渲染构建链表并渲染，updateState依次遍历链表并渲染hooks的渲染就是通过依次遍历来定位每个hooks的内容，如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然就是不可控的 虚拟 DOM1虚拟DOM本质上是JS和DOM之间的一个映射缓存，在形态上表现为一个能够描述DOM结构及其属性信息的JS对象。 Diff 逻辑的拆分与解读1231.Diff算法性能突破的关键点在于 分层对比2.类型一致的节点才有继续Diff的必要性3.key属性的设置，可以帮我们尽可能重用同一层级内的节点 setState 异步1234567setState-&gt;shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate批量更新：每来一个setState，就把它塞进一个队列里面存起来，等时机成熟，再把存起来的state结果做合并，最后只针对最后一次最新的state值走一次更新流程setState的表现会因为调用的场景不同而不同：1.在React钩子函数及合成事件中，表现为异步2.在setTimeout、setInterval等函数中，包括DOM原生事件中，表现为同步。 ReactDOM.render 调用栈的逻辑分层1待补充 React 事件系统123当事件在具体的DOM节点上被触发后，最终都会冒泡到document上，document上所绑定的统一事件处理程序会将事件分发到具体的组件实例react合成事件：在底层抹平了不同浏览器的差异，在上层面向开发者暴漏统一的、稳定的、与DOM原生事件相同的事件接口（原生DOM事件可以通过e.nativeEvent查看）","link":"/2021/10/05/react%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF/"},{"title":"koa-generator快速搭建koa服务","text":"1.全局安装koa-generator脚手架 123npm install -g koa-generator# oryarn global add koa-generator 创建koa项目1234koa2 project-name// 使用ejs引擎koa2 -e project-name 进入项目安装依赖12cd project-nameyarn install 项目运行1234npm start# ornpm run dev# or... 使用 pm2 启动 koa 项目123456// 全局安装npm install -g pm2// 启动项目pm2 start ./bin/www// pm2自动重启pm2 start ./bin/www/ --watch pm2 相关命令（www 是项目名）12345pm2 list #查看所有已启动项目pm2 start #启动pm2 restart www #重启pm2 stop www #停止pm2 delete www #删除","link":"/2022/03/08/koa-generator%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAkoa%E6%9C%8D%E5%8A%A1/"},{"title":"TypeScript","text":"什么是 TypeScript？ TypeScript 是 JavaScript 的超集，任何合法的 js 程序都是合法的 TypeScript 程序 TypeScript 通过向 JavaScript 增加可选的静态类型声明把 JavaScript 变成强类型程序语言 提供静态类型声明可约束函数、变量、属性等程序实体 为什么要使用 TypeScript？ 提供了静态类型系统，大大增强了代码的可读性以及可维护性 提供最新和不断发展的 javascript 特性，能让我们建立 更健壮的组件 TS 具有防患于未然的静态检查，以及干净利落的只能提示 TypeScript 中的数据类型 typescript 中为了使编写的代码更规范，更利于维护，增加了类型校验，在 typescript 中主要提供了以下数据类型： 布尔类型 bolean 数字类型 number 字符串类型 string 数组类型 array 元组类型 tuple 枚举类型 enum 任意类型 any null 和 undefined void 类型 never 类型 typescript 中为了使编写的代码更规范，更有利于维护，增加了类型校验，写 ts 代码必须指定类型 未声明类型的变量: 如果变量在声明的时候，未指定其类型，那么他会被识别为任意类123456let something;something = &quot;seven&quot;;something = 7;//不会报错 如果没有明确的指定类型，那么 typescript 会依照类型推论的规则推导出一个规则1234567let num = &quot;seven&quot;;num = 7;//会报错//上面代码等价于：let num: string = &quot;seven&quot;;num = 7;//typescript自动推测出num属于string类型 联合类型：表示取值可以为多种类型中的一种12345678910111213141516171819202122232425let flag:string | numberflag = 'seven'flag = 7//联合类型使用 | 分隔每个类型，表示允许flag为string类型或者number类型---------------------------------------//访问联合类型的属性或者方法//当typescript不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问联合类型的所有类型中共有的属性和方法function getLength(something:string|number):number{ return something.length}//上面代码会报错，因为length不是string和number共有的属性//可以访问共有属性toString()function getString(something:string|number):string { return something.toString()}---------------------------------------//联合属性在赋值的时候，会根据类型推论的规则推断出一个类型let a:string|numbera = 'seven'console.log(a.length) //5，a被推断为string，有length属性a = 7console.log(a.length) //编译时报错，被推断为number，无length属性 数组类型123456789101112131415161718//数组类型定义(不允许出现其他类型，数组方法参数也有限制，如push('7')会报错，不能为字符串)let arr:number[] = [1,2,3]let arr:(number | string)[] = [1,'1',2]---------------------------------//数组泛型let arr:Array&lt;number&gt; = [1,2,3]----------------------------------//用接口表示数组interface NumberArray { [index:number]:number}let arr:NumberArray = [1,2,3]//NumberArray表示，只要index的类型时number，那么值的类型也必须时number-----------------------------------//any在数组中的应用let arr:any[] = ['hello', 24, {a:1}] 函数类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//函数声明（不允许输入多余或者少于要求的参数）function sum(x:number, y: number):number { return x + y}sum(1,2) //rightsum(1,2,3) //falsesum(1) //false----------------------------------------------//函数表达式let sum:(x:number, y: number) =&gt; number = function(x:number, y:number):number { return x + y}-----------------------------------------------//可选参数（使用 ? 表示可选的参数，只能放在参数的最后，后面不允许出现必须参数）function buildName(firstName:string, lastName?:string):string { if (lastName) { return firstName + ' ' + lastName } else { return firstName }}let tomcat = buildName('tom', 'cat')let tom = buildName('tom')--------------------------------------------------//参数默认值（typescript会将添加了默认值的参数识别为可选参数） function buildName(firstName:string, lastName:string = 'cat'):string { if (lastName) { return firstName + ' ' + lastName } else { return firstName } } let tomcat = buildName('tom', 'cat') let tom = buildName('tom')----------------------------------------------------//剩余参数，可以使用...rest的方式获取函数中的剩余参数function push(array: any[], ...items:any[]) { items.forEach(function(item) { array.push(item) })}let a = []push(a, 1,2,3,4)-------------------------------------------------------//重载：允许一个函数接受不同数量或者类型的参数时，做出不同的处理//例如，数字或者字符串的反转输出function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); }} 泛型（注意点）12345type A1 = &quot;x&quot; extends &quot;x&quot; ? string : number; // stringtype A2 = &quot;x&quot; | &quot;y&quot; extends &quot;x&quot; ? string : number; // numbertype P&lt;T&gt; = T extends &quot;x&quot; ? string : number;type A3 = P&lt;&quot;x&quot; | &quot;y&quot;&gt;; // ? 这里的extends是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集。P 是带参数 T 的泛型类型，A1 和 A2 的形式一样，结果也很好理解，A3 是泛型类型 P 传入参数**’x’ | ‘y’**得到的类型，如果将 ‘x’ | ‘Y’ 代入泛型类的表达式，那应该会得到和 A2 类型的形式完全一样的结果，这里直接给结论了 12type P&lt;T&gt; = T extends 'x' ? string : number;type A3 = P&lt;'x' | 'y'&gt; // A3的类型是 string ｜ number 结果是不是出人意料？原因就是分配条件类型,在 TS 中对于 extends 关键字的条件类型（即上面的三元表达式类型），如果extends前面的参数是一个(裸类型)泛型类型，当传入该参数的是联合类型，则使用分配律计算最终结果。 分配律是指，将联合型类的联合项拆分成单项，分别代入条件类型，然后将每个单项代入，再将得到的结果联合起来，得到最终的结果。 特殊的 never 那么，我们在看一个例子： 12345type A1 = never extends &quot;x&quot; ? string : number;type P&lt;T&gt; = T extends &quot;x&quot; ? string : number;type A2 = P&lt;never&gt;; // never 上面的例子中，A2 和 A1 的结果竟然不一样，看起来never并不是一个联合类型啊，所以直接代入条件类型获取的结果应该和 A1 相同才对啊？ 实际上，never 被认为是空的联合类型，never 是一个没有联合项的联合类型，所以还是满足上面的分配律，又因为没有联合项可以分配，所以*P*的表达式根本就没有执行，所以 A2 的定义就类似于永远没有返回的函数一样，是 never 类型。 如何防止条件判断中的分配 12345type P&lt;T&gt; = [T] extends [&quot;x&quot;] ? string : number;type A1 = P&lt;&quot;x&quot; | &quot;y&quot;&gt;; // numbertype A2 = P&lt;never&gt;; // string 在条件判断类型的定义中，将泛型参数使用 [] 括起来，即可阻断条件判断类型的分配，此时，传入的 T 的类型就会被当作一个整体，不再分配。","link":"/2019/08/23/typescript/"},{"title":"DOM基本操作","text":"一、节点节点属性 12345678910111213141516171819Node.nodeName //返回节点名称，只读Node.nodeType //返回节点类型的常数值，只读Node.nodeValue //返回Text或Comment节点的文本值，只读Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI //返回当前网页的绝对路径Node.ownerDocument //返回当前节点所在的顶层文档对象，即documentNode.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode //返回当前节点的父节点Node.parentElement //返回当前节点的父Element节点Node.childNodes //返回当前节点的所有子节点Node.firstChild //返回当前节点的第一个子节点Node.lastChild //返回当前节点的最后一个子节点Node.children //返回当前节点的所有Element子节点Node.firstElementChild //返回当前节点的第一个Element子节点Node.lastElementChild //返回当前节点的最后一个Element子节点Node.childElementCount //返回当前节点所有Element子节点的数目 操作123456789101112131415Node.appendChild(node) //向节点添加最后的子节点Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true) //默认为false(克隆节点),true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode) //在指定子节点前插入新的子节点Node.removeChild(node) //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild) //替换节点Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(node) //返回布尔值，用于检查两个节点是否想等，所谓的相等节点，指的的两个节点的类型、属性、子节点都相同Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个ChildNode.remove() //用于删除当前节点ChildNode.before() //在ChildNode前插入元素节点或者文本节点ChildNode.after() //在ChildNode后插入元素或文本节点ChildNode.replaceWith() //替换该节点的父节点下的子节点，可以为文本或元素对象 Document 节点Document 节点的属性1234567891011121314151617181920212223242526document.doctype //返回当前文档关联的文档类型定义(DTD)document.documentElement //返回当前文档的根节点(html)document.defaultView //返回document对象所在的window对象document.body //返回当前文档的&lt;body&gt;节点document.head //返回当前文档的&lt;head&gt;节点document.activeElement //返回当前文档中获得焦点的那个元素document.links //返回当前文档的所有a元素document.forms //返回页面中所有表单元素document.images //返回页面中所有图片元素document.embeds //返回网页中所有嵌入对象document.scripts //返回当前文档的所有脚本document.styleSheets //返回当前网页的所有样式表document.documentURI //表示当前文档的网址document.URI //返回当前文档的网址document.domain //返回当前文档的域名document.lastModified //返回当前文档最后修改的时间戳document.location //返回location对象，提供当前文档的URL信息document.referrer //返回当前文档的访问来源document.title //返回当前文档的标题document.characterSet //属性返回渲染当前文档的字符集，比如UTF-8document.readyState //返回当前文档的状态document.designMode //控制当前文档是否可编辑，可读写document.compatMode //返回浏览器处理文档的模式document.cookie //用来操作Cookie Document 节点的方法读写方法1234document.open() //用于新建并打开一个文档document.close() //关闭open方法所新建的文档document.write() //用于向当前文档写入内容document.writeIn() //用于向当前文档写入内容，尾部添加换行符 查找节点1234567document.querySelector(selectors) //接收一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点document.querySelectorAll(selectors) //接收一个CSS选择器作为参数，返回所有匹配该选择器的元素节点document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name) //用于选择拥有name属性的HTML元素(比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;object&gt;等)document.getElementById(id) //返回匹配指定id属性的元素节点document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点 生成节点1234document.createElement(tagName) //用来生成HTML元素节点document.createTextNode(text) //用来生成文本节点document.createAttribute(name) //生成一个新的属性对象节点，并返回document.createDocumentFragment() //生成一个DocumentFragment对象 事件方法1234document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture) //注册事件document.removeEventListener(type,listener,capture) //注销事件document.dispatchEvent(event) //触发事件 其他123document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点document.importNode(externalNode,deep) //从外部文档拷贝指定节点，插入当前文档 Element 节点Element 节点的属性特性属性12345678Element.attributes //返回当前元素节点的所有属性节点Element.id //返回指定元素的id属性，可读写Element.tagName //返回指定元素的大写标签名Element.innerHTML //返回该元素包含的HTML代码，可读写Element.outerHTML //返回该元素节点的所有HTML代码，包括自身和所有子元素，可读写Element.className //返回当前元素的class属性，可读写Element.classList //返回当前元素节点的所有class集合Element.dataset //返回元素节点中所有data-*属性 尺寸属性12345678910111213141516Element.clientHeight //返回元素节点可见部分的高度Element.clientWidth //返回元素节点可见部分的宽度Element.clientLeft //返回元素节点左边框的宽度Element.clientTop //返回元素节点顶部边框的宽度Element.scrollHeight //返回元素节点的总高度Element.scrollWidth //返回元素节点的总宽度Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值，通过设置这个属性可以改变元素滚动的位置Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight //返回元素的垂直高度(包含border，padding)Element.offsetWidth //返回元素的水平宽度(包含border，padding)Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop //返回水平位移Element.style //返回元素节点的行内样式 节点相关属性1234567Element.children //包括当前元素节点的所有子元素Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild //返回当前节点的第一个Element子节点Element.lastElementChild //返回当前节点的最后一个Element子节点Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML元素节点Element.offsetParent //返回当前元素节点的最靠近、并且CSS的position属性不等于static的父元素 Element 节点的方法位置方法12getBoundingClientRect() //获取元素位置getClientRects() //返回当前元素在页面上的矩形区域 属性方法1234Element.getAttribute() //读取指定属性Element.setAttribute() //设置指定属性Element.hasAttribute() //返回一个布尔值，表示当前元素节点是否有指定属性Element.removeAttribute() //移除指定属性 查找方法1234Element.querySelector()Element.querySelectorAll()Element.getElementByTagName()Element.getElementByClassName() 事件方法1234567891011121314151617181920Element.addEventListener() //添加事件的回调函数Element.removeEventListener() //移除事件监听函数Element.dispatchEvent() //触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)//event对象var event = window.event||event//事件的目标节点var target = event.target || event.srcElement//事件代理ul.addEventListener('click',function(event){ if(event.target.tagName.toLowerCase() === 'li'){ console.log(event.target.innerHTML) }}) 123456789101112Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString);Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从DOM中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上 二、CSS 操作类名操作1234567891011121314151617181920//ie8以下Element.className //获取元素节点的类名Element.className += ' ' + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className){ return new RegExp(className,'gi').test(element.className);}//移除classfunction removeClass(element,className){ element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'),'');}//ie10element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class style 操作123456789101112131415161718element.setAttribute('style','')element.style.backgroundColor = 'red'element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName]window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,':after')[attrName] 对象Object 对象生成实例对象var o = new Object() 属性Object.prototype //返回原型对象 方法Object.keys(o) //遍历对象的可枚举属性 Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法valueOf() //返回当前对象对应的值 toString() //返回当前对象对应的字符串形式 toLocaleString() //返回当前对象对应的本地字符串形式 hasOwnProperty() //判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性 isPrototypeof() //判断当前对象是否为另一个对象的原型 propertyIsEnumerable() //判断某个属性是否可枚举 Array 对象生成实例对象var a = new Array() 属性a.length //长度 Array.isArray()Array.isArray(a) //用来判断一个值是否为数组 Array 实例的方法a.valueof() //返回数组本身 a.toString() //返回数组的字符串形式 a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。 pop() //用于删除数组的最后一个元素，并返回该元素 join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。 concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。 shift() //用于删除数组的第一个元素，并返回该元素。 unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。 reverse() //用于颠倒数组中元素的顺序，返回改变后的数组 slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。 splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。 map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。 map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。 forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。 filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。 some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。 every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。 reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员） reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员） indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 Number 对象生成对象var n = new Number() Number 对象的属性Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 Number 对象实例的方法toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。 toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。 toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。 toPrecision() //用于将一个数转为指定位数的有效数字。 String 对象生成实例对象var s = new String() String 对象的属性s.length //返回字符串的长度 方法s.chatAt(index) //返回指定位置的字符 s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。 s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示） s.concat(s2) //用于连接两个字符串 s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。 s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。 s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。 s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。 s.trim() //用于去除字符串两端的空格，返回一个新字符串 s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。 s.toUpperCase() //全部转为大写 s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。 s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 Math 对象属性Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。 数学方法Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。 Math.exp()：返回e的指数，也就是常数e的参数次方。 Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 三角函数方法Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值） JSON 对象方法JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。 //（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。 //还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。 JSON.parse() //用于将JSON字符串转化成对象。 console 对象方法console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。 console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。 console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。 console.warn() //输出信息时，在最前面加一个黄色三角，表示警告； console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈 console.table() //可以将复合类型的数据转为表格显示。 console.count() //用于计数，输出它被调用了多少次。 console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。 console.dirxml() //用于以目录树的形式，显示DOM节点。 console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 //这两个方法用于计时，可以算出一个操作所花费的准确时间。 console.time() console.timeEnd() //time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。 console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。 console.profileEnd() //用来结束正在运行的性能测试器。 console.group() console.groupend() //上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。 console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 console.trace() //显示当前执行的代码在堆栈中的调用路径。 console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。 DOM 基本操作 获取 Dom 节点 document 代表整个文档 document.getElementById() document.getElementByTagName() document.getElementByName() //只有部分标签 name 可生效，表单之类的 document.getElementByClassName() querySelector() //静态的，不是实时的，保存的是当时的状态，是一个副本 querySelectorAll() //即使以后元素发生了改变，该值也不会改变 遍历节点树 parentNode -&gt; 父节点（最顶端 parentNode 为#document） childNodes -&gt; 子节点们 firstChild -&gt; 第一个子节点 lastChild -&gt; 最后一个子节点 nextSibling -&gt; 后一个兄弟节点 previousSibling -&gt;前一个兄弟节点 遍历元素节点树 parentElement -&gt; 返回当前元素的父元素节点（IE9 以下不兼容） children -&gt; 返回当前元素的元素子节点 node.childElementCount === node.children.length 返回当前元素的子元素节点个数（IE9 以下不兼容） firstElementChild -&gt; 返回第一个元素节点（IE9 以下不兼容） lastElementChild -&gt; 返回最后一个元素节点（IE9 以下不兼容） nextElementSibling -&gt; 返回后一个元素节点（IE9 以下不兼容） previousElementSibling -&gt; 返回前一个元素节点（IE9 以下不兼容） 节点的类型 元素节点 —— 1 属性节点 —— 2 文本节点 —— 3 注释节点（Comment）—— 8 document —— 9 DocumentFragment —— 11 获取节点类型 nodeType 节点的四个属性 nodeName 元素的标签名，以大写形式表示，只读 nodeValue Text 节点或 Comment 节点的文本内容，可读写 nodeType 该节点的类型，只读 attributes Element 节点的属性集合 节点的一个方法 Node.hasChildNodes() 所有节点都有 hasChildNodes()方法，判断有无子节点，有一个或多个返回 true Dom 基本操作——增 document.createElement() document.createTextNode() document.createComment() document.createDocumentFragment() Dom 基本操作——插 parentNode.appendChild() parentNode.insertBefore(a, b) Dom 基本操作——删 parent.removeChild() child.remove() Dom 基本操作-替换 parent.replaceChild(new, origin) Element 节点的一些属性 innerHTML innerText(火狐不兼容)/textContent(老版本 IE 不兼容) Element 节点的一些方法 ele.setAttribute() ele.getAttribute() 查看元素的几何尺寸 domEle.getBoundingClientRect() 兼容性很好 返回一个对象，里面有 left、top、right、bottom、width、height。 left 和 top 代表元素左上角的 X 和 Y 坐标，right 和 bottom 代表元素右下角的 X 和 Y 坐标 height 和 width 属性老版本 IE 未实现 返回的结果不是“实时的” 查看元素的宽高尺寸dom.offsetWidth dom.offsetHeight 查看元素的位置dom.offsetLeft dom.offsetTop 对于无定位父级的元素，返回相对文档的坐标。 对于有定位的父级元素，返回相对最近的有定位的父级的坐标，无论距离是怎么产生的 dom.offsetParent返回最近的有定位的父级，若无，返回 body，body.offsetParent 返回 nul 让滚动条滚动 window 上的三个方法：scroll()==scrollTo()、scrollBy() scroll()和 scrollTo()将 x、y 坐标传入，让滚动条滚动到当前位置 scrollBy() 会在之前的数据基础上累加，可以利用 scrollBy()实现快速阅读的功能 查询计算样式 window.getComputedStyle(ele, null)[style] 第二个参数 null，放的是伪元素，可以获取伪元素的属性 计算样式只读 返回的计算样式都是绝对值，没有相对单位 -IE8 及以下不兼容（ele.currentStyle[style]） 封装函数，返回元素的第 n 层祖先元素节点 12345678function retParent(elem, n) { while(elem &amp;&amp; n) { elem = elem.parentElement n-- } return elem}var i = document.getElementByTagName('i')[0] 原型上封装函数 myChildren 获取子元素，解决一千浏览器的兼容性问题 123456789101112Element.prototype.myChildren = function () { var child = this.childNodes var len = child.length for (var i = 0;i &lt; len; i++) { if(child[i].nodeType == 1) { arr.push(child[i]) } } return arr}var div = document.getElementByTagName('div')[0] 自己封装 hasChildren()方法，不可用 children 属性 123456789101112Element.prototype.hasChildren = function () { var child = this.childNodes var len = child.length for (var i = 0;i &lt; len; i++) { if(child[i].nodeType == 1) { return true } } return false}var div = document.getElementByTagName('div')[0] 封装函数，返回元素 e 的第 n 个兄弟元素节点，n 为正，返回后面的兄弟元素节点，n 为负，返回前面的，n 为 0，返回自己 12345678910111213141516171819function retSibling(e, n) { while(e &amp;&amp; n) { if(n &gt; 0) { if(e.nextElementSibling) { e.nextElementSibling } else { for(e = e.nextSibling; e &amp;&amp; e.nodeType != 1; e = e.nextSibling) } n-- }else { if(e.previousElementSibling) { e = e.previousElementSibling } else { for(e = e.previousSibling; e &amp;&amp; e.nodeType != 1; e = e.previousSibling) } n++ } }} 封装 insertAfter(),功能类似与 insertBefore(new, origin),直接在 Element.prototype 上编程 12345678Element.prototype.insertAfter = function(new, origin) { var beforeNode = origin.nextElementSibling if (beforeNode == null) { this.appendChild(new) } else { this.insertBefore(new, beforeNode) }} 封装滚动条的 x 轴、y 轴的距离函数 12345678910111213function getScrollOffset() { if (window.pageXOffset) { return { x: window.pageXOffset, y: window.pageYOffset } } else { return { x: document.body.scrollLeft + document.documentElement.scrollLeft, y: document.body.scrollTop + document.documentElement.scrollTop } }} 封装可视区窗口大小的函数 1234567891011121314151617181920function getViewportOffset() { if (window.innerWidth) { return { w: window.innerWidth, h: window.innerHeight } } else { if (document.compatMode === 'BackCompat') { return { w: document.body.clientWidth, h: document.body.clientHeight } } else { return { w: document.documentElement.clientWidth, h: document.documentElement.clientHeight } } }} 封装样式获取的方法 1234567function getStyle(elem, prop) { if(window.getComputedStyle) { return window.getComputedStyle(elem, null)[prop] } else { return elem.currentStyle[prop] }}","link":"/2019/08/11/dom%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"vue3核心技术揭秘","text":"vue 的特点（优点） vue 关注视图层，用数据操作的方式代替了 dom 操作 vue 通过响应式的数据绑定实现了数据和视图之间的更新交互 vue 通过组件化开发让工程结构更加明确，更易于维护 vue 通过虚拟 DOM，优化了 DOM 操作，实现了性能提高 vue 拥有自己的 vue-cli/vite 脚手架工具，对良好的工程化性能 vue3 生命周期 onBeforMount -&gt; vue 实例挂载之前执行 onMounted -&gt; vue 实例挂载完成执行 onBeforeUpdate -&gt; 组件内数据发生变化之前执行 onUpdated -&gt; 组件内数据发生变化之后执行 onBeforeUnmount -&gt; 组件销毁之前 onUnmounted -&gt; 组件销毁之后 onActivated -&gt; keep-alive 组件激活时执行 onDeactivated -&gt; keep-alive 组件销毁时执行 onErrorCaptured -&gt; 捕获错误 onRenderTracked -&gt; dev 组件更新时跟踪所有变量和方法 onRenderTriggered -&gt; dev 触发渲染时调用，返回变化新旧值 vue3 相比于 vue2 有哪些不同？ 组合式（composition）api vue2 是选项式（option）api 响应式原理 vue2 响应式原理基础是 Object.defineProperty 深层嵌套递归数据响应式 缺点：无法监听对戏那个或数据新增、删除的元素 解决方案：针对数组原型方法 push、pop、shift、unshift、splice、sort 等进行 hack 处理，提供 Vue.set 监听对象/数组新增属性 tips：Object.defineProperty 可以监听数组已有元素，vue2 没有提供是因为性能问题 vue3 是 Proxy（配合 Reflect） 兼容性：放弃了 IE11 以下 动态属性增删都可以拦截 使用 Reflect 可以修正 Proxy 的 this 指向问题 vue3 使用 Proxy 并不能监听对象内部深层次的属性变化，处理方式是在 getter 中递归响应式，只有真正访问内部属性时才会变成响应式，节约性能 生命周期的变化 vue3 需要添加 on ，使用上需要先引入，vue 可以直接调用 移除了 beforeCrete、created 多根节点 vue3 支持多根节点 异步组件 vue3 提供 Suspense 组件，通过 fallback 插槽提供异步组件渲染兜底的内容，如 loading 等 Teleport vue3 提供 Teleport 组件可将部分组件移动到指定 dom 节点位置，如 Dialog 组件 css 变量 支持在 style 标签中使用 v-bind,给 css 绑定 js 变量 代码打包体积 vue3 的 api 可以被 tree-shaking，使用了 es6module，tree-shaking 依赖于 es6 模块的静态结构特性 虚拟 dom vue3 静态提升：保存静态节点（pathchflag 为 -1）直接复用，添加更新类型标记 pathchflag（为 1 是动态绑定的元素） 事件缓存，可以在第一次渲染后缓存事件，vue2 每次渲染都会传递一个新函数 diff 算法 vue2 双端比较 vue3 最长递归子序列 defineProperty 和 Proxy 的区别？ Object.defineProperty 是 Es5 的方法，Proxy 是 Es6 的方法 defineProperty 是劫持对象属性，Proxy 是代理整个对象； defineProperty 不能监听到对象新增属性和修改新增属性的变化，Proxy 可以 defineProperty 不能监听根据自身数组下标修改数组元素的变化（所以 vue2 提供了 Vue.$set和Vue.$delete） defineProperty 不兼容 IE8，Proxy 不兼容 IE11 defineProperty 不支持 Map、Set 等数据结构 defineProperty 只能监听 get、set，而 Proxy 可以拦截多达 13 种方法； Reflect 是为了在执行对应的拦截操作的方法时能传递正确的 this 上下文 Proxy handler 中的 receiver 指向 正常情况下，receiver指向的是当前的代理对象 特殊情况下，receiver指向引发当前操作的对象（obj） Object.setPrototypeOf(obj, proxy)，访问 obj.name 时如果没有 name 就会根据原型链查找 Proxy 兼容性相对较差，且无法通过 pollyfill 解决；所以 Vue3 不支持 IE11 以下； Proxy 返回的是一个新对象 v-if 和 v-for 的优先级？v-if 的优先级高于 v-for ref 和 reactive 定义响应式数据ref 原理 ref 内部封装一个 RefImpl 类，并设置 get/set，当通过.value 调用就会触发劫持，从而实现响应式 当接受的对象或数组时，内部仍然是 reactive 去实现的 1234567891011121314151617181920212223242526272829// 源码路径：packages/reactivity/src/ref.tsclass RefImpl&lt;T&gt; { private _value: T private _rawValue: T public dep?: Dep = undefined public readonly __v_isRef = true constructor(value: T, public readonly __v_isShallow: boolean) { this._rawValue = __v_isShallow ? value : toRaw(value) this._value = __v_isShallow ? value : toReactive(value) } get value() { trackRefValue(this) return this._value } set value(newVal) { newVal = this.__v_isShallow ? newVal : toRaw(newVal) if (hasChanged(newVal, this._rawValue)) { this._rawValue = newVal this._value = this.__v_isShallow ? newVal : toReactive(newVal) triggerRefValue(this, newVal) } }} reactive 原理 使用 Proxy 代理传入对象实现响应式 Proxy 拦截数据的更新和获取操作，使用 Reflect 完成原本的操作（get/set） 1234567891011121314151617181920212223242526272829303132333435363738function createReactiveObject( target, isReadonly, baseHandlers, collectionHandlers, proxyMap) { if (!shared.isObject(target)) { { console.warn(`value cannot be made reactive: ${String(target)}`); } return target; } // target is already a Proxy, return it. // exception: calling readonly() on a reactive object if ( target['__v_raw' /* RAW */] &amp;&amp; !(isReadonly &amp;&amp; target['__v_isReactive' /* IS_REACTIVE */]) ) { return target; } // target already has corresponding Proxy const existingProxy = proxyMap.get(target); if (existingProxy) { return existingProxy; } // only specific value types can be observed. const targetType = getTargetType(target); if (targetType === 0 /* INVALID */) { return target; } const proxy = new Proxy( target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers ); proxyMap.set(target, proxy); return proxy;} vue2 响应式原理 给data创建 Observer 实例 Observer 类给对象添加 get/set 方法、getter 收集依赖、setter 通知依赖更新 针对数组类型数据，自定义封装 array 原生方法，实现拦截执行并通知依赖更新 vue3 响应式原理 activeEffect 解决匿名函数问题 WeakMap、Map、Set 存储对象属性的相关副作用函数 track()实现依赖收集、层级依赖追踪、依赖清理（解决嵌套副作用） trigger()当某个依赖值发生变化时，通过执行副作用函数获得与依赖变化后对应的最新值 vue3 中 watch 和 watchEffect 有什么区别？ watch 显式指定依赖源，依赖源变化时执行回调函数 第一个参数为不同形式的数据源 单个 ref 计算属性 getter 函数（要有返回值） 响应式对象(默认时深层遍历)，不能直接侦听响应式对象的属性，应该用一个返回该属性的 getter 函数 以上类型的值组成的数组 第二个参数是数据发生变化时执行的回调函数 接收三个参数：新值、旧值、清理副作用的回调函数（例如清除无效的副作用，等待中的异步请求） 第三个参数是一个可选对象 immediate：在侦听器创建时立即触发回调 deep：深度遍历 flush：回调的触发时机 pre：默认，dom 更新前调用 post：dom 更新后调用 sync：sync 同步调用 onTrack/onTrigger: 用于调试的钩子，在依赖收集和回调函数触发时被调用 其他： watch 的返回值是一个用来停止该副作用的函数 使用同步语句创建的侦听器，会自动绑定到宿主组件实例实例上，并在宿主组件卸载时自动停止 异步回调（setTimeout 等）创建的侦听器，则不会绑定到当前组件上，必须手动停止，以防止内存泄漏 watchEffect 自动收集依赖源，依赖源变化时重新执行自身 接收两个参数 第一个参数是一个回调函数 回调函数的参数为一个 onCleanup 函数，用来清除副作用 第二个参数是一个可选对象 flush：回调的触发时机 pre：默认，dom 更新前调用 post：dom 更新后调用 sync：sync 同步调用 watchEffect 的回调函数会立即执行，即{immediate: true} computed 其实类似一个带输出的同步版本 watchEffect watchEffect 仅会在同步执行期间才会追踪依赖，使用异步回调时，只有在第一个 await 之前访问到的依赖才会被追踪 watchEffect 无法访问侦听数据的新值和旧值 动态新增的依赖也会被收集 使用场景： 大部分时候使用 watch 显示指定依赖以避免不必要的重复触发，也避免在后续代码修改或重构时不小心引入新的依赖 watchEffect 使用于逻辑相对简单，依赖源和逻辑强相关的场景 vue 中动态引入的图片为什么要是 require？因为动态添加 src 被当作静态资源处理了，而动态 src 编译过后的地址与图片编译后的资源地址不一致导致无法正确引入资源，而使用 require 返回的资源文件就是编译后的文件地址，所以可以正确的引入资源 1234567891011// vue文件中使用require动态的引入一张图片&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;!-- 使用require动态引入图片 --&gt; &lt;img :src=&quot;require('../assets/logo.png')&quot; alt=&quot;logo&quot;&gt; &lt;/div&gt;&lt;/template&gt;//最终编译的结果//这张图片是可以被正确打开的&lt;img src=&quot;/img/logo.6c137b82.png&quot; alt=&quot;logo&quot;&gt; 什么是静态资源？ 静态资源就是直接放在项目中的资源，不需要发送请求获取动态资源就是需要发送请求获取资源（数据库连接数据处理） 为什么静态引入图片，没有使用 require 返回的依然是编译后的文件地址？ 因为 webpack 编译 vue 文件时，遇见 src 等属性会默认使用 require 引入资源路径 如 url(./image.png) 会转为 require('./image.png') &lt;img src='./image.png' /&gt; 会被编译为 h('img',{attrs: {src: require('./image.png')}}) 动态引入图片，src 后面的属性值 webpack 会认为是一个变量，根据 v-bind 指令去解析 src 的属性值，并不会通过 require 引入资源路径 引入 public 下面静态资源的时候，也会默认使用 require 引入吗？ 官方：任何放置在public文件夹下的静态资源会被简单的复制，而不经过webpack，你需要通过绝对路径来引用它们 答：不会，使用 require 引入资源的前提是该资源是 webpack 解析的模块，而 public 下的文件压根不会走编译，所以不会使用 require 为什么使用 public 下的资源一定要用绝对路径？ 答：public 文件不会被编译返回的是代码中定义的文件地址，src 下的文件被编译，编译后生成的文件目录（dist）下会找不到对应目录","link":"/2023/03/24/vue3%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"title":"TS进阶题目","text":"在线 TS 地址 typescript 第一题 以下代码为什么会提示错误，应该如何解决上述问题？ 1234567891011type User = { id: number; kind: string;}function createCustomer&lt;T extends User&gt;(u: T): T { return { id: u.id, kind: 'customer' }} 第一种解决方案 1234567891011type User = { id: number; kind: string;}function createCustomer&lt;T extends User&gt;(u: T): User { return { id: u.id, kind: 'customer', }} 第二种解决方案 123456789101112type User = { id: number; kind: string;}function createCustomer&lt;t extends User&gt;(u: T): T { return { ...u, id: u.id, kind: 'customer' }} 第二题 以下函数我们希望参数a和b的类型都是一致的，即a和b同时为number或string类型，当它们的类型不一致时，ts 类型检查器能自动提示对应的错误信息。 123456789101112function f(a: string | number,b: string | number) { if (typeof a === 'string') { return a + ':' + b; } else { return a + b; }}f(1, 2); // OKf('a', 'b'); // OKf('a', 2); // Errorf(1, 'b'); //Error 第一种解决方案 函数重载 1234567891011121314function f(a: string, b: string): string;function f(a: number, b: number): number;function f(a: string | number, b: string | number): string | number { if (typeof a === 'string') { return a + ':' + b; } else { return (a as number) + (b as number); }}f(1, 2); // OKf('a', 'b'); // OKf(1, 'b'); // Errorf('a', 2); // Error 第二种解决方案 自定义路由守卫 1234567891011121314const isStringArray = (params: string[] | number[]): params is string[] =&gt; typeof params[0] === 'string';function f(...args: string[] | number[]) { if (isStringArray(args)) { return args[0] + ':' + args[1]; } else { return args[0] + args[1]; }}f(1, 2); // OKf('a', 'b'); // OKf(1, 'b'); // Errorf('a', 2); // Error 第三种解决方案 范型 123456789101112function f&lt;T extends string | number&gt;(a: T, b: T) { if (typeof a === 'string') { return a + ':' + b; } else { return (a as number) + (b as number); }}f(1, 2); // OKf('a', 'b'); // OKf(1, 'b'); // Errorf('a', 2); // Error 第三题 实现 SetOptional 工具类型，支持把给定的 keys 对应的属性变为可选，参考Partial 实现 SetRequired 工具类型，支持把给定的 keys 对应的属性变成必填，参考 Require 1234567891011121314151617181920212223242526272829// SetOptional 测试用例type Foo = { a: number; b?: string; c: boolean;}type SomeOptional = SetOptional&lt;Foo, 'a' | 'b'&gt;type SomeOptional = { a?: number; //该属性变为可选的 b?: string; //保持不变 c: boolean;}// SetRequired 测试用例type Foo = { a: number; b?: string; c: boolean;}type SomeRequired = SetRequired&lt;Foo, 'a' | 'b'&gt;type SomeRequired = { a: number; //保持不变 b: string; //该属性变为必选的 c: boolean;} 解决方案 1 SetOptional 1234567891011121314type Foo = { a: number; b?: string; c: boolean;}// 对交叉类型进行扁平化处理type Simplify&lt;T&gt; = { [P in keyof T]: T[P]}type SetOptional&lt;T, K extends keyof T&gt; = Simplify&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;&gt;type SomeOptional = SetOptional&lt;Foo, 'a' | 'b'&gt; SetRequired 12345678910111213type Foo = { a: number; b?: string; c: boolean;}type Simplify&lt;T&gt; = { [P in keyof T]: T[P]}type SetRequired&lt;T, K extends keyof T&gt; = Simplify&lt;Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt; &amp; Required&lt;Pick&lt;T, K&gt;&gt;&gt;type SomeRequired = SetRequired&lt;Foo, 'b' | 'c'&gt; 解决方案 2 1234567891011121314151617type Foo = { a: number; b?: string; c: boolean;}type Simplely&lt;T&gt; = { [P in keyof T]: T[P]}type SetOptional&lt;T, K extends keyof T&gt; = Simplely&lt;{ [X in keyof Omit&lt;T, K&gt;]: T[X]; } &amp; { [P in K]?: T[P] }&gt;;type SetRequired&lt;T, K extends keyof T&gt; = Simplely&lt;{ [X in keyof Omit&lt;T, K&gt;]: T[X]; } &amp; { [P in K]-?: T[P] }&gt;;// 测试用例type SomeOptional = SetOptional&lt;Foo, 'a' | 'b'&gt;;type SomeRequired = SetRequired&lt;Foo, 'b' | 'c'&gt;; 解决方案 3 1234567type Simplify&lt;T&gt; = { [P in keyof T]: T[P]}type SetOptional&lt;T, K extends keyof T&gt; = Simplify&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt;;type SetRequired&lt;T, K extends keyof T&gt; = Simplify&lt;Required&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt; 第四题 Pick&lt;T, K extends keyof T&gt; 的作用是将某个类型中的字属性挑出来，得到包含这个类型部分属性的字类型。 123456789101112interface Todo { title: string; description: string; completed: boolean;}type TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;const todo: TodoPreview = { title: &quot;clean room&quot;, completed: false} 问题：如何定义一个ConditionalPick工具类型，支持根据指定的Condition条件来生成新的类型，对应的使用示例如下： 12345678910interface Example { a: string; b: string | number; c: () =&gt; void; d: {}}// 测试用例type StringKeyOnly = ConditionalPick&lt;Example, string&gt;;// =&gt; {a: string} 解决方案 神奇的 as 1234567891011121314interface Example { a: string; b: string | number; c: () =&gt; void; d: {};}type ConditionalPick&lt;T, K&gt; = { [P in keyof T as (T[P] extends K ? P : never)]: T[P]}// 测试用例type StringKeysOnly = ConditionalPick&lt;Example, string&gt;;// =&gt; {a: string} 第五题 定义一个工具类型AppendArgument,为已有函数累心增加指定类型的参数，新增的参数名是x，将作为新函数类型的第一个参数，示例如下： 123456type Fn = (a: number, b: string) =&gt; number;type AppendArgument&lt;F, A&gt; = // 你的实现代码// 测试用例type FinalFn = AppendArgument&lt;Fn, boolean&gt;// (x: boolean, a: number, b: string) =&gt; number; 解决方案 1 延伸阅读 掌握 TS 这些工具类型，让你开发事半功倍 123456type AppendArgument&lt;F extends (...args: any) =&gt; any, A&gt; = (x: A, ...args: Parameters&lt;F&gt;) =&gt; ReturnType&lt;F&gt;type Fn = (a: number, b: string) =&gt; number;type FinalFn = AppendArgument&lt;Fn, boolean&gt;;// (x: boolean, a: number, b: string) =&gt; number; 解决方案 2 延伸阅读 用上这几招，轻松实现 TS 类型提取 123456type AppendArgument&lt;F, T&gt; = F extends (...args: infer Args) =&gt; infer Return ? (x: T, ...args: Args) =&gt; Return : never;type Fn = (a: number, b: string) =&gt; number;type FinalFn = AppendArgument&lt;Fn, boolean&gt;;// (x: boolean, a: number, b: string) =&gt; number 第六题 定义一个 NativeFlat 工具类型，支持把数组类型拍平(扁平化),示例如下： 12345type NativeFlat&lt;T extends any[]&gt; = // 实现代码//测试用例type NativeResult = NativeFlat&lt;[['a'],['b','c'],['d']]&gt;;// =&gt; &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; 在完成NativeFlat工具类型之后，继续实现DeepFlat工具类型，以支持多维数组类型： 123456type DeepFlat&lt;T extends any[]&gt; = unknown // 你的实现代码// 测试用例type Deep = [['a'], ['b', 'c'], [['d']], [[[['e']]]]];type DeepTestResult = DeepFlat&lt;Deep&gt;// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; 解决方案 NativeFlat 123456type NaiveFlat&lt;T extends any[]&gt; = { [P in keyof T]: T[P] extends any[] ? T[P][number] : T[P]}[number]type NaiveResult = NaiveFlat&lt;[['a'], ['b', 'c'], ['d']]&gt;// NaiveResult的结果： &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; DeepFlat 12345678type Deep = [['a'], ['b', 'c'], [['d']], [[[['e']]]]];type DeepFlat&lt;T extends any[]&gt; = { [K in keyof T]: T[K] extends any[] ? DeepFlat&lt;T[K]&gt; : T[K]}[number]type DeepTestResult = DeepFlat&lt;Deep&gt;// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; 第七题 使用类型别名定义一个EmptyObject类型，是的该类型只允许空对象赋值： 1234567type EmptyObject = {}// 测试用例const shouldPass: EmptyObject = {}; // OKconst shouldFail: EmptyObject = { // Error prop: &quot;TS&quot;} 更改以下takeSomeTypeOnly函数类型定义，让参数只允许严格 SomeType 类型的值，示例如下： 123456789101112type SomeType = { prop: string;}function takeSomeTypeOnly(x: SomeType) {return x};// 测试用例const x = {prop: 'a'};takeSomeTypeOnly(x); // OKconst y = {prop: 'a', additionalProp: 'x'};takeSomeTypeOnly(y); // Error 解决方案 EmptyObject 1234567891011// type PropertyKey = string | number | symbol;type EmptyObject = { [K in PropertyKey]: never;}// 测试用例const shouldPass: EmptyObject = {}; // OKconst shouldFail: EmptyObject = { // Error prop: &quot;TS&quot;} takeSomeTypeOnly 12345678910111213141516type SomeType = { prop: string;}type Exclusive&lt;T1, T2 extends T1&gt; = { [K in keyof T2]: K extends keyof T1 ? T2[K] : never;}function takeSomeTypeOnly&lt;T extends SomeType&gt;(x: Exclusive&lt;SomeType, T&gt;) {return x};// 测试用例const x = {prop: 'a'};takeSomeTypeOnly(x); // OKconst y = {prop: 'a', additionalProp: 'x'};takeSomeTypeOnly(y); // Error 第八题 定义一个NonEmptyArray工具类型，用于确保数据为非空数组 1234type NonEmptyArray&lt;T&gt; = // 代码实现const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 解决方案 1 1234type NonEmptyArray&lt;T&gt; = [T, ...T[]];const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 解决方案 2 12345type NonEmptyArray&lt;T&gt; = T[] &amp; {0: T};const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 解决方案 3 12345678type NonEmptyArray&lt;T&gt; = { [P in number]: T;} &amp; { 0: T};const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 第九题 定义一个JoinStrArray工具类型，用于根据指定的Separator分隔符，对字符串数据类型进行拼接，示例如下： 1234567type JoinStrArray&lt;Arr extends string[], Separator extends string, Result extends string = &quot;&quot;&gt; = // 你的实现代码// 测试用例type Names = [&quot;Sem&quot;, &quot;Lolo&quot;, &quot;Kaquko&quot;]type NamesComma = JoinStrArray&lt;Names, &quot;,&quot;&gt; // &quot;Sem,Lolo,Kaquko&quot;type NamesSpace = JoinStrArray&lt;Names, &quot; &quot;&gt; // &quot;Sem Lolo Kaquko&quot;type NamesStars = JoinStrArray&lt;Names, &quot;⭐️&quot;&gt; // &quot;Sem⭐️Lolo⭐️Kaquko&quot; 解决方案 12345678910111213141516171819type JoinStrArray&lt; Arr extends string[], Separator extends string, Result extends string = &quot;&quot;&gt; =Arr extends [infer El,...infer Rest]? Rest extends string[]? El extends string? Result extends &quot;&quot;? JoinStrArray&lt;Rest, Separator,`${El}`&gt;: JoinStrArray&lt;Rest, Separator,`${Result}${Separator}${El}`&gt;: `${Result}`: `${Result}`: `${Result}`type Names = [&quot;Sem&quot;, &quot;Lolo&quot;, &quot;Kaquko&quot;]type NamesComma = JoinStrArray&lt;Names, &quot;,&quot;&gt; // &quot;Sem,Lolo,Kaquko&quot;type NamesSpace = JoinStrArray&lt;Names, &quot; &quot;&gt; // &quot;Sem Lolo Kaquko&quot;type NamesStars = JoinStrArray&lt;Names, &quot;⭐️&quot;&gt; // &quot;Sem⭐️Lolo⭐️Kaquko&quot; 第十题 实现一个Trim工具类型，用于对字符串字面量类型进行去空格处理，示例如下： 123type Trim&lt;V extends string&gt; = // 代码实现type Result = Trim&lt;' foolishmax '&gt; 解决方案 123456type TrimLeft&lt;V extends string&gt; = V extends ` ${infer R}` ? TrimLeft&lt;R&gt; : V;type TrimRight&lt;V extends string&gt; = V extends `${infer R} `? TrimRight&lt;R&gt; : V;type Trim&lt;V extends string&gt; = TrimLeft&lt;TrimRight&lt;V&gt;&gt;;type Result = Trim&lt;' foolishmax '&gt; 第十一题 实现一个*IsEqual&lt;A, B&gt;*工具类型，用于比较两个类型是否相等，示例如下： 123456type IsEqual&lt;A, B&gt; = // 代码实现// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1, {a: 1}}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false 解决方案（原始方案） 1 123456789101112type IsEqual&lt;A, B&gt; = A extends B ? (B extends A ? true : false) : false;// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1}, {a: 1}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false// errortype E3 = IsEqual&lt;true, boolean&gt; // booleantype E4 = IsEqual&lt;1 | 2, 1&gt; // boolean这是因为泛型和*extends*两者结合所产生的*distributive conditionial types*效应导致的 解决方案（稍微优化）2 12345678910111213141516type IsEqual&lt;A, B&gt; = [A] extends [B] ? [B] extends [A] ? true : false : false或type IsEqual&lt;A, B&gt; = [A, B] extends [B, A] ? true : false// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1}, {a: 1}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false// errortype E3 = IsEqual&lt;any, string&gt; // truetype E4 = IsEqual&lt; { name: string }, { readonly name: string }&gt; // true这是因为Ts中any可以赋值为任何类型，任何类型也可以赋值给any，这就意味着any和任意类型之间都是assignable的，对于extends而言就是都可以相互extends的，所以E3是true。readonly不会改变assignable。 解决方案 4 12345678type IsEqual&lt;A, B&gt; =(&lt;G&gt;() =&gt; G extends A ? 1 : 2) extends(&lt;G&gt;() =&gt; G extends B ? 1 : 2) ? true : false;// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1}, {a: 1}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false 第十二题 实现一个Head工具类型，用于获取数组类型的第一个类型，示例如下： 123456type Head&lt;T extends Array&lt;any&gt;&gt; = // 代码实现// 测试用例type H0 = Head&lt;[]&gt; // nevertype H1 = Head&lt;[1]&gt; // 1type H2 = Head&lt;[2,3,4]&gt; // 2 解决方案 1 123456type Head&lt;T extends Array&lt;any&gt;&gt; = T extends [] ? never : T[0];// 测试用例type H0 = Head&lt;[]&gt; // nevertype H1 = Head&lt;[1]&gt; // 1type H2 = Head&lt;[2,3,4]&gt; // 2 解决方案 2 123456type Head&lt;T extends Array&lt;any&gt;&gt; = T extends [head: infer H, ...rest: any[]] ? H : never;// 测试用例type H0 = Head&lt;[]&gt; // nevertype H1 = Head&lt;[1]&gt; // 1type H2 = Head&lt;[2,3,4]&gt; // 2 第十三题 实现一个Tail工具类型，用于获取数组类型除了第一个类型外，剩余的类型，示例如下： 123456type Tail&lt;T extends Array&lt;any&gt;&gt; = // 代码实现// 测试用例type T0 = Tail&lt;[]&gt; //[]type T1 = Tail&lt;[1, 2]&gt; // [2]type T2 = Tail&lt;[1, 2, 3, 4, 5]&gt; //[2, 3, 4, 5] 解决方案 123456type Tail&lt;T extends Array&lt;any&gt;&gt; = T extends [infer A, ...infer B] ? B : [];// 测试用例type T0 = Tail&lt;[]&gt; //[]type T1 = Tail&lt;[1, 2]&gt; // [2]type T2 = Tail&lt;[1, 2, 3, 4, 5]&gt; //[2, 3, 4, 5] 第十四题 实现一个Unshift工具类型，用于把指定类型 E 作为第一个元素添加到T数组类型中，示例如下： 12345type Unshift&lt;T extends any[], E&gt; = // 代码实现// 测试用例type U0 = Unshift&lt;[], 1&gt;; // [1]type U1 = Unshift&lt;[1, 2, 3], 0&gt;; //[0, 1, 2, 3] 解决方案 12345type Unshift&lt;T extends any[], E&gt; = [E, ...T];// 测试用例type U0 = Unshift&lt;[], 1&gt;; // [1]type U1 = Unshift&lt;[1, 2, 3], 0&gt;; //[0, 1, 2, 3] 第十五题 实现一个Shift工具类型，用于移除T数组类型中的第一个类型，示例如下： 12345type Shift&lt;T extends any[]&gt; = // 代码实现// 测试用例type S0 = Shift&lt;[1, 2, 3]&gt;type S1 = Shift&lt;[string, number, boolean]&gt; 解决方案 1234567type Shift&lt;T extends any[]&gt; = T extends [infer A, ...infer B] ? B : [];// 测试用例type S0 = Shift&lt;[1, 2, 3]&gt;; // [2, 3]type S1 = Shift&lt;[string, number, boolean]&gt;; // [number, boolean]type S2 = Shift&lt;[]&gt;; // []type S3 = Shift&lt;[string]&gt;; // [] 第十六题 实现一个Push工具类型，用于把指定类型E作为最后一个元素添加到T数组类型中，示例如下： 12345type Push&lt;T extends any[], E&gt; = // 代码实现// 测试用例type P0 = Push&lt;[], 1&gt;; // [1]type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4] 解决方案 1 12345type Push&lt;T extends any[], E&gt; = T extends [...infer U] ? [...U, E] : never;// 测试用例type P0 = Push&lt;[], 1&gt;; // [1]type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4] 解决方案 2 123456type Push&lt;T extends any[], E&gt; = [...T, E];// 测试用例type P0 = Push&lt;[], 1&gt;; // [1]type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4] 第十七题 实现一个Includes工具类型，用于判断指定的类型E，是否包含在T数组类型中，示例如下： 12345type Includes&lt;T extends any[], E&gt; = // 代码实现// 测试用例type I0 = Includes&lt;[], 1&gt;; // falsetype I1 = Includes&lt;[2, 3], 2&gt;; // true 解决方案 1 12345type Includes&lt;T extends any[], E&gt; = E extends T[number] ? true : false;// 测试用例type I0 = Includes&lt;[], 1&gt;; // falsetype I1 = Includes&lt;[2, 3], 2&gt;; // true 解决方案 2 123456type Includes&lt;T extends any[], E&gt; = T extends [infer A, ...infer R] ? E extends A ? true : Includes&lt;R, E&gt; : false;// 测试用例type I0 = Includes&lt;[], 1&gt;; // falsetype I1 = Includes&lt;[2, 3], 2&gt;; // true 第十八题 实现一个UnionToIntersection工具类型，用于把联合类型转换为交叉类型，示例如下： 12345type UnionToIntersection&lt;U&gt; = // 代码实现// 测试用例type U0 = UnionToIntersection&lt;string | number&gt;; // nevertype U1 = UnionToIntersection&lt;{name: string} | {age: number}&gt;; // {name: string} &amp; {age: number} 解决方案 逆变协变 注释 12345678910type Fun&lt;X&gt; = (...args: X[]) =&gt; void;let f: Fun&lt;string&gt;let g: Fun&lt;string | number&gt;g = f // this cannot be assigned当f赋值给g时，新的g不能使用number类型的参数，我们丢失了g的一部分类型，这就属于 逆变(contra-variance),这个和交集的工作机制类似。当我们把逆变位置放在条件类型时：Typescript会创建一个交集，我们从函数参数中infer了一个类型，TypeScript知道我们必须符合逆变的条件，然后TypeScript会自动创建并集中所有的成分的交集。 123456type UnionToIntersection&lt;U&gt; = (U extends any ? (k: U) =&gt; void : never) extends (k: infer I) =&gt; void ? I : never// 测试用例type U0 = UnionToIntersection&lt;string | number&gt; // nevertype U1 = UnionToIntersection&lt;{ name: string } | { age: number }&gt; // { name: string; } &amp; { age: number; } 第十九题 实现一个 OptionalKeys 工具类型，用来获取对象类型中声明的可选属性，示例如下: 12345678910type Person = { id: string; name: string; age: number; from?: string; speak?: string;}type OptionalKeys&lt;T&gt; = // 代码实现type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot; 解决方案 1 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;}type OptionalKeys&lt;T&gt; = NonNullable&lt;{ [P in keyof T]: undefined extends T[P] ? P : never}[keyof T]&gt;type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot; 解决方案 2 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;}type OptionalKeys&lt;T&gt; = keyof { [P in keyof T as undefined extends T[P] ? P : never]: T[P]}type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot; 解决方案 3 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;};type OptionalKeys&lt;T&gt; = Exclude&lt;{ [P in keyof T]: T extends T[P] ? never : T[P]}[keyof T], undefined&gt;type PersonOptionalKeys = OptionalKeys&lt;Person&gt;; // &quot;from&quot; | &quot;speak 解决方案 4 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;};type OptionalKeys&lt;T&gt; = { [P in keyof T]: (undefined extends T[P] ? P : never)}[keyof T] &amp; keyof Ttype PersonOptionalKeys = OptionalKeys&lt;Person&gt;; // &quot;from&quot; | &quot;speak 第二十题 实现一个Curry工具类型，用来实现函数类型的柯里化处理，示例如下： 123456789type Curry&lt; F extends (...args: any[]) =&gt; any, P extends any[] = Parameters&lt;F&gt;, R = ReturnType&lt;F&gt;&gt; = // 代码实现type C0 = Curry&lt;() =&gt; Date&gt;; // () =&gt; Datetype C1 = Curry&lt;(a:number) =&gt; Date&gt;; // (arg: number) =&gt; Datetype C2 = Curry&lt;(a: number, b: string) =&gt; Date&gt;; // (arg: number)=&gt;(arg: string) =&gt; Date 解决方案 12345678910111213type Curry&lt; F extends (...args: any[]) =&gt; any, P extends any[] = Parameters&lt;F&gt;, R = ReturnType&lt;F&gt;,&gt; = P extends [infer A, ...infer B] ? B extends [] ? (arg: A) =&gt; R : (arg: A) =&gt; Curry&lt;(...arg: B) =&gt; R&gt; : F;type C0 = Curry&lt;() =&gt; Date&gt;; // () =&gt; Datetype C1 = Curry&lt;(a:number) =&gt; Date&gt;; // (arg: number) =&gt; Datetype C2 = Curry&lt;(a: number, b: string) =&gt; Date&gt;; // (arg: number)=&gt;(arg: string) =&gt; Date 第二十一题 实现一个Merge工具类型，用于把两个类型合成一个新的类型，第二类型（SecondType）的Keys将会覆盖第一种类型（FirstType）的Keys，示例如下： 123456789101112type Foo = { a: number; b: string;}type Bar = { b: number;}type Merge&lt;FirstType, SecondType&gt; = // 代码实现type M = Merge&lt;Foo, Bar&gt;; // {a: number, b: number} 解决方案 1 将 FirstType 和 SecondType 做交叉类型，并遍历每一个属性； 如果当前属性名在 SecondType 类型中，则使用 SecondType 类型中的当前属性值； 如果当前属性名在 FirstType 类型中，则使用 FirstType 类型中的当前属性值； 否则为 never； 123456789101112131415161718type Foo = { a: number; b: string;}type Bar = { b: number;}type Merge&lt;FirstType, SecondType&gt; ={ [K in keyof (FirstType &amp; SecondType)] : K extends keyof SecondType ? SecondType[K] : K extends keyof FirstType ? FirstType[K] : never}type M = Merge&lt;Foo, Bar&gt;; // {a: number, b: number} 解决方案 2 先将 FirstType 类型中已经有的，和 SecondType 类型中相同的属性删除； 将前面结果和 SecondType 做交叉类型，获得合并后结果。 123456789101112type Foo = { a: number; b: string;}type Bar = { b: number;}type Merge&lt;F, S&gt; = Omit&lt;F, keyof S&gt; &amp; S;type M = Merge&lt;Foo, Bar&gt;; // {a: number, b: number} 第二十二题 实现一个RequireAtLeastOne工具类型，它将创建一个至少含有一个给定keys的类型，其余keys类型保持原样，示例如下： 123456789101112131415type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;}type RequireAtLeastOne&lt; ObjectType, KeysType extends keyof ObjectType = keyof ObjectType,&gt; = 代码实现const responder: RequireAtLeastOne&lt;Responder, 'text'|'json'&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true} 解决方案 1 1234567891011121314151617181920212223type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;}type RequireAtLeastOne&lt; ObjectType, KeysType extends keyof ObjectType = keyof ObjectType,&gt; = KeysType extends unknown ? ObjectType &amp; { [K in KeysType]-?: ObjectType[K]} : never;// 表示当前类型至少包含 'text' 或 'json' 键const responder: RequireAtLeastOne&lt;Responder, 'text' | 'json'&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true};// @ts-expect-error 因为没有'text'和'json'中的任何一个，报错const responder2: RequireAtLeastOne&lt;Responder, 'text' | 'json'&gt; = { secure: true}; 解决方案 2 12345678910111213141516type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;};type RequireAtLeastOne&lt;ObjectType, KeysType extends keyof ObjectType = keyof ObjectType&gt; = { [K in keyof ObjectType]: K extends KeysType ? ObjectType &amp; Required&lt;Pick&lt;ObjectType, K&gt;&gt; : never;}[keyof ObjectType]// 表示当前类型至少包含 'text' 或 'json' 键const responder: RequireAtLeastOne&lt;Responder, &quot;text&quot; | &quot;json&quot;&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true,}; 解决方案 3 12345678910111213141516type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;};type RequireAtLeastOne&lt;ObjectType, KeysType extends keyof ObjectType = KeysType extends unknown? Omit&lt;ObjectType, KeysType&gt; &amp; Require&lt;Pick&lt;ObjectType, KeysType&gt;&gt;: never// 表示当前类型至少包含 'text' 或 'json' 键const responder: RequireAtLeastOne&lt;Responder, &quot;text&quot; | &quot;json&quot;&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true,}; 第二十三题 实现一个RemoveIndexSignature工具类型，用于移除已有类型中的索引签名，示例如下： 12345678910interface Foo { [key: string]: any; [key: number]: any; [key: symbol]: any; bar(): void;}type RemoveIndexSignature&lt;T&gt; = // 代码实现type R = RemoveIndexSignature&lt;Foo&gt;; // {bar: ()=&gt;void;} 解决方案 123456789101112interface Foo { [key: string]: any; [key: number]: any; [key: symbol]: any; bar(): void;}type RemoveIndexSignature&lt;T&gt; = { [K in keyof T as string extends K ? never : number extends K ? never : symbol extends K ? never : K]: T[K]}type R = RemoveIndexSignature&lt;Foo&gt;; // {bar: () =&gt; void;} 第二十四题 实现一个 Mutable 工具类型，用于移除对象类型上所有属性或者部分属性的 readonly 修饰符，示例如下： 123456789101112type Foo = { readonly a: number; readonly b: string; readonly c: boolean;}type Mutable&lt;T, Keys extends keyof T = keyof T&gt; = // 代码实现const mutableFoo: Mutable&lt;Foo, 'a'&gt; = { a: 1, b: '2', c: true };mutableFoo.a = 3; // okmutableFoo.b = '6'; // Cannot assign to 'b' because it is a read-only property. 解决方案 1 12345678910111213type Foo = { readonly a: number; readonly b: string; readonly c: boolean;}type Mutable&lt;T, Keys extends keyof T = keyof T&gt; ={-readonly [K in Keys]: T[K] } &amp; Pick&lt;T, Exclude&lt;keyof T, Keys&gt;&gt;;const mutableFoo: Mutable&lt;Foo, 'a'&gt; = { a: 1, b: '2', c: true };mutableFoo.a = 3; // okmutableFoo.b = '6'; // Cannot assign to 'b' because it is a read-only property. 解决方案 2 12345678910111213type Foo = { readonly a: number; readonly b: string; readonly c: boolean;}type Mutable&lt;T, Keys extends keyof T = keyof T&gt; ={-readonly [K in Keys]: T[K] : T[K]} &amp; Omit&lt;T, Keys&gt;;const mutableFoo: Mutable&lt;Foo, 'a'&gt; = { a: 1, b: '2', c: true };mutableFoo.a = 3; // okmutableFoo.b = '6'; // Cannot assign to 'b' because it is a read-only property. 第二十五题 实现一个 IsUnion 工具类型，判断指定的类型是否为联合类型，示例如下： 12345type IsUnion&lt;T, U = T&gt; = // 代码实现type I0 = IsUnion&lt;string|number&gt; // truetype I1 = IsUnion&lt;string|never&gt; // falsetype I2 = IsUnion&lt;string|unknown&gt; //false 解决方案 12345type IsUnion&lt;T, U = T&gt; = T extends any ? [U] extends [T] ? false : true : never;type I0 = IsUnion&lt;string|number&gt; // truetype I1 = IsUnion&lt;string|never&gt; // falsetype I2 = IsUnion&lt;string|unknown&gt; //false 知识点： 1.联合类型作为泛型的时候 extends 会触发分发执行 2.联合类型 T 写成[T]就变成了普通类型，extends 的时候不会分发执行 这里第一步T extends any肯定为真，一个其实就是利用其分发的特性，后面的[T]就是一个联合类型拆开后的某一个，因此如果是联合类型的话[U] extends [T]一定为否 第二十六题 实现一个IsNever工具类型，判断指定的类型是否为never类型，示例如下： 12345type IsNever&lt;T&gt; = // 代码实现type I0 = IsNever&lt;never&gt; // truetype I1 = IsNever&lt;never | string&gt; // falsetype I2 = IsNever&lt;null&gt; // false 解决方案 用[]包裹 T，否则泛型参数会被当作一个裸类型处理，走条件式分布类型的判断逻辑，当泛型参数是 any 这种特殊值时，会得到分布后的类型。 12345type IsNever&lt;T&gt; = [T] extends [never] ? true : false;type I0 = IsNever&lt;never&gt; // truetype I1 = IsNever&lt;never | string&gt; // falsetype I2 = IsNever&lt;null&gt; // false 第二十七题 实现一个Reverse工具类型，用于对元祖类型中元素的位置颠倒，并返回该数组，元祖的第一个元素就会变成最后一个，最后一个元素变成第一个。 1234567type Reverse&lt; T extends any[], R extends any[] = []&gt; = // 代码实现type R0 = Reverse&lt;[]&gt; // []type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1] 解决方案 1 1234567type Reverse&lt; T extends any[], R extends any[] = []&gt; = T extends [infer A, ...infer B] ? Reverse&lt;B, [A, ...R]&gt; : R;type R0 = Reverse&lt;[]&gt; // []type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1] 解决方案 2 123456type Reverse&lt; T extends any[]&gt; = T extends [infer A, ...infer B] ? [...Reverse&lt;B&gt;, A] : [];type R0 = Reverse&lt;[]&gt; // []type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1] 第二十八题 实现一个Split工具类型，根据给定的分割符(Delimiter)对包含分割符的字符串进行切割，可用于定义String.prototype.split方法的返回值类型，示例如下： 12345678type Item = `zs, ls, ww`;type Split&lt; S extends string, Delimiter extends string&gt; = // 代码实现type ElementType = Split&lt;Item, ','&gt;; // [&quot;zs&quot;, &quot;ls&quot;,&quot;ww&quot;] 解决方案 1234567891011121314type Item = `zs, ls, ww`;type Split&lt; S extends string, Delimiter extends string,&gt; = S extends `${infer Key}${Delimiter}${infer Rest}`? [Key, ...Split&lt;Rest, Delimiter&gt;]: S extends '' /* 处理空字符串 */? []: [S]type ElementType = Split&lt;Item, ','&gt;; // [&quot;zs&quot;, &quot;ls&quot;,&quot;ww&quot;]type ElementType2 = Split&lt;'a|b|c||d', '|'&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot;]type ElementType3 = Split&lt;'abcdef', ''&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 第二十九题 实现一个ToPath工具类型，用于把属性访问(.或[])路径转换为元祖的形式，示例如下： 1234type ToPath&lt;S extends string&gt; = // 代码实现ToPath&lt;'foo.bar.baz'&gt; // ['foo', 'bar', 'baz']ToPath&lt;'foo[0].bar.baz'&gt; // ['foo', '0', 'bar', 'baz'] 解决方案 12345678910type ToPath&lt;S extends string&gt; = S extends `${infer F}${`[${infer D}]`}${infer R}`? [...ToPath&lt;F&gt;, ...([D] extends [never] ? [] : [D]), ...ToPath&lt;R&gt;]: S extends `${infer F}.${infer R}`? [...ToPath&lt;F&gt;, ...ToPath&lt;R&gt;]: S extends ''? []: [S]type T0 = ToPath&lt;'foo.bar.baz'&gt; // ['foo', 'bar', 'baz']type T1 = ToPath&lt;'foo[0].bar.baz'&gt; // ['foo', '0', 'bar', 'baz'] 第三十题 完善Chainable类型的定义，是的 TS 能成功推断出result变量的类型，调用option方法之后会不断扩展当前对象的类型，使得调用get方法后能获取正确的类型。 12345678910111213141516171819202122declare const config: Chainabletype Chainable = { option(key: string, value: any): any get(): any}const result = config .option('age', 7) .option('name', 'lolo') .option('address', { value: 'XiaMen' }) .get()type ResultType = typeof result// 期望 ResultType 的类型是：// {// age: number// name: string// address: {// value: string// }// } 解决方案 12345678910declare const config: Chainable;type Chainable&lt;T = {}&gt; = { option&lt;K extends string, V extends any&gt;(key: K, value: V): Chainable&lt;{ [P in K]: V } &amp; T&gt;; get(): T;};const result = config.option(&quot;age&quot;, 7).option(&quot;name&quot;, &quot;lolo&quot;).option(&quot;address&quot;, { value: &quot;XiaMen&quot; }).get();type ResultType = typeof result; 第三十一题 实现一个Repeat工具类型，用于根据类型变量C的值，重复T类型并以元祖的形式返回新的类型，示例如下： 12345type Repeat&lt;T, C extends number&gt; = // 代码实现type R0 = Repeat&lt;0, 0&gt;; // []type R1 = Repeat&lt;1, 3&gt;; // [1, 1, 1]type R2 = Repeat&lt;number, 2&gt;; // [number, number] 解决方案 12345type Repeat&lt;T, C extends number, A extends any[]&gt; = A[&quot;length&quot;] extends C ? A : Repeat&lt;T, C, [...A, T]&gt;;type R0 = Repeat&lt;0, 0&gt;; // []type R1 = Repeat&lt;1, 3&gt;; // [1, 1, 1]type R2 = Repeat&lt;number, 2&gt;; // [number, number] 第三十二题 实现一个RepeatString工具类型，用于根据类型变量C的值，重复 T 类型并以字符串的形式返回新的类型，示例如下： 1234567type RepeatString&lt; T extends string, C extends number,&gt; = // 代码实现type S0 = RepeatString&lt;&quot;a&quot;, 0&gt;; // ''type S1 = RepeatString&lt;&quot;ab&quot;, 2&gt;; // 'abab' 解决方案 1234567891011type RepeatString&lt; T extends string, C extends number, S extends string = '', A extends any[] = []&gt; = A[&quot;length&quot;] extends C? S: RepeatString&lt;T, C, `${S}${T}`, [...A, T]&gt;type S0 = RepeatString&lt;&quot;a&quot;, 0&gt;; // ''type S1 = RepeatString&lt;&quot;ab&quot;, 2&gt;; // 'abab' 第三十三题 实现一个ToNumber工具类型，用于实现把数值字符串转换为数值类型，示例如下： 12345type ToNumber&lt;T extends string&gt; = // 代码实现type T0 = ToNumber&lt;&quot;0&quot;&gt;; // 0type T1 = ToNumber&lt;&quot;10&quot;&gt;; // 10type T2 = ToNumber&lt;&quot;20&quot;&gt;; // 20 解决方案 123456type ToNumber&lt;T extends string, S extends any[] = [], L extends number = S[&quot;length&quot;]&gt; =`${L}` extends T ? L : ToNumber&lt;T, [...S, 1]&gt;type T0 = ToNumber&lt;&quot;0&quot;&gt;; // 0type T1 = ToNumber&lt;&quot;10&quot;&gt;; // 10type T2 = ToNumber&lt;&quot;20&quot;&gt;; // 20 第三十四题 实现一个SmallerThan工具类型，用于比较数值类型的大小，示例如下： 12345678type SmallerThan&lt; N extends number, M extends number,&gt; = //代码实现type S0 = SmallerThan&lt;0, 1&gt;; // truetype S1 = SmallerThan&lt;2, 0&gt;; // falsetype S2 = SmallerThan&lt;8, 10&gt;; // true 解决方案 123456789101112type SmallerThan&lt; N extends number, M extends number, S extends any[] = [], L extends number = S[&quot;length&quot;]&gt; = L extends N? L extends M ? false : true: L extends M ? false : SmallerThan&lt;N, M, [...S, 1]&gt;type S0 = SmallerThan&lt;0, 1&gt;; // truetype S1 = SmallerThan&lt;2, 0&gt;; // falsetype S2 = SmallerThan&lt;8, 10&gt;; // true 第三十五题 实现一个Add工具类型，用于实现对数组对应的数值进行加法运算，示例如下： 12345type Add&lt;T, R&gt; = // 代码实现type A0 = Add&lt;5, 5&gt;; // 10type A1 = Add&lt;8, 20&gt;; // 28type A2 = Add&lt;10, 20&gt;; // 30 解决方案 123456789101112type Push&lt;T extends number[], V&gt; = [...T, V];type CreateTuple&lt; T extends number, A extends number[] = []&gt; = A[&quot;length&quot;] extends T ? A : CreateTuple&lt;T, Push&lt;A, 1&gt;&gt;;type Add&lt;T extends number, R extends number&gt; = [...CreateTuple&lt;T&gt;, ...CreateTuple&lt;R&gt;][&quot;length&quot;];type A0 = Add&lt;5, 5&gt;; // 10type A1 = Add&lt;8, 20&gt;; // 28type A2 = Add&lt;10, 20&gt;; // 30 第三十六题 实现一个Filter工具类型，用于根据类型变量F的值进行类型过滤，示例如下： 12345type Filter&lt;T extends any[], F&gt; = // 代码实现type F0 = Filter&lt;[6, &quot;lolo&quot;, 7, &quot;semlinker&quot;, false], number&gt;; // [6, 7]type F1 = Filter&lt;[&quot;kakuqo&quot;, 2, [&quot;ts&quot;], &quot;lolo&quot;], string&gt;; // [&quot;kakuqo&quot;, &quot;lolo&quot;]type F2 = Filter&lt;[0, true, any, &quot;abao&quot;], string&gt;; // [any, &quot;abao&quot;] 解决方案 1234// 本题关键点就是对`any`类型的处理：type A0 = any &amp; 1; // anytype A1 = any &amp; boolean; // anytype A2 = any &amp; never; // never 1234567891011type IsAny&lt;T&gt; = 0 extends (1 &amp; T) ? true : false;type Filter&lt;T extends any[], F&gt; = T extends [infer R1, ...infer R2]? IsAny&lt;R1&gt; extends true? [R1, ...Filter&lt;R2, F&gt;]: [...R1 extends F ? [R1] : [], ...Filter&lt;R2, F&gt;]:[]type F0 = Filter&lt;[6, &quot;lolo&quot;, 7, &quot;semlinker&quot;, false], number&gt;; // [6, 7]type F1 = Filter&lt;[&quot;kakuqo&quot;, 2, [&quot;ts&quot;], &quot;lolo&quot;], string&gt;; // [&quot;kakuqo&quot;, &quot;lolo&quot;]type F2 = Filter&lt;[0, true, any, &quot;abao&quot;], string&gt;; // [any, &quot;abao&quot;] 第三十七题 实现一个Flat工具类型，支持把数组类型拍平（扁平化）,示例如下： 12345type Flat&lt;T extends any[]&gt; = // 代码实现type F0 = Flat&lt;[]&gt;; // []type F1 = Flat&lt;['a', 'b', 'c']&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]type F2 = Flat&lt;['a', ['b', 'c'], ['d', ['e', ['f']]]]&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 解决方案 1 123456789type Flat&lt;T extends any[]&gt; = T extends [infer First, ...infer Rest]? First extends any[]? [...Flat&lt;First&gt;, ...Flat&lt;Rest&gt;]: [First, ...Flat&lt;Rest&gt;]: [];type F0 = Flat&lt;[]&gt;; // []type F1 = Flat&lt;['a', 'b', 'c']&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]type F2 = Flat&lt;['a', ['b', 'c'], ['d', ['e', ['f']]]]&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 解决方案 2 123456789type Flat&lt;T extends any[], S extends any[] = []&gt; = T extends [infer R, ...infer Rest]? R extends any[]? Flat&lt;Rest, Flat&lt;R, S&gt;&gt;: Flat&lt;Rest, [...S, R]&gt;: Stype F0 = Flat&lt;[]&gt;; // []type F1 = Flat&lt;['a', 'b', 'c']&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]type F2 = Flat&lt;['a', ['b', 'c'], ['d', ['e', ['f']]]]&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 第三十八题 实现StartsWith工具类型，判断字符串字面量类型T是否以给定的字符串字面量类型U开头，并根据判断结果返回布尔值，示例如下： 12345type StartsWith&lt;T extends string, U extends string&gt; = // 代码实现type S0 = StartsWith&lt;'123', '12'&gt;; // truetype S1 = StartsWith&lt;'123', '13'&gt;; // falsetype S2 = StartsWith&lt;'123', '1234'&gt;; // false 之后，继续实现EndsWith工具类型，判断字符串字面量类型T是否以给定的字符串字面量类型U结尾，并根据判断结果返回布尔值，示例如下： 12345type EndsWith&lt;T extends string, U extends string&gt; = // 代码实现type E0 = EndsWith&lt;'123', '23'&gt;; // truetype E1 = EndsWith&lt;'123', '13'&gt;; //falsetype E2 = EndsWith&lt;'123', '123'&gt;; //true 解决方案 12345678910111213// StartWithtype StartsWith&lt;T extends string, U extends string&gt; = T extends `${U}${infer R}` ? true : false;type S0 = StartsWith&lt;'123', '12'&gt;; // truetype S1 = StartsWith&lt;'123', '13'&gt;; // falsetype S2 = StartsWith&lt;'123', '1234'&gt;; // false// EndsWithtype EndsWith&lt;T extends string, U extends string&gt; = T extends `${infer Head}${U}` ? true : false;type E0 = EndsWith&lt;'123', '23'&gt;; // truetype E1 = EndsWith&lt;'123', '13'&gt;; //falsetype E2 = EndsWith&lt;'123', '123'&gt;; //true 第三十九题 实现IsAny工具类型，用于判断类型T是否为any类型，示例如下： 12345type IsAny&lt;T&gt; = // 代码实现type I0 = IsAny&lt;never&gt;; // falsetype I1 = IsAny&lt;unknown&gt;; // falsetype I2 = IsAny&lt;any&gt;; // tue 解决方案 1 123456// 思路： 利用任何类型和any交叉都等于any来实现type IsAny&lt;T&gt; = 0 extends 1 &amp; T ? true : false;type I0 = IsAny&lt;never&gt;; // falsetype I1 = IsAny&lt;unknown&gt;; // falsetype I2 = IsAny&lt;any&gt;; // tue 解决方案 2 123456// unknown 只能赋给 unknown 或者 anytype IsAny&lt;T&gt; = [unknown] extends [T] ? ([T] extends [string] ? true : false) : false;type I0 = IsAny&lt;never&gt;; // falsetype I1 = IsAny&lt;unknown&gt;; // falsetype I2 = IsAny&lt;any&gt;; // tue 第四十题 实现AnyOf工具类型，只要数组中任意元素的类型非Falsy类型、{}类型或[]类型，则返回true，否则返回false,如果数组为空的话，则返回false，示例如下： 12345type AnyOf&lt;T extends any[]&gt; = // 代码实现type A0 = AnyOf&lt;[]&gt;; //falsetype A1 = AnyOf&lt;[0,'',false,[],{}]&gt;; //falsetype A2 = AnyOf&lt;[1, &quot;&quot;,false,[],{}]&gt;; true 解决方案 1234567type Falsy = { [p in PropertyKey]: never} | [] | '' | &quot;&quot; | false | 0 | undefined | nulltype AnyOf&lt;T extends any[]&gt; = T extends [infer A, ...infer Rest]? (A extends Falsy ? AnyOf&lt;Rest&gt; : true): false 第四十一题 实现Replace工具类型，用于实现字符串类型的替换操作，具体的使用示例如下： 123456789type Replace&lt; S extends string, From extends string, To extends string&gt; = // 代码实现type R0 = Replace&lt;'', '', ''&gt;; // ''type R1 = Replace&lt;'foobar', 'bar', 'foo'&gt;; // 'foofoo'type R2 = Replace&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoobar' 此外，继续实现ReplaceAll工具类型，用于实现替换所有满足条件的字串，示例如下： 12345678910type ReplaceAll&lt; S extends string, From extends string, To extends string&gt; = // 代码实现type R0 = ReplaceAll&lt;'', '', ''&gt;; // ''type R1 = ReplaceAll&lt;'barfoo', 'bar', 'foo'&gt;; // 'foofoo'type R2 = ReplaceAll&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoofoo'type R3 = ReplaceAll&lt;'foobarfoobar', 'ob', 'b'&gt;; // 'fobarfobar' 解决方案 1234567891011type Replace&lt; S extends string, From extends string, To extends string,&gt; = S extends `${infer H}${From}${infer R}`? `${H}${To}${R}`: S;type R0 = Replace&lt;'', '', ''&gt;; // ''type R1 = Replace&lt;'foobar', 'bar', 'foo'&gt;; // 'foofoo'type R2 = Replace&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoobar' 123456789101112type ReplaceAll&lt; S extends string, From extends string, To extends string,&gt; = S extends `${infer H}${From}${infer R}`? `${H}${To}${ReplaceAll&lt;R, From, To&gt;}`: S;type R0 = ReplaceAll&lt;'', '', ''&gt;; // ''type R1 = ReplaceAll&lt;'barfoo', 'bar', 'foo'&gt;; // 'foofoo'type R2 = ReplaceAll&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoofoo'type R3 = ReplaceAll&lt;'foobarfoobar', 'ob', 'b'&gt;; // 'fobarfobar' 第四十二题 实现IndexOf工具类型，用于获取数组类型中指定项的索引值，若不存在的话，则返回-1字面量类型，示例如下： 123456type IndexOf&lt;A extends any[], Item&gt; = // 代码实现type Arr = [1, 2, 3, 4, 5];type I0 = IndexOf&lt;Arr, 0&gt;; // -1type I1 = IndexOf&lt;Arr, 1&gt;; // 0type I2 = IndexOf&lt;Arr, 3&gt;; // 2 解决方案 12345678910type IndexOf&lt;A extends any[], Item, R extends any[] = []&gt; = A extends [infer H, ...infer Rest]? Item extends H? R[&quot;length&quot;]: IndexOf&lt;Rest, Item, [...R, H]&gt;: -1type Arr = [1, 2, 3, 4, 5];type I0 = IndexOf&lt;Arr, 0&gt;; // -1type I1 = IndexOf&lt;Arr, 1&gt;; // 0type I2 = IndexOf&lt;Arr, 3&gt;; // 2 第四十三题 实现一个Permutation工具类型，当输入一个联合类型时，返回一个包含该联合类型的全排列类型数组。示例如下： 1234type Permutation&lt;T, K = T&gt; = // 代码实现type P0 = Permutation&lt;'a' | 'b'&gt;; // ['a', 'b'] | ['b' , 'a']type P1 = Permutation&lt;'a' | 'b' | 'c'&gt;; //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] | [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;] | [&quot;b&quot;, &quot;a&quot;, &quot;c&quot;] | [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] | [&quot;c&quot;, &quot;a&quot;, &quot;b&quot;] | [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;] 解决方案 12345678type Permutation&lt;T, K = T&gt; = [T] extends [never]? []: K extends K? [K, ...Permutation&lt;Exclude&lt;T, K&gt;&gt;]: nevertype P0 = Permutation&lt;'a' | 'b'&gt;; // ['a', 'b'] | ['b' , 'a']type P1 = Permutation&lt;'a' | 'b' | 'c'&gt;; //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] | [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;] | [&quot;b&quot;, &quot;a&quot;, &quot;c&quot;] | [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] | [&quot;c&quot;, &quot;a&quot;, &quot;b&quot;] | [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;] 第四十四题 实现Unpacked工具类型，用于对类型执行“拆箱”操作，示例如下： 12345678910type Unpacked&lt;T&gt; = // 代码实现// 测试用例type T00 = Unpacked&lt;string&gt;; // stringtype T01 = Unpacked&lt;string[]&gt;; // stringtype T02 = Unpacked&lt;() =&gt; string&gt;; // stringtype T03 = Unpacked&lt;Promise&lt;string&gt;&gt;; // stringtype T04 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;; // stringtype T05 = Unpacked&lt;any&gt;; // anytype T06 = Unpacked&lt;never&gt;; // never 解决方案 12345678910111213141516type Unpacked&lt;T&gt; = T extends (...args: any) =&gt; infer A? A: T extends Promise&lt;infer B&gt;? B: T extends (infer A)[]? A: T// 测试用例type T00 = Unpacked&lt;string&gt;; // stringtype T01 = Unpacked&lt;string[]&gt;; // stringtype T02 = Unpacked&lt;() =&gt; string&gt;; // stringtype T03 = Unpacked&lt;Promise&lt;string&gt;&gt;; // stringtype T04 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;; // stringtype T05 = Unpacked&lt;any&gt;; // anytype T06 = Unpacked&lt;never&gt;; // never 第四十五题 实现JsonifiedObject工具类型，用于对Object对象类型进行序列话操作，示例如下： 123456789101112131415161718192021declare class MyClass { toJSON(): &quot;MyClass&quot;;}type Jsonified&lt;T extends object&gt; = // 代码实现type MyObject = { str: &quot;literalstring&quot;; fn: () =&gt; void; date: Date; customClass: MyClass; obj: { prop: &quot;property&quot;; clz: MyClass; nested: { attr: Date }; };};type JsonifiedMyObject = Jsonified&lt;MyObject&gt;;declare let ex: JsonifiedMyObject;const z1: &quot;MyClass&quot; = ex.customClass;const z2: string = ex.obj.nested.attr; 解决方案 1234567891011121314151617181920212223242526272829declare class MyClass { toJSON(): &quot;MyClass&quot;;}type Jsonified&lt;T extends object&gt; = { [K in keyof T]: T[K] extends { toJSON(): infer Return } ? ReturnType&lt;T[K][&quot;toJSON&quot;]&gt; : T[K] extends (...arg: any[]) =&gt; any ? never : T[K] extends object ? Jsonified&lt;T[K]&gt; : T[K];};type MyObject = { str: &quot;literalstring&quot;; fn: () =&gt; void; date: Date; customClass: MyClass; obj: { prop: &quot;property&quot;; clz: MyClass; nested: { attr: Date }; };};type JsonifiedMyObject = Jsonified&lt;MyObject&gt;;declare let ex: JsonifiedMyObject;const z1: &quot;MyClass&quot; = ex.customClass;const z2: string = ex.obj.nested.attr; 第四十六题 实现RequireAllOrNone工具类型，用于满足以下功能，当设置age属性时，gender属性也会变成必填，示例如下： 1234567891011121314151617interface Person { name: string; age?: number; gender?: number;}type RequireAllOrNone&lt;T, K extends keyof T&gt; = // 你的实现代码const p1: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;};const p2: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1}; 解决方案 123456789101112131415161718192021222324interface Person { name: string; age?: number; gender?: number;}type RequireAllOrNone&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; &amp; ( {[P in K]-?: T[P]} | {[P in K]?: never})const p1: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;};const p2: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1};const p3: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { // error name: &quot;lolo&quot;, age: 7,}; 第四十七题 实现RequireExactlyOne工具类型，用于满足以下功能，即只能包含age或gender属性，不能包含着两个属性，示例如下： 12345678910111213141516171819202122232425interface Person { name: string; age?: number; gender?: number;}// 只能包含Keys中唯一的一个Keytype RequireExactlyOne&lt;T, Keys extends keyof T&gt; = // 你的实现代码const p1: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7,};const p2: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, gender: 1};// Errorconst p3: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1}; 解决方案 12345678910111213141516171819202122232425262728interface Person { name: string; age?: number; gender?: number;}// 只能包含Keys中唯一的一个Keytype RequireExactlyOne&lt;T, Keys extends keyof T, K extends keyof T = Keys&gt; =Keys extends any? Omit&lt;T, K&gt; &amp; Required&lt;Pick&lt;T, Keys&gt;&gt; &amp; Partial&lt;Record&lt;Exclude&lt;K, Keys&gt;, never&gt;&gt;: never;const p1: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7,};const p2: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, gender: 1};// Errorconst p3: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1}; 第四十八题 实现ConsistsOnlyOf工具类型，用于判断LongString字符串类型是否由 0 个或多个Substring字符串类型组成，示例如下： 123456type ConsistsOnlyOf&lt;LongString extends string, SubString extends string&gt; = // 代码实现type C0 = ConsistsOnlyOf&lt;'aaa', 'a'&gt;; // truetype C1 = ConsistsOnlyOf&lt;'ababab', 'ab'&gt;; // truetype C2 = ConsistsOnlyOf&lt;'aBa', 'a'&gt;; // falsetype C3 = ConsistsOnlyOf&lt;'', 'a'&gt;; // true 解决方案 1234567891011type ConsistsOnlyOf&lt;LongString extends string, SubString extends string&gt; =LongString extends ''? true: LongString extends `${SubString}${infer R}`? ConsistsOnlyOf&lt;R, SubString&gt;: falsetype C0 = ConsistsOnlyOf&lt;'aaa', 'a'&gt;; // truetype C1 = ConsistsOnlyOf&lt;'ababab', 'ab'&gt;; // truetype C2 = ConsistsOnlyOf&lt;'aBa', 'a'&gt;; // falsetype C3 = ConsistsOnlyOf&lt;'', 'a'&gt;; // false 第四十九题 项目中定义了接口返回的数据的类型，每层都能灵活扩展一些属性，怎么做呢？ 1234567// 接口返回数据结构type Data = { aaa?: number; bbb: { ccc: number; };}; 解决方案 1234567type DeepRecord&lt;Obj extends Record&lt;keyof any, unknown&gt;&gt; = { [key in keyof Obj]: Obj[key] extends Record&lt;keyof any, unknown&gt; ? DeepRecord&lt;Obj[key]&gt; &amp; Record&lt;keyof any, unknown&gt; : Obj[key];} &amp; Record&lt;keyof any, unknown&gt;;type IData = DeepRecord&lt;Data&gt;; 第五十题 当一个索引为 ‘desc’ | ‘asc’ 的时候，其他索引都是 false 解决方案 123456789type GenerateType&lt;keys extends keyof any, V1, V2&gt; = { [key in keys]: { [key1 in key]: V1; } &amp; { [key2 in Exclude&lt;keys, key&gt;]: V2; };}[keys];type R = GenerateType&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;, &quot;desc&quot; | &quot;asc&quot;, false&gt;; 第五十一题 取出interface中userInfo的类型 1234567interface Result { data?: { userInfo?: { name: string; }; };} 解决方案 1 1234// 简单版 Required// 缺点 层级深了需要写多个Requiredtype UserInfo = Required&lt;Required&lt;Result&gt;[&quot;data&quot;]&gt;[&quot;userInfo&quot;]; 解决方案 2 1234567891011// 递归Required// 缺点数据类型都会变成Requiredtype IsOptional&lt;Key extends keyof Obj, Obj&gt; = {} extends Pick&lt;Obj, Key&gt; ? Key : never;type DeepRequired&lt;T&gt; = { [K in keyof T]-?: IsOptional&lt;K, T&gt; extends never ? T[K] : DeepRequired&lt;T[K]&gt;;};type UserInfo = DeepRequired&lt;Result&gt;[&quot;data&quot;][&quot;userInfo&quot;];","link":"/2022/01/17/typescript%E8%BF%9B%E9%98%B6%E9%A2%98%E7%9B%AE/"},{"title":"vue3源码调试","text":"vue3 源码调试步骤 clone 项目1git clone https://github.com/vuejs/vue-next.git 安装依赖1yarn --ignore-scripts 修改配置修改package.json中的 scripts 下 dev 的配置，后面添加 –sourcemap 123&quot;dev&quot;: &quot;node scripts/dev.js&quot;// ⬇&quot;dev&quot;: &quot;node scripts/dev.js --sourcemap&quot; 编译1yarn run dev 当终端出现waiting for changes…表示编译成功，可以ctrl+c结束进程查看源码了 打包完成之后，examples 下面的文件会引用 dist 文件下的文件（dist 文件是我们刚才编译后生成的文件） debugger我们直接在package/vue/examples目录下添加demo/test.html文件，并引用**../../dist/vue.global.js**文件就可以使用 vue3 了，代码如下： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../../dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;template id=&quot;foo&quot;&gt; &lt;h2&gt;{{name}}&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; const App = { template: '#foo', data: function () { return { name: 'foolishmax' } } } Vue.createApp(App).mount('#app') &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 接下来在浏览器中打开就可以进行 vue3 的代码调试了。","link":"/2022/01/02/vue3%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/"},{"title":"vue响应式系统实现","text":"源码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274const bucket = new WeakMap();// 用一个全局变量存储当前激活的effect函数let activeEffect;// effect栈const effectStack = [];function effect(fn, options = []) { const effectFn = () =&gt; { // 调用cleanup函数完成清除工作 cleanup(effectFn); // 当调用effect注册副作用函数时，将副作用函数赋值给activeEffect activeEffect = effectFn; // 调用副作用函数之前将当前副作用函数压入栈顶 effectStack.push(effectFn); // 把fn的执行结果存储在res中 const res = fn(); // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并将activeEffect还原为之前的值 effectStack.pop(); activeEffect = effectStack[effectStack.length - 1]; return res; }; // 将options挂载到effectFn上 effectFn.options = options; // 用来存储所有与该副作用函数相关的依赖集合 effectFn.deps = []; // 只有非lazy的时候，才执行 if (!options.lazy) { effectFn(); } return effectFn;}// computedfunction computed(getter) { // 用来缓存上一次计算的值 let value; // dirty标志，用来识别是否需要重新计算值，为true时则意味着“脏”，需要计算 let dirty = true; const effectFn = effect(getter, { lazy: true, scheduler() { if (!dirty) { dirty = true; // 当计算属性依赖的响应式数据变化时，手动调用trigger函数触发响应 trigger(obj, &quot;value&quot;); } }, }); const obj = { get value() { if (dirty) { value = effectFn(); dirty = false; } // 当读取value时，手动调用track函数进行追踪 track(obj, &quot;value&quot;); return value; }, }; return obj;}// watchfunction watch(source, cb, options = {}) { let getter; // 如果是函数，说明用户传递的不再是一个响应式数据，而是一个getter函数，直接把source赋值给getter if (typeof source === &quot;function&quot;) { getter = source; } else { // 否则调用traverse递归读取响应式数据属性 getter = () =&gt; traverse(source); } //定义旧值和新值 let oldValue, newValue; // cleanup用来存储用户注册的国旗回调 let cleanup; // 定义onInvalidate函数 function onInvalidate(fn) { // 将过期回调存储到cleanup中 cleanup = fn; } // 提取调度器scheduler为一个独立的job函数 const job = () =&gt; { // 在scheduler中重新执行副作用函数，得到的是新值 newValue = effectFn(); // 在调用糊掉函数cb之前，先调用过期回调 if (cleanup) { cleanup(); } // 将旧值和新值作为回调函数的参数 cb(newValue, oldValue); // 更新旧值，不然下次会得到错误的旧值 oldValue = newValue; }; // 使用effect注册副作用函数时，开启lazy选项，并把返回值存储到effectFn中一边后续手动调用 const effectFn = effect(() =&gt; getter(), { lazy: true, scheduler: job, }); if (options.immediate) { // 当immediate为true时立即执行job，从而触发回调执行 job(); } else { // 手动调用副作用函数，拿到的值就是旧值 oldValue = effectFn(); }}function traverse(value, seen = new Set()) { // 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做 if (typeof value !== &quot;object&quot; || value === null || seen.has(value)) return; // 将数据添加到seen中，代表便利地读取过了，避免循环引用引起的死循环 seen.add(value); // 暂时不考虑数组等其他结构 // 假设value是一个对象，使用for...in读取对新啊个的每一个值，并递归调用traverse进行处理 for (const k in value) { traverse(value[k], seen); } return value;}function cleanup(effectFn) { // 遍历effectFn.deps数组 for (let i = 0; i &lt; effectFn.deps.length; i++) { // deps是依赖集合 const deps = effectFn.deps[i]; // 将effectFn从依赖集合中移除 deps.delete(effectFn); } // 最后需要重置effectFn.deps数组 effectFn.deps.length = 0;}// 在get拦截函数内调用track函数追踪变化function track(target, key) { // 没有activeEffect，直接return if (!activeEffect) return target[key]; // 根据target从“桶”中取得depsMap，也是一个Map类型：key --&gt; effects let depsMap = bucket.get(target); // 如果不存在depsMap，新建一个Map并与target关联 if (!depsMap) { bucket.set(target, (depsMap = new Map())); } // 根据key从depsMap中取得deps，它是一个Set类型， // 里面存储着所有与当前key相关联的副作用函数：effects let deps = depsMap.get(key); if (!deps) { depsMap.set(key, (deps = new Set())); } // 最后将当前激活的副作用函数添加到“桶”中 deps.add(activeEffect); // deps就是一个与当前副作用函数存在联系的依赖集合 // 将其添加到activeEffect.deps数组中 activeEffect.deps.push(deps);}// 在set函数拦截内调用trigger函数出发变化function trigger(target, key) { // 根据target从桶中取出depsMap，它是 key --&gt; effects const depsMap = bucket.get(target); if (!depsMap) return; // 根据key取得所有副作用函数effects const effects = depsMap.get(key); // 在调用forEach遍历Set集合时，如果一个值已经被访问过了， // 但该值被删除并重新添加集合，如果此时forEach遍历还没结束 // 该值会重新被访问，就会导致无限循环执行。 // 解决方法：构造另一个Set集合遍历它 const effectsToRun = new Set(); // 执行副作用函数 effects &amp;&amp; effects.forEach((effectFn) =&gt; { // 如果trigger触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行 if (effectFn !== activeEffect) { effectsToRun.add(effectFn); } }); effectsToRun.forEach((effectFn) =&gt; { // 如果一个副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递 if (effectFn.options.scheduler) { effectFn.options.scheduler(effectFn); } else { // 否则直接执行副作用函数 effectFn(); } });}const data = { text: &quot;hello world&quot;, ok: false, foo: 1, bar: 2 };const obj = new Proxy(data, { // 拦截读取操作 get(target, key) { // 将副作用函数activeEffect添加到存储副作用函数的桶中 track(target, key); // 返回属性值 return target[key]; }, // 拦截设置操作 set(target, key, newVal) { // 设置属性值 target[key] = newVal; // 把副作用函数从桶中取出并执行 trigger(target, key); },});let temp1, temp2;// watchwatch( () =&gt; obj.foo, (newValue, oldValue) =&gt; { console.log(&quot;数据变化了&quot;, newValue, oldValue); }, { immediate: true, });obj.foo++;// computed// const sum = computed(() =&gt; obj.foo + obj.bar);// effect(() =&gt; {// console.log(sum.value);// });// obj.foo++;// lazy// const effectFn = effect(// () =&gt; {// console.log(obj.text);// },// {// lazy: true,// }// );// effectFn();// 嵌套的effect与effect栈// effect(function effectFn1() {// console.log(&quot;effectFn1 执行&quot;);// effect(function effectFn2() {// console.log(&quot;effectFn2 执行&quot;);// temp2 = obj.ok;// });// temp1 = obj.text;// obj.text += &quot;1&quot;;// });// 分支切换与cleanup// effect(() =&gt; {// console.log('effect run');// document.body.innerText = obj.ok ? obj.text : &quot;not&quot;;// obj.text = 'foolishmax'// });// 不存在的属性不添加响应式// setTimeout(() =&gt; {// obj.text = &quot;hello vue3&quot;;// // obj.notExist = 'hello vue3'// }, 3000);","link":"/2022/08/07/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"title":"webpack配置工程师","text":"构建 webpack 知识体系分为下面三个层级： 1.基础–会配置 2.进阶–能优化 3.深入–懂原理 一、基础篇 1.简单配置该部分需掌握：1.Webpack 常规配置项有哪些？ 2.常用 loader 有哪些？如何配置？ 3.常用插件 plugin 有哪些？如何配置？4.Babel 如何配置？Babel 插件如何使用？ 1.1 安装依赖需要现在本地安装webpack及webpack-cli 1$ npm install webpack webpack-cli -D 1.2 开始工作webpack 在 4 以后就支持 0 配置打包，我们可以测试一下 1.新建 webpack-work 项目，新建 ./src/index.js文件，写一段简单的代码 123const a = 'hello foolishmax';console.log(a);module.exports = a; 2.直接运行npx webpack，启动打包) 打包完成，会有一个提示：The 'mode' option has not been set,... 意思就是我们没有配置 mode（告知 webpack 使用相应模式的内置优化，默认为production，另外还有development、none） 选项 描述 development 开发模式，打包更加快速，省了代码优化步骤 production 生产模式，打包比较慢，开启 tree-shaking 和压缩代码 none 不使用任何默认优化选项 webpack.config.js 中配置： 123module.exports = { mode: 'development',} 1.3 配置文件虽然可以零配置打包，但是实际工作中，还是需要使用配置文件的方式来满足不同项目的需求。 1.跟路径下创建配置文件webpack.config.js 2.新增基本配置信息 1234567891011const path = require('path');module.exports = { mode: 'development', // 模式 entry: './src/index.js', // 打包入口地址 output: { filename: 'bundle.js', // 输出文件名 path: path.join(__dirname, 'dist') // 输出文件目录 }} 1.4 loader这里我们把入口文件改成 css 文件，看下打包结果如何 1.新增./src/main.css 1234567body { margin: 0 auto; padding: 0 20px; max-width: 800px; background: #f4f8fb;} 2.修改 entry 配置 1234567891011const path = require('path');module.exports = { mode: 'development', entry: './src/main.css', output: { filename: 'bundle.js', path: path.join(__dirname, 'dist') }} 3.运行打包命令： npx webpack这里的报错信息是因为：webpack 默认支持处理 js 文件，其他类型都处理不了，需要借助 loader 来对不同类型的文件进行处理。 4.安装css-loader来处理 CSS 1npm install css-loader -D 5.配置资源加载模块 12345678910111213141516171819const path = require('path');module.exports = { mode: 'development', entry: './src/main.css', output: { filename: 'bundle.css', path: path.join(__dirname, 'dist') }, module: { rules: [ // 转换规则 { test: /.css$/, // 匹配所有css文件 use: 'css-loader', //对应的loader名称 } ] }} 6.重新运行打包命令npx webpack,就可以打包成功了 总结：loader 就是将 webpack 不认识的内容转化为认识的内容 插件（plugin）插件可以贯穿 webpack 打包的生命周期，执行不同的任务 1.新建./src/index.html文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 如果想要打包后的资源文件，例如 js 或者 css 文件可以自动引入到 html 中，就需要使用插件html-webpack-plugin来做这件事情。 2.本地安装 html-webpack-plugin 1npm install html-webpack-plugin -D 3.配置插件 12345678910111213141516171819202122232425const HtmlWebpackPlugin = require('html-webpack-plugin');const path = require('path');module.exports = { mode: 'development', entry: './src/main.js', output: { filename: 'bundle.js', path: path.join(__dirname, 'dist') }, module: { rules: [ // 转换规则 { test: /.css$/, // 匹配所有css文件 use: 'css-loader', //对应的loader名称 } ] }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', }) ]} 运行一下打包，打开 dist 目录下的 index.html 文件 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 可以看到它自动引入打包好的 bundle.js 1.6 自动清空打包目录每次打包的时候，打包目录都会遗留上次打包的文件，为了保持打包目录的纯净，打包前需将上次打包目录清空。 1.安装 clean-webpack-plugin 1$ npm install clean-webpack-plugin -D 2.配置 123456789101112const HtmlWebpackPlugin = require('html-webpack-plugin');const {CleanWebpackPlugin} = require('clean-webpack-plugin');const path = require('path');module.exports = { plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', }), new CleanWebpackPlugin() ]} 1.7 区分环境本地环境 需要更快的构建速度 需要打印 debug 信息 需要 live reload 或者 hot reload 功能 需要 sourcemap 方便定位问题 … 生产环境： 需要更小的包体积，代码压缩+tree-shaking 需要进行代码分割 需要压缩图片体积 … 掘金","link":"/2021/10/27/webpack%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E5%B8%88/"},{"title":"WEB前端性能优化","text":"WEB 前端性能优化常见方法前端性能优化针对不用资源有不同的性能优化方式 内容优化 + (1)减少HTTP请求数：因为一个完整的请求要经过 DNS寻址，与服务器建立连接，发送数据， 等待服务器响应，接受数据等消耗时间成本和资源成本的复杂过程。 - 常见解决方法： + 资源和并和压缩：合并多个 CSS 文件和 js 文件并使用相应的工具对 js、css、图片等进行压缩处理 + 雪碧图（精灵图）：减少请求数 + 合理设置 http 缓存：原则就是能缓存的越多越好，越久越好，通过 http header 中设置 Expires 过期时间，或者 Last-Modifed 进行请求验证 + 减少 http 请求头、配置多个域名和 CDN 加速、使用缓存（HTTP 缓存、浏览器缓存、应用缓存）、优化 cookie + （2）避免重定向：减少不必要的 http 跳转 + （3）延迟加载组件，预加载组件，图片懒加载 + （4）减少 DOM 元素数量：页面中存在大量 DOM 元素，会导致 JavaScript 遍历 DOM 的效率变慢。 服务器优化 （1）使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度 （2）Gzip 压缩 （3）设置 ETag：ETags（Entity tags，实体标签）是 web 服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。 （4）提前刷新缓冲区 （5）避免空的图像 src Cookie 优化 （1）减少 Cookie 的大小 （2）针对 Web 组件使用域名无关的 Cookie CSS 优化 将 CSS 代码放在 HTML 页面的顶部 避免使用 CSS 表达式 使用来代替@import 避免使用 Filters JavaScript 优化 (1) 将 JavaScript 脚本放在页面的底部。 (2) 将 JavaScript 和 CSS 作为外部文件来引用：在实际应用中使用外部文件可以提高页面速度，因为 JavaScript 和 CSS 文件都能在浏览器中产生缓存。 (3) 最小化 DOM 的访问：使用 JavaScript 访问 DOM 元素比较慢。 (4) document.getElement…将获取到的元素长度提取出来 (5) 尽量减少会产生 reflow 和 repaint 的操作，因为它们都是需要消耗资源的 (6) 慎用 with，with 他会修改编译时的词法作用域，修改了执行环境，访问非局部属性的时候，会从指定 obj 作用域上开始查找，相当于增长了作用域长度，而过长的作用域链会造成查找性能下降。 (7) 慎用 eval 和 Function,需要 js 引擎将源代码转换成可执行代码，这是很消耗资源的操作，同时，也不利于压缩工具进行压缩。 (8) 减少作用域链的查找，访问非本作用域下的变量，在循环遍历的时候使用局部变量缓存该变量，遍历结束后再重写那个变量，尤其是全局变量处于作用域的最顶端，访问时查找次数最多 图像优化 (1)优化图片大小 （2）通过 CSS Sprites 优化图片 （3）不要在 HTML 中使用压缩图片 （4）favicon.ico 要小而且可缓存 robots.txt搜索引擎蜘蛛访问网站时会第一个访问 robots.txt 文件，robots.txt 用于指导搜索引擎蜘蛛禁止抓取网站的某些内容和只允许抓取哪些内容，放在站点根目录。 dns-prefetch &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.bootcss.com&quot;&gt; 使用 dns-prefetch 对项目中使用的域名进行 DNS 预解析，减少 DNS 查询。 URL 优化越短越好避免太多参数目录层次尽量少文件及目录名具有描述性字母全部小写连词符使用-而不是_URL 中包括关键字 TDK 优化TDK 为 title，description，keywords 三个的统称。title：分隔符一般有 ， - ,其中对百度比较友好，-对谷歌比较友好，title 长度 pc 端一般30 个中文，移动端 20 个，超过会截断为省略号。 其他标签语义化img 设置 alt 属性不需要跟踪爬行的链接，设置 rel = “nofollow” [参考]：（https://segmentfault.com/a/1190000008829958）","link":"/2019/07/17/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"Vuex &amp; Redux工作流程","text":"Vue 核心原理 Store : 统一的状态管理容器对象 Vue Components : Vue 组件 dispatch : 操作行为触发方法，是唯一能执行 action 的方法 actions : 操作行为处理模块。 负责处理 Vue Components 接收的所有交互行为， commit : 状态改变提交操作方法，对 mutation 进行提交，是唯一能执行 mutation的方法 mutation : 状态改变操作方法，Vuex 中修改 state 的唯一推荐方法，该方法只能进行同步操作 getter : state 对象读取方法，类似 computed 计算属性。 过程：Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。 Redux 核心原理 只使用 redux，流程是这样的： component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component 使用 react-redux 之后，流程是这样的： component –&gt; actionCreator(data) –&gt; reducer –&gt; component store 的三大功能：dispatch,subscribe,getState 都不需要手动来写了，react-redux 帮我们做了这些，同时提供了 Provider 和 connect 注意点: store 是唯一的 只有 store 能够改变自己的内容 reducer 必须是一个纯函数（给定固定的输入，一定会有固定的输出，不会产生副作用） 核心 API createStore(reducer) 创建 store，并将 reducer 传递给 store store.dispatch(action) 创建 action 之后，负责将 action 传给 store action 是一个对象形式，会包含 Type(告诉 store 要做的事情)、Value(参数结果) store.getState() 获取 store 内容 store.subscribe() 订阅 store 改变，只要 store 发生改变，其中的回调函数就会被执行 Vuex 和 Redux 的区别？ 都是状态管理系统，除了具备床柜的状态管理的功能之外，也针对自身框架进行一些优化特性。 状态注入组件： React-Redux: 通过&lt;Provider/&gt;组件拿到 store 之后，还需要显示指定容器组件，即用 connect 包装一下该组件。 Vue 通过 Vue.use(Vuex)将 vuex 应用为全局的插件，将 store 传入跟实例，就可以使得 store 对象运行在任何 vue 组件中。 vuex 借鉴 redux，通过弱化概念（action、reducer），弱化了 dispatch 的存在感，任何东西都没做实质性消减，但同时使得整套框架更加易于理解了","link":"/2019/09/18/vuex%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"title":"前端安全","text":"前端安全 sql 注入 就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令 预防：比如使用基于 nodejs 的 sequelize 框架，不要裸写 sql 语句，使用常见的数据库工具即可解决 XSS xss：跨站脚本攻击(Cross Site Scripting),攻击者通过注入非法的 html 标签或者 JavaScript 代码，从而当用户浏览该网页时，控制用户浏览器。 xss 主要分为三类： DOM xss DOM 即文本对象模型，DOM 通常代表在 html、xhtml 和 xml 中的对象，使用 DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发 XSS 靠的是浏览器端的 DOM 解析，可以认为完全是客户端的事情。 反射型 xss 反射型 XSS 也被称为非持久性 XSS，是现在最容易出现的一种 XSS 漏洞。发出请求时，XSS 代码出现在 URL 中 ，最后输入提交到服务器，服务器解析后在响应内容中出现这段 XSS 代码，最后浏览器解析执行。 存储型 xss 存储型 XSS 又被称为持久性 XSS，它是最危险的一种跨站脚本，相比反射型 XSS和 DOM 型 XSS 具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。允许用户存储数据的 web 程序都可能存在存储型 XSS 漏洞，当攻击者提交一段 XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被 XSS，其中最典型的例子就是留言板。 主要影响： 利用虚假输入表单骗取用户个人信息 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。 显示伪造的文章或者图片 防御措施： 设置 httpOnly：在 cookie 中设置 HttpOnly 属性后，js 脚本将无法读取到 cookie 的信息。 输入检查，对于用户输入进行格式检查。 移除用户上传的 DOM 属性，如 onerror 事件等。 移除用户上传的 style 节点、script 节点、iframe 节点。 vue 中输出原生 html 需要使用 v-html react 中可以使用 dangerouslySetInnerHTML CSRF csrf：跨站请求伪造(Cross-Site Request Forgeries)，冒充用户发起请求，完成一些违背用户意愿的事情。 防御措施 提交数据使用 post 请求 Token 验证： 第一步：后端随机产生一个 token，把这个 token 保存在 session 状态中，同时后端把 token 交给前端页面； 第二步：前端页面提交请求时，把 token 加入到请求数据或者头信息中，一起传给后端； 后端验证前端传来的 token 与 session 是否一致，一致则合法，否则非法请求。 Referer check：请求来源验证，但是不能保证 100%有效，因为服务器并不是什么时候都能取到 Referer，而且低版本浏览器存在伪造 Referer 的风险。 验证码：强制用户必须和应用进行交互，完成最终请求，但用户体验比较差。 clickjacking clickjacking: 点击劫持，利用透明的按钮或连接做成陷阱，覆盖在 web 页面之上，然后诱使用户在不知的情况下，点击那个链接访问内容的一种攻击手段。又称为界面伪装。 大概有两种方式： 攻击者使用一个透明 iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用将在不知情的情况下点击透明的 iframe 页面。 攻击者使用一张图片覆盖在网页，遮挡网页原有的位置含义。 防御措施： X-FRAME-OPTIONS 响应头是用来给浏览器指示允许一个页面可否在&lt;frame&gt;,&lt;iframe&gt; 或者 &lt;object&gt; 中展现的标记。网站可以使用此功能，来确保自己网站内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。 控制台注入代码附：优化请求头（使用 helmet 协议规范）","link":"/2019/10/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"title":"单页面应用前端路由原理","text":"什么是单页面应用？ 单页面应用是指第一次进入页面的时候会请求一个 html 文件，切换到其他组件的时候，虽然路径会发生相应的变化，但是没有新的 html 文件请求，原理是 js 会感知到 url 的变化，js 会动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这时候的路由不是后端做的而是由前端来做，来判断页面到底显示哪个组件，这个过程就是单页面的应用。 单页面应用的优缺点优点：页面切换快，因为页面每次切换的时候，并不需要做 html 文件的请求，这样就减少的很多 http 发送的时延。 缺点：单页面应用的首屏加载时间比较慢，首屏加载需要一次 html 请求和一次 js 请求，时间相对较慢，而且 SEO 效果差，因为搜索引擎只认识 html 中的内容，但是单页面应用中内容很多需要靠 js 渲染出来，搜索引擎不识别这部分内容，就会导致 SEO 效果不好。 什么是多页面应用？多页面应用是指每一次页面跳转的时候，服务器都会返回一个新的 html 文档，这种类型的应用叫做多页应用。 多页面应用的优缺点优点：首屏加载快，SEO 效果好，因为客户端向服务端发起请求的时候，服务器之返回了一个 html 页面，所以加载比较快。 缺钱：页面切换比较慢 单页面应用和多页面应用的区别1.应用构成不同多页面应用是由多个不同的页面构成，单页面应用是一个外壳页面和多个页面片段构成。 2.页面跳转方式不同多页面应用的页面跳转是从一个页面跳转到另一个页面，而单页面则是把一个页面判断删除或隐藏，加载另一个页面片段。 3.跳转后公共资源是否重新加载跳转后多页面应用需要重新进行加载，但是单页面不需要重新加载 4.用户体验不同多页面应用首屏加载快但是切换慢，单页面应用首屏加载慢但是切换快 5.页面传递数据方式不同多页面应用依靠 url、cookie、localstorage 来传递数据，单页面应用则是靠组件进行通信，相对更加简单。 前端路由的原理前端路由的原理本质上就是通过不刷新浏览器的请求下修改 url、检测 url 的变化，截获 url 的地址，通过解析、匹配路由规则从而实现 UI 的更新，路由的实现通常有两种实现：hash 模式、history 模式 hash 路由的原理在 hash 模式下，在 url 中#后面的部分表示的是一个客户端状态，当这部分发生变化的时候，浏览器本身就不会刷新，这样就满足了第一个条件，即在不刷新浏览器的情况下修改浏览器链接，同事通过监听 hashChange 事件来监听 url 中 hash 值的变化，触发相关函数，改变相关组件。 history 路由的原理history 模式利用 html5 中 history API，history.pushState 和 history.replaceState 这两个方法可以在不刷新页面的情况下，操作浏览器的历史记录，然后通过 popState 事件来监听 url 的变化，从而触发相关函数，改变相关组件。 history.back()、history.forward()、history.go()会触发 popstate 事件history.pushState()、history.replaceState 不会出发 popstate 事件，需要对 replaceState 和 pushState 创建全局 Event 事件，然后 window.addEventListener 监听我们加的 event 事件","link":"/2022/03/14/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/"},{"title":"实现精简版useSize","text":"ahooks是阿里开源的一套 React Hooks 库，里面封装了大量好用的 Hooks，最近也在项目中频繁使用到了库中useSize这个钩子函数，于是就学习了一下它的源码实现，并且实现了一个精简版useSize。 要点一：ResizeObserver监听 Element 内容区域的边界框改变 要点二：requestAnimationFrame优化高频刷新情况下的数据更新 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import { MutableRefObject, useCallback, useEffect, useLayoutEffect, useRef, useState,} from &quot;react&quot;;type TargetValue&lt;T&gt; = T | undefined | null;type TargetType = HTMLElement | Element | Window | Document;export type BasicTarget&lt;T extends TargetType = Element&gt; = | (() =&gt; TargetValue&lt;T&gt;) | TargetValue&lt;T&gt; | MutableRefObject&lt;TargetValue&lt;T&gt;&gt;;type Size = { width: number; height: number };export default function useSize(target: BasicTarget): Size | undefined { const [state, setState] = useState&lt;Size | undefined&gt;(); const ref = useRef(0); const [resizeObserver, setResizeObserver] = useState&lt;ResizeObserver&gt;(); const setRafState = useCallback( (value: Size | ((prevState?: Size) =&gt; Size)) =&gt; { cancelAnimationFrame(ref.current); ref.current = requestAnimationFrame(() =&gt; { setState(value); }); }, [] ); useEffect( () =&gt; () =&gt; { resizeObserver?.disconnect(); cancelAnimationFrame(ref.current); }, [] ); useLayoutEffect(() =&gt; { if (!target) return; let targetEl: TargetValue&lt;TargetType&gt;; if (&quot;current&quot; in target) { targetEl = target.current; } else if (typeof target === &quot;function&quot;) { targetEl = target(); } else { targetEl = target; } if (!targetEl) return; const resizeObserver = new ResizeObserver((entries) =&gt; { entries.forEach((entry) =&gt; { const { clientWidth, clientHeight } = entry.target; setRafState({ width: clientWidth, height: clientHeight, }); }); }); setResizeObserver(resizeObserver); resizeObserver?.observe(targetEl); }, []); return state;} 具体使用12345678910111213export default function App() { const ref = useRef(null); const size = useSize(ref); return ( &lt;div ref={ref} style={{ border: &quot;1px solid red&quot; }}&gt; &lt;p&gt;Try to resize the preview window &lt;/p&gt; &lt;p&gt; width: {size?.width}px, height: {size?.height}px &lt;/p&gt; &lt;/div&gt; );} 仅作为自己的学习积累，有什么需要改进的地方请大家多多批评指点 😅！","link":"/2022/08/04/%E5%AE%9E%E7%8E%B0%E7%B2%BE%E7%AE%80%E7%89%88useSize/"},{"title":"全面解读React v18全部Api","text":"ComponentReact 提供 类组件 和 函数式组件 两种方式，类组件需要使用 Component 继承，主要做一些初始化工作 PureComponent会对 props 和 state 进行浅比较（可能会因为深层的数据不一致而产生错误的否定判断），跳过不比较的更新，提高组件性能 PureComponent 和 shouldComponentUpdate 的关系PureComponent通过自带的 props 和 state 浅比较实现了shouldComponentUpdate(nextProps, nextState) memomemo接收两个参数： 第一个参数：组件本身，也就是要优化的组件 第二个参数：(preProps, nextProps)=&gt;boolean, 若为 true 则不更新，为 false 则更新 生命周期 v16.0 前四大阶段：Initialization（初始化）、Mounting（挂载）、Update（更新）、Unmounting（卸载） Initailization： constructor()：初始化操作，定义 this.state 的初始内容，只会执行一次 super 的作用：调用基类构造方法，将父组件的 props 注入子组件，供子组件读取（props 只读不可变，state 可变） Mounting componentWillMount：组件挂载到 DOM 前调用，只调用一次不会引起组件重渲染 render：渲染 componentDidMount：组件挂载到 DOM 后调用，只调用一次 Update componentWillReceiveProps(nextProps): 调用与 props 引起的组件更新过程中 shouldComponentUpdate(nextProps, nextState): 性能优化组件，返回 false 停止更新，减少组件的不必要渲染，优化性能 componentWillUpdate(nextProps, nextState):组件更新前调用 componentDidUpdate(prevProps, prevState):组件更新后调用 Unmounting componentWillUnmount：组件被卸载前调用，执行一些清理工作，避免内存泄漏 React v16.4 后移除了：componentWillMount、componentWillReceiveProps、componentWillUpdate新增了：static getDerivedStateFromProps、getSnapshotBeforeUpdate getDerivedStateFromProps(prevProps, prevState):组件创建和更新时调用getSnapshotBeforeUpdate(prevProps, prevState):更新时 DOM 节点渲染前，获取 DOM 信息（如滚动位置），返回值作为参数传递给 componentDidUpdate React v16.8 的 hooks useState useEffect useLayoutEffect：同步，useLayoutEffect 在 DOM 更新之后，浏览器绘制之前，浏览器只会绘制一次，useLayoutEffect 先于 useEffect 前执行，如果在 useEffect 中改变 DOM，可能会导致浏览器再次回流和重绘，useLayoutEffect 的 callback 中代码执行会阻塞浏览器绘制 useReducer useMemo useCallback useRef useImperativeHandle(ref, createHandle, [deps]):createHandle 返回值作为暴露给付组件的 ref 对象 useDebugValue：可用于在 React 开发者工具中显示自定义 hook 的标签 React v18 的 hooks useSyncExternalStore：是一个推荐用于读取和订阅外部数据源的 hook，其方式与选择性的 hydration 和时间切片等并发渲染功能兼容 useTransition：返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。 useDeferredValue：接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。 useId ： 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。 react-dom createPortal: 在 Portal 中提供了一种将子节点渲染到已 DOM 节点中的方式，该节点存在于 DOM 组件的层次结构之外。 flushSync：可以将回调函数中的更新任务，放到一个较高级的优先级中，适用于强制刷新，同时确保了 DOM 会被立即更新 unstable_batchedUpdates :可用于手动批量更新 state，可以指定多个 setState 合并为一个更新请求","link":"/2023/03/13/%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BBreact-v18%E5%85%A8%E9%83%A8api/"},{"title":"常见设计模式","text":"SOLID 五大设计原则 S 单一职责原则 一个程序只做好一件事，如果功能过于复杂就拆分开，每个部分保持独立 O 开放封闭原则 对修改封闭，对扩展开放 L 李氏置换原则 子类能覆盖父类 I 接口独立原则 保持接口的单一独立，避免出现胖接口 D 依赖倒置原则 面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 常见的设计模式 工厂模式 jquery、react createElement 单例模式 自定义事件 EventBus 全局唯一 Vuex Redux 的 store 全局唯一 12345678910111213141516class SingleTon { private constructor() {} private static instance: SingleTon | null; static getInstance(): SingleTon { if (SingleTon.instance === null) { SingleTon.instance = new SingleTon(); } return SingleTon.instance; }}SingleTon.getInstance(); // 正确SingleTon.instance; // 报错new SingleTon(); // 报错 构造函数模式 建造者模式 代理模式 命令模式 观察者模式 适配器模式 职责链模式","link":"/2019/09/27/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"微信小程序","text":"微信小程序 文件主要目录及文件作用 component 组件文件夹 navBar 底部组件 navBar.js 底部组件的 js 代码 navBar.json 底部组件的配置文件 navBar.wxml 底部组件的 html 代码 navBar.wxss 底部组件的 css 代码 pages 页面文件夹 index 首页 index.js 首页的 js 代码 index.json 首页的配置文件 index.wxml 首页的 html 代码 index.wxss 首页的 css 代码 public 图片文件夹 utils 工具文件夹 api.js 控制 api 的文件 md5.js 工具：MD5 加密文件 timestamp.js 工具：事件戳文件 app.json 设置全局的基础数据等 app.wxss 公共样式，可通过 import 导入更多 project.config.json 项目配置文件 微信小程序生命周期 onLoad(): 页面加载时触发，一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow(): 页面显示/切入前台时触发，每次打开页面都会调用一次。 onReady(): 页面初次渲染完成时触发，一个页面只会调用一次。 onHide(): 页面隐藏/切入后台时触发，当 navigateTo 或底部 tab 切换时调用。 onUnload(): 页面卸载时触发。 app.json 是对当前小程序的全局配置，讲述三个配置各个项的含义? pages 字段：用于描述当前小程序所有页面路径，为了让微信客户端知道当前小程序页面定义在那个目录。 window 字段：小程序所有页面的顶部背景颜色，文字颜色定义等。 tab 字段：小程序全局顶部 tab 或底部 tab。 小程序的 wxss 和 css 有哪些不一样的地方？ 新像素单位 rpx 样式可直接使用 import 导入 小程序 wxml 和标准的 html 的异同？都是用来描述页面的结构，都是由标签、属性等构成。 标签名字不一样，且小程序标签更少，单一标签更多。 多了一些 wx:if 这样的属性和双大括号这样的表达式。 wxml 只能在微信小程序开发者工具中预览，html 可以在浏览器内预览。 组件封装不同，wxml 对组件进行了重新封装。 小程序运行在 JS Core 内，没有 DOM 树和 window 对象，小程序无法使用 window 对象和 document对象。 小程序 wxss 和 css 的异同？都是用来描述页面的样子 wxss 具有 css 大部分的特性，也做了一些扩充和修改。 wxss 新增了尺寸单位，wxss 在底层支持新的尺寸单位 rpx。 wxss 仅支持部分 css 选择器。 wxss 提供全局样式和局部样式。 小程序页面间有哪些传递数据的方法？ 使用全局变量实现数据传递 页面跳转或重定向时，使用 url 带参数传递数据 使用组件模板 template 传递参数 使用数据库传递数据","link":"/2019/10/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"title":"微前端源码剖析","text":"为什么需要微前端？ 将不同的功能按照不同维度拆分成多个子应用（将子应用打包成一个个 lib），当路径切换时通过主应用来加载这些子应用当路径切换时通过主应用来加载这些子应用当路径切换时通过主应用来加载这些子应用 核心：先拆-&gt;后合 微前端解决的问题？ 不同团队（技术栈不同），开发同一个应用 每个团队开发的模块独立开发，独立部署 增量迁移 实现微前端技术方案？ 实现微前端考虑要点 如何进行应用拆分 如何进行应用通信 如何进行应用隔离 技术方案 iframe 通过 postMessage 通信 自带的沙箱机制可以进行应用隔离 缺点：用户体验差，弹框只能在 iframe 中、内部刷新切换状态丢失等 Web Components 将前端应用程序分解为自定义 html 元素 通过 CustomEvent 通信 Shadow DOM 天生的作用域隔离 缺点：兼容问题、学习成本、调试困难 single-spa 通过路由劫持，采用 SystemJS，子应用暴露固定钩子 bootstrap、mount、unmount 接入协议 基于 props 进行通信 无沙箱机制，需要自己实现 JS 沙箱和 CSS 沙箱 缺点：学习成本、无沙箱机制、应用改造、资源重复加载问题 Module federation 通过模块联邦将组件打包导出 共享模块通信 无 CSS 沙箱和 JS 沙箱 缺点：需要 webpack5 简易版 single-spa 源码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a onclick=&quot;go('#/a')&quot;&gt;a应用&lt;/a&gt; &lt;a onclick=&quot;go('#/b')&quot;&gt;b应用&lt;/a&gt; &lt;!-- navigation-event.js --&gt; &lt;script&gt; // 对用户的路径切换 进行劫持，劫持后，重新调用reroute方法，进行计算应用的加载 function urlRoute() { reroute(arguments); } window.addEventListener('hashchange', urlRoute); window.addEventListener('popstate', urlRoute); // 浏览器历史切换的时候会执行此方法 // 但是当路由切换的时候 我们触发single-spa的addEventLister, 应用中可能也包含addEventLister // 需要劫持原生的路由系统，保证当我们加载完后再切换路由 const capturedEventListeners = { hashchange: [], popstate: [], }; const listentingTo = ['hashchange', 'popstate']; const originalAddEventListener = window.addEventListener; const originalRemoveEventListener = window.removeEventListener; window.addEventListener = function (eventName, callback) { // 有要监听的事件， 函数不能重复 if ( listentingTo.includes(eventName) &amp;&amp; !capturedEventListeners[eventName].some( (listener) =&gt; listener === callback ) ) { return capturedEventListeners[eventName].push(callback); } return originalAddEventListener.apply(this, arguments); }; window.removeEventListener = function (eventName, callback) { // 有要监听的事件， 函数不能重复 if (listentingTo.includes(eventName)) { capturedEventListeners[eventName] = capturedEventListeners[ eventName ].filter((fn) =&gt; fn !== callback); return; } return originalRemoveEventListener.apply(this, arguments); }; function callCaptureEventListeners(e) { if (e) { const eventType = e[0].type; if (listentingTo.includes(eventType)) { capturedEventListeners[eventType].forEach((listener) =&gt; { listener.apply(this, e); }); } } } function patchFn(updateState, methodName) { return function () { const urlBefore = window.location.href; const r = updateState.apply(this, arguments); // 调用此方法 确实发生了路径的变化 const urlAfter = window.location.href; if (urlBefore !== urlAfter) { // 手动派发popstate事件 window.dispatchEvent(new PopStateEvent('popstate')); } return r; }; } window.history.pushState = patchFn(window.history.pushState, 'pushState'); window.history.replaceState = patchFn( window.history.replaceState, 'replaceState' ); &lt;/script&gt; &lt;!-- app.helpers.js --&gt; &lt;script&gt; // app status const NOT_LOADED = 'NOT_LOADED'; // 没有被加载 const LOADING_SOURCE_CODE = 'LOADING_SOURCE_CODE'; // 路径匹配了 要去加载这个资源 const LOAD_ERROR = 'LOAD_ERROR'; // 启动的过程 const NOT_BOOTSTRAPED = 'NOT_BOOTSTRAPED'; // 资源加载完毕了 需要启动，此时还没有启动 const BOOTSTRAPING = 'BOOTSTRAPING'; // 启动中 const NOT_MOUNTED = 'NOT_MOUNTED'; // 没有被挂载 // 挂载流程 const MOUNTING = 'MOUNTING'; // 正在挂载 const MOUNTED = 'MOUNTED'; // 挂载完成 // 卸载流程 const UNMOUNTING = 'UNMOUNTING'; // 卸载中 // 加载正在下载应用 LOADING_SOURCE_CODE，激活已经运行了 // 看一下这个应用是否正在被激活 function isActive(app) { return app.status === MOUNTED; // 此应用正在被激活 } // 看一下此应用是否被激活 function shouldBeActive(app) { return app.activeWhen(window.location); } function getAppChanges() { const appsToLoad = []; const appsToMount = []; const appsToUnmount = []; apps.forEach((app) =&gt; { let appShouldBeActive = shouldBeActive(app); switch (app.status) { case NOT_LOADED: case LOADING_SOURCE_CODE: // 1） 标记当前路径下 哪些应用要被加载 if (appShouldBeActive) { appsToLoad.push(app); } break; case NOT_BOOTSTRAPED: case BOOTSTRAPING: case NOT_MOUNTED: // 2) 当前路径下 哪些应用要被挂在 if (appShouldBeActive) { appsToMount.push(app); } break; case MOUNTED: // 3） 当前路径下 哪些应用要被卸载 if (!appShouldBeActive) { appsToUnmount.push(app); } break; default: break; } }); return { appsToLoad, appsToMount, appsToUnmount }; } &lt;/script&gt; &lt;!-- lifecycles --&gt; &lt;script&gt; // load function flattenArrayToPromise(fns) { fns = Array.isArray(fns) ? fns : [fns]; return function (props) { // redux return fns.reduce( (rPromise, fn) =&gt; rPromise.then(() =&gt; fn(props)), Promise.resolve() ); }; } function toLoadPromise(app) { return Promise.resolve().then(() =&gt; { if (app.status !== NOT_LOADED) { // 此应用加载完毕了 return app; } app.status = LOADING_SOURCE_CODE; // 正在加载应用 // loadApp 对于之前的内容 System.import() return app.loadApp(app.customProps).then((v) =&gt; { const { bootstrap, mount, unmount } = v; app.status = NOT_BOOTSTRAPED; app.bootstrap = flattenArrayToPromise(bootstrap); app.mount = flattenArrayToPromise(mount); app.unmount = flattenArrayToPromise(unmount); return app; }); }); } // mount function toMountPromise(app) { return Promise.resolve().then(() =&gt; { if (app.status !== NOT_MOUNTED) { return app; } return app.mount(app.customProps).then(() =&gt; { app.status = MOUNTED; return app; }); }); } // unmount function toUnmountPromise(app) { return Promise.resolve().then(() =&gt; { if (app.status !== MOUNTED) { return app; } app.status = UNMOUNTING; // app.unmount 方法用户可能写的是一个数组。。。。。 return app.unmount(app.customProps).then(() =&gt; { app.status = NOT_MOUNTED; }); }); } // bootstrap function toBootstrapPromise(app) { return Promise.resolve().then(() =&gt; { if (app.status !== NOT_BOOTSTRAPED) { // 此应用加载完毕了 return app; } app.status = BOOTSTRAPING; return app.bootstrap(app.customProps).then(() =&gt; { app.status = NOT_MOUNTED; return app; }); }); } &lt;/script&gt; &lt;!-- reroute --&gt; &lt;script&gt; // 后续路径变化 也需要走这里， 重新计算哪些应用被加载或者写在 let appChangeUnderWay = false; let peopleWaitingOnAppChange = []; function reroute(event) { // 如果多次触发reroute 方法我们可以创造一个队列来屏蔽这个问题 if (appChangeUnderWay) { return new Promise((resolve, reject) =&gt; { peopleWaitingOnAppChange.push({ resolve, reject, }); }); } // 获取app对应的状态 进行分类 const { appsToLoad, appsToMount, appsToUnmount } = getAppChanges(); // 加载完毕后 需要去挂载的应用 if (started) { appChangeUnderWay = true; // 用户调用了start方法 我们需要处理当前应用要挂载或者卸载 return performAppChange(); } // 先拿到应用去加载 -》 return loadApps(); function loadApps() { // 应用的加载 return Promise.all(appsToLoad.map(toLoadPromise)).then( callEventListener ); // 目前我们没有调用start } function performAppChange() { // 将不需要的应用卸载掉, 返回一个卸载的promise // 1) 稍后测试销毁逻辑 const unmountAllPromises = Promise.all( appsToUnmount.map(toUnmountPromise) ); // 流程加载需要的应用 -》 启动对应的应用 -》 卸载之前的 -》 挂载对应的应用 // 2) 加载需要的应用（可能这个应用在注册的时候已经被加载了） // 默认情况注册的时候 路径是 /a , 但是当我们start的时候应用是/b const loadMountPromises = Promise.all( appsToLoad.map((app) =&gt; toLoadPromise(app).then((app) =&gt; { // 当应用加载完毕后 需要启动和挂载，但是要保证挂载前 先卸载掉来的应用 return tryBootstrapAndMount(app, unmountAllPromises); }) ) ); // 如果应用 没有加载 加载 -》启动挂载 如果应用已经加载过了 挂载 const MountPromises = Promise.all( appsToMount.map((app) =&gt; tryBootstrapAndMount(app, unmountAllPromises) ) ); function tryBootstrapAndMount(app, unmountAllPromises) { if (shouldBeActive(app)) { // 保证卸载完毕在挂载 return toBootstrapPromise(app).then((app) =&gt; unmountAllPromises.then(() =&gt; toMountPromise(app)) ); } } return Promise.all([loadMountPromises, MountPromises]).then(() =&gt; { // 卸载完毕后 callEventListener(); appChangeUnderWay = false; if (peopleWaitingOnAppChange.length &gt; 0) { peopleWaitingOnAppChange = []; // 多次操作 我缓存起来，。。。。 } }); } function callEventListener() { callCaptureEventListeners(event); } } &lt;/script&gt; &lt;!-- registerApplication --&gt; &lt;script&gt; const apps = []; function registerApplication(appName, loadApp, activeWhen, customProps) { const registeration = { name: appName, loadApp, activeWhen, customProps, status: NOT_LOADED, }; apps.push(registeration); reroute(); // 重写路由 } &lt;/script&gt; &lt;!-- start --&gt; &lt;script&gt; let started = false; // 默认没有调用start方法 function start() { started = true; // 用户启动了 reroute(); } &lt;/script&gt; &lt;!-- 入口 --&gt; &lt;script type=&quot;module&quot;&gt; let app1 = { bootstrap: [ async () =&gt; console.log('app1 bootstrap1'), async () =&gt; console.log('app1 bootstrap2'), ], mount: [ async (props) =&gt; { // new Vue().$mount()... console.log('app1 mount1', props); }, async () =&gt; { // new Vue().$mount()... console.log('app1 mount2'); }, ], unmount: async (props) =&gt; { console.log('app1 unmount'); }, }; let app2 = { bootstrap: async () =&gt; console.log('app2 bootstrap1'), mount: [ async () =&gt; { // new Vue().$mount()... return new Promise((resolve, reejct) =&gt; { setTimeout(() =&gt; { console.log('app2 mount'); resolve(); }, 1000); }); }, ], unmount: async () =&gt; { console.log('app2 unmount'); }, }; registerApplication( 'a', async () =&gt; app1, (location) =&gt; location.hash.startsWith('#/a'), { a: 1 } ); registerApplication( 'b', async () =&gt; app2, (location) =&gt; location.hash.startsWith('#/b'), { a: 1 } ); // 开启路径的监控，路径切换的时候 可以调用对应的mount unmount start(); // 这个监控操作 应该被延迟到 当应用挂挂载完毕后再行 window.addEventListener('hashchange', function () { console.log(window.location.hash, 'p----'); }); &lt;/script&gt; &lt;script&gt; function go(url) { // 用户调用pushState replaceState 此方法不会触发逻辑reroute history.pushState({}, null, url); } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2023/03/22/%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%89%96%E6%9E%90/"},{"title":"比较Vue和React？","text":"比较 Vue 和 React 的相同点和不同点？ 相同点 + 都有组件化开发和 Virtual DOM + 都支持 props 进行父子组件间的数据通信 + 都支持数据驱动视图，不直接操作真实 DOM，状态数据更新页面则自动更新 + 都支持服务端渲染 + 都支持原生应用的开发方案，React 有 React Native，Vue 有 Weex 不同点 数据绑定： Vue 实现了数据的双向绑定，React 数据流动是单向的 React 推荐的组件写法为 JSX，也就是把 HTML 和 CSS 全部写进 Javascript 中，即“all in js”Vue 推荐的组件写法是 webpack+vue-loader 的单文件组件格式，即 html、css、js 写在同一个文件 state 对象在 react 应用中不可变，需要使用 setState 方法更新状态；在 vue 中 state 对象不是必须的，数据由 data 属性在 vue 对象中管理 virtual DOM 不一样，vue 会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树，而对于 React 而言，每当应用的状态被改变时，全部组件都会重新渲染，所以 react 会需要shouldComponentUpdate 这个生命周期函数方法进行控制。 React 严格上只针对 MVC 的 view 层，Vue 则是 MVVM 模式。 前端框架使用 Vue 还是 React？清晰比较两者差异诞生 vue vue 由尤雨溪开发，独立团队维护，大部分子项目交给团队成员打理，Vue 核心库依然主要由尤雨溪亲自维护。 react React 起源于 Facebook 的内部项目，在建设 instagram(图片分享)的时候，为了处理数据流且考虑性能方面的问题，因该公司对市场上所有框架都不满意，就决定自己写一套，用来架构 Instagram 的网站。并在 2013 年 5 月开源。 设计思想 vue vue 是一款渐进式框架，采用自底向上增量开发的设计。在声明式渲染(视图模板引擎)的基础上，通过添加组件系统(component)、客户端路由(vue-router)、状态管理(vuex)来构建一个完整的框架。 react react 主张函数式编程，所以推崇纯组件，数据不可变，单向数据流， 编写语法 vue vue 推荐的做法是 webpack + vue-loader 的单文件格式，vue 保留了 html、css、js分离的写法，数据绑定使用 mustache 风格，样式直接使用 css，在&lt;style&gt;标签提供了一个可选的 scoped 属性，用开控制 css 仅对当前组件生效还是全局生效。 react react 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript中，即“all in js”，react 没有模板，直接就是一个渲染函数，返回一个虚拟 DOM 树，在 render()编写的 JSX 语法最终会被编译成原生 JavaScript。 构建工具 vue vue 提供了 CLI 脚手架，可以帮助我们非常容易地构建项目，全局安装后用 vue create命令创建新项目，可以让用户自定义选择需要安装的模板。 react react 提供了 create-react-app，但只提供一个构建单页面应用的默认选项。 数据绑定 vue vue 实现双向数据绑定，view 的变化能实时让 model 改变，而 model 的变化也能实时更新到 view vue 采用数据劫持 + 发布-订阅模式，通过 Object.defineProperty 对数据进行操作，为数据动态添加 getter 和 setter 方法，当获取数据的时候会触发对应的 getter 方法，当设置数据的时候会触发对应的 setter 方法，从而进一步触发 vm 的 watcher 方法，然后对数据进行更改，vm 则进一步触发视图更新操作。 react react 是单向数据流，react 中属性是不允许更改的，状态是允许更改的。react 中组件不允许通过 this.state 这种方法直接更改组件的状态。自身设置的状态，可以通过 setState进行更改。 setState 是异步的，导致获取 dom 可能拿到的还是之前的内容，所以需要在 setState第二个参数(回调函数)中获取更新后的内容。 性能优化 vue vue 中每个组件内部自动实现了 shouldComponentUpdate 的优化，在 vue 中里面由于依赖追踪系统的存在，当任意数据变动的时候，Vue 的每一个组件都能精确的知道自己是否需要重绘。而在 react 中需要我们手动去优化其性能，但 s 是当数据特别多的时候 vue 中的 watcher 也会特别多，从而造成页面卡顿，所以一般大西瓜项目会倾向于 react。 react 当 props 或 state 发生改变的时候会触发 shouldComponentUpdate 生命周期函数，它是用来控制组件是否被重新渲染的，如果它返回 true，则执行 render 函数，更新组件；如果它返回 false，则不会触发重新渲染的过程。 如果希望更新之前和之前的状态进行一个对比，这个时候需要重写 shouldCompnentUpdate来避免不必要的 dom 操作，对比当前的 props 或 state 和更新后的 nextProps 或 nextState，返回 true 时，组件更新；返回 false，不更新，节省性能。","link":"/2019/06/30/%E6%AF%94%E8%BE%83vue%E5%92%8Creact%EF%BC%9F/"},{"title":"集合","text":"什么是数据结构与算法？ 数据结构就是在计算机中，存储和组织数据的方式。 + 常见的数据结构： &lt;img src=&quot;http://vamknight.com/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png&quot;&gt; &lt;!--more--&gt; 算法（Algorithm）的定义： 算法就是解决问题的方法/步骤，数据结构的实现离不开算法。 一个有限指令集，每条指令的描述不依赖于语言 接受一些输入（有些情况不需要输入） 产生输出 一定在有限步骤之后终止 集合 集合通常是由一组无序的，不能重复的元素构成。可以看成是一种特殊的数组，特殊之处在于里面的元素没有顺序就意味着不能通过下标值进行访问，不能重复意味着相同的对象在同一个集合中只能存在一份。 集合都有哪些常见的操作方法呢？ add(value)：向集合添加一个新的项。 remove(value)：从集合移除一个值。 has(value)：如果值在集合中，返回 true，否则返回 false。 clear()：移除集合中的所有项。 size()：返回集合所包含元素的数量。与数组的 length 属性类似。 values()：返回一个包含集合中所有值的数组。 集合之间都有哪些操作呢？ 并集：对于两个给定的集合，返回一个包含两个集合中所有元素的新集合。 交集：对于两个给定的集合，返回一个包含两个集合中公有元素的新集合。 差集：对于两个给定的集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的新集合。 子集：验证一个给定集合是否是另一个集合的子集。 集合封装的完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// 封装集合的构造函数function Set() { // 使用一个对象来保存集合的元素 this.items = {} // 集合的操作方法 // 判断集合中是否有某个元素 Set.prototype.has = function (value) { return this.items.hasOwnProperty(value) } // 向集合中添加元素 Set.prototype.add = function (value) { // 1.判断集合中是否已经包含了该元素 if (this.has(value)) return false // 2.将元素添加到集合中 this.items[value] = value return true } // 从集合中删除某个元素 Set.prototype.remove = function (value) { // 1.判断集合中是否包含该元素 if (!this.has(value)) return false // 2.包含该元素, 那么将元素删除 delete this.items[value] return true } // 清空集合中所有的元素 Set.prototype.clear = function () { this.items = {} } // 获取集合的大小 Set.prototype.size = function () { return Object.keys(this.items).length /* 考虑兼容性问题, 使用下面的代码 var count = 0 for (var value in this.items) { if (this.items.hasOwnProperty(value)) { count++ } } return count */ } // 获取集合中所有的值 Set.prototype.values = function () { return Object.keys(this.items) /* 考虑兼容性问题, 使用下面的代码 var keys = [] for (var value in this.items) { keys.push(value) } return keys */ } //集合之间的操作 //并集 Set.prototype.union = function (otherSet) { //this:集合对象A //otherSet:集合对象B //1.创建新的集合 var unionSet = new Set() //2.将A集合中所有的元素添加到新集合中 var values = this.values() for(var i = 0; i &lt; values.length; i++) { unionSet.add(values[i]) } //3.取出B集合中的元素，判断是否需要添加到新集合 values = otherSet.values() for(var i = 0; i &lt; values.length; i++) { unionSet.add(values[i]) } return unionSet } //交集 Set.prototype.intersection = function (otherSet) { var intersectionSet = new Set() var values = this.values() //取出A集合一个个元素，判断是否同时存在于B中，存在B中，则添加到新集合中 for (var i = 0; i &lt; values.length; i++) { var item = values[i] if (otherSet.has(item)) { intersectionSet.add(item) } } return intersectionSet } //差集 Set.prototype.difference = function (otherSet) { var differenceSet = new Set() var values = this.values() //取出A集合一个个元素，判断是否同时存在于B中，不存在B中，则添加到新集合中 for (var i = 0; i &lt; values.length; i++) { var item = values[i] if (!otherSet.has(item)) { differenceSet.add(item) } } return differenceSet } // 子集 Set.prototype.subset = function (otherSet) { var values = this.values() for (var i = 0; i &lt; values.length; i++) { var item = values[i] if (!otherSet.has(item)) { return false } } return true }} 队列（Queue） 队列是一种受限的线性表，先进先出（FIFO First In First Out）。 它只允许在表的前端（front）进行删除操作 在表的后端（rear）进行插入操作 常见应用场景： + 队列主要用在和时间有关的地方，特别是操作系统中，队列是实现多任务的重要机制。 + 消息机制可以通过队列来实现，进程调度也是使用队列来实现。 队列有哪些常见的操作呢？ enqueue(element): 向队列尾部添加一个（或多个）新的项。 dequeue(): 移除队列的第一项，并返回被移除的元素。 front(): 返回队列中第一个元素，队列不做任何改动。 isEmpty(): 如果队列中不包含任何元素，返回 true，否则返回 false。 size(): 返回队列包含的元素个数，与数组 length 类似。 toString(): 将队列中的内容，转成字符串形式。 队列常见操作的封装： 1234567891011121314151617181920212223242526272829303132333435363738//封装队列function Queue() { //属性 this.items = [] //将元素加入到队列中 Queue.prototype.enqueue = function(element) { this.items.push(element) } //从队列中删除前端元素 Queue.prototype.dequeue = function() { return this.items.shift() } //查看前端的元素 Queue.prototype.front = function() { return this.items[0] } //查看队列是否为空 Queue.prototype.isEmpty = function() { return this.items.length == 0 } //查看队列中元素的个数 Queue.prototype.size = function() { return this.items.length } //toString方法 Queue.prototype.toString = function() { var resultString = '' for (var i = 0; i&lt; this.items.length; i++) { resultString += this.items[i] + ' ' } return resultString }}//调用队列函数var queue = new Queue()queue.enqueue(20)alert(queue) 面试题： 击鼓传花 12345678910111213141516171819//面试题: 击鼓传花function passGame(nameList, num) { //创建一个队列结构 var queue = new Queue() //将所有人加入到队列中 for(var i = 0; i &lt; nameList.length; i++) { queue.enqueue(nameList[i]) } //开始数数字 while (queue.size() &gt; 1) { //不是num重新加入队列末尾 //是num从队列中删除 for (var i = 0; i&lt; num - 1; i++) { queue.enqueue(queue.dequeue()) } queue.dequeue() } return queque.front()} 封装优先队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//封装优先级队列function PriorityQueue() { //内部创建一个构造类 function QueueElement(element, priority) { this.element = element this.priority = priority } //属性 this.items = [] //实现队列元素的插入 PriorityQueue.prototype.enqueue = function(element, priority) { //创建QueueElement对象 var queueElement = new QueueElement(element, priority) //判断为队列是否为空 if (this.items.length == 0) { this.items.push(queueElement) } else { var added = false for (var i = 0; i &lt; this.items.length; i++) { if (queueElement.priority &lt; this.items[i].priority) { this.items.splice(i, 0, queueElement) added = true break } } if (!added) { this.items.push(queueElement) } } } //从队列中删除前端元素 PriorityQueue.prototype.dequeue = function() { return this.items.shift() } //查看前端的元素 PriorityQueue.prototype.front = function() { return this.items[0] } //查看队列是否为空 PriorityQueue.prototype.isEmpty = function() { return this.items.length == 0 } //查看队列中元素的个数 PriorityQueue.prototype.size = function() { return this.items.length } //toString方法 PriorityQueue.prototype.toString = function() { var resultString = '' for (var i = 0; i&lt; this.items.length; i++) { resultString += this.items[i].element + '-' + this.items[i].priority + ' ' } return resultString }}//测试代码var pq = new PriorityQueue()pq.enqueue('a',10)pq.enqueue('b',100)pq.enqueue('c',50)alert(pq) 链表 什么是链表？ + 链表的元素在内存中不必是连续的空间，链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。 相对于数组，链表都有哪些优势？ 内存空间不是比是连续的. 可以充分利用计算机的内存. 实现灵活的内存动态管理。 链表不必在创建时就确定大小, 并且大小可以无限的延伸下去。 链表在插入和删除数据时, 时间复杂度可以达到 O(1). 相对数组效率高很多。 相对于数组，链表都有哪些缺点？ + 链表访问任何一个位置的元素时, 都需要从头开始访问.(无法跳过第一个元素访问任何一个元素)。 + 无法通过下标直接访问元素, 需要从头一个个访问, 直到找到对应的问题。 链表的数据结构： 链表有哪些常见操作？ + append(element)：向列表尾部添加一个新的项 + insert(position, element)：向列表的特定位置插入一个新的项。 + update(position, element): 修改某一个位置上的元素。 + remove(element)：从列表中移除一项。 + indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。 // 链表中的属性 this.length = 0 this.head = null // 链表尾部追加元素方法 LinkedList.prototype.append = function (element) { // 1.根据新元素创建节点 var newNode = new Node(element) // 2.判断原来链表是否为空 if (this.head === null) { / + removeAt(position)：从列表的特定位置移除一项。 this.next = null}/ 链表尾空this.head = newNode} else { // 链表不为空// 2.1.定义变量, 保存当前找到的节点var current = this.headwhile (current.next) {current = current.next} // 2.2.找到最后一项, 将其next赋值为node current.next = newNode } // 3.链表长度增加1 this.length++ } // 链表的toString方法 LinkedList.prototype.toString = function () { // 1.定义两个变量 var current = this.head var listString = &quot;&quot; // 2.循环获取链表中所有的元素 while (current) { listString += &quot;,&quot; + current.element current = current.next } // 3.返回最终结果 return listString.slice(1) } // 根据下标删除元素 LinkedList.prototype.insert = function (position, element) { // 1.检测越界问题: 越界插入失败 if (position &lt; 0 || position &gt; this.length) return false // 2.定义变量, 保存信息 var newNode = new Node(element) var current = this.head var previous = null index = 0 // 3.判断是否列表是否在第一个位置插入 if (position == 0) { newNode.next = current this.head = newNode } else { while (index++ &lt; position) { previous = current current = current.next } newNode.next = current previous.next = newNode } // 4.length+1 this.length++ return true } //update方法 LinkedList.prototype.update = function (position, newData) { if (position &lt; 0 || position &gt;= this.length) return null var current = this.head var index = 0 while (index++ &lt; position) { current = current.next } current.data = newData return true } // 根据位置移除节点 LinkedList.prototype.removeAt = function (position) { // 1.检测越界问题: 越界移除失败, 返回null if (position &lt; 0 || position &gt;= this.length) return null // 2.定义变量, 保存信息 var current = this.head var previous = null var index = 0 // 3.判断是否是移除第一项 if (position === 0) { this.head = current.next } else { while (index++ &lt; position) { previous = current current = current.next } previous.next = current.next } // 4.length-1 this.length-- // 5.返回移除的数据 return current.element } // 根据元素获取链表中的位置 LinkedList.prototype.indexOf = function (element) { // 1.定义变量, 保存信息 var current = this.head index = 0 // 2.找到元素所在的位置 while (current) { if (current.element === element) { return index } index++ current = current.next } // 3.来到这个位置, 说明没有找到, 则返回-1 return -1 } // 根据元素删除信息 LinkedList.prototype.remove = function (element) { var index = this.indexOf(element) return this.removeAt(index) } // 判断链表是否为空 LinkedList.prototype.isEmpty = function () { return this.length == 0 } // 获取链表的长度 LinkedList.prototype.size = function () { return this.length } // 获取第一个节点 LinkedList.prototype.getFirst = function () { return this.head.element } } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- 以上操作的都是单向链表，下面来认识一下双向链表。- 单向链表的缺点： + 只能从头遍历到尾，也就是链表的相连的过程是单向的，实现的原理是上一个链表中有一个指向下一个的引用。 + 我们可以轻松的到达下一个节点，但是回到上一个节点是很难的，只能从头遍历。 + 但是，实际开发中，经常会遇到回到上一个节点的情况。- 双向链表： + 既可以从头遍历到尾，又可以从尾遍历到头。 + 也就是链表相连的过程是双向的。 + 实现的原理就是既有先前连接的引用，也有一个向后连接的引用。 + 双向链表可以有效的解决单向链表的问题。- 双向链表的一些缺点： + 每次在插入或删除某一个节点时，需要处理四个引用，实现起来比较复杂。 + 相对于单向链表占用的内存更大一些。- 双向链表的结构图：&lt;img src=&quot;http://vamknight.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png&quot;&gt;- 双向链表的特点： + 可以使用一个head和一个tail分别指向头部和尾部的节点。 + 每个节点都是由三部分组成：前一个节点的指针（prev）、保存的元素（item）、后一个节点的指针（next）。 + 双向链表的第一个节点的prev是null。 + 双向链表的最后一个节点的next是null。- 双向链表都有哪些常见操作？ + append(element)：向列表尾部添加一个新的项 + insert(position, element)：向列表的特定位置插入一个新的项。 + update(position, element): 修改某一个位置上的元素。 + get(position): 获取对应位置的元素。 + remove(element)：从列表中移除一项。 + indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。 + removeAt(position)：从列表的特定位置移除一项。 + isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。 + size()：返回链表包含的元素个数。与数组的length属性类似。 + toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。 + forwardString(): 返回正向遍历的节点字符串形式。 + backwardString(): 返回反向遍历的节点字符串形式。- 双向链表常见方法的封装： // 创建双向链表的构造函数function DoublyLinkedList() {// 创建节点构造函数function Node(element) {this.element = elementthis.next = nullthis.prev = null // 新添加的} // 定义属性 this.length = 0 this.head = null this.tail = null // 新添加的 // 定义相关操作方法 // 在尾部追加数据 DoublyLinkedList.prototype.append = function (element) { // 1.根据元素创建节点 var newNode = new Node(element) // 2.判断列表是否为空列表 if (this.head == null) { this.head = newNode this.tail = newNode } else { this.tail.next = newNode newNode.prev = this.tail this.tail = newNode } // 3.length+1 this.length++ } // 在任意位置插入数据 DoublyLinkedList.prototype.insert = function (position, element) { // 1.判断越界的问题 if (position &lt; 0 || position &gt; this.length) return false // 2.创建新的节点 var newNode = new Node(element) // 3.判断插入的位置 if (position === 0) { // 在第一个位置插入数据 // 判断链表是否为空 if (this.head == null) { this.head = newNode this.tail = newNode } else { this.head.prev = newNode newNode.next = this.head this.head = newNode } } else if (position === this.length) { // 插入到最后的情况 // 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么? this.tail.next = newNode newNode.prev = this.tail this.tail = newNode } else { // 在中间位置插入数据 // 定义属性 var index = 0 var current = this.head var previous = null // 查找正确的位置 while (index++ &lt; position) { previous = current current = current.next } // 交换节点的指向顺序 newNode.next = current newNode.prev = previous current.prev = newNode previous.next = newNode } // 4.length+1 this.length++ return true } // 根据位置删除对应的元素 DoublyLinkedList.prototype.removeAt = function (position) { // 1.判断越界的问题 if (position &lt; 0 || position &gt;= this.length) return null // 2.判断移除的位置 var current = this.head if (position === 0) { if (this.length == 1) { this.head = null this.tail = null } else { this.head = this.head.next this.head.prev = null } } else if (position === this.length -1) { current = this.tail this.tail = this.tail.prev this.tail.next = null } else { var index = 0 var previous = null while (index++ &lt; position) { previous = current current = current.next } previous.next = current.next current.next.prev = previous } // 3.length-1 this.length-- return current.element } // 根据元素获取在链表中的位置 DoublyLinkedList.prototype.indexOf = function (element) { // 1.定义变量保存信息 var current = this.head var index = 0 // 2.查找正确的信息 while (current) { if (current.element === element) { return index } index++ current = current.next } // 3.来到这个位置, 说明没有找到, 则返回-1 return -1 } // 根据元素删除 DoublyLinkedList.prototype.remove = function (element) { var index = this.indexOf(element) return this.removeAt(index) } // 判断是否为空 DoublyLinkedList.prototype.isEmpty = function () { return this.length === 0 } // 获取链表长度 DoublyLinkedList.prototype.size = function () { return this.length } // 获取第一个元素 DoublyLinkedList.prototype.getHead = function () { return this.head.element } // 获取最后一个元素 DoublyLinkedList.prototype.getTail = function () { return this.tail.element } // 遍历方法的实现 // 正向遍历的方法 DoublyLinkedList.prototype.forwardString = function () { var current = this.head var forwardStr = &quot;&quot; while (current) { forwardStr += &quot;,&quot; + current.element current = current.next } return forwardStr.slice(1) } // 反向遍历的方法 DoublyLinkedList.prototype.reverseString = function () { var current = this.tail var reverseStr = &quot;&quot; while (current) { reverseStr += &quot;,&quot; + current.element current = current.prev } return reverseStr.slice(1) } // 实现toString方法 DoublyLinkedList.prototype.toString = function () { return this.forwardString() } } 1 栈 我们知道数组是一种线性结构，可以在数组的任意位置插入或删除数据。但有些时候，我们为了实现某种功能，必须对这种 任意性 加以限制，而我们的栈和队列就是比较常见的 受限的线性结构。 栈是一种先进后出或**后进先出(LIFO Last In First Out)**的数据结构，栈内的元素只能通过列表的一端访问，这一端称为栈顶，因为数据只能在栈顶添加或删除，所以只要数据的保存满足“先进后出或后进先出”的原理，都优先考虑使用栈。 栈的结构示意图： 栈常见有哪些操作？ push（element）：添加一个新元素到栈顶位置。 pop（）：移除栈顶的元素，同时返回被移除的元素。 peek（）：返回栈顶的元素，不对栈做任何修改。 isEmpty（）：如果栈里没有任何元素返回 true，否则返回 false。 size（）：返回栈里的元素个数，类似数组中的 length。 toString（）：将栈结构的内容以字符形式返回。 栈常见操作的封装： 1234567891011121314151617181920212223242526272829303132333435function Stack() { this.items = [] //将元素压入栈 Stack.prototype.push = function(element) { this.items.push(element) } //从栈中移除元素 Stack.prototype.pop = function() { return this.items.pop() } //查看栈顶元素 Stack.prototype.peek = function() { return this.items[this.items.length - 1] } //判断栈是否为空 Stack.prototype.isEmpty = function() { return this.items.length == 0 } //判断栈中元素个数 Stack.prototype.size = function() { return this.items.length } //toString方法 Stack.prototype.toString = function() { var resultString = '' for (var i = 0; i&lt; this.items.length; i++) { resultString += this.items[i] + ' ' } return resultString }}//栈的使用var s = new Stack()s.push(23)alert(s) 12345678910111213141516171819//函数十进制转为二进制function dec2bin(decNumber) { //定义栈对象 var stack = new Stack() while (decNumber &gt; 0) { //获取余数放入栈中 stack.push(decNumber % 2) //获取除后的结果,作为下次操作的对象 decNumber = Math.floor(decNumber / 2) } //从栈中取出0和1 var binaryString = '' while (!stack.isEmpty()) { binaryString += stack.pop() } return binaryString}//调用函数alert(dec2bin(100)) 数据结构与算法 五大算法 贪心算法 分治算法 动态规划 回溯法 分支限界法 冒泡排序1234567891011function bubleSort(arr) { var len = arr.length; for (let outer = len ; outer &gt;= 2; outer--) { for(let inner = 0; inner &lt;=outer - 1; inner++) { if(arr[inner] &gt; arr[inner + 1]) { [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]] } } } return arr;} 选择排序1234567891011function selectSort(arr) { var len = arr.length; for(let i = 0 ;i &lt; len - 1; i++) { for(let j = i ; j&lt;len; j++) { if(arr[j] &lt; arr[i]) { [arr[i],arr[j]] = [arr[j],arr[i]]; } } } return arr} 插入排序123456789101112function insertSort(arr) { for(let i = 1; i &lt; arr.length; i++) { //外循环从1开始，默认arr[0]是有序段 for(let j = i; j &gt; 0; j--) { //j = i,将arr[j]依次插入有序段中 if(arr[j] &lt; arr[j-1]) { [arr[j],arr[j-1]] = [arr[j-1],arr[j]]; } else { break; } } } return arr;} 快速排序12345678910111213141516function quickSort(arr) { if(arr.length &lt;= 1) { return arr; //递归出口 } var left = [], right = [], current = arr.splice(0,1); for(let i = 0; i &lt; arr.length; i++) { if(arr[i] &lt; current) { left.push(arr[i]) //放在左边 } else { right.push(arr[i]) //放在右边 } } return quickSort(left).concat(current,quickSort(right));} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173//创建列表类function ArrayList() { this.array = [] //方法 //插入方法 ArrayList.prototype.insert = function(item){ this.array.push(item) } //toString 方便测试 ArrayList.prototype.toString = function(){ return this.array.join('-') }}&lt;!--var arr = new ArrayList()--&gt;&lt;!--arr.insert(1)--&gt;&lt;!--arr.insert(2)--&gt;&lt;!--arr.insert(3)--&gt;//实现排序算法//冒泡排序ArrayList.prototype.bubbleSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.反向循环, 因此次数越来越少 for (var i = length - 1; i &gt;= 0; i--) { // 3.根据i的次数, 比较循环到i位置 for (var j = 0; j &lt; i; j++) { // 4.如果j位置比j+1位置的数据大, 那么就交换 if (this.array[j] &gt; this.array[j+1]) { // 交换 this.swap(j, j+1) } } }}ArrayList.prototype.swap = function (m, n) { var temp = this.array[m] this.array[m] = this.array[n] this.array[n] = temp}//选择排序ArrayList.prototype.selectionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 从0位置开始取出数据, 直到length-2位置 for (var i = 0; i &lt; length - 1; i++) { // 3.内层循环: 从i+1位置开始, 和后面的内容比较 var min = i for (var j = min + 1; j &lt; length; j++) { // 4.如果i位置的数据大于j位置的数据, 那么记录最小的位置 if (this.array[min] &gt; this.array[j]) { min = j } } // 5.交换min和i位置的数据 this.swap(min, i) }}//插入排序ArrayList.prototype.insertionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后 for (var i = 1; i &lt; length; i++) { // 3.记录选出的元素, 放在变量temp中 var j = i var temp = this.array[i] // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环 while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) { this.array[j] = this.array[j-1] j-- } // 5.将选出的j位置, 放入temp元素 this.array[j] = temp }}//希尔排序ArrayList.prototype.shellSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.根据长度计算增量 var gap = Math.floor(length / 2) // 3.增量不断变量小, 大于0就继续排序 while (gap &gt; 0) { // 4.实现插入排序 for (var i = gap; i &lt; length; i++) { // 4.1.保存临时变量 var j = i var temp = this.array[i] // 4.2.插入排序的内层循环 while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) { this.array[j] = this.array[j - gap] j -= gap } // 4.3.将选出的j位置设置为temp this.array[j] = temp } // 5.重新计算新的间隔 gap = Math.floor(gap / 2) }}//快速排序 // 选择枢纽 ArrayList.prototype.median = function (left, right) { // 1.求出中间的位置 var center = Math.floor((left + right) / 2) // 2.判断并且进行交换 if (this.array[left] &gt; this.array[center]) { this.swap(left, center) } if (this.array[center] &gt; this.array[right]) { this.swap(center, right) } if (this.array[left] &gt; this.array[right]) { this.swap(left, right) } // 3.巧妙的操作: 将center移动到right - 1的位置. this.swap(center, right - 1) // 4.返回pivot return this.array[right - 1] } // 快速排序实现 ArrayList.prototype.quickSort = function () { this.quickSortRec(0, this.array.length - 1) } ArrayList.prototype.quickSortRec = function (left, right) { // 0.递归结束条件 if (left &gt;= right) return // 1.获取枢纽 var pivot = this.median(left, right) // 2.开始进行交换 // 2.1.记录左边开始位置和右边开始位置 var i = left var j = right - 1 // 2.2.循环查找位置 while (true) { while (this.array[++i] &lt; pivot) { } while (this.array[--j] &gt; pivot) { } if (i &lt; j) { // 2.3.交换两个数值 this.swap(i, j) } else { // 2.4.当i&lt;j的时候(一定不会=, 看下面解释中的序号3), 停止循环因为两边已经找到了相同的位置 break } } // 3.将枢纽放在正确的位置 this.swap(i, right - 1) // 4.递归调用左边 this.quickSortRec(left, i - 1) this.quickSortRec(i + 1, right) } 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// 封装ArrayList function ArrayList() { this.array = [] ArrayList.prototype.insert = function (item) { this.array.push(item) } ArrayList.prototype.toString = function () { return this.array.join() } ArrayList.prototype.bubbleSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.反向循环, 因此次数越来越少 for (var i = length - 1; i &gt;= 0; i--) { // 3.根据i的次数, 比较循环到i位置 for (var j = 0; j &lt; i; j++) { // 4.如果j位置比j+1位置的数据大, 那么就交换 if (this.array[j] &gt; this.array[j+1]) { // 交换 this.swap(j, j+1) } } } } ArrayList.prototype.selectionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 从0位置开始取出数据, 直到length-2位置 for (var i = 0; i &lt; length - 1; i++) { // 3.内层循环: 从i+1位置开始, 和后面的内容比较 var min = i for (var j = min + 1; j &lt; length; j++) { // 4.如果i位置的数据大于j位置的数据, 记录最小的位置 if (this.array[min] &gt; this.array[j]) { min = j } } this.swap(min, i) } } ArrayList.prototype.insertionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后 for (var i = 1; i &lt; length; i++) { // 3.记录选出的元素, 放在变量temp中 var j = i var temp = this.array[i] // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环 while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) { this.array[j] = this.array[j-1] j-- } // 5.将选出的j位置, 放入temp元素 this.array[j] = temp } } ArrayList.prototype.shellSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.根据长度计算增量 var gap = Math.floor(length / 2) // 3.增量不断变量小, 大于0就继续排序 while (gap &gt; 0) { // 4.实现插入排序 for (var i = gap; i &lt; length; i++) { // 4.1.保存临时变量 var j = i var temp = this.array[i] // 4.2.插入排序的内存循环 while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) { this.array[j] = this.array[j - gap] j -= gap } // 4.3.将选出的j位置设置为temp this.array[j] = temp } // 5.重新计算新的间隔 gap = Math.floor(gap / 2) } } ArrayList.prototype.swap = function (m, n) { var temp = this.array[m] this.array[m] = this.array[n] this.array[n] = temp } // 选择枢纽 ArrayList.prototype.median = function (left, right) { // 1.求出中间的位置 var center = Math.floor((left + right) / 2) // 2.判断并且进行交换 if (this.array[left] &gt; this.array[center]) { this.swap(left, center) } if (this.array[center] &gt; this.array[right]) { this.swap(center, right) } if (this.array[left] &gt; this.array[right]) { this.swap(left, right) } // 3.巧妙的操作: 将center移动到right - 1的位置. this.swap(center, right - 1) // 4.返回pivot return this.array[right - 1] } // 快速排序实现 ArrayList.prototype.quickSort = function () { this.quickSortRec(0, this.array.length - 1) } ArrayList.prototype.quickSortRec = function (left, right) { // 0.递归结束条件 if (left &gt;= right) return // 1.获取枢纽 var pivot = this.median(left, right) // 2.开始进行交换 var i = left var j = right - 1 while (true) { while (this.array[++i] &lt; pivot) { } while (this.array[--j] &gt; pivot) { } if (i &lt; j) { this.swap(i, j) } else { break } } // 3.将枢纽放在正确的位置 this.swap(i, right - 1) // 4.递归调用左边 this.quickSortRec(left, i - 1) this.quickSortRec(i + 1, right) } } 哈希表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174// 创建HashTable构造函数function HashTable() { // 定义属性 this.storage = [] this.count = 0 this.limit = 8 // 定义相关方法 // 判断是否是质数 HashTable.prototype.isPrime = function (num) { var temp = parseInt(Math.sqrt(num)) // 2.循环判断 for (var i = 2; i &lt;= temp; i++) { if (num % i == 0) { return false } } return true } // 获取质数 HashTable.prototype.getPrime = function (num) { while (!isPrime(num)) { num++ } return num } // 哈希函数 HashTable.prototype.hashFunc = function(str, max) { // 1.初始化hashCode的值 var hashCode = 0 // 2.霍纳算法, 来计算hashCode的数值 for (var i = 0; i &lt; str.length; i++) { hashCode = 37 * hashCode + str.charCodeAt(i) } // 3.取模运算 hashCode = hashCode % max return hashCode } // 插入数据方法 HashTable.prototype.put = function (key, value) { // 1.获取key对应的index var index = this.hashFunc(key, this.limit) // 2.取出数组(也可以使用链表) // 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ] [ [k,v] ] ] var bucket = this.storage[index] // 3.判断这个数组是否存在 if (bucket === undefined) { // 3.1创建桶 bucket = [] this.storage[index] = bucket } // 4.判断是新增还是修改原来的值. var override = false for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] if (tuple[0] === key) { tuple[1] = value override = true } } // 5.如果是新增, 前一步没有覆盖 if (!override) { bucket.push([key, value]) this.count++ if (this.count &gt; this.limit * 0.75) { var primeNum = this.getPrime(this.limit * 2) this.resize(primeNum) } } } // 获取存放的数据 HashTable.prototype.get = function (key) { // 1.获取key对应的index var index = this.hashFunc(key, this.limit) // 2.获取对应的bucket var bucket = this.storage[index] // 3.如果bucket为null, 那么说明这个位置没有数据 if (bucket == null) { return null } // 4.有bucket, 判断是否有对应的key for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] if (tuple[0] === key) { return tuple[1] } } // 5.没有找到, return null return null } // 删除数据 HashTable.prototype.remove = function (key) { // 1.获取key对应的index var index = this.hashFunc(key, this.limit) // 2.获取对应的bucket var bucket = this.storage[index] // 3.判断同是否为null, 为null则说明没有对应的数据 if (bucket == null) { return null } // 4.遍历bucket, 寻找对应的数据 for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] if (tuple[0] === key) { bucket.splice(i, 1) this.count-- // 缩小数组的容量 if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) { var primeNum = this.getPrime(Math.floor(this.limit / 2)) this.resize(primeNum) } } return tuple[1] } // 5.来到该位置, 说明没有对应的数据, 那么返回null return null } // isEmpty方法 HashTable.prototype.isEmpty = function () { return this.count == 0 } // size方法 HashTable.prototype.size = function () { return this.count } // 哈希表扩容 HashTable.prototype.resize = function (newLimit) { // 1.保存旧的数组内容 var oldStorage = this.storage // 2.重置属性 this.limit = newLimit this.count = 0 this.storage = [] // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中 oldStorage.forEach(function (bucket) { // 1.bucket为null, 说明这里面没有数据 if (bucket == null) { return } // 2.bucket中有数据, 那么将里面的数据重新哈希化插入 for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] this.put(tuple[0], tuple[1]) } }).bind(this) }}","link":"/2019/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"title":"说一下浏览器的缓存机制","text":"前言 缓存可以简单高效的提高性能优化，对于一个数据请求来说，分为网络请求、后端处理、浏览器 响应三个步骤，浏览器缓存可以优化网络请求和响应部分。比如：直接换用缓存而不发起请求， 或者发起请求但后端存储的数据和前端一致，就没有必要将数据回传，这样就减少的响应数据， 使得缓存文件可以重复利用，减少带宽，减低网络负荷。 缓存位置网络请求会先从缓存位置上面查找缓存，如果都没有命中，才会去请求网络资源，从缓存位置 分为四种，并且各自有优先级： - Service Worker - Memory Cache - Disk Cache - Push Cache Service Worker: Service Worker 是运行在浏览器背后的独立线程，一般可以用 来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。 Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、 如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问 的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件， 否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数 获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级 去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显 示我们是从 Service Worker 中获取的内容。 Memory Cache: Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面 上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效， 可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就 被释放了。 Disk Cache: Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会 根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源 已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不 会再次去请求数据。 Push Cache: Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种 缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放， 并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中 的缓存指令。 `如果以上四种缓存都没有命中的话，只能发起网络请求来获取资源了。 为了性能上的考虑，大部分接口都应该选择好缓存策略， 浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置HTTP Header来实现的。` 强缓存强缓存：不会向服务器发送请求，直接从缓存中读取资源，可以通过HTTP Header实现：Expires 和Cache-Control。 + Expires：缓存过期时间，用来指定资源到期的时间，是服务端的具体的时间点，结合Last-modified 使用，Expires是HTTP/1.0的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 + Cache-Control(http/1.1)：和多个指令(private、no-store、no-cache)配合使用，实现资源缓存。 + Expires和Cache-Control同时存在，Cache-Control优先级高于Expires。 协商缓存协商缓存就是强缓存失效后，浏览器携带缓存表示向服务器发起请求，由服务器根据缓存表示决定 是否使用缓存的过程，主要有以下两种情况： + 协商缓存生效，返回304和Not Modified + 协商缓存失效，返回200和请求结果。 + 协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。 + ETag是服务器响应请求时，返回当前资源文件的一个唯一标识（有服务器生成），只要资源有变化 ，ETag就会重新生成。 缓存机制强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用 缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效， 那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中； 生效则返回304，继续使用缓存 http 缓存？ 强制缓存 强制缓存过期后会去服务端重新请求 协商缓存 服务端缓存策略 服务端判断客户端资源，是否和服务端资源一样 一致则返回 304，否则返回 200 和最新的资源 在 Response Headers 中，有两种： Last-Modified 资源的最后修改时间 Etag 资源的唯一标识 Last-Modified 和 Etag 会优先使用 Etag Last-Modified 只能精确到秒级 如果资源被重复生成，而内容不变，则 Etag 更精确 综述 刷新操作对缓存的影响？ 正常操作：地址输入 url，跳转链接，前进后退等 强制缓存有效，协商缓存有效 手动刷新：F5，点击刷新按钮，右击菜单刷新 强制缓存失效，协商缓存有效 强制刷新：ctrl + F5 强制缓存失效，协商缓存失效","link":"/2019/07/10/%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"计算机网络","text":"网络模型OSI(open system interconnect)参考模型 应用层（为应用程序提供网络服务） 表示层（数据格式化，加密等） 会话层（建立、维护管理会话连接） 传输层（建立、维护管理到端连接） 网络层（IP 寻址和路由选择） 寻址就是根据 IP 地址找到具体的设备 路由就是选择数据传输的线路 数据链路层（控制网络层和物理层之间通信） 物理层（通过光缆、无线电波等方式连接组网） TCP/IP 模型 应用层（应用层就是向用户提供通信服务的活动，提供用户程序接口 HTTP、FTP、DNS） 传输层（传输层为两台主机上的应用程序提供端到端的通信 TCP，UDP） 网络层（网络层实现数据包的选路和转发） 数据链路层（ARP 地址解析协议、RARP 逆地址解析协议，使用物理地址寻找一台机器） WebSocketWebSocket是html5定义的新协议，特点是即时通信、替代轮训 与传统http协议不同，实现了浏览器和服务器的全双工通信 HTTP 和 WebSocket 相同点： 都是基于 TCP 可靠传输协议 不同点： WebSocket 是全双工通信协议，通信双方可以同时发送和接收消息，http 是单向的 WebSocket 没有 Request 和 Response 概念 WebSocket 需要依赖 http 协议进行一次握手，握手成功后直接从 TCP 通道传输，与 http 无关 WebSocket 数据格式较轻量，数据包头部较小，http 协议每次通信需要携带完成头部信息 WebSocket 无跨域问题 WebSocket 多了两个属性 Upgrade: webSocket、Connection: Upgrade，服务端返回 101 成功状态码 单工、半双工和全双工通信 单工通信：指消息只能单向传输的工作方式，数据信息从一端到另一端是单向的。例如：广播 半双工通信：可以双向通信，但必须交替进行。例如：对讲机 全双工通信：指在通信的任意时刻，都允许数据同时在两个方向上传输，通讯双方都设置了发送器和接收器。","link":"/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"获取唯一id的三种方法","text":"uuid 1234567891011const UUID = (len = 32) =&gt; { return &quot;xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx&quot; .replace(/[xy]/g, function replace(c) { /* eslint-disable no-bitwise */ const r = (Math.random() * 16) | 0; const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8; return v.toString(16); }) .substring(0, len);}; nanoid1234567891011121314151617const nanoid = (t = 21) =&gt; { let e = &quot;&quot;, r = crypto.getRandomValues(new Uint8Array(t)); for (; t--; ) { let n = 63 &amp; r[t]; e += n &lt; 36 ? n.toString(36) : n &lt; 62 ? (n - 26).toString(36).toUpperCase() : n &lt; 63 ? &quot;_&quot; : &quot;-&quot;; } return e;}; 原生方法1const id = URL.createObjectURL(new Blob()).substr(-36)","link":"/2022/01/04/%E8%8E%B7%E5%8F%96%E5%94%AF%E4%B8%80id%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"面试题目总结","text":"[toc] 从浏览器地址栏输入 url 到显示页面的步骤 * 先检查搜索关键字是否符合url规则，然后将其组装成完成url进行访问 * 检查缓存，浏览器检查本地强缓存是否可用，如果命中强缓存就直接从缓存中返回资源 * DNS解析，如果未命中强缓存，则向服务器发起请求，通过递归查询和迭代查询解析域名来获取对应IP地址 - 浏览器IP缓存 - 操作系统IP缓存 - 本地hosts文件 - 路由器缓存 - DNS根服务器 - 本地DNS服务器以递归方式进行查询缓存记录 - 若没有缓存记录就向根DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器， 本地DNS服务器把对应关系暂存在缓存中（以便下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。 * 客户端发送HTTP请求 * 建立TCP连接，三次握手 * 发起http请求 * 负载均衡：服务端网管收到http请求后，可能会进行一系列负载均衡处理，通过反向代理分配给对应集群中的服务器去执行 * 服务端返回响应：服务端收到请求后，根据请求头中缓存标识来判断缓存是否生效，生效返回304状态码，未命中缓存返回200状态码 * 浏览器接收到http响应后，根据connection: keep-alive判断保持连接或者四次挥手断开TCP连接 * 浏览器缓存响应头中缓存标识字段 * 解析HTML文档，此时document.readystate为loading * 构建DOM树，浏览器从上到下解析html文档生成DOM节点树 * 构建CSSOM树，浏览器解析遇到样式进行异步下载，构建CSSOM树（不会阻塞DOM树构建，但是会阻塞渲染，防止css规则不断变化） * 构建渲染树，根据DOM节点树和CSSOM树构建渲染树Render * 遇到图片异步下载，遇到不带async和defer的script时，阻塞html的解析并下载且执行 * 带async的script标签，不会中断html解析并行下载脚本，下载完成后中断html解析并执行脚本，优先级高于defer * 带defer的script标签，不会中断html解析并行下载脚本，当浏览器解析完html时，DOMContentLoaded事件即将触发时执行脚本 * 文档解析完成，document.readystate变为interactive,触发DOMContentLoaded事件 * 等待图片加载或所有异步脚本加载执行完成，document.readystate变为complete,window触发load事件 * 布局Layout，根据Render树计算每个节点在屏幕上的位置布局 * 绘制Paint，绘制节点到屏幕上，涉及到构建图层树、绘制列表、光栅化（合成线程）和显示等。 其他：dns-prefetch:前端网络性能优化的一种措施，提前解析之后可能遇到的域名，使解析结果缓存到系统缓存中，缩短 DNS 解析时间，进而提高网站的访问速度 dns-prefetch 原理：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP(运行商)DNS 缓存-&gt;根域名服务器-&gt;顶级域名服务器-&gt;主域名服务器 dns-prefetch 将解析后的 IP 缓存放在系统缓存中dns-prefetch 与 preconnect 预连接提示配对 12&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com/&quot; crossorigin&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://fonts.gstatic.com/&quot;&gt; Note：如果页面需要建立与许多第三方域的连接，则将它们预先连接会适得其反。 preconnect 提示最好仅用于最关键的连接。对于其他的，只需使用 即可节省第一步的时间 DNS 查找。 扩展：收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？ DNS 负载均衡当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用 DNS 负载均衡技术，它的原理是在 DNS 服务器中为同一个域名配置多个 IP 地址,在应答 DNS 查询时,DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 强缓存和协商缓存强缓存：（expires、Cache-Control）在过期时间内，浏览器再次加载资源时，不会向服务器发起请求，直接从缓存中读取资源 协商缓存：向服务器发送请求，服务器会根据请求头（request header）的一些参数（Etag、last-modified）来判断是否命中协商缓存，首先根据 Etag 的值判断请求的文件有没有被修改，如果 Etag 一致则没有被修改，命中协商缓存返回 304，如果不一致则返回新的资源并带上新的 Etag 返回 200 状态码。如果没有 Etag 值，则对比 If-Modified-Since 和请求文件的最后修改时间，一致则命中协商缓存返回 304，不一致则返回新的 last-modified 和 200 状态码 http 协议的特点1.支持客户/服务器模式 2.简单快速：客户向服务器发送请求时，只需传送请求方法和路径。 3.灵活：http 允许传输任意类型的数据对象（Content-Type 内容编码类型） application/x-www-form-urlencoded 常见 post 提交数据格式（key-value 格式）application/json 4.无连接：限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。（原因是早期服务器需要同时面对全世界数十万、上百万的客户端的网页访问，但是每次客户端与服务端传输的数据关联性很低，就会导致大部分通过会很空闲，无端占用资源） （解决无连接）Keep-Alive：使客户端到服务端之间的 Http 连接保持，不会断开，当再次对服务器发送请求时，keep-Alive 功能避免了重新建立连接 5.无状态：Http 是一个无状态协议，就是每个请求都是独立的，数据传输完毕不会记录任何信息。缺点就是如果后续处理需要前面的信息，就必须重传，就会导致每次连接传送的数据量增加，如果服务器不需要前面信息的时候应答就会很快。 （解决无状态）怎样保持 http 连接状态呢Cookie（每次 http 请求的时候，客户端都需要发送响应的 cookie 信息到服务端，服务端根据 cookie 判断来自哪个客户端）服务端生成 cookie，客户端保存 Session服务端生成一个 sessionid，在客户端下次请求的时候在 cookie 里面记录这个 sessionid，然后发送给服务端，服务端再根据 cookie 中的 sessionid 来识别客户端返回资源数据。 禁用 cookie 怎么办？url 重写，每次 http 请求的时候，在 url 后面拼接 sid=**参数 withCredentials:指定在涉及到跨域请求时，是否携带 cookie 信息，默认为 falseAccess-Control-Allow-Credentials: true cookie 和 session 的区别12341.存取方式不同： cookie只能保存ASCII字符串，session能够存储任意类型的数据2.隐私策略不同3.cookie是存在客户端，session是存在服务器的4.浏览器的支持不同，浏览器可以禁用cookie 权限身份验证一般都是通过 sessionid 来进行用户身份验证，sessionid 一般会存放在 redis 中。 1.用户向服务端发送用户名和密码进行登陆 2.服务器验证通过后，服务器为用户创建一个 session，并将 session 信息存储起来 3.服务器向用户返回一个 sessionid，写入用户的 cookie 4.当用户保持登陆状态时，每次后续请求都会一起发送给后端 5.服务器将存储在 cookie 中的 sessionid 和存储在内存或者数据库中的 sessin 信息进行一个比较，验证用户身份，然后返回响应信息 注意： 1.依赖 session 的关键业务一定要确保客户端开启了 cookie 2.注意 session 的过期时间 一般在 http header 的 Authorization 字段中添加 token 禁用 cookie 之后 session 还能用吗？12url重写，例如 https://javascript.cn/?session_id=xxx缺点是安全性降低，可以对sessionid进行一次加密后传输 get 和 post 的区别1234561.url可见性：get参数url可见，post参数url不可见2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数3.缓存性：get请求可以缓存，post请求不可以缓存4.get请求网页回退时，不产生影响，post请求网页回退会重新发请求5.传输数据：get一般传输数据大小不超过4k，post可以传输大量数据6.post较get安全性较高，get是不安全的因为url可见，可能会泄漏私密信息 http 常见的请求头字段12345678910111213141516Accept: 浏览器可接受的数据类型Accept-Charset: 浏览器可接受的字符集Accept-Encoding：浏览器能够进行解码的数据编码方式Accept-Language： 浏览器所希望的语言种类Connection：是否需要持久连接，值“Keep-Alive”，HTTP1.1默认进行持久连接Cookie：cookie信息content-typeIf-Modified-Since：内容被修改才会返回User-Agent：浏览器类型响应头：content-Length: 表示内容长度content-type：文档类型Date：当前时间Expires：指定缓存过期时间Last-Modified：文档过期时间 http 和 https 的区别http 是超文本传输协议，信息是明文传输，https 是更加安全的 ssl 加密传输协议http 默认是 80 端口，https 默认是 443 端口https 需要申请 CA 证书https 是 http + ssl/tls（数字证书）进行组合的更加安全的传输协议 https 工作原理（非对称加密） 1.服务端向客户端传递证书作为公钥 2.客户端对证书进行解析，判断证书的办法机构和过期时间等，如果都没有问题，生成一个随机值作为私钥，然后使用证书进行加密发送给服务端 3.服务端解密得到客户端私钥 4.之后双方利用私钥进行加密解密，完成信息的通信 xss（跨域脚本攻击）csrf（跨站请求伪造）csrf: 需要用户先登陆网站 A，获取 cookie，利用的是网站 A 本身的漏洞，去请求网站 A 的 api，—进行 token 验证，referer 验证，只接收本站的请求 xss：向网站 A 注入 js 代码，然后执行 js 代码，篡改网站 A 的内容，破坏页面正常结构，插入恶意广告。—编码转换 什么是跨域？解决跨域的方法有哪些? 同源策略 是一种浏览器的安全策略 协议、域名、端口号必须完全一致 不同源的客户端脚本在没有明确的授权的情况下，不能读取对方的资源 跨域 指一个域下的文档或脚本尝试去请求另一个域下的资源。 解决跨域 jsonp postMessage 跨域 WebSocket 协议跨域 CORS（跨域资源共享，服务端设置 Access-Control-Allow-Origin，前端无需设置，若要带 cookie 请求，前后端都要设置） nginx 反向代理接口跨域 document.domain(两个页面通过 js 强制设置 document.domain 为基础主域，针对基础域名相同的情况) window.name + iframe location.hash + iframe … 实现 jsonp 跨域 通常为了减轻 web 服务器的负载，我们把 js、css、img 等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过响应的标签从不同域名加载静态资源。jsonp 就是利用此原理，动态创建 script，再请求一个带参网址实现跨域通信 12345678910111213&lt;script&gt; var script = document.createElement('script') script.type = 'text/javascript' //传参一个回调函数名给后端，方便后端返回时执行这个前端定义的回调函数 script.src = 'http://www.xxx.com:8080/login?user=admin&amp;callback=handleCallback' document.body.appendChild(script) //回调执行函数 function handleCallbak(res) { alert(JSOn.stringify(res)) }&lt;/script&gt; http1.0、http1.1 和 http2.0 的区别123http/1.0 每个请求都要建立一个连接http/1.1 多了长连接keep-alive，若干个请求需要排队串行化单线程处理，会发生网络请求阻塞问题。http/2.0 同一个连接可以有多个请求，各个请求直接互不影响（进行了头部压缩和多路复用的优化） 设计模式123456单例模式 （class组件中new store创建store实例）工厂模式 （mobx store中creatLayoutStore）观察者模式发布订阅模式装饰器模式 （移动、pc配置同步@sync） TCP 与 UDP 区别 TCP 是面向连接的协议，发送数据前先要建立连接，TCP 提供可靠的服务，通过 TCP 建立连接传输的数据不会丢失，没有重复，并且按照顺序到达。 UDP 是无连接的协议，发送数据前不需要建立连接，是不可靠的 TCP 只支持点对点通信，而 UDP 支持一对一，多对多 TCP 是面向字节流的，UDP 是面向报文的 TCP 通信类似打电话，接通后需要确认身份，才可以开始通信 UDP 类似广播直接进行通信 正向代理和反向代理12正向代理是客户端代理，服务端不知道是哪个客户端发起的请求反向代理是服务端代理，客户端不知道是哪个服务端提供的资源 OSI 模型12345678910应用层表示层会话层传输层网络层数据链路层物理层 三次握手为什么需要三次握手？两次握手第二次结束后，服务端并不能保证客户端已经接收到了第二次的应答信息，如此一来服务器会一直保持通信过程，因为 TCP 通信会占用端口，造成资源浪费。 防止已失效的连接请求报文段突然又传送到服务端，产生错误。如上述情况，如果 client 没有再次向 server 发出确认，server 收不到确认就不会建立连接，可以避免 server 端一直等待浪费资源。 四次挥手 https://blog.csdn.net/rememberyf/article/details/80309148 301 和 302 的区别301 表示资源被永久移除，浏览器在拿到状态码后跳转到一个新的 URL 地址，可从相应头的 location 首部中获取，搜索引擎在抓取新内容的同时也将就地址交换为重定向之后的网址。 302 表示地址资源还在，仍可以访问，搜索引擎会抓取新的内容而保存旧的地址，seo 302 优于 301. 重定向的原因：网站调整（改变网页目录结构）页面被移到一个新地址页面扩展名改变 .php -&gt;.html如果不做重定向会返回 404 页面，会白白流失用户访问量。 1XX 信息性状态码，表示接受的请求正在处理2XX 成功状态码，表示请求被正常处理完毕3XX 重定向状态码，表示需要进行附加操作以完成请求4XX 客户端错误状态码，表示服务器无法处理请求400 Bad Request 请求出现语法错误401 被请求的页面需要用户名和密码403 forbidden 请求页面的访问被禁止404 资源未找到5XX 服务器错误状态码，表示服务器处理请求出错502 网关错误503 服务器超负载或者停机维护，无法处理请求504 网关超时 cookie cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据 cookie 追踪用户在不同页面的访问信息。 cookie 特点 1.大小限制，cookie 大小限制在 4KB 以内 2.宽带限制，cookie 数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。 3.安全风险，cookie 会频繁的在网络中传送，不加密的情况下是有安全风险的。 4.操作复杂123456function setCookie(name: string, value: string) { const exp = new Date(); //过期时间设置为一天 exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000); document.cookie = `${name}=${escape(value);expires=${exp.toString()}}`;} localStorage 会话存储 和 sessionStorage 本地存储 1.存储容量大 2.零宽带，仅存储在本地，不会和服务器发生任何交互行为，不存在网络宽带占用问题。 3.编程接口，提供一套丰富的接口，操作数据更加方便。 4.独立的存储空间，不会造成数据的混乱。 主要区别在于数据存储的 时间范围和页面范围 sessionStorage: 数据只存储到窗口或标签关闭时，只在当前窗口的当前标签内可见,5M 左右，不同浏览器不同大小。 localStorage: 数据会一直存在除非手动清除，数据可被同源(协议、域名、端口号一致)的每个窗口或标签共享,5M 左右，不同浏览器不同大小。 监测是否支持 web Storage 1.通过 window.sessionStorage,window.localStorage 判断浏览器是否支持 2.通过 try{}catch{} 执行一下 storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。 html5 的几种存储形式 1.本地存储 localStorage,sessionStorage 2.离线缓存 application cache indexedDb,webSQL 性能优化1234567891011121.负载均衡、CDN加速、设置缓存、2.业务逻辑优化3.代码程序优化（组件按需加载、图片懒加载，代码压缩）4.避免重绘回流重绘：页面元素的样式改变不会影响它在文档流中的位置时发生重绘回流：DOM尺寸大小结构发生变化时回流一定会导致重绘如何避免：1.避免频繁操作dom，通过创建document.createDocumentFragment()一次性插入需要操作的dom2.具有复杂动画的Dom元素使用绝对定位，使其脱离文档流3.合并对于Dom中style样式的操作4.避免使用css表达式 calc() fetch 和 axios12345678910fetch取消发送1.创建一个AbortController实例2.该实例具有signal属性3.将signal传递给fetch option4.调用AbortController的abort属性来取消所有使用该信号的fetchaxios取消发送1.const cancelToken = axios.CancelToken2.const source = CancelToken.source()3.axios.get('/xxx',{cancelToken: source.token}) flex 常用属性，grid 布局flex 属性：1.flex-direction 属性，决定主轴方向2.flex-wrap 属性，控制换行3.flex-flow 属性，flex-direction 和 flex-wrap 的简写形式，默认值 flex-flow: row nowrap;4.justify-content 属性，项目主轴上的对齐方式5.align-item 属性，项目在交叉轴上的对齐方式6.align-content 属性，多个轴线的时候在元素在交叉轴的对齐方式，只有一根轴线时不起作用flex（子元素的属性）：1.order 属性,定义项目的排列顺序，数值越小，排列越靠前，默认为 0.2.align-self 属性，允许单个项目与其他项目不一样的对齐方式，会覆盖 align-items 属性.3.flex 属性，flex-grow、flex-shrink、flex-basis 简写，默认为 0 1 autoauto(1 1 auto) none(0 0 auto)4.flex-grow 属性，定义项目的放大比例，默认为 0，即如果存在剩余空间也不放大，1 等分，一个项目为 2，其他为 1，则前者占据空间是其他的两倍。5.flex-shrink 属性，定义项目的缩小比例，默认为 1，空间不足则缩小，如果所有项目都为 1，则等比例缩小，如果有的项目为 0，则空间不足时为 0 的不缩小，负值无效6.flex-basis 属性，项目占据的固定空间 padding-bottom 实现子元素高度等于父元素宽度问题当 margin 或者 padding 取值是百分比的时候，无论是 left，right 或者 top，bottom，都是以父元素的 width 为参考物，进行提前占位 预编译123456在作用域的创建阶段（预编译阶段），会生成js的变量对象（VO对象）供js引擎去访问。1.创建ao对象2.找形参和变量声明，作为ao对象的属性名，值为undefined3.实参和形参相统一4.找函数声明，如果名字和变量相同则覆盖变量声明5.解释执行 箭头函数中的 this121.箭头函数中的this是在定义函数的时候绑定的（继承自父执行上下文中的this），而不是执行函数时绑定。2.箭头函数没有this，所以不能用作构造函数。 Map 和 Set 两种新的数据结构的区别？1231. Map类似Object是一种键值对集合，区别在于Map的键不仅限于字符串，其他各种类型的值都可以作为Map的键2.Set是类似数组的一种数据结构，不点在于Set中没有重复的值 你对闭包了解多少？解释一下作用域链是如何产生的 解释一下js执行山下文的创建、执行过程 解释一下闭包所产生的变量放在哪里 闭包的定义：闭包就是能够读取其他函数内部变量的函数。 闭包的底层实现原理 js 执行上下文： 1234567891011121314151617181920212223242526272829js运行三部曲1.语法分析2.预编译3.解释执行js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。预编译的环境需要个环境，这个环境就是执行上下文。js执行上下文分为三种：1.全局执行上下文：代码开始执行时首先进入的环境2.函数执行上下文：函数调用时，会开始执行函数中的代码3.eval执行上下文：不建议使用执行上下文的周期，分为两个阶段1.创建阶段 创建词法环境 生成变量对象VO，建立作用域链 确认this指向，并绑定this2.执行阶段 进行变量赋值，函数引用以及执行代码预编译发生在函数执行前，预编译四部曲：1.创建AO对象2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined3.将形参和实参相统一4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）5.最后程序输出变量值的时候，就是从AO对象中拿（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包） 原型12345student.__proto__ === Student.prototype1.每个函数function都由一个prototype，即显式原型。是在定义函数的时候自动添加的，默认是一个空的Object对象2.每个引用类型都有一个__proto__,即隐式原型。是创建对象时自动添加的，默认值为构造函数的prototype属性值实例对象的隐式原型 等于 对应构造函数或类的显式原型能直接操作显式原型，不能直接操作隐式原型 简单说下原型链 原型链是由原型对象组成的，每个对象都有proto属性，指向了创建该对象的构造函数的原型，proto将对象连接起来组成了原型链。 原型链：用来实现继承和共享属性的有限对象链。 每个对象都有proto（隐式原型）属性，指向创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 proto 来访问。 对象的隐式原型等于对象的构造函数的显式原型：obj.proto === Object.prototype 访问属性的时候，js 引擎会调用内部的默认。。。。。。[[Get]]操作，[[Get]]操作首先会检查对象本身是否包含这个属性如果对象没有这个属性，则对象可以通过proto来寻找不属于该对象的属性，proto将对象和原型连接起来形成原型链 Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎创建。 js 的 new 操作符都做了些什么？1234567891011121314151617181920211. 创建一个空的js对象{}2. 将空对象的隐式原型__proto__指向构造函数的原型3. 将空对象作为构造函数的上下文（改变this指向）4. 对构造函数返回值做判断实现：function create(fn, ...args) { let obj = Object.create({}); // obj.__proto__ = fn.prototype; Object.setPrototypeOf(obj, fn.prototype); let result = fn.apply(obj, args); return result instanceof Object ? result : obj;}补充：在new的时候，会对构造函数的返回值做一些判断1. 如果返回值是基础类型数据，则忽略返回值2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效 calc, support, media 各自的含义及用法？1234567891011121314151617@support 主要用于检测浏览器是否支持css的某个属性，相当于条件语句，支持的话写一套样式，不支持写另外一套样式，例如 @supports (display: grid) { div { display: grid; } } @supports not (display: grid) { div { float: right; } }calc(): 用于动态计算值，支持 + - * / 运算。@media查询：可以针对不同的媒体类型定义不同的样式。 什么是会话 cookie,什么是持久 cookie?1cookie是服务器返回的，指定了expire（有效期）的是持久cookie,没有指定的是会话cookie img 标签 title 和 alt 属性1234alt: 图片加载失败时，显示在网页上的替代文字title: 鼠标放在图片上的提示文字alt是必须属性，可以为空；title为非必须 es6 新特性12345671.let和const2.模版字符串3.箭头函数4.函数可以设置默认参数值5.扩展运算符6.对象和数组的解构7.class 图片懒加载原理12345671. 浏览器是否发起请求是根据&lt;img /&gt;标签的src属性2. 所以懒加载的关键是：在图片没有进入可视区域时，先不给&lt;img /&gt;的src属性赋值，等到图片进入可是区域再给data-src -&gt; src赋值。当图片底边距离页面的偏移（图片高度+图片距离顶部偏移高度）小于等于浏览器底边距离页面顶部高度（浏览器一屏高度 + 滚动区域） H5 新增了哪些标签？1article、aside、audio、video、footer、header、nav、section SVG 和 Canvas 的区别？12341.svg:表示以XML格式定义图像的可伸缩矢量图形。2.canvas：通过js来绘制2D图形svg通过标签fill属性可以调整颜色 AMD 和 CMD 的区别1234567共同点：1.两者都是框架在推广过程中对模块定义的规范产出2.都是异步加载模块不同点：1.AMD是RequireJs在推广过程中对模块定义的规范产出，CMD是SeaJs在推广过程中对模块定义的规范化产出2.AMD推崇依赖前置，CMD推崇依赖就近3.AMD的应用体验好，因为模块提前执行了，CMD性能好，因为只有用户需要的时候才执行 如何实现 js 倒计时的纠偏？123451. 第一种通过前端定时向服务端发送请求获取最新的时间差，以此来校准倒计时时间。2. 通过前端根据偏差时间来自动调整下次间隔的时间来实现，首先以setTimeout递归的方式来实现倒计时，通过一个变量记录倒计时的秒数，根据秒数和间隔时间计算出此时无偏差时应该显示的时间，然后拿当前真实时间与这个时间相减，就可以得到时间的偏差大小，因此在设置下一个定时器的时候，间隔时间减去这个偏差大小就可以纠正时间误差。 js 的执行机制js 是单线程的，处理 js 任务只能一个一个顺序执行，js 中把任务分为了同步任务和异步任务，同步任务进入主线程先执行，异步任务进入 Event Table 并注册函数，指定事情完成后，Event Table 就会将函数移入到事件队列 Event Queque 中，等待主线程任务执行完毕，就会从事件队列中取出对应事件进入主线程执行。 macro-task（宏任务）：包括整体代码 script、setTimeout、setIntervalmicro-task（微任务）：Promise.then、process.nextTick微任务先于宏任务先执行（除了 script）执行过程不同任务进入不同的 event quue js 先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，遇到宏任务放到宏任务事件队列中。 然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，以此类推。 请说一下你对 React 的理解？1234567891011121314151. react是一个网页的UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。2. react的核心设计思路有三个：声明式 命令式：命令程序一步一步的执行操作 声明式：只需告诉程序我们想要的结果，其他的交给程序去做。组件化 将视图拆分和模块复用，做到高内聚低耦合通用性 一次学习，随处编写。RN，react360等，跨平台底层靠虚拟DOM实现3. 缺点1.没有官方系统解决方案，在开发大型应用时需要向社区寻找并整合解决方案。2.过于灵活，需要注意代码规范 React.lazy 懒加载1234567891011// React.lazy方法可以异步加载组件const Foo = React.lazy(() =&gt; import('../components/Foo')// React.lazy不能单独使用，需要配合React.suspense,用来包裹异步组件，添加loading效果等。&lt;React.Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt; &lt;Foo /&gt;&lt;/React.Suspense&gt;React.lazy原理React.lazy使用import来懒加载组件，import在webpack中最终会调用requireEnsure方法，动态插入script来请求js文件，类似jsonp的形式。 类组件和函数组件之间的区别？1234567891011121314相同点：接受属性返回React元素不同点： 1.编程思想不同：类组件需要创建实例，基于面向对象的方式编程。函数式组件接受输入返回输出，属于函数式编程的思想。 2.内存占用：类组件需要创建实例，会占用内存，函数组件不需要创建实例，可以节约内存 3.捕获特性：函数组件具有捕获特性 4.可测试性：函数组件更方便编写单元测试 5.状态：类组件有实例可以维护自己的状态，函数组件可以使用useState维护自己的状态 6.声明周期：类组件有生命周期，可以在生命周期内写逻辑，函数组件可以在useEffect中 7.逻辑复用：函数组件通过继承实现逻辑复用，函数组件可以通过自定义hooks实现逻辑复用 8.性能优化：类组件通过shouldComponentUpdate和PureComponent来跳过更新，函数组件通过React.memo 当调用 setState 的时候，发生了什么事？12将传递给setState的参数对象合并到组件的当前的状态，react遍历dom节点，计算差异，更新UI。https://segmentfault.com/a/1190000018250127 为什么 setState 的参数是一个 callback 而不是一个对象123456因为this.props和this.state的更新可能是异步的，不能依赖它们的值去计算下一个state(更新状态不要直接修改this.state，虽然状态可以改变，但不会触发组件的更新)setState何时同步何时异步？异步：由React控制的事件处理程序以及生命周期函数中调用setState为异步同步：React控制之外的原生js绑定的事件、setTimeout/setInterval等。 setState 什么时候同步什么时候异步？react 三个模式：1.legacy 模式： 通过 ReactDOM.render(, rootNode)创建的，当前 react 的使用方式2.blocking 模式：通过 ReactDOM.createBlockingRoot(rootNode).render(),实验阶段，作为迁移到 concurrent 模式的第一个步骤3.concurrent 模式，通过 ReactDOM.createRoot(rootNode).render(),实验阶段，未来 react 的默认开发模式 setState 只在合成事件（react 为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件）和钩子函数（生命周期中）是异步的，在原生事件和 setTimeout 中都是同步的。 不同模式执行结果不同，legacy 模式命中 batchedUpadates（批处理）时异步，为命中时同步concurrent 模式都是异步的 setState 异步并不是说内部由异步代码实现，其本身执行过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了“异步” 可以通过第二个参数的 callback 回调函数中拿到最新的值，在异步中如果对同一个值进行多次 setState，那么 setState 的批量更新策略会将其覆盖，去最后一次的执行，如果同时 setState 多个值，会在更新时对其进行合并批量更新。 react 渲染机制12345678首先打开页面会渲染出一颗DOM树，更新数据会生成一颗虚拟DOM树，通过diff算法，比较两颗DOM树的差异，找到更新的地方进行批量改动。diff：计算一棵树形结构到另一颗树形结构的最少操作。1.把树形结构按照层级分解，只比较同级元素2.给列表结构的每个单元添加唯一的 key 属性，方便比较3.diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。（官方也不推荐） React.StrictMode 目前有助于：12345识别不安全的生命周期关于使用过时字符串 ref API 的警告关于使用废弃的 findDOMNode 方法的警告检测意外的副作用检测过时的 context API 虚拟 DOM 优点12345678910111213141516171819202122231. 减少不必要的DOM操作 1.1虚拟dom可以将多次操作合并为一次操作，比如添加100个节点，确是一个一个操作的 1.2虚拟dom借助dom diff可以将多余的操作省略掉，比如添加100个节点，其中10个是新增的2. 跨平台渲染 1.因为虚拟dom本质上是一个js对象react虚拟dom结构:const vNode = { key: null, props:{ children: [ {type: 'span', ....}, ], className: 'red', onClick: () =&gt; {} }, ref: null, type: 'div',}创建虚拟dom：React.createElement diff 策略`策略一： tree diff1.React 对树进行分层比较，两颗虚拟 DOM 树只会对同一层级的 DOM 节点进行比较。如果存在跨层级的操作，只会进行创建和删除 2.如果节点是组件就进行 Component diff 3.如果节点是标签就进行 Element diff 策略二：component diff如果为非同类型组件的话标记组件为 dirty component，替换组件下所有子节点，类型相同更新属性，然后深入组件进行 Tree diff（递归遍历对比） 策略三：element diff如果节点是原生标签，则看标签名标签名不同直接替换，相同更新属性，然后进入标签进行 Tree diff（递归遍历对比）` shouldComponentUpdate(nextProps, nextState)是做什么的，（react 性能优化是哪个周期函数？）12shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新绘制dom,由于渲染dom非常消耗性能，合理的调用shouldComponentUpdate方法可以极大的提高性能。 createElement 和 cloneElement 有什么区别？1234567891011121314151617React.createElement()构建React元素。接受三个参数，第一个参数为标签名，如div、span等，或者react组件，第二个参数为传入的属性，第三个为组件的子组件。React.createElement( type, [props], [...children])React.cloneElement(),第一个参数传入react元素不是标签名，第二个参数传入属性，新添加的属性会并入原有的属性，第三个参数为子组件React.cloneElement( element, [props], [...children]) 虚拟 DOM 的优缺点？123456789优点：1. 处理了浏览器兼容性问题，避免了用户操作真实DOM2.内容经过xss处理，可以防范xss攻击3.跨平台开发4.更新的时候可以实现差异化更新，减少更新DOM的操作缺点：1.虚拟DOM需要消耗额外的内存2.首次渲染不一定会更快 React 中创建组件的方式1React.createClass()、ES6 class组件 无无状态函数式组件 react 中 key 的作用12345key在react中用于追踪哪些列表中元素被修改、添加或者移除的辅助标识。在开发中，需要保证某个元素的key在同级元素中具有唯一性。diff算法会借助元素的key值来判断元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染 react 优势12341. 速度快：不直接操作dom，采用虚拟dom的概念2.跨浏览器兼容，兼容性好3.一切都是component，代码更加模块化，可维护性高4.单向数据流，采用Flux单向数据层架构 react 事件机制1234567react的事件机制利用了事件委托机制，事件并没有真正的绑定在真实的dom节点上，而是把事件绑定在结构的最外层document，使用统一的事件监听器，所有事件都由这个监听器统一分发。组件挂载和更新时，会将绑定的事件分门别类的放进一个叫EvnentPluginHub的事件池中。事件触发时，根据事件产生的Event对象找到触发事件的组件，再通过组件标识和事件类型从事件池中找到对应的事件监听回调，然后执行相关的监听函数。 异步回调中怎么使用 syntheticEvent？123在合成事件机制里，一旦事件监听回调执行，合成事件对象就会被销毁，异步回调执行的时候合成事件对象早就被销毁了。解决方法：执行event.persist(),通知react不需要回收。 React 生命周期123456789101112131415161718192021React 16推出Fiber之后，如果要开启async rendering，那么在render函数之前的所有函数都有可能被执行多次废弃：componentWillMountcomponentWillReceiveProps(nextProps)componentWillUpdate(nextProps, nextState)代替：静态函数：static getDerivedStateFromProps(nextProps, prevState)静态函数：static getDerivedStateFromError(error) // 渲染备用UI此生命周期return的值会自动调用setState，将值和state合并运行事件节点：子组件被渲染发生错误后且在页面更新前getSnapshotBeforeUpdate(prevProps, prevState) 此生命周期的返回值将作为参数传递给componentDidUpdate()componentDidCatch(error, info) // 打印错误信息错误边界无法捕获的错误：1.组件自身的错误2.异步错误，setTimeout3.事件中的错误，比如click事件中发生错误 Redux12345678910111. 构建action，通过创建一个函数，返回一个对象，需要携带type属性2. 构建reducer，用来响应action，然后通过return把数据传回store3. 利用createStore来构建store，把reducer作为参数传入4. 利用store.subscribe()注册监听5. 利用store.dispatch()发送action6. 利用store.getState()拿到值 ts 中 type 和 interface 的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445相同点：1.都可以描述一个对象和函数interface User { name: string;}interface SetUser { (name: string): void;}type User = { name: string;}type SetUser = (name: string): void;2.扩展与交叉类型interface可以extends进行类型扩展，type可以通过交叉类型实现interface的extend行为。interface可以exteds type，type也可以与interface类型交叉（&amp;符号）不同点：1.type可以声明基本类型别名，联合类型，元祖等类型基本类型别名type Name = string;联合类型interface Dog { wang();}interface Cat { miao();}type Pet = Dog | Cat;元祖类型type PetList = [Dog, Cat];2. interface能够声明合并interface User { name: string;}interface User { age: number;}=/**interface User { name: string; age: number;}*/ ts 中如何实现一个函数的重载12js是动态类型语言，所以是没有overload的，但js可以在运行的时候判断类型ts的重载只是重载函数声明，函数的实现还是只有一个 mobxObservable //被观察者Observer // 观察者Reaction //响应 mobx 底层对数据的观察是使用 Object.defineProperty(mobx4)或 Proxy(mobx5)observer 这个装饰器，对 react 组件的 render 方法进行跟踪，将 render 方法加入到各个 observable 的依赖中，当 observale 发生变化的时候，就会调用 forceUpdate 更新组件（mobx4 将 Array 用类数组对象来模拟的，通过包装类封装为一个对象） webpack 常用 loader12345678910111213样式：style-loader、css-loader、less-loader、sass-loader文件：file-loader、url-loader编译：babel-loader、ts-loader校验：eslint-loader常用的pluginhtml-webpack-pluginwebpack-bundle-analyzer 打包分析HotModuleReplacementPlugin 热更新自己写webpack插件：主要就是通过访问compliler和compilation拦截webpack的执行 垃圾回收机制12345678910111213垃圾收集器会定期（周期性）的找出那些不再继续使用的变量，释放其内存，因为开销比较大，所以会按照固定的时间间隔周期性的执行最常用的两种方法：标记清除（常用）和引用计数标记清除：变量进入作用域，进行标记，离开作用域进行清除回收引用计数：就是跟踪记录每个值被引用的次数，引用一次加1，删除减1，引用计数为0时，进行回收，（循环引用可能会导致内存泄漏）常见的内存泄漏原因：全局变量过多引起内存泄漏闭包dom事件未清除循环引用 谈谈你对 webpack 的理解？1234567webpack是一个打包模块化js的工具，在webpack里一切文件皆模块，通过loader转换，通过plugin注入钩子，最后输出由多个模块组合成的文件，webpack专注构建模块化。WebPack可以看做是模块的打包机器：它做的事情是，分析你的项目结构，找到js模块及其它的一些浏览器不能直接运行的拓展语言，例如：Scss，TS等，并将其打包为合适的格式以供浏览器使用。 说说 webpack 与 grunt、gulp 的不同？12345678910111213141516171819三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据，整条链式操作构成了一个任务，多个任务就构成了web的构建流程。webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。所以，从构建来说，gulp和grunt需要开发者将整个前端构建过程拆分成多个`Task`，并合理控制所有`Task`的调用关系；webpack需要开发者找到入口，并需要清楚对于不同的资源应该使什么Loader做何种解析和加工对于知识背景来说，gulp更像后端开发者的思路，需要对于整个流程了如指掌webpack更倾向于前端开发者的思路 什么是 bundle,什么是 chunk，什么是 module?123bundle：是由webpack打包出来的文件chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块 什么是 Loader?什么是 Plugin?123451.Loaders是用来告诉webpack如何转化处理某一类型的文件，并且引入到打包出的文中2）Plugin是用来自定义webpack打包过程的方式，一个插件是含有apply方法的一个，通过这个方法可以参与到整个webpack打包的各个流程(生命周期)。 有哪些常见的 Loader？他们是解决什么问题的？12345678910file-loader：把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件url-loader：和file-loader类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中去source-map-loader：加载额外的Source Map文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把ES6转换成ES5css-loader：加载CSS，支持模块化、压缩、文件导入等特性style-loader：把CSS代码注入到JavaScript中，通过DOM操作去加载CSS。eslint-loader：通过ESLint检查JavaScript代码 有哪些常见的 Plugin？他们是解决什么问题的？123define-plugin：定义环境变量commons-chunk-plugin：提取公共代码uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 Loader 和 Plugin 的不同？不同的作用Loader 直译为”加载器”。Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。 Plugin 直译为”插件”。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法Loader 在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin 在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。 webpack 的构建流程是什么?1234567891011121314151617181920212223Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；开始编译：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；确定入口：根据配置中的 entry 找出所有的入口文件；编译模块：从入口文件出发，调用所有配置的 Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；完成模块编译：在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，Webpack会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 描述一下编写 loader 或 plugin 的思路？Loader 像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个 Loader 通过链式操作，将源文件一步步翻译成想要的样子。编写 Loader 时要遵循单一原则，每个 Loader 只做一种”转义”工作。 每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback()方法，将内容返回给 webpack。 还可以通过 this.async()生成一个 callback 函数，再用这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发 loader 的工具函数集——loader-utils。相对于 Loader 而言，Plugin 的编写就灵活了许多。 webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 如何利用 webpack 来优化前端性能？123456789101112131415用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件，利用cssnano（css-loader?minimize）来压缩css利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现提取公共代码。 如何提高 webpack 的构建速度？1234567多入口情况下，使用CommonsChunkPlugin来提取公共代码通过externals配置来提取常用库利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。使用Happypack 实现多线程加速编译使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用Tree-shaking和Scope Hoisting来剔除多余代码 怎么配置单页应用？怎么配置多页应用？单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。多页应用中要注意的是：每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套 css 样式表,随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置 vue 项目中实现按需加载？为了快速开发前端项目，经常会引入现成的 UI 组件库如 ElementUI、iView 等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。不过很多组件库已经提供了现成的解决方案，如 Element 出品的 babel-plugin-component 和 AntDesign 出品的 babel-plugin-import 安装以上插件后，在.babelrc 配置中或 babel-loader 的参数中进行设置，即可实现组件按需加载了。 单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。 通过 import()语句来控制加载时机，webpack 内置了对于 import()的解析，会将 import()中引入的模块作为一个新的入口在生成一个 chunk。当代码执行到 import()语句时，会去加载 Chunk 对应生成的文件。import()会返回一个 Promise 对象，所以为了让浏览器支持，需要事先注入 Promise polyfill 自主搭建、灵活定制、高效复用 1.单向链表的创建、插入和反转 2.二叉搜索树的查找、插入、删除思想，写伪代码3.tcp 链接和释放过程，http，https，tcp 和 udp 比较 4.链表顺序翻转 如何阻止冒泡?W3C的方法e.stopPropagation(),IE使用e.cancelBubble = true; 封装： //阻止冒泡行为 function stopBubble(e) { //如果提供了事件对象，则这是一个非IE浏览器 if (e &amp;&amp; e.stopPropagation) e.stopPropagation() //IE的方法 else window.event.cancelBubble = true } 如何阻止默认事件？W3C的方法是e.preventDefault(),IE使用e.returnValue = false 封装： //阻止浏览器的默认行为 function stopDefault (e) { if (e &amp;&amp; e.preventDefault) e.preventDefault() //IE中阻止默认事件的方法 else window.event.returnValue = false return false } 补充：事件绑定的封装function addEvent(element,type,handle) { if(element.addEventListener){ element.addEventListener(type,handle,false); }else if(element.attachEvent){ element.attachEvent('on'+type,function () { handle.call(element); }) }else { element['on'+type] = handle; } } JS 如何设置获取盒子模型对应的宽和高？ dom.style.width/height dom.currentStyle.width/height (ie 支持) window.getComputedStyle(dom).width/height dom.getBoundingClientRect().width/height 如何判断一个对象是否为数组1. Array.prototype.isPrototypeOf(obj)方法，判断Array.prototype是不是在obj的原型链中， 如果在，则返回true，否则返回false。 2. obj instanceof Array 3. Object.prototype.toString.call(obj); //(===&quot;[object Array]&quot;) 4.Array.isArray(obj) 宏任务和微任务1.macro-task(宏任务)：包括整体代码script、setTimeout、setInterval 2.micro-task(微任务)：Promise.then、process.nextTick Http 的持久连接和管线化1. 什么是持久连接？ HTTP1.1规定了默认保持持久连接，数据传输完成也保持TCP连接不断开，等待同域名下 继续使用这个通道传输数据,在一个TCP连接上传输多个HTTP请求和响应。 持久连接避免了重新建立连接，大大减少了建立和关闭连接的消耗和延迟，HTTP的连接是建立 在TCP协议之上的，建立一条TCP连接需要三次握手，TCP连接关闭需要四次挥手，这些都需要时间。 2. 什么是管线化？ 持久连接： 请求1 ——&gt; 响应1 ——&gt; 请求2 ——&gt; 响应2 管线化： 请求1 ——&gt; 请求2 ——&gt; 响应1 ——&gt; 响应2 管线化机制需要通过持久化连接完成。 持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后， 才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。 实现并行发送请求。 只有GET和HEAD请求可以进行管线化，而POST有所限制。 初次建立连接不应启动管线机制，因为对方服务器不一定支持HTTP1.1版本的协议。 为什么利用多个域名来存储网站资源会更有效？1.CDN 是构建在网络之上的内容分发网络，可以使用户就近获取资源，减低网络拥塞，提高用户 访问的响应效率以及命中率。 2.突破浏览器的并发限制，同一时间针对同一域名下的请求有一定的数量限制，超过限定数目 的请求会被阻塞。 3.节约cookie带宽 4.减少主域名的连接数，优化页面响应速度 5.防止不必要的安全问题 CSS 权重（156 进制）1. ！import 权值：infinite 无穷大 2. 内联样式， 权值1000 3. ID选择器， 权值： 100 4. 类、伪类、属性选择器， 权值： 10 5.标签、伪元素选择器， 权值： 1 6.通配符选择器 *，子选择器 &gt;,相邻选择器 +，权值： 0 权值相等，后来居上 html5 的新特性1. 添加了video、radio标签 2. 添加了canvas画布和svg渲染矢量图片 3. 添加了一些语义化的标签 header、footer、main、section... 4. input的type值新添加了很多属性（email，search，color，number...） 5. 添加了地理位置定位功能 Geolocation API 6. 添加了web Storage存储功能，localStorage和sessionStorage 7. 使用html5，通过创建cache manifest文件，可以轻松地创建web应用的离线版本 8. web worker创造多线程环境，是运行在后台的javaScript。 9。 服务端推送（EventSource用于接受服务端发送事件通知） CSS3 新添加的特性？1. 媒体查询 2. transform，transition，translate，scale，rotate等相关动画效果 3. box-shadow，text-shadow等特效 4. CSS3 @font-face规则，可以引入任意字体 5. CSS3 @keyframes规则，创建动画(配合animation使用) 6. 2D、3D转化 7. 添加了border-radius、border-image、column-count、resize、box-sizing 、outline-offset等属性 基本数据类型基本数据类型：Null、Undefined、String、Boolean、Number ES6：Symbol ES10：Bigint（可以突破安全整数限制，安全的存储和操作最大整数之外的整数，不会损失精度） 牛客学习 超链接 a 标签的 href 的属性值是 url，里面必须包含协议，没有协议就会解析成相对路径。 HTTP 状态码分类： 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接受并处理。 200 服务端成功处理了请求并返回内容 3** 重定向，需要进一步的操作以完成请求 301 永久重定向 302 临时重定向 304 资源未被修改，返回一个 304 状态吗然后从本地缓存中加载请求的资源 4** 客户端错误，请求包含语法错误或无法完成请求。 404 （页面丢失）未找到资源 403 服务器拒绝请求 408 （请求超时） 服务器等候请求时发生超时 5** 服务器错误，服务器在处理请求的过程中发生错误 + 503 服务器暂时不可用 + 504 服务器内部错误 HTTP 协议的特征： C/S(客户端/服务器)模式：只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过 HTTP 来发送，客户端和服务器指定合适的 MIME-type 内容类型。 简单快速 灵活 无连接：限制每次连接只处理一个请求，收到客户的应答后即断开连接，可以节省传输时间。 无状态：对于事物处理没有记忆能力，意味着如果后续处理需要前面的信息，则必须重传，这样就会导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就会很快。 get 和 post 的请求区别？ 区别一： get 重点是从服务器上获取资源 post 重点是向服务器发送数据 区别二： get 传输数据通过 url 请求，以 field（字段）=value 的形式放在 url 后，用“？”连接，多个请求数据间用“&amp;”连接，过程用户可见。 post 传输数据放在请求体（request body）中发送给服务器，用户不可见。 区别三： get 传输数据大小有限制，但效率较高 post 可以传输大量数据，所以上传文件用 post 方式 区别四： get 请求不安全，因为参数直接暴露在 url 上，不能用来传递敏感信息。 post 较 get 安全性较高。 区别五： get 方式只能支持 ASCII 字符，向服务传的中文字符可能会乱码。 post 支持标准字符集，可以正确传递中文字符。 区别六： get 在浏览器回退是无害的，而 post 会再次提交请求。 区别七 get 请求会被浏览器主动 cache（缓存），而 post 不会除非手动设置。 iframe 有哪些缺点？ iframe 会阻塞主页面的 onload 事件 通过 oIframe.contentWindow 寻找子 window 对象 通过 window.parent 寻找父级窗体 通过 window.top 寻找顶级窗体 window.location.hash 解决父页面向子页面传值 window.name 解决子页面向父页面传值 不利于 SEO，搜索引擎的检索程序无法解读这种页面（百度 spider 不收录，浏览器对 iframe 框架的兼容问题） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 如果需要使用 iframe，最好通过 javascript 动态给 iframe 添加 src 属性值。 xhtml 和 html 有什么区别？ 性能方面 XHTML 兼容性好，兼容各大浏览器、手机以及 PDA，使浏览器可以快速正确编译网页 书写习惯方面 HTML 标签不区分大小写，XHTML 所有标签必须小写 XHTML 必须成双成对 HTML 对标签顺序要求不严格，XHTML 标签顺序必须正确 等等 html 和 xml 的区别？ xml 被设计用来传输和存储数据，其焦点是数据的内容 html 被设计用来显示数据，其焦点是数据的外观 html 旨在显示信息，而 xml 旨在传输信息 xml 在定义标记时区分大小写，而 html 不区分大小写 link 和@import 的区别：两者都是外部引用 CSS 的方式，但有一定的区别 + link是XHTML标签，除了加载CSS外，还可以加载其他文件；@import只能加载CSS。 + 解析到link时，页面会同步加载Css；@import在页面加载完后加载Css。 + link是XHTML标签，无兼容问题；@import是在**CSS2.1**之后提出的，只有再IE5以上才能识别。 + link可以js动态引入，@import不行 + @import的最佳写法： @import url(style.css),其他写法：@import 'style.css'、 @import &quot;style.css&quot;、@import url('style.css')、@import url(&quot;style.css&quot;) viewport 1234&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt; // width 设置 viewport 宽度，为一个正整数，或字符串‘device-width’// device-width 设备宽度// height 设置 viewport 高度，一般设置了宽度，会自动解析出高度，可以不用设置// initial-scale 默认缩放比例（初始缩放比例），为一个数字，可以带小数// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数// user-scalable 是否允许手动缩放 单行文本溢出省略号 overflow: hidden; text-overflow:ellipsis; white-space: nowrap; 多行文本溢出省略号 display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; 换行标签 word-wrap: break-word 深度封装 typeof 判断function myTypeof(val) { var type = typeof(val) var res = { '[object Object]' : 'object', '[object Array]' : 'array', '[object Number]' : 'object number', '[object String]' : 'object string', '[object Boolean]' : 'object boolean' } if (val === null) { return 'null' } else if (type == 'object') { var str = Object.prototype.toString.call(val) return res[str] } else { return type } } 浏览器的 reflow 和 repaint reflow（回流||重排）：当浏览器上某一个位置的布局发生了改变，浏览器会重新从根部开始计算该节点的 布局。比如：向页面中添加、删除某一元素等，dom 节点的宽高位置改变，只要这些操作影响了 页面的元素位置或大小的变化，都会引起 reflow。 repaint（重绘）：如果只改变页面元素的颜色、字体等不影响布局的属性时，浏览器会进行 repaint。 123由上可见，相比repaint操作，reflow的耗时要更多。只要是动态的对页面进行修改，浏览器的reflow和repaint的操作就不可避免，我们要做的就是尽可能的减少浏览器的reflow和repaint的次数。 浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？ 在线的情况下：浏览器发现 html 头部有 manifest 属性，会请求 manifest 文件，如果是第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并进行离线缓存。如果已经离线存储了，浏览器会使用离线的资源加载页面，然后浏览器会比对新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不要做任何操作，如果文件改变，就会重新下载文件中的资源并进行离线存储。 离线的情况下：浏览器就直接使用离线存储的资源。 如何清除 token 浏览器关闭会出发 beforeunload ，unload 这两个事件。 浏览器刷新也会触发，还会触发load事件 方案一 123window.onbeforeunload = function () { localStorage.removeItem(&quot;token&quot;)} 缺点： 刷新也会清空 token 方案二 123456789101112131415window.onunload = function() { localStorage.setItem(&quot;lastTime&quot;,new Date().getTime())}window.onload = function() { let lastTime = localStorage.getItem(&quot;lastTime&quot;); const interval = 3 * 1000; // 如果时间间隔大于3s，则清除token if (!lastTime || new Date().getTime() - lastTime &gt; interval) { localStorage.remove(&quot;token&quot;); console.log(&quot;remove token&quot;); } else { console.log(&quot;time is less than not remove token&quot;); }} 补充可以使用 sessionStorage 代替 localStorage 来存储 token，当关闭浏览器时会自动清除 token，sessionStorage 不是持久化的本地存储，而是会话级别的存储，而 localStorage 是持久化的本地存储，除非主动删除数据，否则数据是不会过期的。 npm 1234567891011121314151617181920212223242526272829303132333435363738// 举个例子：&quot;dependencies&quot;: { &quot;jquery&quot;: &quot;^13.4.6&quot;, // 只锁定主版本号 major &quot;jquery&quot;: &quot;~13.4.6&quot;, // 锁定主版本号和次版本号 major + minor &quot;jquery&quot;: &quot;13.4.6&quot;, // 锁定版本 &quot;jquery&quot;: &quot;*&quot;, // 最新版本}// major: 13, minor: 4, patch: 6$ npm info jquery // 查看 jquery 信息$ npm view jquery versions // 查看 jquery 所有版本$ npm list | grep gulp // 过滤 gulp$ npm outdated // 查看过期版本$ npm update //更新版本$ npm cache clean --force // 清楚缓存$ npm ls // 查看项目引用了哪些包$ npm unpublish --force // 从npm卸载包// 执行顺序$ npm run script1 &amp; npm run script2 //并行执行$ npm run script1 &amp;&amp; npm run script2 // 继发执行// cross-env: 运行跨平台设置和使用环境变量的脚本// cross-env可以设置NODE_ENV环境变量，process.env.NODE_ENV === 'production'$ npm install --save-dev cross-env// {// &quot;scripts&quot;: {// &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;// }// }$ npm config get registry // 查看当前源$ npm config set registry https://registry.npm.taobao.org //切换镜像源// npx// --no-install: 让npx强制使用本地模块，不下载远程模块，如果本地不存在，就会报错$ npx --no-install http-server// --ignore-existing: 忽略本地的同名模块，强制安装远程模块$ npx --ignore-existing http-server 本地存储 客户端的本地存储： localStorage - 生命周期永久生效，除非手动删除，否则关闭页面也会存在 - 可以在同一浏览器多窗口共享 - 以键值对的形式存储使用 - 方法： + 存储数据：localStorage.setItem(key, value) + 获取数据：localStorage.getItem(key) + 删除数据：localStorage.removeItem(key) + 删除所有数据：localStorage.clear() sessionStorage 声明周期为关闭浏览器窗口 在同一个窗口中数据可以共享 以键值对的形式存储 方法： 存储数据：sessionStorage.setItem(key, value) 获取数据：sessionStorage.getItem(key) 删除数据：sessionStorage.removeItem(key) 删除所有数据：sessionStorage.clear() localStorage 和 sessionStorage cookie 和 session IndexDB 离线存储，当网络断开，可以从浏览器中读取数据，用来做一些离线应用 Cookie 包含字段 name: cookie 名称 value: 值 domain: cookie 生效的域名 path: cookie 生效的路径 expires/max-age: cookie 过期时间 size: 大小 HttpOnly: 用户端不可更改 存储用户信息，通过在客户端记录信息确定用户身份，最大为 4kb 会话 Cookie，若不设置过期时间，表示这个 cookie 的生命周期为浏览器会话期间，浏览器关闭，cookie 就消失，会话 cookie 会保存在内存中而不是硬盘上。 持久 Cookie，若设置了过期时间，浏览器会把 cookie 保存在硬盘上，关闭浏览器仍然有效直到超过设定的过期时间。 cookie 数据始终在同源的 http 请求中携带(即使不需要)，即会在浏览器和服务器之间来回传递。 Cookie 具有不可跨域名性，例如浏览器访问百度不会带上谷歌的 cookie 服务端的存储： Session Session 服务器端一种记录客户端状态的机制 cookie 数据存放在客户的浏览器上，session 将数据存放在服务器端 Session 相对 Cookie 来说比较安全，别人可以分析本地存放的 cookie 进行 cookie 欺骗 Session 会在一定时间内保存在服务器上，访问量较多的时候会比较占用服务器的性能，考虑到减轻服务器性能方面的时候，应当使用 cookie 可以将登陆等重要信息保存在 session，其他信息放在 cookie 中 日期 Date.now() //获取当前时间毫秒数 var dt = new Date() //构造一个实例对象 dt.getTime() //获取毫秒数 dt.getFullYear() //年 dt.getMonth() //月（0-11） dt.getDate() //日 （0-31） dt.getHours() //小时（0-23） dt.getMinutes() //分钟（0-59） dt.getSeconds() //秒（0-59） dt.getDay() //星期几（0-6） 如何监听未处理的异常 try…catch 无法捕捉到语法错误，只能捕捉运行时错误 可以拿到出错的信息(出错的文件，行号，列号) window.onerror 由于 try…catch 只能捕获块里面的错误，全局的一些错误可以用 window.onerror window.addEventListener(‘error’,callback):捕获资源错误 window.addEventListener(‘unhandledrejection’,callback):捕获 promise 类型错误 vue.config.errorHandler: vue 错误 componentDidCatch：错误边界函数 http 和 https 的区别 http 是一种一种广泛使用的网络协议，是一个客户端和服务器请求和应答的标准。 http 工作在 TCP 协议的 80 端口，https 工作在 TCP 协议的 443 端口 http 协议运行在 TCP 协议之上，所有的传输内容都是明文，https 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有的传输内容都是经过加密的。 https 是以安全为目标的 http 通道，是 http 的安全版。是 http 加上 SSL 层对传输的信息和 url 做了一些加密处理，更加安全 为什么 https 不会被截取信息 完成 TCP 三次同步握手 客户端验证服务器数字证书，通过，进入步骤 3 DH 算法协商对称加密算法的密钥、hash 算法的密钥 SSL 安全加密隧道协商完成 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的 hash 算法进行数据完整性保护，保证数据不被篡改 浏览器如何缓存 html meta 标签控制缓存 &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cahce&quot;&gt; //告诉浏览器当前页面不被缓存 http 头信息控制缓存 Expires ——&gt; 过期时间 Cache-Control 响应头信息(no-cache、no-store、max-age、public) TCP 协议如何保证传输的可靠性 校验和 确认应答 + 序列号 超时重传 流浪控制 拥塞控制 TCP 的连接管理 滑动窗口 UDP &amp; TCP 的区别 相同点： UDP 协议 和 TCP 协议 都是运输层协议 不同点： UDP 特点： 无连接 —— 知道对端的 IP 和端口号就直接进行传输，不需要建立连接 不可靠 —— 没有确认机制，没有重传机制，即使因为网络故障无法发送到对方，UDP 协议也不会给应用层返回任何错误信息 面向数据报 传输速 度块 TCP 特点： 面向连接，在客户端和服务器进行交换数据前，必须先在双方之间建立一个TCP 连接 可靠传输，具有确认应答机制、超时重传机制、拥塞控制、流量控制、滑动窗口机制、延迟应答等。 面向字节流 UDP 的响应速度优于 TCP，安全性和数据可靠性不如 TCP UDP 一般用在网络负担非常重，但对响应速度要求高，数据类型都是短消息的情况下 样式导入方式及优先级？ 引入方式 行内样式 内联式 外链式 导入式: @import url(reset.css) 各种方式的优先级 行内样式 &gt; 外链式 &gt; 内联式 &gt; @import 导入式 选择器优先原则：!important &gt; 行间样式 &gt; ID 选择器 &gt;class 选择器｜伪类选择器｜属性选择器 &gt;元素选择器｜伪元素选择器 &gt; 通配符选择器｜子选择器选择器｜相邻兄弟选择器 BFCBFC(block formatting context)翻译为“块级格式化上下文”，它会生成独立的渲染区域(不影响外面的元素，同时也不受外部元素的影响)，它有一下规则： 内部的 box 会在垂直方向上一个接一个的放置。 内部 box 在垂直方向上的距离由 margin 决定，同属一个 BFC 内的相邻 box 会发生 margin 重叠。 BFC 的区域不会与 float box 发生重叠。 计算 BFC 的高度时，浮动元素也参与计算(清除浮动) 触发 BFC 的条件： float 属性不为 none position 为 absolute 或者 fixed display 为 inline-block、table-cell、table-caption、flex、inline-flex overflow 不为 visible 字符串去重for 遍历function removeRepeatStr(str){ var newStr = ''; var flag; var len = str.length; for(var i=0; i&lt;len; i++){ flag = 1; var newLen = newStr.length; for(var j=0; j&lt;newLen; j++){ if(str[i] == newStr[j]){ flag = 0; break; } } if(flag){ newStr = newStr + str[i]; } } return newStr; } indexOf 方法function removeRepeatStr(str){ var newStr = ''; var len = str.length; for(var i=0; i&lt;len; i++){ if(newStr.indexOf(str[i])==-1){ newStr = newStr + str[i]; } } return newStr; } search 方法function removeRepeatStr(str){ var newStr = ''; var len = str.length; for(var i=0; i&lt;len; i++){ if(newStr.search(str[i])==-1){ newStr = newStr + str[i]; } } return newStr; } 对象属性法12345678910111213function removeRepeatStr(str) { var obj = {}; var newStr = ''; var len = str.length; for (var i = 0; i &lt; len; i++) { if (!obj[str[i]]) { newStr = newStr + str[i]; //注意，这里的1是给对象属性赋值，这个值可以任意取。意思是把每个遍历的字符作为对象属性并赋值保存，保证该属性的唯一性 obj[str[i]] = 1; } } return newStr;} 同步和异步的区别，怎么异步加载 javascript? 同步模式同步模式，又称阻塞模式，javascript 在默认情况下是会阻塞加载的，当前面的 javascript 请求没有处理和执行完时，会阻止浏览器的后续处理 异步模式异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理 异步加载 JavaScript 动态添加 script 标签 defer async defer 属性和 async 都是属于 script 标签上面的属性，两者都能实现 JavaScript 的 异步加载。不同之处在于：async 在异步加载完成的时候就马上开始执行了，defer 会等到 html 加载完毕之后再执行。 有哪些常见的 meta 标签？ 指定文档编码 &lt;meta charset = &quot;UTF-8&quot;&gt; name 属性 1.&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;：在移动设备浏览器上，禁用缩放（zooming） 功能，用户只能滚动屏幕。 2.&lt;meta name=”description” content=””&gt;：告诉搜索引擎，当前页面的主要内容是xxx。 3.&lt;meta name=”keywords” content=””&gt;：告诉搜索引擎，当前页面的关键字。 4.&lt;meta name=”author” content=””&gt;：告诉搜索引擎，标注网站作者是谁。 5.&lt;meta name=”copyright” content=””&gt;：标注网站的版权信息。 http-equiv 属性(http 协议的响应头报文) 1.&lt;meta http-equiv=”Set-Cookie” content=”cookievalue=xxx; expires=Friday,12-Jan-2001 18:18:18 GMT; path=/”&gt;:如果网页过期， 那么存盘的cookie将被删除。必须使用GMT的时间格式。 2.&lt;meta http-equiv='expires' content='时间' &gt;：用于设定网页的到期时间。 一旦网页过期，必须到服务器上重新传输。 3.&lt;meta http-equiv=”Refresh” content=”5;URL”&gt;：告诉浏览器在 【数字】秒后跳转到【一个网址】 4.&lt;meta http-equiv=”content-Type” content=”text/html; charset=utf-8″&gt;： 设定页面使用的字符集。 -5.&lt;meta http-equiv=”Pragma” content=”no-cache”&gt;：禁止浏览器从本地 计算机的缓存中访问页面内容。访问者将无法脱机浏览。 6.&lt;meta http-equiv=”Window-target” content=”_top”&gt;：用来防止 别人在iframe(框架)里调用自己的页面，这也算是一个非常实用的属性。 7.&lt;meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'&gt; :强制浏览器按照特定的版本标准进行渲染。但不支持IE7及以下版本。如果是 ie浏览器就用最新的ie渲染，如果是双核浏览器就用chrome内核。 什么是 FOUC？如何避免？ 一、为什么会有白屏和 FOUC 呢？ 浏览器再渲染的时候没有请求到或请求时间过长造成的，那么浏览器怎么应对的呢？ 白屏：CSS 全部载入解析完成后渲染展示页面，如果没有加载完，就会出现白屏。 FOUC(Flash of Unstyled Content)无样式内容闪烁：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式表加载渲染之后，再重新显示文档，造成页面闪烁。 解决方法 使用 link 标签将样式表放在顶部标签中，防止白屏问题出现。 将 JS 放在标签底部，原因如下： 脚本会阻塞后面内容的呈现 脚本会阻塞其后组件的下载 什么是 DOCTYPE 及其作用？ DOCTYPE 是 document type（文档类型）的缩写。 写法：(声明了浏览器就会进入标准模式，按照 W3C 标准渲染页面) DOCTYPE 的作用： DOCTYPE 是用来声明文档类型和 DTD 规范的，校验文件和代码的合法性。 告诉浏览器通过哪种规范（文档类型，DTD）来解析文档。 DTD（document type definition）文档类型定义是一系列的语法规则，用来定义 XML或 HTML 的文件类型。浏览器会根据它来判断文档类型，决定使用哪种协议来解析，以及切换浏览器的模式。 浏览器模式 为了能够很好的显示满足标准的页面，又能最大程度兼容不合法的 HTML，浏览器厂商会提供两种浏览器模式。 标准模式：根据 W3C 标准来渲染页面。 混杂模式（兼容模式、怪异模式）：浏览器采用更加宽松、向后兼容的方式来渲染页面。 CSS-清除浮动 原文链接 什么是 CSS 清除浮动?1234在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。 清除浮动的方法 方法一：使用带 clear 属性的空元素 12345在浮动元素后使用一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt;来进行清理。优点：简单，代码少，浏览器兼容好。缺点：需要添加大量的无语义的html元素，代码不够优雅，后期不容易维护。 方法二：使用 CSS 的 overflow 属性 1给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动。 方法三：给浮动的元素的容器添加浮动（不太推荐） 12给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 方法四：使用邻接元素处理 1什么都不做，给浮动元素后面的元素添加clear:both属性。 方法五：使用 CSS 的：after 伪元素 12345678910给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。.clearfix::after{ content: &quot;020&quot;; display: block; height: 0; clear: both; visibility: hidden; } Chrome 打开一个页面需要启动多少线程？分别有哪些线程？ 最新Chrome浏览器包括：一个浏览器(Browser)主线程、一个GPU进程、一个网络(NetWork) 进程、多个渲染进程和多个插件进程 线程： 浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU 进程：Chrome 刚开始的时候是没有 GPU 进程的，而 GPU 使用的使用初衷是为了实现3D CSS 效果，之后随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 称为浏览器普遍的需求，最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程：主要负责网页的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，最近才独立出来，称为一个单独的进程。 插件进程：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 CommonJS、AMD、CMD 是什么及区别？ CommonJS 是服务器端 js 模块化的规范，NodeJS 是这种规范的实现，加载模块使用 require 方法， 导出使用 exports AMD 和 CMD 都是为了解决浏览器端模块化问题而产生的，AMD 规范对应的库 Require.js, CMD 规范对应的库 Sea.js AMD 和 CMD 的区别: AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD 推崇就近依赖，只有在用到的某个模块的时候再去 require 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行，但 RequireJS(AMD)从 2.0 开始，也改为延迟执行 AMD 的 API 默认是一个当多个，CMD 的 API 严格区分，推崇职责单一 js 加载(浏览器加载)时间线理论：它是根据js出生的那一刻开始记录的一系列浏览器按照顺序做的事， 就是加载顺序及一些优化 创建 Document 对象，开始解析 web 页面，这个阶段 document.readyState = ‘loading’ 遇见 link 外部 css，css 资源异步下载，并继续解析文档，下载和解析都不会阻塞构建 dom 树 遇见 script 外部 js，并且没有设置 async、defer，浏览器同步加载，并阻塞构建 dom 树，等待 js 加载完成并执行该脚本，然后继续解析文档 遇见 script 外部 js，并且设置了 async、defer，浏览器创建线程 加载，并继续解析文档，对于 async 属性的脚本，加载完成后立即执行。（异步加载禁止使用 document.write(),它会清除文档流） 遇见 img 等，先正常解析 dom 结构，然后浏览器异步加载 src，并继续解析文档 文档解析完成，document.readyState = ‘interactive’ 文档解析完成后，所有设置 defer 的脚本会按照顺序执行。（也禁止使用 document.write()） 之后 document 对象触发 DOMContentLoaded 事件，标志程序执行从同步脚本执行阶段，转化为事件驱动阶段 当所有 async 的脚本加载并执行后、img 等加载完成后，document.readyState = ‘complete’,这时 window 对象触发 load 事件。 … 异步加载 jsjavascript 异步加载的三种方案: - defer - async - 动态创建 script，插入到 dom 中，加载完毕后 callback。 简单实例： 1234567891011var script = document.createElement('script')script.type = 'text/javascript'script.src = demo.jsscript.onload = function() { //兼容性很好，除了IE // ...}document.head.appendChild(script) 123456789101112131415161718192021222324//动态加载函数封装function asyncLoaded(url,callback){ var script = document.createElement(&quot;script&quot;);// script.src = url; 假如说网速非常好，直接执行完成了，后面就监听不到状态的改变了 if(script.readyState){ script.onreadystatechange = function(){ if(script.readyState == &quot;complete&quot; || script.readyState ==&quot;loaded&quot;){// 执行某个函数 callback() } } }else{ script.onload = function(){// 执行某个函数 callback() } } script.src = url; //异步的过程 document.head.appendChild(script)}asyncLoaded('demo.js', function(){ test();}) async 和 defer 对比？async和defer的解析过程： · 浏览器解析到async的script标签，不会中断html解析，并行下载脚本，下载完成后中断html解析并执行脚本 · 浏览器解析到defer的script标签，不会中断html解析，并下下载脚本，当浏览器解析完html、DOMContentLoaded事件即将触发时执行脚本 async和defer的区别： · async和defer仅对外部脚本有效 · async加载完立即执行，defer在html解析完成且dom构建完毕后延迟执行 · 如果存在多个js脚本，async那个先下载完成哪个先执行（无序），defer按照js脚本的书写顺序执行 · 同时存在async和defer时，defer不起作用 · DOMContentLoaded事件会等待defer的脚本执行完才触发 getomputedstyle 和 style 的区别？ getComputedStyle 方法是只读的，只能获取样式，不能设置；而 element.style 能读写。 getComputedStyle 方法获取的是最终应用在元素上的所有 Css 属性样式(即使没有 css 代码)，而 element.style 只能获取元素 style 属性中的 css 样式。 getComputedStyle 可以获取伪元素的样式。 兼容性：getComputedStyle 方法在 IE6~IE8 是不支持的。 什么是 HTML 语义化？ 1根据内容的结构化，选择合适的标签，便于开发者阅读和写出更优雅的代码的同时利于SEO的优化。 为什么要语义化？1234567- 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；- 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；- 有利于SEO ：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息： 爬虫依赖于标签来确定上下文和各个关键字的权重；- 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页- 便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 构建打包优化（webpack-bundle-analyzer 分析各个打包文件）速度优化: exclude/include 通过 exclude、include 配置来确保转译尽可能少的文件 cache thread-loader resolve.alias webpack 直接根据对应别名的目录查找模块，减少搜索时间 模块懒加载 externals + CDN V8 垃圾回收机制 V8 会把堆分为新生代和老生代 新生代（副垃圾回收器） 存放生存时间短的对象 通常只支持 1 ～ 8M 的容量 分为对象区和空闲区 对对象区域中的垃圾做标记，标记完成进入垃圾清理阶段，把存活的对象复制到空闲区域，把这些对象有序的排列起来 完成复制后，对象区和空闲区进行角色翻转 老生代（主垃圾回收器） 对象存放生存时间久 对象占用空间大 副垃圾回收器采用对象晋升策略：移动那些经过两次垃圾回收依然还存活的对象到老生代中 V8 实现了精准式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。 新生代算法新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。 老生代算法老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是 标记清除算法 和 标记压缩算法。在将算法前，先来说下什么情况下对象会出现在老生代空间中：● 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间。● To 空间的对象占比大于 25%。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。 以下情况会启动 标记清除算法：● 某一空间没有分块的时候● 空间中对象超过一定限制● 空间不能保证新生代中的对象移动时 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动 压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清除不需要的内存。 如何处理 TCP 的粘包?发生 TCP 粘包或拆包有很多原因，现列出常见的几点： 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。 关键点：如何给每个数据包添加边界信息 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。 发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。 请说说 HTTPS 的握手过程？HTTPS 的握手过程主要包括以下步骤： 客户端向服务端发送一个加密过的客户端随机数和客户端支持的加密算法列表，同时请求建立 SSL/TLS 连接。 服务端在接收到请求后，向客户端发送一个包含服务端随机数、服务器支持的加密算法列表以及服务器的数字证书的报文。 客户端在接收到服务器的响应后，会对证书进行校验。如果证书被认为是合法的，那么客户端将使用证书中包含的公钥对一个随机数进行加密，并将加密后的随机数发送给服务端。 服务端在接收到客户端的响应后，使用私钥对加密的随机数进行解密，得到客户端生成的随机数。同时，服务端也会生成一个加密的会话密钥，并使用客户端和服务端的随机数以及协商出的加密算法对该密钥进行加密，最后将加密后的密钥发送给客户端。 客户端接收到服务端发送的加密的会话密钥后，使用服务端公布的公钥进行解密，得到原始的会话密钥。 客户端和服务端都会使用会话密钥进行加密和解密，从而实现安全的通信。 这个过程中，客户端和服务端会进行多次来回的通信，以建立安全的 SSL/TLS 连接。其中数字证书的校验和会话密钥的生成都是关键步骤，它们保证了通信的安全性。 请说说什么是数字证书？它有什么作用? 数字证书是一种加密技术，用于验证在线交互中的身份和信息安全性。它是由可信任的第三方机构（例如数字证书颁发机构）颁发的一份电子文档，其中包含了一些加密信息，如公钥、数字签名等。数字证书的作用是确保通信双方的身份和数据的完整性和保密性。 在使用数字证书进行加密通信时，服务端会向证书颁发机构申请一份数字证书。数字证书包含了服务端的公钥，以及一些描述服务端身份的信息，例如域名、组织名称等。客户端在与服务端建立连接时，会向服务端请求数字证书，并验证证书的真实性和合法性。如果验证成功，客户端就可以使用服务端的公钥加密数据并发送给服务端了。同时，服务端也可以使用客户端的公钥进行数据的加密和验证。这样就可以确保通信过程中的数据不被窃听或篡改。 数字证书的使用广泛，特别是在网站安全和电子商务领域。它可以用来验证网站的真实性和合法性，确保网站访问过程中的信息安全。此外，数字证书还可以用于文件签名、电子邮件加密等其他领域。 使用 git commit 后，如何修改 commit 的信息？1git commit --amend 在 less 中如何将 px 转换为 vw？123456789101112.pxToVW (@px, @attr: width) { @vw: (@px / 750) * 100; @{attr}:~&quot;@{vw}vw&quot;;}.title{ .pxToVW(300,width) .pxToVW(32,font-size)}这里是指，设计图是按照750px的宽度进行设计的,title 中所有的值都是直接取的设计图的值，通过函数进行统一换算 [js] 请说说写一个拖拽组件的思路及注意事项?123456789首先，其实拖拽效果的思路是很简单的。主要就是三个步骤：1.onmousedown的时候，启动可拖拽事件，记录被拖拽元素的原始坐标参数。2.onmousemove的时候，实时记录鼠标移动的距离，结合被拖拽元素第一阶段的坐标参数，计算并设置新的坐标值。3.onmouseup的时候，关闭可拖拽事件，记录新的坐标值。注意：这里主要是通过绝对定位的top和left来确定元素的位置的，因此被拖拽元素的css一定要设置绝对定位。 为什么 try/catch 不能捕获到 promise 的错误？ try-catch 主要用于捕获同步函数的异常，如果 try 里面的异步方法出现了异常，此时 catch 是无法捕获到异常的。ES6 中 Promise 对象的实例提供了 catch() 方法，表示异步捕获异常。 原因：当异步函数抛出异常时，对于宏任务而言，执行函数时已经将该函数推入栈，此时并不在 try-catch 所在的栈，所以 try-catch 并不能捕获到错误。对于微任务而言，比如 promise，promise 的构造函数的异常只能被自带的 reject 也就是.catch 函数捕获到。 gitlab CI/CD 流程生产环境1、推送代码-&gt;编译-&gt;生成的 jar 包发布到私服-&gt;打包为 docker 镜像-&gt;推送到 Harbor 镜像仓库（成功，微信通知，c 结束返回成功|失败，微信通知，ci 结束返回失败）2、运维人员 触发部署到 k8s 集群-&gt;健康检查（成功，微信通知，c 结束返回成功|失败，微信通知，ci 结束返回失败）","link":"/2021/10/04/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%932/"},{"title":"面试优质手写题","text":"数组去重 12345678910111213141516171819202122232425262728293031323334353637383940// indexOffunction unique(arr) { let res = []; for (let i = 0; i &lt; arr.length; i++) { if (res.indexOf(arr[i]) &lt; 0) { res.push(arrp[i]); } } return res;}// includesfunction unique(arr) { let res = []; for (let item of arr) { if (!res.includes(item)) { res.push(item); } } return res;}// 利用filterfunction unique(arr) { const res = arr.filter(function (item, index, array) { return array.indexOf(item) === index; }); return res;}// 利用Es6中的Set数据结构(扩展运算符)const unique = (arr) =&gt; [...new Set(arr)];// Array.form 方法将set结构转换为数组const unique = (arr) =&gt; Array.from(new Set(arr)); 数组扁平化123456789101112131415let arr = [1, [2, [3]]];// let res = arr.flat(Infinity)// let res = JSON.parse(&quot;[&quot;+JSON.stringify(arr).replace(/\\[|\\]/g,&quot;&quot;) + &quot;]&quot;)function flatArr(arr) { let res = arr.reduce((accu, curr) =&gt; { return accu.concat(Array.isArray(curr) ? flatArr(curr) : curr); }, []); return res;}console.log(flatArr(arr)); 浅拷贝12345678910111213141516171819202122// 只考虑对象类型function shallowCopy(obj) { if (typeof obj !== 'object') return; let newObj = obj instanceof Array ? [] : {}; if (obj === null) return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key]; } } return newObj;}// Object.assign()// arr.slice(0)// arr.concat()// 扩展运算符 深拷贝123456789101112131415161718192021// 只考虑普通对象属性，不考虑内置对象和函数function deepCone(obj) { if (typeof obj !== 'object') return; let newObj = obj instanceof Array ? [] : {}; if (obj === null) return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]; } } return newObj;}// JSON.parse(JSON.stringify())// lodash: _.cloneDeep() 实现一个 compose(组合)函数12345678910111213141516171819202122function compose(...fn) { if(!fn.length) return (v) =&gt; v; if(fn.length === 1) return fn[0]; return fn.reduce((accu, curr) =&gt; (...args) =&gt; accu(curr(...args)) );}例子：function fn1(x) { return x + 1;}function fn2(x) { return x + 2;}function fn3(x) { return x + 3;}function fn4(x) { return x + 4;}const res = compose(fn1, fn2, fn3, fn4);console.log(res(5)); // 5+4+3+2+1=15 assign12345678910111213141516171819Object.assign = function (target, ...source) { if (target === null || target === undefined) { throw new TypeError('Cannot convert undefined or null to object'); } let result = Object(target); source.forEach(function (obj) { if (obj !== null) { for (let key in obj) { if (obj.hasOwnProperty(key)) { result[key] = obj[key]; } } } }); return result;}; 防抖函数12345678910111213function debounce(func, wait) { let timeout; return function () { clearTimeout(timeout); timeout = setTimeout(() =&gt; { func.apply(this, arguments); }, wait); };}// 搜索联想，用户在不断输入时，用防抖来节约请求资源// window触发resize的时候 节流函数12345678910111213141516function throttle(func, wait) { const previous = 0; return function () { const now = +new Date(); if (now - previous &gt; wait) { func.apply(this, arguments); previous = now; } };}// 鼠标不断点击触发，可以使其单位时间内只触发一次// 监听滚动事件// 防止高频点击提交 函数柯里化123456789101112131415161718192021222324function curry(fn, ...args) { // 需要柯里化的函数fn，也可以支持初始参数的传入 return function () { //参数缓存在args里面,合并上次参数和本次参数 args = [...args, ...arguments]; // 判断参数个数，不够继续递归 if (args.length &lt; fn.length) { return curry(fn, ...args); } else { //参数足够返回函数执行结果 return fn.apply(null, args); } };}function bar(a, b, c) { return a + b + c;}const f = curry(bar);console.log(f(1)(2)(3), f(1, 2)(3), f(1, 2, 3)); 如何把字符串中大小写取反1234567let str = 'LiBoShi';str = str.replace(/[a-zA-Z]/g, (content) =&gt; { return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();}); 从 S 中查找 T 字符串，找到返回索引值，没有则返回-1，类似 indexOf12345678910111213141516171819// 普通方法function myIndexOf(T) { let index = -1; for (let i = 0; i &lt;= this.length - T.length; i++) { if (this.substr(i, T.length) === T) { return (index = i); } } return index;}String.prototype.myIndexOf = myIndexOf;// 正则方法function myIndexOf(T) { let reg = new RegExp(T); let res = reg.exec(this); return res === null ? -1 : res.index;} call12345678910111213141516171819202122232425Function.prototype.myCall = function (context, ...args) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;};// 使用let obj = { desc: function (from, to) { console.log(`${this.name}来自${from}去往${to}`); },};let person = { name: 'lbs',};obj.desc.myCall(person, '北京', '上海'); apply1234567891011Function.prototype.myApply = function (context, args = []) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;}; bind12345678910111213Function.prototype.myBind = function (content, ...args) { const fn = this; return function newFn(...newFnArgs) { // 检测 New // 如果当前函数的this指向的是构造函数中的this 则判定为new 操作 if (this instanceof newFn) { return new fn(...args, ...newFnArgs); } return fn.myApply(context, [...args, ...newFnArgs]); };}; instanceof123456789101. 通过left.__proto__.__proto__这种方式从下往上的获取原型对象2. 通过Object.create(null)的实例是没有原型链3. 有原型链的实例的尽头都是Objectfunction instanceof(left, right) { if(!left.__proto__) return false; if(right === Object || left.__proto__ === right.prototype) return true; return instanceof(left.__proto__, right);} 手写 Object.is123456789function is(x, y) { if (x === y) { // x,y都为0，但是1 / +0 = +Infinity,1 / -0 = -Infinity 是不一样的 return x !== 0 || y !== 0 || 1 / x === 1 / y; } else { //NaN === NaN = false是不对的，做一个拦截操作 return x !== x &amp;&amp; y !== y; }} ajax12345678910111213141516171819202122232425262728function ajax(method, url, headers, body) { return new Promise((resolve, reject) =&gt; { let req = null; try { req = new XMLHttpRequest(); } catch { req = new ActiveXObject('Microsoft.XMLHTTP'); } req.open(method, url); for (let key in headers) { req.setRequestHeader(key, headers[key]); } req.onreadystatechange(() =&gt; { if (req.readystate === 4) { if (req.status &gt;= 200 &amp;&amp; req.status &lt;= 300) { resolve(req.responseText); } else { reject(req); } } }); req.send(body); });} async 和 await12345678910111213141516171819202122232425262728293031323334// 执行async函数，返回的都是Promise对象async function test1() { return 1;}async function test2() { return Promise.resolve(2);}console.log(test1(), test2());// Promise.then 成功的情况对应的就是awaitasync function test3() { const p = Promise.resolve(3); p.then((data) =&gt; console.log(data)); const data = await p; console.log(data);}test3();// Promise.catch 异常对应 try...catchasync function test4() { const p = Promise.reject('异常了'); try { const data = await p; console.log(data); } catch (e) { console.log(e); }}test4(); map123456789101112Array.prototype.map = function (fn, toThis) { const arr = this; const result = []; const _this = toThis || Object.create(null); for (let i = 0; i &lt; arr.length; i++) { const item = fn.call(_this, arr[i], i, arr); result.push(item); } return result;}; 手写 promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161class Promise1 { static PENDING = 'pending'; static FULFILLED = 'fulfilled'; static REJECTED = 'rejected'; constructor(executor) { this.status = Promise.PENDING; //默认状态，进行中 this.value = null; //成功值 this.reason = null; // 失败原因 // 解决异步问题 this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; try { executor(this.resolve.bind(this), this.reject.bind(this)); } catch (e) { this.reject(e); } } resolve(value) { if (this.status === Promise.PENDING) { this.status = Promise.FULFILLED; this.value = value; setTimeout(() =&gt; { this.onFulfilledCallbacks.forEach((cb) =&gt; cb(this.value)); }); } } reject(reason) { if (this.status === Promise.PENDING) { this.status = Promise.REJECTED; this.reason = reason; setTimeout(() =&gt; { this.onRejectedCallbacks.forEach((cb) =&gt; cb(this.reason)); }); } } then(onFulfilled, onRejected) { if (typeof onFulfilled !== 'function') { onFulfilled = () =&gt; this.value; } if (typeof onRejected !== 'function') { onRejected = () =&gt; this.reason; } return new Promise1((resolve, reject) =&gt; { if (this.status === Promise.PENDING) { return new Promise1((resolve, reject) =&gt; { this.onFulfilledCallbacks.push(() =&gt; { this.parse(onFulfilled(this.value), resolve, reject); }); }); return new Promise1((resolve, reject) =&gt; { this.onRejectedCallbacks.push(() =&gt; { this.parse(onRejected(this.value), resolve, reject); }); }); } if (this.status === Promise.FULFILLED) { setTimeout(() =&gt; { return new Promise1((resolve, reject) =&gt; { this.parse(onFulfilled(this.value), resolve, reject); }); }); } if (this.status === Promise.REJECTED) { setTimeout(() =&gt; { return new Promise1((resolve, reject) =&gt; { this.parse(onRejected(this.reason), resolve, reject); }); }); } }); } parse(result, resolve, reject) { try { if (result instanceof Promise1) { result.then(resolve, reject); } else { resolve(result); } } catch (error) { reject(error); } } static resolve(value) { return new Promise1((resolve, reject) =&gt; { if (value instanceof Promise1) { value.then(resolve, reject); } else { resolve(value); } }); } static reject(reason) { return new Promise1((resolve, reject) =&gt; { reject(reason); }); } static all(promises) { const result = []; return new Promise1((resolve, reject) =&gt; { promises.forEach((promise) =&gt; { promise.then( (value) =&gt; { result.push(value); if (result.length === promises.length) { resolve(result); } }, (reason) =&gt; { reject(reason); } ); }); }); } static race(promises) { return new Promise1((resolve, reject) =&gt; { promises.forEach((promise) =&gt; { promise.then( (value) =&gt; { resolve(value); }, (reason) =&gt; { reject(reason); } ); }); }); }}let aaa = new Promise1((resolve, reject) =&gt; { resolve('lbs'); // reject('error')}).then((value) =&gt; { console.log(value); return '666';});aaa.then(() =&gt; { console.log(123);});console.log(aaa); 手写 event bus12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class EventEmitter { constructor() { this.events = {}; this.maxListeners = maxListeners || Infinity; } emit(event, ...args) { const cbs = this.events[event]; if (!cbs) { console.log('没有这个事件函数'); return this; } cbs.forEach((cb) =&gt; cb.apply(this, args)); return this; } on(event, cb) { if (!this.events[event]) { this.events[event] = []; } if ( this.maxListeners !== Infinity &amp;&amp; this.events[event].length &gt;= this.maxListeners ) { console.log('当事件超过了最大监听数'); return this; } this.events[event].push(cb); return this; } once(event, cb) { const fn = (...args) =&gt; { this.off(event, fn); cb.apply(this, args); }; this.on(event, func); return this; } off(event, cb) { if (!cb) { this.events[event] = null; } else { this.events[event] = this.events[event].filter((item) =&gt; item !== cb); } return this; }} 继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 构造函数继承function Person() { this.name = 'lbs';}function Student() { Person.call(this); this.age = 18;}const s = new Student();// 原型链继承function Person() { this.name = 'lbs';}function Student() { this.age = 18;}Student.prototype = new Person();const s = new Student();//寄生式组合继承function Person(obj) { this.name = obj.name;}function Student(obj) { Person.call(this, obj); this.age = obj.age;}// object.create()// 方法创建一个新对象，使用现有的对象来提供新创建对象的__proto__Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;// 或者：Student.prototype = Object.create(Person.prototype, { constructor: { value: Student, enumerable: false, writable: true, configurable: true, },});const student = new Student({ name: 'lbs', age: 18 });console.log(student); createElement 手写1234567891011121314151617181920212223242526272829303132333435363738394041424344const symbolFor = Symbol.for;const REACT_ELEMENT_TYPE = symbolFor('react.element');const RESERVED_PROPS = { key: true, ref: true, __self: true, __source: true,};function createElement(type, config, children) { const props = {}; let key = null; if (config !== null) { key = config.key; } for (let propName in config) { if (!RESERVED_PROPS.hasOwnProperty(propName)) { props[propName] = config[propName]; } } const childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = children; } else if (childrenLength &gt; 1) { const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } props.children = childArray; } const element = { $$typeof: REACT_ELEMENT_TYPE, type, key, props, };} 编写正则，验证一个 6 ～ 16 位的字符串，必须同时包含大小写字母和数字1234567正向预查 ？= 必须反向预查 ？！必须不let reg = /(?!^[a-zA-Z]+$)(?!^[0-9]+$)(?!^[a-z0-9]+$)(?!^[A-Z0-9]+$)^[a-zA-Z0-9]{6,16}$/;补充：数字、字母、下划线组成字符串，必须有_let reg = /(?=_)\\w/;let reg = /(?!^[a-zA-Z0-9]+$)^\\w{1,10}$/; 限制1-10位 获取所有属性为 name，值为 value 的元素集合12345678910111213141516171819202122232425// 正则\\b单词边界function getElements(property, value) { let elements = document.getElementsByTagName('*'); let arr = []; elements = Array.from(elements); elements.forEach((item) =&gt; { // 当前元素property对应的值 let itemValue = item.getAttribute(propertype); if (property === 'class') { const reg = new RegExp(`\\b${value}\\b`); if (reg.test(itemValue)) { arr.push(item); } } if (itemValue === value) { arr.push(item); } }); return arr;} 英文字母汉字组成的字符串，用正则给英文单词前后加空格12345678let str = '中国hello你好';let reg = /\\b[a-z]+\\b/gi;str = str .replace(reg, (value) =&gt; { return ` ${value} `; }) .trim(); // 去除首尾空格 js 实现斐波那契数列的几种方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1.递归function fibonacci(n) { if (n === 1 || n === 2) { return 1; } return fibonacci(n - 1) + fibonacci(n - 2);}// 2.尾递归(每次调用都在收集结果，避免了线性递归不收集结果只依次展开消耗内存的坏处)function fibonacci(n, res1 = 1, res2 = 1) { if (n &lt;= 2) return res2; return fibonacci(n - 1, res2, res1 + res2);}// 循环function fibonacci(n) { let num1 = 1; let num2 = 2; let sum = 1; for (let i = 3; i &lt; n; i++) { sum = num1 + num2; num1 = num2; num2 = sum; } return sum;}// 数组function fibonacci(n) { const arr = [0, 1, 1]; if (n &lt; 0) { throw new Error('输入的数字不能小于0'); } if (n &gt;= 3) { for (let i = 3; i &lt;= n; i++) { arr[i] = arr[i - 1] + arr[i - 2]; } } return arr[n];} 并发加载123456789101112131415161718192021222324252627282930313233343536373839404142function limitLoad(urls, handler, limit) { const sequence = [].concat(urls); let promises = []; promises = sequence.splice(0, limit).map((url, index) =&gt; { return handler(url).then(() =&gt; { return index; }); }); let p = Promise.race(promises); for (let i = 0; i &lt; sequence.length; i++) { p = p.then((res) =&gt; { promises[res] = handler(sequence[i]).then(() =&gt; { return res; }); console.log(promises); return Promise.race(promises); }); }}function loadImg(url) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // console.log(url.info + '---OK!!!') resolve(); }, url.time); });}let urls = [ { info: 1, time: 2000 }, { info: 2, time: 1000 }, { info: 3, time: 3000 }, { info: 4, time: 4000 }, { info: 5, time: 5000 },];limitLoad(urls, loadImg, 3); 前端内存处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781. 内存的生命周期 内存分配：声明变量、函数对象的时候，js会自动分配内存 内存使用 内存回收2. js中的垃圾回收机制 引用计数：缺点循环引用无法清除 标记清除3. 常见内存泄漏 全局变量（记得手动回收） 未被清除的定时器 闭包 dom的引用4. 怎么避免内存泄漏 减少不必要的全局变量 使用完数据，及时解除引用实现sizeOf，传入object，计算其所占字节大小number: 8 字节string: 2 字节boolean; 4 字节const seen = new WeakSet();function sizeOfObject(obj) { if (obj === null) { return 0; } let bytes = 0; const keys = Object.keys(obj); for(let i = 0; i &lt; keys.length; i++) { const key = keys[i]; bytes += calculator(key); if (typeof obj[key] === 'object' &amp;&amp; obj[key] !== null) { if (seen.has(obj[key])) { continue; } seen.add(obj[key]) } bytes += calculator(obj[key]) }}function calculator(obj) { const objType = typeof obj; switch(objType) { case 'string': { return obj.length * 2 } case 'boolean': { return 4 } case 'number': { return 8 } case 'object': { if (Array.isArray(obj)) { return obj.map(calculator).reduce((accu, curr) =&gt; { return accu + curr }, 0) } else { return sizeOfObject(obj) } } default: { return 0 } }} 数据结构就是在计算机中存储和组织数据的方式。 算法（Algorithm）解决问题的逻辑或步骤 栈(封装)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function Stack() { this.items = []; // 1. 将元素压入栈 Stack.prototype.push = function (element) { this.items.push(element); }; // 2.从栈中取出元素 Stack.prototype.pop = function () { return this.items.pop(); }; // 3.查看一下栈顶元素 Stack.prototype.peek = function () { return this.items[this.items.length - 1]; }; // 4.判断栈是否为空 Stack.prototype.isEmpty = function () { return !this.items.length; }; // 5.获取栈中元素个数 Stack.prototype.size = function () { return this.item.length; }; // 6. toString方法 Stack.prototype.toString = function () { let res = ''; for (let i = 0; i &lt; this.items.length; i++) { res += `${this.items[i]} `; } return res; };}const stack = new Stack();// 实例：将十进制转换成二进制function dec2bin(decimalNumber) { let stack = new Stack(); let binary = ''; while (decimalNumber &gt; 0) { stack.push(decimalNumber % 2); decimalNumber = Math.floor(decimalNumber / 2); } while (!stack.isEmpty()) { binary += stack.pop(); } return binary;} 平衡括号问题12345678910111213141516171819202122232425262728293031function check(str) { const stack = new Stack(); const open = '{[('; const close = '}])'; let index = 0; let balanced = true; while (index &lt; str.length &amp;&amp; balanced) { if (open.includes(str[index])) { stack.push(str[index]); } else { const top = stack.pop(); if (open.indexOf(top) === close.indexOf(str[index])) { balanced = true; } else { balanced = false; } } index++; } if (balanced &amp;&amp; stack.isEmpty()) { return true; } return false;}check('{([][])}');check('{[(])}'); 翻转链表12345678910function reverseList(head) { if (head === null || head.next === null) return head; let result = reverseList(head.next); head.next.nexd = head; head.next = null; return result;} 二分查找1234567891011121314151617function binarySearch(elements, value, _start, _end) { let end = _end || elements.length - 1; let start = _start || 0; let povitIndex = Math.floor((start + end) / 2); if (elements[povitIndex] === value) { return povitIndex; } if (value &lt; elements[povitIndex]) { return binarySearch(elements, value, 0, povitIndex - 1); } else { return binarySearch(elements, value, povitIndex + 1, end); } return false;} 快速排序123456789101112131415161718192021222324function quickSort(elements) { if (elements.length &lt;= 1) { return elements; } let pivotIndex = Math.floor(elements.length / 2); let [pivot] = elements.splice(pivotIndex, 1); let left = []; let right = []; for (let i = 0; i &lt; elements.length; i++) { if (elements[i] &lt; pivot) { left.push(elements[i]); } else { right.push(elements[i]); } } return quickSort(left).concat([pivot], quickSort(right));}let elements = [2, 4, 3, 7, 5];console.log(quickSort(elements)); 冒泡排序123456789101112131415161718192021function bubbleSort(elements) { let elementLength = elements.length; for (let i = 0; i &lt; elementLength - 1; i++) { for (let j = 0; j &lt; elementLength - i - 1; j++) { if (elements[j] &gt; elements[j + 1]) { let temp = elements[j]; elements[j] = elements[j + 1]; elements[j + 1] = temp; } } } console.log(elements);}let elements = [2, 4, 3, 7, 5];bubbleSort(elements);// console.log(elements) 二叉搜索树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//满二叉树：每层节点数都达到最大值，第n层节点数为2^(n - 1),总节点数为2^n -1(2的n次方减一)//完全二叉树：除最后一层外，其他各层节点数都达到最大个数，最后一层所有节点集中在最左边class Node { constructor(value) { this.value = value; this.left = null; this.right = null; }}class BinarySearchTree { constructor() { this.root = null; } // 插入前比较 insertNode(node, newNode) { // 右侧插入 if (newNode.value &gt; node.value) { if (node.right === null) { node.right = newNode; } else { this.insertNode(node.right, newNode); } } else if (newNode.value &lt; node.value) { // 左侧插入 if (node.left === null) { node.left = newNode; } else { this.insertNode(node.left, newNode); } } } // 插入 insert(value) { let newNode = new Node(value); if (this.root === null) { this.root = newNode; } else { this.insertNode(this.root, newNode); } } preOrderTraversalNode(node, callback) { if (node === null) return; callback(node.value); this.preOrderTraversalNode(node.left, callback); this.preOrderTraversalNode(node.right, callback); } // 先序遍历 preOrderTraversal(callback) { this.preOrderTraversalNode(this.root, callback); } inOrderTraversalNode(node, callback) { if (node === null) return; this.inOrderTraversalNode(node.left, callback); callback(node.value); this.inOrderTraversalNode(node.right, callback); } // 中序遍历 inOrderTraversal(callback) { this.inOrderTraversalNode(this.root, callback); } postOrderTraversalNode(node, callback) { if (node === null) return; this.postOrderTraversalNode(node.left, callback); this.postOrderTraversalNode(node.right, callback); callback(node.value); } // 中序遍历 postOrderTraversal(callback) { this.postOrderTraversalNode(this.root, callback); } //最大值 max() { let node = this.root; while (node.right !== null) { node = node.right; } return node.value; } // 最小值 min() { let node = this.root; while (node.left !== null) { node = node.left; } return node.value; } // 寻找指定值是否存在 search(val) { let node = this.root; while (node !== null) { if (val &lt; node.value) { node = node.left; } else if (val &gt; node.value) { node = node.right; } else { return true; } } }}var bst = new BinarySearchTree();bst.insert(3);bst.insert(2);bst.insert(5);// bst.preOrderTraversal((nodeValue) =&gt; {// console.log(nodeValue)// })// bst.inOrderTraversal((nodeValue) =&gt;{// console.log(nodeValue)// })// bst.postOrderTraversal((nodeValue) =&gt;{// console.log(nodeValue)// })// console.log(bst.max())console.log(bst.search(5));console.log(bst); 翻转链表12345678910111213141516171819202122232425262728293031323334// 递归var reverseList = function (head) { if (head === null || head.next === null) return head; let res = reverseList(head.next); head.next.next = head; head.next = null; return res;};// 循环var reverseList = function (head) { let pre = null; let cur = head; if (cur === null || cur.next === null) { return cur; } while (cur) { const t = cur.next; cur.next = pre; pre = cur; cur = t; // cur.next = null // cur.next.next = cur // cur = cur.nexxt } return pre;}; 算法 1: Two Sum1234567891011121314151617181920example:given nums = [2, 7, 11, 15], target = 9because num[0] + num[1] = 2 + 7 = 9,return [0, 1]答：function twoSum(nums, target) { const map = new Map(); for(let i = 0; i &lt; nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) { return [map.get(complement), i] } else { map.set(nums[i], i) } }} 装箱：基本类型到引用类型的一个转换拆箱：将引用类型到基本类型的转换（toPrimitive） 编码和解码：escape(str) unescape(str)encodeURI() decodeURI()encodeURIComponent() decodeURIComponent()btoa() atob() 回流：相当与刷新页面重绘： 不刷新，动态更新内容重绘不一定引起回流，回流一定引起重绘 打乱数组1. 常见的sort打乱数组的方法 function shuffle(arr) { return arr.sort (function () { return Math.random() - 0.5 }) } var arr = [1,2,3,4,5,6,7] shuffle(arr) 更加简洁的ES6写法 function shuffle(arr) { return arr.sort(() =&gt; Math.random() - 0.5) } 但是这种写法有问题，并不能真正地随机打乱数组，经过大量的实验发现 每个元素仍然有很大的几率出现在它原来的位置附近。 2.洗牌算法 从最后一个数据开始往前，每次随机一个位置，将两者的位置进行交换，直到数组交换完毕。 ES6实现： function shuffle(arr) { let i = arr.length; while(i) { let j = Math.floor(Math.random() * i--); [arr[j], arr[i]] = [arr[i], arr[j]]; } return arr } var arr = [1,2,3,4,5,6,7] shuffle(arr) 封装函数使字符串以驼峰式命名 已知字符串 foo = ‘get-element-by-id’,写一个函数将其转换为驼峰式命名“getElementById” 1234567891011121314151617181920212223//详细过程分析：var foo = 'get-element-by-id';//根据某个字符进行分割var arr = foo.split('-');//分割成四个片段保存在数组内console.log(arr) // (4) [&quot;get&quot;, &quot;element&quot;, &quot;by&quot;, &quot;id&quot;]//将下标为1的数组元素第一个字符元素转为大写console.log(arr[1].charAt(0).toUpperCase()) //E//截取后面字符元素console.log(arr[1].substr(1, arr[1].length - 1)) //lement//遍历for(var i = 1; i &lt; arr.length; i++) { arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1)}console.log(arr) //(4) [&quot;get&quot;, &quot;Element&quot;, &quot;By&quot;, &quot;Id&quot;]//根据某一个字符将数组转换为字符串console.log(arr.join('')); 1234567891011//封装function toString(foo) { var arr = foo.split('-'); for(var i = 1; i &lt; arr.length; i++) { arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1) } return arr.join('');}console.log(toString('get-element-by-id')) 把 the-first-name 变成 theFirstName 123456var reg = /-(\\w)/gvar str = &quot;the-first-name&quot;console.log(str.replace(reg, function($, $1){ return $1.toUpperCase()})) 把 aabb 换成 bbaa 123456var reg = /(\\w)\\1(\\w)\\2/g;var str = &quot;aabb&quot;;// console.log(str.replace(reg,&quot;$2$2$1$1&quot;));//&quot;bbaa&quot;console.log(str.replace(reg,function($,$1,$2){ return $2+$2+$1+$1;})) 正则简单的去重 123456789101112131415var str = &quot;aaaabbbbbccccc&quot;;var reg = /(\\w)\\1*/g;console.log.replace(reg,&quot;$1&quot;));//abc ~~~ 把&quot;1000000000&quot;变成&quot;100.000.000&quot;这种写法，把后面往前面查，三位加个点 ~~~ var str = &quot;100000000&quot;; var reg = /(?=(\\B)(\\d{3})+$)/g; console.log(str.replace(reg,&quot;.&quot;))//&quot;100.000.000&quot; || string.replace(/\\B(?=(\\d{3})+(?!\\d))/g, &quot;.&quot;) //先行断言?=,后行断言(?!\\d) || (25435345.22).toLocaleString(str('en-US')","link":"/2022/03/31/%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E6%80%BB%E7%BB%93/"},{"title":"100道前端优质面试题","text":"复杂度 程序执行时需要的计算量和内存空间 复杂度是数量级，不是具体的数字 一般是针对一个具体的算法，而非一个完整的系统 将一个数组旋转 K 步 输入一个数组[1, 2, 3, 4, 5, 6, 7] k=3,即旋转 3 步 输出[5, 6, 7, 1, 2, 3, 4] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @param arr 原数组 * @param k 步数 * 时间复杂度O(n^2),空间复杂度O(1) */function rotate1(arr: number[], k: number): number[] { const length = arr.length; if (!k || length === 0) return arr; const step = Math.abs(k % length); for (let i = 0; i &lt; step; i++) { const n = arr.pop(); if (n != null) { // unshift内置api时间复杂度位O(n),开销比较大 arr.unshift(n); } } return arr;}/** * @param arr 原数组 * @param k 步数 * 时间复杂度O(1)，空间复杂度O(n) */function rotate2(arr: number[], k: number): number[] { const length = arr.length; if (!k || length === 0) return arr; const step = Math.abs(k % length); const part1 = arr.slice(-step); const part2 = arr.slice(0, length - step); const part3 = part1.concat(part2); return arr;}/** * 性能测试 */const arr = [];for (let i = 0; i &lt; 10 * 10000; i++) { arr.push(i);}console.time('rotate1');rotate1(arr, 9 * 10000);console.time('rotate1');console.time('rotate2');rotate2(arr, 9 * 10000);console.time('rotate2'); 判断字符串是否括号匹配 一个字符串 s 可能包含{}()[]三种括号 判断 s 是否是括号匹配的 如（a{b}c）匹配，而{a(b 或者{a(b}c)就是不匹配的 栈 vs 数组栈：逻辑结构，理论模型，不管如何实现，不受任何语言的限制。数组：物理结构，真实的功能实现，受限于编程语言。 12345678910111213141516171819202122232425262728293031323334353637function isMatch(left: string, right: string): boolean { if (left === '{' &amp;&amp; right === '}') return true; if (left === '(' &amp;&amp; right === ')') return true; if (left === '[' &amp;&amp; right === ']') return true; return false;}function matchBracket(str: string): boolean { const length = str.length; if (length === 0) return true; const stack = []; const leftSymbols = '{[('; const rightSymbols = ')]}'; // 时间复杂度O(n),空间复杂度O(n) for (let i = 0; i &lt; length; i++) { const s = str[i]; if (leftSymbols.includes(s)) { // 左括号，压栈 stack.push(s); } else if (rightSymbols.includes(s)) { const top = stack[stack.length - 1]; // 判断右括号是否匹配 if (isMatch(top, s)) { stack.pop(); } else { return false; } } } return stack.length === 0;} 两个栈实现一个队列 请用两个栈实现一个队列 API：add delete length 123456789101112131415161718192021222324252627282930313233343536class Queue { private stack1: number[] = []; private stack2: number[] = []; add(n: number) { this.stack1.push(n); } delete(): number | null { let res; while (stack1.length) { const n = stack1.pop(); if (n != null) { stack2.push(n); } } res = stack2.pop(); while (stack2.length) { const n = stack2.pop(); if (n != null) { stack1.push(n); } } return res || null; } get length(): number { return this.stack1.length; }} 定义一个 js 函数，反转单向链表链表是一种物理结构(非逻辑结构),类似数组数组需要一段连续的内存空间，而链表是零散的链表节点的数据结构{ value, next?, prev? } 链表 vs 数组都是有序结构链表：查询慢 O(n),新增和删除快 O(1)数组：查询快 O(1),新增和删除慢 O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465interface ILinkListNode { value: number; next?: ILinkListNode;}/** * 创建链表 * @param arr 数组 */function createLinkList(arr: number[]): ILinkListNode { const length = arr.length; if (length === 0) throw new Error('arr is empty'); let curNode: ILinkListNode = { value: arr[length - 1], }; if (length === 1) return curNode; for (let i = length - 2; i &gt;= 0; i--) { curNode = { value: arr[i], next: curNode, }; } return curNode;}const arr = [100, 200, 300];const list = createLinkList(arr);console.info('list', list);/** * 反转单向链表，返回反转后的head node * @param listNode 需要操作的链表 */function reverseLinkList(listNode: ILinkListNode): ILinkListNode { let prevNode: ILinkListNode | undefined; let curNode: ILinkListNode | undefined; let nextNode: ILinkListNode | undefined = listNode; while (nextNode) { // 第一个元素，删除next指针，防止循环引用 if (curNode &amp;&amp; !prevNode) { delete curNode.next; } // 反转指针 if (curNode &amp;&amp; prevNode) { curNode.next = prevNode; } prevNode = curNode; curNode = nextNode; nextNode = nextNode?.next; } // 处理链表最后一个元素 curNode!.next = prevNode; return curNode!;}const reverseList = reverseLinkList(list);console.info('reverseList', reverseList); 用链表实现队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253interface ILinkListNode { value: number; next: ILinkListNode | null;}class Queue { private head: ILinkListNode | null = null; private tail: ILinkListNode | null = null; private len = 0; // 入队，在tail位置 add(n: number) { const newNode: ILinkListNode = { value: n, next: null, }; if (this.head === null) { this.head = newNode; } if (this.tail) { this.tail.next = newNode; } this.tail = newNode; this.len++; } // 出队，在head位置 delete(): number | null { if (this.head === null || this.len &lt;= 0) return null; const value = this.head.value; this.head = this.head.next; this.len--; return value; } get length(): number { return this.len; }}const queue = new Queue();queue.add(100);queue.add(200);queue.add(300);console.log('length', queue.length); //3console.log(queue.delete()); //100console.log('length2', queue.length); //2 链表和数组，哪个实现队列更快？ 空间复杂度都是 O(n) add 时间复杂度：链表 O(1)，数组 O(1); delete 时间复杂度：链表 O(1)，数组 O(n); 实现二分查找 凡有序，必二分 凡二分，时间复杂度必包含 O(logn) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 循环的方式 * @param arr 查找的数组 * @param target 目标对象 * 返回目标索引下标 */function binarySearch1(arr: number[], target: number): number { const length = arr.length; if (length === 0) return -1; let startIndex = 0; let endIndex = length - 1; while (startIndex &lt;= endIndex) { const midIndex = Math.floor((startIndex + endIndex) / 2); const midValue = arr[midIndex]; if (target &lt; midValue) { endIndex = midIndex - 1; } else if (target &gt; midValue) { startIndex = midIndex + 1; } else { return midIndex; } } return -1;}/** * 二分查找-递归的方式 *@param arr 查找的数组 *@param target 目标对象 *@param startIndex *@param endIndex */function binarySearch2( arr: number[], target: number, startIndex?: number, endIndex?: number): number { const length = arr.length; if (length === 0) return -1; if (!startIndex) startIndex = 0; if (!endIndex) endIndex = length - 1; if (startIndex &gt; endIndex) return -1; const midIndex = Math.floor((startIndex + endIndex) / 2); const midValue = arr[midIndex]; if (target &lt; midValue) { return binarySearch2(arr, target, startIndex, midIndex - 1); } else if (target &gt; midValue) { return binarySearch2(arr, target, midIndex + 1, endIndex); } else { return midIndex; }}// 功能测试const arr = [10, 20, 30, 40, 50, 60];const target = 20;console.log(binarySearch1(arr, target));console.log(binarySearch2(arr, target)); 给定一个递增的数组，找出其中和为 n 的两个元素 有一个递增的数组[1, 2, 4, 7, 11, 15]和一个 n = 15 数组中有两个数和为 n，即 4+11=15 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 嵌套循环 时间复杂度：O(n^2) * @param arr 操作数组 * @param n 和 */function findTwoNumbers1(arr: number[], n: number): number[] { const res: number[] = []; const length = arr.length; if (length === 0) return res; // 时间复杂度：O(n^2) for (let i = 0; i &lt; length - 1; i++) { const n1 = arr[i]; let flag = false; for (let j = i + 1; j &lt; length; j++) { const n2 = arr[j]; if (n1 + n2 === n) { res.push(n1, n2); flag = true; break; } } if (flag) break; } return res;}/** * 双指针，时间复杂度 O(n) * @param arr 操作数组 * @param n 和 *//* 思路： 定义i指向头，j指向尾，求arr[i] + arr[j] 如果大于n，则j需要向前移动 如果小于n，则j需要向后移动 */function findTwoNumbers2(arr: number[], n: number): number[] { const res: number[] = []; const length = arr.length; if (length === 0) return res; let i = 0; let j = length - 1; while (i &lt; j) { const n1 = arr[i]; const n2 = arr[j]; const sum = n1 + n2; if (sum &gt; n) { j--; } else if (sum &lt; n) { i++; } else { res.push(n1, n2); break; } } return res;} 求一个二叉搜索树（BST）的第 k 小值 前序(根左右)，中序(左根右)，后序(左右根) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394interface ItreeNode { value: number; left: ItreeNode | null; right: ItreeNode | null;}let bstTree: ItreeNode = { value: 5, left: { value: 3, left: { value: 2, left: null, right: null, }, right: { value: 4, left: null, right: null, }, }, right: { value: 7, left: { value: 6, left: null, right: null, }, right: { value: 8, left: null, right: null, }, },};/** * 二叉树前序遍历 * @param node tree node */function preOrderTraverse(node: ItreeNode | null) { if (node === null) return; console.log(node.value); preOrderTraverse(node.left); preOrderTraverse(node.right);}/** * 二叉树中序遍历 * @param node tree node */function inOrderTraverse(node: ItreeNode | null) { if (node === null) return; inOrderTraverse(node.left); console.log(node.value); inOrderTraverse(node.right);}/** * 二叉树后序遍历 * @param node tree node */function postOrderTraverse(node: ItreeNode | null) { if (node === null) return; postOrderTraverse(node.left); postOrderTraverse(node.right); console.log(node.value);}/** * 求二叉搜索树第k值 * @param node bst tree * @param k 第k个值 */function getKthValue(node: ItreeNode | null, k: number) { if (node === null) return; let arr: number[] = []; function inOrderTraverse(node: ItreeNode | null) { if (node === null) return arr; inOrderTraverse(node.left); arr.push(node.value); inOrderTraverse(node.right); } inOrderTraverse(node); return arr[k - 1];} 斐波那契数列123456789101112131415161718192021222324252627282930313233/** * 斐波那契数列（递归） * @param n * 时间复杂度O(2^n) */function fibonacci(n: number): number { if (n &lt;= 0) return 0; if (n === 1) return 1; return fibonacci(n - 1) + fibonacci(n - 2);}/** * 斐波那契数列（循环） * @param n * 时间复杂度O(n) */function fibonacci(n: number): number { if (n &lt;= 0) return 0; if (n === 1) return 1; let n1 = 1; // 记录n-1的结果 let n2 = 0; // 记录n-2的结果 let res = 0; for (let i = 2; i &lt;= n; i++) { res = n1 + n2; n2 = n1; n1 = res; } return res;} 青蛙跳台阶（动态规划思想解决问题） 一只青蛙，一次可以跳 1 级，也可以跳 2 级 问：青蛙跳到 n 级台阶，总共有多少种方式？ 1// 答案同上一题 将数组中的 0 移动到末尾 如输入[1, 0, 3, 0, 11, 0],输出[1, 3, 11, 0, 0, 0] 只移动 0 ，其他顺序不变 必须在原数组进行操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * (嵌套循环) * @param arr number arr * 时间复杂度 O(n^2) */function moveZero1(arr: number[]): void { const length = arr.length; if (length === 0) return; let zeroCount = 0; for (let i = 0; i &lt; length - zeroCount; i++) { if (arr[i] === 0) { arr.push(0); arr.splice(i, 1); // O(n) i--; zeroCount++; } }}/** * (双指针) * @param arr number arr * 时间复杂度 O(n) */function moveZero2(arr: number[]): void { const length = arr.length; if (length === 0) return; let i; let j = -1; // 指向第一个 0 for (i = 0; i &lt; length; i++) { if (arr[i] === 0) { if (j &lt; 0) { j = i; } } if (arr[i] !== 0 &amp;&amp; j &gt;= 0) { const n = arr[i]; arr[i] = arr[j]; arr[j] = n; j++; } }}const arr = [0, 1, 2, 0, 3, 0, 0, 4];// moveZero1(arr);moveZero2(arr);console.log(arr); 计算字符串中连续最多的字符以及次数 输入’abbbcccccccddeee1234412’ 计算得到连续最多的字符是’c’,7 次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @param str * 时间复杂度： O(n) */interface IRes { char: string; length: number;}function findContinuousChar1(str: string): IRes { const res: IRes = { char: '', length: 0, }; const length = str.length; if (length === 0) return res; let tempLength = 0; // 临时记录当前连续字符的长度 for (let i = 0; i &lt; length; i++) { tempLength = 0; // 重置 for (let j = i; j &lt; length; j++) { if (str[i] === str[j]) { tempLength++; } if (str[i] !== str[j] || j === length - 1) { if (tempLength &gt; res.length) { res.char = str[i]; res.length = tempLength; } if (i &lt; length - 1) { i = j - 1; // 跳步 } break; } } } return res;}/** * 双指针 * @param str * 时间复杂度： O(n) */interface IRes { char: string; length: number;}function findContinuousChar2(str: string): IRes { const res: IRes = { char: '', length: 0, }; const length = str.length; if (length === 0) return res; let tempLength = 0; // 临时记录当前连续字符的长度 let i = 0; let j = 0; for (; i &lt; length; i++) { if (str[i] === str[j]) { tempLength++; } if (str[i] !== str[j] || i === length - 1) { // 如果不相等或者 i 循环到了末尾 if (tempLength &gt; res.length) { res.char = str[j]; res.length = tempLength; } tempLength = 0; if (i &lt; length - 1) { j = i; // 让 j 追上 i i--; } } } return res;}const str = 'abbbcccccccddeee1234412';console.log(findContinuousChar1(str)); 快速排序12345678910111213141516171819202122232425262728/** * @param arr * 时间复杂度：O(nlogn) */function quickSort1(arr: number[]): number[] { const length = arr.length; if (length === 0) return arr; const midIndex = Math.floor(length / 2); const midValue = arr.splice(midIndex, 1)[0]; const left: number[] = []; const right: number[] = []; // 注意： splice会改变原数组，不能直接使用length for (let i = 0; i &lt; arr.length; i++) { const n = arr[i]; if (n &lt; midValue) { left.push(n); } else { right.push(n); } } return quickSort1(left).concat(midValue, quickSort1(right));}const arr = [2, 7, 5, 2, 3, 1];console.log(quickSort1(arr)); 对称数 求 1 - 10000 之间的所有对称数（回文） 例如：0， 1， 2， 11， 22， 101， 232，1221 12345678910111213141516171819202122232425262728293031323334353637function findPalindromeNumbers1(max: number): number[] { const res: number[] = []; if (max &lt; 0) return res; for (let i = 1; i &lt;= max; i++) { // 转换为字符转 -&gt; 转换为数组 -&gt; 再反转 -&gt; 比较 const s = i.toString(); if (s === s.split('').reverse().join('')) { res.push(i); } } return res;}console.log(findPalindromeNumbers1(200));function findPalindromeNumbers2(max: number): number[] { const res: number[] = []; if (max &lt;= 0) return res; for (let i = 1; i &lt;= max; i++) { let n = i; let rev = 0; // n: 123 // rev: 321 while (n &gt; 0) { rev = rev * 10 + (n % 10); n = Math.floor(n / 10); } if (i === rev) res.push(i); }}console.log(findPalindromeNumbers2(200)); 高效的字符串前缀匹配 有一个英文单词库（数组），里面有几十万个英文单词 输入一个字符串，快速判断是不是某一个单词的前缀 （说明思路，不用写代码） 思路一： 遍历单词库数组 indexOf 判断前缀 实际时间复杂度超过 O(n),因为 indexOf 的计算量 思路二（对象取 key 时间复杂度为 O(1)）： 英文字母一共就 26 个，可以提前把单词库数组拆分为 26 个 第一层 26 个，第二层、第三层，继续拆分… 最后把单词库拆分为一颗树 1234567891011121314// 树结构const wordsTree = { a: { a: {...} b: {...} }, b: { a: {...} }, c: { a: {...} } ...} 数字千分位格式化 将数字千分位格式化，输出字符串 如输入数字 12050100，输出字符串 12,050,100 (注意：逆序判断) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @param n * 使用数组 */function format1(n: number): string { n = Math.floor(n); // 只考虑整数 const reverseArr = n.toString().split('').reverse(); return reverseArr.reduce((prev, curr, index) =&gt; { if (index % 3 === 0) { if (prev) { return curr + ',' + prev; } else { return curr; } } else { return curr + prev; } }, '');}/** * @param n * 使用字符串 */function format2(n: number): string { n = Math.floor(n); let res = ''; const str = n.toString(); const length = str.length; for (let i = length - 1; i &gt;= 0; i--) { const j = length - i; if (j % 3 === 0) { if (i === 0) { res = str[i] + res; } else { res = ',' + str[i] + res; } } else { res = str[i] + res; } } return res;} 切换字母大小写 输入一个字符串，切换其中字母的大小写 如：输入字符串 12aBc34，输出字符串 12AbC34 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 正则表达式 * @param s */function switchLetterCase1(s: string): string { let res = ''; const length = s.length; if (length === 0) return res; const reg1 = /[a-z]/; const reg2 = /[A-Z]/; for (let i = 0; i &lt; length; i++) { const c = s[i]; if (reg1.test(c)) { res += c.toUpperCase(); } else if (reg2.test(c)) { res += c.toLowerCase(); } else { res += c; } } return res;}/** * ASCII 编码 * @param s */function switchLetterCase2(s: string): string { let res = ''; const length = s.length; if (length === 0) return res; const reg1 = /[a-z]/; const reg2 = /[A-Z]/; for (let i = 0; i &lt; length; i++) { const c = s[i]; const code = c.charCodeAt(0); if (code &gt;= 65 &amp;&amp; code &lt;= 90) { res += c.toLowerCase(); } else if (code &gt;= 97 &amp;&amp; code &lt;= 122) { res += c.toUpperCase(); } else { res += c; } } return res;} 为何 0.1+0.2 !==0.3? 计算机使用二进制存储数据 整数转二进制没有误差 小数可能无法用二进制准确表达 请说明 ajax、fetch、axios 三者的区别？ ajax(asynchronous javascript xml),一种技术统称 fetch，一个具体的 API axios，第三方库 https://axios-http.com/ 节流和防抖：两者有什么区别？分别用于什么场景？ 防抖 例如：一个搜索输入框，等输入停止后，再出发搜索 123456789101112// 防抖function debounce(fn, delay = 200) { let timer = 0; return function () { if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; { fn.apply(this, arguments); }, delay); };} 节流 drag 或 scroll 期间出发某个回调，要设置一个时间间隔 123456789101112function throttle(fn, delay) { let timer = 0; return function () { if (timer) return; timer = setTimeout(() =&gt; { fn.apply(this, arguments); timer = 0; }, delay); };} px % em rem vw/vh有什么区别？ px 基本单位，是绝对单位（其他的都是相对单位） % 是相对于父元素的宽度比例 em 相对于当前元素的 font-size rem 相对于跟元素的 font-size vw 屏幕宽度的 1% vh 屏幕高度的 1% vmin 取 vw、vh 两者中的最小值 vmax 取 vw、vh 两者中的最大值 箭头函数 箭头函数的特点 没有 arguments 无法通过 apply、call、bind 改变 this 某些肩头函数代码难以阅读 for…in 和 for…of 有什么区别 key 和 value for…in 遍历得到 key for…of 遍历得到 value 适用于不同的数据类型 遍历对象： for…in 可以，for…of 不可以 遍历 Map、Set：for…of 可以，for…in 不可以 遍历 generator：for…of 可以，for…in 不可以 可枚举 vs 可迭代 for…in 用于可枚举（Object.getOwnPropertyDescriptors(obj)）数据，如对象、数组、字符串 for…of 用于可迭代(arr[Symbol.iterator])数据，如数组、字符串、Map、Set for await…of 有什么作用？ for await…of 用于遍历多个 Promise 12345678910111213141516171819202122232425262728293031323334353637383940function createPromise(value) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(value); }, 1000); });}(async function () { const p1 = createPromise(100); const p2 = createPromise(200); const p3 = createPromise(300); const list = [p1, p2, p3]; const list2 = [100, 200, 300]; // ---------------同时调用---------------- // 方式一 // const res1 = await p1; // console.log(res1); // const res2 = await p2; // console.log(res2); // const res3 = await p3; // console.log(res3); // 方式二 // Promise.all(list).then((res) =&gt; console.log(res)); // 方式三 // for await (let res of list) { // console.log(res); // } // -----------------逐步调用--------------- for (let value of list2) { const res = await createPromise(value); console.log(res); }})(); offsetHeight、scrollHeight、clientHeight 区别？ offsetHeight、offsetWidth: border + padding + content clientHeight、clientWidth: padding + content scrollHeight、scrollWidth: padding + 实际内容尺寸 HTMLCollection 和 NodeList 区别？ Node 和 Element DOM 是一棵树，所有节点都是 Node Node 是 Element 的基类 Element 是其他 HTML 元素的基类，如 HTMLDivElement HTMLCollection 和 NodeList HTMLCollection 是 Element 的集合（elem.children） NodeList 是 Node 集合（elem.childNodes） HTMLCollection 不会包含 Text 和 Comment 节点，NodeList 则会包含 HTMLCollection 和 NodeList 都不是数组，而是“累数组” 1234// 转换const arr1 = Array.from(list);const arr2 = Array.prototype.slice.call(list);const arr3 = [...list]; Vue 中 computed 和 watch 的区别？ 用途不同 computed 用于计算产生新的数据，有缓存 watch 用于监听现有数据 扩展知识 computed 有缓存 methods 没有缓存 Vue 组件通讯的方式 props 和 $emit 自定义事件 $attrs $parent $refs provide/inject vuex vuex mutation 和 action 的区别？ mutation: 同步代码 action: 可包含异步代码 JS 严格模式有什么特点？12345'use strict'; //全局开启function fn() { 'use strict'; // 局部开启} 特点 全局变量必须先声明 禁止使用 with this 指向 undefined 而不是 window 函数参数不能重名 eval 有单独作用域，不推荐使用 HTTP 跨域请求事为什么发送 options 请求？ 跨域请求 浏览器同源策略 同源策略一般限制 ajax 网络请求，不能跨域请求 server 不会限制&lt;link&gt; &lt;img&gt; &lt;script&gt; &lt;iframe&gt; 加载第三方资源 1234567891011// JSONP// client&lt;script&gt; window.onSuccess = function(data) { console.log(data) }&lt;/script&gt;&lt;script src=&quot;https://www.aaa.com/api/getData&quot;&gt;&lt;/script&gt;// server// https://www.aaa.com/api/getData 返回一段字符串，交给前端执行达到传递数据的目的'onSuccess({data: {/* 数据内容 */}})' 12345678// CORS 配置允许跨域（服务端）response.setHeader('Access-Control-Allow-Origin', 'http://localhost:8080'); // 或者 *response.setHeader('Access-Control-Allow-Headers', 'X-Requested-With');response.setHeader( 'Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS');response.setHeader('Access-Control-Allow-Credentials', 'true'); // 允许跨域接受cookie 答案 options 请求，是跨域请求之前的预检查 浏览器自行发起的 不会影响实际的功能 JS 内存泄漏如何检测？场景有哪些？ 垃圾回收 GC 引用计数 标记清除 场景 意外的全局变量 遗忘的定时器 使用不当的闭包 遗漏的 DOM 元素 网络回调 内存泄漏属于非预期的，闭包是主动行为，闭包非内存泄漏 可以使用 chrome devtools 的 performance 和 memory 工具类检测 js 内存 参考 vdom 真的很快吗？ js 直接操作 dom 才是最快的，vdom 并不快 但是 vdom 是最合适“数据驱动视图”的技术方案 遍历数组，for 和 forEach 哪个快？ 时间复杂度都是 O(n) 结论： for 更快 forEach 每次都要创建一个函数来调用，而 for 不会创建函数 函数需要独立的作用域，会有额外的开销 nodejs 如何开启进程，进程如何通讯？ 进程 process VS 线程 thread 进程： 进行资源分配和调度的最小单元，有独立内存空间 线程： 进行运算调度的最小单元，共享进程内存空间 js 是单线程的，但可以多进行执行，如 、WebWorker 为何需要多进程？ 多核 CPU，更适合处理多进程 内存较大，多个进程才能更好的利用（单进程有内存上线） 开启进程两种方法 child_process.fork， cluster.fork 1234567891011121314151617181920212223242526// parent.jsconst http = require('http');const fork = require('child_process').fork;const server = http.createServer((req, res) =&gt; { if (req.url === '/xxx') { // 开启子进程 const computeProcess = fork('./compute.js'); computeProcess.send('start'); computeProcess.on('message', (data) =&gt; { res.end('sum is' + data); }); computeProcess.on('close', () =&gt; { console.log('子进程因报错而退出'); computeProcess.kill(); res.end('error'); }); }});server.listen(3000, () =&gt; { console.log('localhost: 3000 starting...');}); 12345678910111213141516171819// compute.jsfunction getSum() { let sum = 0; for (let i = 0; i &lt; 10000; i++) { sum += i; } return sum;}process.on('message', (data) =&gt; { console.log('子进程id', process.pid); console.log('子进程接收到的数据', data); const sum = getSum(); process.send(sum);}); 123456789101112131415161718192021const http = require('http');const cpuCoreLength = require('os').cpus().length;const cluster = require('cluster');if (cluster.isMaster) { for (let i = 0; i &lt; cpuCoreLength; i++) { cluster.fork(); // 开启子进程 } cluster.on('exit', (worker) =&gt; { console.log('子进程退出'); cluster.fork(); // 进程守护 });} else { const server = http.createServer((req, res) =&gt; { res.writeHead(200); res.end('done'); }); server.listen(3000);} 请描述 JS Bridge 的原理 什么是 JS Bridge？ js 无法直接调用 native API 需要通过一些特定的“格式”来调用 这些“格式”就统称 JS-Bridge，例如微信 JSSDK JS Bridge 的常见实现方式 注册全局 API URL Scheme requestIdleCallback 和 requestAnimationFrame 有什么区别？requestIdleCallback(callback, timeout): · 低优先级 · 兼容性不好 · 执行时机：浏览器空闲时被调用 · 指定timeout，回调任务就会被放进事件循环队列，强制执行，但是会影响性能 requestAnimationFrame(callback): · 高优先级 · 执行时机：下次重绘前执行传入的回调函数 - 补充 - 两者都是宏任务(其实也算不上，重要的是执行时机) vue 生命周期？ befroeCreate 创建一个空白的 Vue 实例 data、method 尚未被初始化，不可使用 created vue 实例初始化完成，完成相应式绑定 data、method 都已经初始化完成，可以调用 尚未开始渲染模板 beforeMount 编译模板，调用 render 生成 vdom 还没有开始渲染 DOM mounted 完成 DOM 渲染 组件创建完成 开始由“创建阶段”进入“运行阶段” beforeUpdate data 发生变化之后 准备更新 DOM （尚未更新 DOM） updated data 发生变化，且 DOM 更新完成 不要在 updated 中修改 data，可能会导致死循环 beforeUnmount 组件进入销毁阶段（尚未销毁，可以正常使用） 可移除、解绑一些全局事件、自定义事件 unmounted 组件被销毁了 所有子组件也被销毁了 连环问：vue 什么时候操作 dom 比较合适？ mounted 和 updated 都不能保证子组件全部挂载完成 使用 $nextTick 操作 dom 12345mounted() { this.$nextTick(function() { // 仅在整个视图都被渲染之后才会运行的代码 })} 连环问：Ajax 应该放在那个生命周期？ 两个选择：created 和 mounted 推荐：mounted vue3 composition API 生命周期有什么区别？ setup 代替了 beforeCreate 和 created 使用 hooks 函数的形式，如 mounted 改为 onMounted() Vue2、Vue3、React 三者 diff 算法有什么区别？ 严格的 Tree diff 算法的时间复杂度是 O(n*3) vue、react 框架对 tree diff 进行了优化 O(n) 只比较同一层级，不跨级比较 tag 不同则删除重建 子节点通过 key 区分 vdom diff 算法会根据 key 判断元素是否需要删除 匹配了 key，则只移动元素 - 性能较好 未匹配 key，则删除重建 - 性能较差 区别 react 仅右移 vue2 双端比较 vue3 最长递增子序列 Vue-router 三种模式（React-router 也一样） Hash WebHistory MemoryHistory（v4 之前叫做 abstract history） 移动端 H5 click 有 300ms 延迟，如何解决？ 背景：double tap to zoom 初期解决方案 FastClick 监听 touchend 事件(touchstart touchend 会先于 click 触发) 使用自定义 DOM 事件模拟一个 click 事件 把默认的 click 事件(300ms 之后触发)禁止掉 1234567window.addEventListener( 'load', function () { FastClick.attach(document.body); }, false); 现代浏览器的改进（width=device-width） 123456&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;id=edge&quot;&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt; 网络请求中，token 和 cookie 有什么区别？ cookie http 无状态，每次请求都要带 cookie，以帮助识别身份 服务端也可以向客户端 set-cookie，cookie 大小限制 4kb 默认有跨域限制：不可跨域共享、传递 cookie token vs cookie cookie 是 http 规范，而 token 是自定义传递 cookie 会默认被浏览器存储，而 token 需自己存储 token 默认没有跨域限制 JWT(JSON Web Token) 前端发起登录，后端验证成功之后，返回一个加密的 token 前端自行存储这个 token（其中包含了用户信息，加密了） 以后访问服务端的接口，都带着这个 token，作为用户信息 Session 和 JWT 哪个更好？ session 优点 原理简单，易于学习 用户信息存储在服务端，可以快速封禁某个用户 缺点 占用服务端内存，硬件成本高 多进程，多服务器时，不好同步-需要使用第三方缓存，如 redis 默认有跨域限制 JWT 优点 不占用服务器内存 多进程、多服务器不受影响 没有跨域限制 缺点 用户信息存储在客户端，无法快速封禁某用户 万一服务器密钥被泄漏，则用户信息全部丢失 token 体积一般大于 cookie，会增加请求的数据量 答案 如有严格管理用户信息的需求（保密、快速封禁），推荐 session 如没有特殊要求，则使用 JWT 如何实现 SSO 单点登录？ 基于 cookie（主域名相同） cookie 默认不可跨域共享，但有些情况下可设置共享 主域名相同，如www.baidu.com,image.baidu.com 设置 cookie domain 为主域名，即可共享 cookie SSO（主域名不相同，cookie 无法共享） HTTP 协议和 UDP 协议有什么区别？ 网络协议 HTTP 协议在应用层 TCP、UDP 协议在传输层 TCP 协议 有连接，有断开 稳定传输 UDP 协议 无连接，无断开 不稳定传输，但效率高 如视频会议、语音通话 HTTP 协议 1.0、1.1、2.0 有什么区别？ HTTP 1.0 最基础的 HTTP 协议 支持基本的 GET、POST 方法 HTTP 1.1 缓存策略 cache-control、E-tag 等 支持长连接 Connection: keep-alive,一次 TCP 连接多次请求 支持断点续传，状态码 206 支持新的方法 PUT、DELETE 等，可用于 Restful API HTTP 2.0 可压缩 header，减少体积 多路复用，一次 TCP 连接中可以多个 HTTP 并行请求 服务端推送 什么是 HTTPS 中间人攻击？如何预防？ HTTPS 加密传输 HTTP 明文传输 HTTPS 加密传输 HTTP + TLS/SSL 答案 使用正规厂商的加密证书可以防止中间人攻击 defer 和 async 有什么区别？ 区别 prefetch 和 dns-prefetch 有什么区别？ preload 资源在当前页面使用，会优先加载 prefetch 资源在未来页面使用，空闲时加载 1234&lt;head&gt; &lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot; /&gt; &lt;link rel=&quot;prefetch&quot; href=&quot;other.js&quot; as=&quot;script&quot; /&gt;&lt;/head&gt; dns-prefetch 即 DNS 预查询 preconnect 即 DNS 预连接 1234&lt;head&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://www.xxx.com/&quot; /&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://www.xxx.com&quot; /&gt;&lt;/head&gt; Map 和 WeakMap 的区别和应用场景？ Map： key 可以是任意数据类型 key 是强引用，只要键不释放，就会一直占着内存不会被 GC 能轻易转化为数据（扩展运算符），weakmap 做不到 WeakMap: key 只能是非 null 的对象引用 key 是弱引用，没有其他引用存在时会被 GC key 随时会被回收，所以 key 不可枚举，没有 size 等属性 Map 场景： 频繁的读写和查询 键值复杂的情况 你知道哪些前端攻击？该如何预防？ xss Cross Site Script 跨站脚本攻击 手段：将 js 代码插入到网页内容中，渲染时执行 js 代码 预防：特殊字符替换（前端或后端） csrf Cross Site Request Forgery 跨站请求伪造 手段：诱导用户去访问另一个网站的接口，伪造请求 预防：严格的跨域限制 + 验证码机制 csrf 详细过程 用户登录 A 网站，有了 A 网站的 cookie 诱导用户到 B 网站，并发起 A 网站的请求 A 网站的 API 发现有 cookie，认为是用户自己操作的 csrf 预防手段 严格的跨域请求限制，如判断 referer（请求来源） 为 cookie 设置 SameSite，禁止跨域传递 cookie 关键接口使用短信验证码 点击劫持 click jacing 手段：诱导界面上蒙一个透明 iframe，诱导用户点击 预防：让 iframe 不能跨域加载 DDos Distribute denial-of-service 分布式拒绝服务 手段：分布式的、大规模的流量访问，使服务器瘫痪 预防：软件层不好做，需硬件预防（如阿里云 WAF） SQL 注入 手段：提交内容时写入 SQL 语句，破环数据库 预防：处理输入的内容，替换特殊字符 WebSocket 和 HTTP 有什么区别？ WebSocket 支持端对端通讯 可以由 client 发起，也可以由 server 发起 用于：消息通知，直播间讨论区，聊天室，协同编辑 client 1234567891011121314const { WebSocketServer } = require('ws');const wsServer = new WebSocketServer({ port: 3000 });wsServer.on('connection', (ws) =&gt; { console.log('connection'); ws.on('message', (msg) =&gt; { console.log('收到了信息', msg.toString()); setTimeout(() =&gt; { ws.send('服务端已经收到了信息' + msg.toString()); }, 2000); });}); server 1234567891011121314const ws = new WebSocket('ws://127.0.0.1:3000');ws.onopen = () =&gt; { console.log('opened'); ws.send('client opened');};ws.onmessage = (event) =&gt; { console.log('收到了信息', event.data);};const btn = document.getElementById('btn');btn.addEventListener('click', () =&gt; { console.log('clicked'); ws.send('当前时间' + Date.now());}); WebSocket 连接过程 先发起一个 http 请求 成功之后再升级到 WebSocket 协议，再通讯 WebSocket 和 HTTP 区别？ WebSocket 协议名是 ws://,可双端发起请求 WebSocket 没有跨域限制 通过 send 和 onmessage 通讯（HTTP 通过 req 和 res） ws 可升级为 wss（like https） 12345678910import { createServer } from 'https';import { readFileSync } from 'fs';import { WebSocketServer } from 'ws';const server = createServer({ cert: readFileSync('/path/to/cert.pem'), key: readFileSync('/path/to/key.pem'),});const wss = new WebSocketServer({ server }); 实际项目推荐 socket.io,API 更简洁 WebSocket 和 HTTP 长轮询的区别？ 区别 HTTP 长轮询：客户端发起请求，服务端阻塞，不会立即返回 WebSocket：客户端可发起请求，服务端也可发起请求 注意 HTTP 长轮询，需处理 timeout，即 timeout 之后重新发请求 描述从输入 url 到页面展示的完整过程 网络请求 DNS 查询（得到 IP），建立 TCP 连接（三次握手） 浏览器发起 HTTP 请求 收到请求响应，得到 HTML 源代码 解析（字符串 -&gt; 结构化数据） HTML 构建 DOM 树 CSS 构建 CSSOM 树（style tree） 两者结合，形成 render tree 渲染（render tree 绘制到页面） 计算各个 DOM 的尺寸、定位，最后绘制到页面 遇到 js 可能会执行（参考 defer、async） 异步 CSS、图片加载，可能会触发重新渲染 重绘 repaint 重排 reflow 有什么区别？ 重绘 repaint 元素外观改变，如颜色、背景色 但元素的尺寸、定位不变，不会影响到其他元素的位置 重排 relfow 重新计算尺寸和布局，可能会影响其他元素的位置 如元素高度增加，可能会使相邻元素位置下移 区别 重排比重绘影响更大，消耗更大 所以，要尽量避免无意义的重排 减少重排的方法 集中修改样式，或直接切换 css、class 修改之前先设置 display: none,脱离文档流 使用 BFC 特性，不影响其他元素位置 频发触发（resize、scroll）使用节流和防抖 使用 createDocumentFragment 批量操作 DOM 优化动画，使用 CSS3 和 requestAnimationFrame 如何实现网页多标签通讯？ 使用 WebSocket 无跨域限制 需要服务端支持，成本高 localStorage（跨域不共享） 同域的 A 和 B 两个页面 A 页面设置 localStorage B 页面可监听到 localStorage 值的修改 SharedWorker(必须同域) SharedWorker 是 WebWorker 的一种 WebWorker 可开启子进程执行 JS，但不能操作 DOM SharedWorker 可单独开启一个进程，用于同域页面通讯 网页和 iframe 如何通讯？ 使用 postMessage 通讯 注意跨域的限制和判断 123456789// 父传子window.iframe1.contentWindow.postMessage('hello', '*');// 子传父window.parent.postMessage('world', '*');// 接收window.addEventListener('message', (event) =&gt; { console.log(event.origin); console.log(event.data);}); 请描述 koa2 洋葱圈模型？ koa2 一个简约、流行的 nodejs 框架 通过中间件组织代码 多个中间件以“洋葱圈模型”执行 代码执行过程 洋葱圈模型(类似捕获冒泡) H5 页面如何进行首屏优化？ 路由懒加载 适用于 SPA 路由拆分，优先保证首页加载 服务端渲染 SSR 传统前后端分离（SPA）渲染页面的过程复杂 SSR 渲染页面过程简单，所有性能好 如果是纯 H5 页面，SSR 是性能优化的终极方案 App 预取 如果 H5 在 App WebView 中展示，可使用 App 预取 用户访问列表页面时，App 预加载文章首屏内容 用户进入 H5 页面，直接从 App 中获取内容，瞬间展示首屏 分页 针对列表页 默认只展示第一页内容 上滑加载更多 图片懒加载 lazyload 针对详情页 默认只展示文本内容，然后出发图片懒加载 注意：提前设置图片尺寸，尽量只重绘不重排 Hybrid 提前将 HTML、JS、CSS 下载到 App 内部 在 App webview 中使用 file：// 协议加载页面文件 再用 Ajax 获取内容并展示（也结合 App 预取） 后端一次性返回 10w 条数据，你该如何渲染？ 设计不合理，去砍了后端 自定义中间层 自定义 nodejs 中间层，获取并拆分这 10w 条数据 前端对接 nodejs 中间层，而不是服务端 成本比较高 虚拟列表 只渲染可视区域 React 都有哪些注意点（坑）？ 自定义组件首字母大写 js 关键字的冲突（htmlFor、className） JSX 的数据类型 12&lt;Demo value={1} /&gt; // number&lt;Demo value=&quot;1&quot; /&gt; // string setState 是异步更新的 123456789this.setState( { num: this.state.num + 1, }, () =&gt; { console.log(this.state.num); // 正确 });console.log(this.state.num); // 错误 如何统一监听 Vue 组件报错？ window.onerror 全局监听所有 js 错误 try…catch 中的错误无法被监听到 1234567window.onerror = function (msg, source, line, column, error) { console.log(msg, source, line, column, error);};// orwindow.addEventListener('error', (event) =&gt; { console.log(event);}); errorCaptured 生命周期 监听所有下级组件的错误 返回 false 会阻止向上传播 errorHandler 配置 Vue 全局错误监听，所有组件错误都会汇总到这里 但 errorCaptured 返回 false，不会传播到这里 123app.config.errorHandler = (err, vm, info) =&gt; { console.log(error, vm, info);}; 异步错误 异步回调里面的错误，errorHandler 监听不到 需要使用 window.onerror 如何统一监听 React 报错？ ErrorBoundary 组件 监听所有下级组件报错，可降级展示 UI 只监听组件渲染时报错，不监听 DOM 事件、异步错误 不监听 DOM 事件报错，可用 try…catch,window.onerror 只在 production 环境生效，dev 会直接抛出错误 12345678910111213141516171819202122232425262728class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { error: null, }; } static getDerivedStateFromError(error) { // 更新state，显示降级UI console.log(error); return { error }; } componentDidCatch(error, errorInfo) { // 统计上报错误信息 console.log(error, errorInfo); } render() { if (this.state.error) { return &lt;h1&gt;报错了&lt;/h1&gt;; } return this.props.children; }} 如果一个 H5 很慢，你该如何排查性能问题？ 前端性能指标 First Paint（FP） First ContentFul Paint（FCP） DomContentLoaded（DCL） Largest Contentful Paint（LCP） Load（L） Chrome devtools Performance 可查看上述性能指标，并有网页快照 Network 可以查看各个资源的加载时间 lighthouse（第三方性能评测工具） 12// terminallighthouse https://www.imooc.com/ --view --preset=desktop 通过以上工具来判读是加载慢还是渲染慢 加载慢 优化服务端硬件配置，使用 CDN 路由懒加载，大组件异步加载-减少主包的体积 优化 http 缓存策略 渲染慢 优化服务端接口（如 ajax 获取数据慢） 优化全段组件内部逻辑 服务端渲染 SSR 如何理解 HTML 语义化？ 让人更容易读懂（增加代码可读性） 让搜索引擎更容易读懂（SEO） 块状元素 &amp; 内联元素？ 块级元素 display: block/table; div、h1、h2、table、ul、ol、p 等 内联元素 display: inline/inline-block; span、img、input、button 等； 如下代码，请问 div 的 offsetWidth 是多大？12345678910&lt;style&gt; #div { width: 100px; padding: 10px; margin: 10px; border: 1px solid #ccc; }&lt;/style&gt;&lt;div id=&quot;div&quot;&gt;&lt;/div&gt; offsetWidth = (内容宽度 + 内边距 + 边框)，无外边距 答案： 100 + 10 + 1 * 2 = 122px 可以通过：box-sizing: border-box; 使得 offsetWidth=100 margin 纵向重叠问题 如下代码，A 和 B 之间的距离是多少？ 1234567891011121314&lt;style&gt; p { font-size: 16px; line-height: 1; margin-top: 10px; margin-bottom: 15px; }&lt;/style&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;B&lt;/p&gt; 相邻元素的 margin-top 和 margin-bottom 会发生重叠 空白内容 p 标签也会重叠 答案：15px margin 负值问题 margin-top 和 margin-left 负值，元素向上、向左移动 margin-right 负值，右侧元素左移，自身不受影响 margin-bottom 负值，下方元素上移，自身不受影响 BFC 理解与应用 block format context，块级格式化上下文 一块独立渲染区域，内部元素的渲染不会影响边界以外的元素 形成 BFC 的常见条件 float 不是 none position 是 absolute 或 fixed overflow 不是 visible(hidden、auto、scroll) display 是 flex、inline-block 等 常见应用： 清除浮动 阻止 margin 重叠 float 布局 实现圣杯布局和双飞翼布局 目的 三栏布局，中间一栏最先加载和渲染 两侧内容固定，中间内容随着宽度自适应 一般用于 PC 网页 实现 使用 float 布局 两侧使用 margin 负值，以便和中间内容横向重叠 防止中间内容被两侧覆盖，一个用 padding，一个用 margin css 定位 absolute 和 relative 定位 relative 依据自身定位 absolute 依据最近一层的定位元素定位 定位元素：absolute、relative、fied、body 居中对齐 水平居中 inline 元素：text-align: center block 元素：margin: auto absolute 元素：left:50% + margin-left 负值 垂直居中 inline 元素：line-height 的值等于 height 的值 absolute 元素：top: 50% + margin-top 负值 absolute 元素：transform(-50%, -50%) absolute 元素：top,left,bottom,right=0 + margin: auto css-图文样式 line-height 如何继承 如下代码，p 标签的行高是多少？ 1234567891011121314&lt;style&gt; body { font-size: 20px; line-height: 200%; /* 40px */ line-height: 1.5; /* 16 * 1.5 = 24 */ line-height: 30px; /* 30px */ } p { font-size: 16px; }&lt;/style&gt;&lt;body&gt; &lt;p&gt;AAA&lt;/p&gt;&lt;/body&gt; 答案： 40px 具体数值，如 30px，则继承该值 写比例，如 2/1.5，则继承当前元素 font-size 的比例 写百分比，如 200%，则继承计算出来的值 css-响应式 常见长度单位 px，绝对长度单位 em，相对长度单位，相对于父元素 rem，相对长度单位，相对于根元素，常用与响应式布局 响应式布局常用方案 media-query，根据不同屏幕宽度设置根元素 font-size rem，基于根元素的相对单位 rem 的弊端：“阶梯”性 1234567891011121314151617181920212223242526272829&lt;style&gt; @media only screen and (max-width: 374px) { html { font-size: 86px; } } @media only scrren and (min-width: 375px) and (max-width: 413px) { html { font-size: 100px; } } @media only scrren and (min-width: 414px) { html { font-size: 110px; } } body { font-size: 0.16rem; } #div { width: 1rem; /* 100px */ }&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt;div&lt;/div&gt;&lt;/body&gt; 网页视口尺寸 window.screen.height // 屏幕高度 window.innerHeight // 网页视口高度 vh 网页视口高度的 1/100 vw 网页视口宽度的 1/100 vmax 取两者最大值；vmin 取两者最小值 document.body.clientHeight // body 高度 typeof 运算符 识别所有值类型 undefined string number boolean Symbol 识别函数、 function 判断是否是引用类型 object 手写 call123456789101112Function.prototype.call = function (context, ...args) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;}; 手写 apply123456789101112Function.prototype.apply = function (context, args = []) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;}; 手写 bind1234567891011Function.prototype.bind = function (context, ...args) { const fn = this; return function newFn(...newFnArgs) { if (this instanceof newFn) { return new fn(...args, ...newFnArgs); } return fn.apply(context, [...args, ...newFnArgs]); };}; 手写 instanceof12345678910/** 1.通过left.__proto__.__proto__这种方式从下往上获取原型对象* 2.通过Object.create(null)的实例是没有原型链* 3.有原型链的实例的尽头都是Object*/function instanceof(left, right) { if (!left.__proto__) return false; if (right === Object || left.__proto__ === right.protorype) return true; return instanceof(left.__proto__, right);} 异步和单线程 js 是单线程语言，同时只能做一件事 浏览器和 nodejs 已支持启动进程，如 web worker js 和 dom 渲染共用同一个线程，因为 js 可以修改 dom 结构，所以遇到等待（网络请求，定时任务）就会卡住 网络请求，如 ajax 图片加载 定时任务，如 setTimeout 所以需要异步（callback） 异步和同步的区别？ 基于 js 是单线程语言 异步不会阻塞代码执行 同步会阻塞代码执行 for…of for…in（以及 forEach、for）都是常规的同步遍历 1234567891011121314151617181920212223function muti(num) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(num * num); }, 1000); });}const nums = [1, 2, 3];// 现象：1s后，同时打印 1，4，9nums.forEach(async (item) =&gt; { const res = await muti(item); console.log(res);});// 现象：异步等待打印!(async function () { for (let i of nums) { const res = await muti(i); console.log(res); }})(); for…of 常用于异步的遍历 从 event loop 解释，为什么微任务执行更早？ 宏任务： setTimeout、setInterval、ajax、DOM 事件 微任务： promise、async/await 微任务的执行时机要比宏任务要早 每次 call stack 清空，即每次轮询结束，即同步任务执行完成 如果 DOM 结构有改变，则会重新进行 DOM 渲染 宏任务：DOM 渲染后触发，如 setTimeout 微任务：DOM 渲染前触发，如 promise 所以：微任务先于宏任务先执行 补充： 微任务都是 ES6 语法规定的 宏任务都是由浏览器规定的 BOM API navigator screen location history ajax xhr.readyState 0 (未初始化)还没有调用 send()方法 1 (载入)已调用 send()方法，正在发送请求 2 (载入完成) send()方法执行完成，已经接收到全部响应内容 3 (交互) 正在解析响应内容 4 (完成) 响应内容解析完成，可以在客户端调用 xhr.status 2xx 表示成功处理请求，如 200 3xx 需要重定向，浏览器直接跳转，如 301、302、304 4xx 客户端请求错误，如 404、403 5xx 服务端错误 常见状态码？信息响应 101 协议切换 成功响应 200 成功 204 请求成功，不返回任何内容 206 分块请求成功 重定向 301 永久重定向（配合 location，浏览器自动处理） 302 临时重定向（配合 location，浏览器自动处理） 304 资源未被修改（协商缓存 ） 客户端响应 400 无法被服务器理解 401 未授权 403 禁止访问 404 资源未找到 405 没有权限,请求方法(get/post 等)错误 服务端响应 500 服务器错误 503 服务不可达 504 网关超时 本身状态码就是一种约定，一种协议和规范，不要尝试违反规范，例如 IE 浏览器 http 常见 methods？ 传统 methods get 获取服务器的数据 post 向服务器提交数据 新的 methods get 获取数据 post 新建数据 patch/put 更新数据 delete 删除数据 Restful API 一种新的 API 设计方法 传统 API 设计：把每个 url 当作一个功能 Restful API 设计：把每个 url 当作一个唯一的资源 原则 不使用 url 参数 传统 API 设计：/api/list?pageIndex=2 Restful API 设计：/api/list/2 用 method 表示操作类型 传统 API 设计 post 请求 /api/create-blog post 请求 /api/update-blog?id=100 get 请求 /api/get-blog?id=100 Restful API 请求 post 请求 /api/blog patch 请求 /api/blog/100 get 请求 /api/blog/100 常见 http headers？ Request Headers Accept 浏览器可接收的数据格式 Accept-Encoding 浏览器可接收的压缩算法，如 gzip Accept-Languange 浏览器可接收的语言，如 zh-CN Connection: keep-alive 一次 TCP 连接重复使用 cookie Host 如：www.baidu.com Cache-Control User-Agent （简称 UA）浏览器信息 Content-type 发送数据的格式，如 application/json Response Headers Content-type 返回数据的格式，如 application/json Content-length 返回数据的大小，多少字节 Content-Encoding 返回数据的压缩算法，如 gzip Set-Cookie Expires Etag date 自定义 header 缓存相关的 headers Cache-Control Expires Last-Modified If-Modified-Since Etag If-None-Match 访问浏览器网页过程？ 加载过程 DNS 解析：域名-&gt;IP 地址 浏览器根据 IP 地址向服务器发起 http 请求 服务器处理 http 请求，并返回给浏览器 渲染过程 根据 HTML 代码生成 DOM Tree 根据 CSS 代码生成 CSSOM 树 将 DOM Tree 和 CSSOM 整合成 Render Tree 根据 Render Tree 渲染页面 遇到 script 标签则停止渲染，优先加载并执行 js 代码，完成再继续 直至把 Render Tree 渲染完成 为何要将 css 文件放在 head 标签中呢？ css 放在 body 标签尾部时，DOMTree 构建完成之后便开始构建 RenderTree，并计算布局渲染网页，等加载解析完 css 之后，开始构建 CSSOMTree，并和 DOMTree 重新构建 RenderTree，重新计算布局渲染网页 css 放在 head 中，先加载 css，之后解析 css 构建 CSSOMTree，同时构建 DOMTree，CSSOMTree 和 DOMTree 都构建完成之后开始构建 Render Tree，计算布局网页 两者对比，css 放在 head 中比放在 body 标签尾部少了一次构建 RenderTree，一次计算布局和一次渲染网页，因此性能会更好，并且 css 放在 body 标签尾部会在网页中短暂出现裸奔的 html，不利于用户体验 为什么建议把 script 标签放在 body 最后？ js 的下载和执行会阻塞 DOMTree 的构建，即会中断 DOMTree 的更新，所以如果把 script 标签放在首屏范围内的 HTML 代码中会截断首屏的内容。 普通 script 标签放在 body 底部，做与不做 async 或者 defer 处理都不会影响首屏时间，但是会影响 DomContentLoad 和 load 的时间，进而影响依赖他们的代码的执行的开始时间 123456window.addEventListener('load', function () { // 页面的全部资源加载完成后才会执行，包括图片、视频等});document.addEventListener('DOMContentLoaded', function () { // DOM 渲染完成后即可执行，此时图片、视频可能还没有加载完}); 性能优化（空间换时间） 性能优化原则 多使用内存、缓存 减少 CUP 计算，减少网络加载耗时 适用于所有编程的性能优化-空间换时间 减少资源体积：压缩代码 减少访问次数：合并代码，SSR 服务器渲染，缓存，精灵图 缓存（webpack contenthash） 静态资源加 hash 后缀，根据文件内容计算 hash 文件内容不变，则 hash 不变则 url 不变 url 和文件不变，则会自动触发 http 的缓存机制，返回 304 SSR 服务器端渲染：将网页和数据一起加载，一起渲染 非 SSR（前后端分离）：先加载网页，后加载数据，再渲染数据 DNS 预解析 减少 cookie 大小，http 请求会携带 cookie 使用 http2 头部压缩 避免重定向：当页面发生了重定向，就会延迟整个 HTML 文档的传输。在 HTML 文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。 渲染优化 css 放在 head，js 放在 body 最下面 尽早开始执行 js，用 DOMContentLoaded 触发 懒加载（图片懒加载-IntersectionObserver，下滑更多等） 对 DOM 查询进行缓存 减少 DOM 数量，大数据量分页、虚拟列表 合并频繁的 DOM 操作,document.createDocumentFragment()，减少 dom 操作次数 节流 throttle、防抖 debounce 使用 loading 图，提高用户视觉体验 使用 GPU 加速：使用 transform、opacity，要慎用低端机 GPU 差，占用较多内存，因此是否开启硬件加速，要用测试结果决定 使用 requestAnimationFrame 来实现视觉变化 三方资源 第三方资源、库使用 CDN 压缩图片体积，减少图片大小 图片使用 webp 格式，减少图片体积 preload 预先加载 css 文件或者字体文件、js 文件等 浏览器需要先把 html 页面加载回来，才能知道下一步去加载那些 js、css 或字体文件，中间时间就被浪费掉了 可以在等待 html 响应的同时把重要的静态资源文件也加载回来 安全 XSS 跨站请求攻击 攻击方式 一个博客网站，我发表一篇博客，其中嵌入 script 脚本 脚本内容：获取 cookie，发送到我的服务器 发布这篇博客，有人查看，就可以回去到访问者的 cookie 预防方式 替换特殊字符 XSRF 跨站请求伪造 预防 增加验证，例如密码、短信验证、指纹等 ES6 新增的声明方式 let、const 不属于顶层对象 window 不允许重复声明 不存在变量提升 暂时性死区（不能在变量声明之前去使用） 块级作用域 定制化输出特定数组 随机生成一个长度为 10 的整数类型的数据 例如 [2, 10, 3, 35, 5, 11, 10, 11, 20] 将其排列成一个新数组，要求新数组形式如下： [[2, 3, 5], [10, 11],[20],[35]] 12345678910111213141516171819202122232425262728// 1. 获取随机数 0-99function getRandomNumber(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min);}let arr = Array.from({ length: 10 }, () =&gt; getRandomNumber(0, 99));// 2. 去重(没必要)arr = [...new Set(arr)];// 3. 排序arr.sort((a, b) =&gt; a - b);// 4. 存储 0-9 10-19 20-29const map = {};arr.forEach((item) =&gt; { const key = Math.floor(item / 10); if (!map[key]) { map[key] = []; } map[key].push(item);});const result = [];for (const key in map) { result.push(map[key]);}console.log(result); 将树状结构转换为属性平铺的结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 题目const entry = { a: { b: { c: { dd: 'abcdd', }, }, d: { ee: 'adee', }, f: 'af', },};const output = { 'a.b.c.dd': 'abcdd', 'a.d.ee': 'adee', 'a.f': 'af',};// 解答// 方法1: 递归function flatObj(obj, preKey = '', result = {}) { for (const key in obj) { if (obj.hasOwnProperty(key)) { const newKey = `${preKey}${key}`; if (typeof obj[key] === 'object') { flatObj(obj[key], `${newKey}.`, result); } else { result[newKey] = obj[key]; } } } return result;}// 方法2: while循环-队列function flatObj2(obj) { const queue = Object.entries(obj); const result = {}; while (queue.length) { const [key, value] = queue.pop(); for (const [k, v] of Object.entries(value)) { if (typeof v === 'object') { queue.push([`${key}.${k}`, v]); } else { result[`${key}.${k}`] = v; } } } return result;}// 测试用例flatObj(entry);flatObj2(entry); 将平铺属性的数据结构转换为树状数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 题目const entry = { 'a.b.c.dd': 'abcdd', 'a.d.ee': 'adee', 'a.f': 'af',};const output = { a: { b: { c: { dd: 'abcdd', }, }, d: { ee: 'adee', }, f: 'af', },};// 答案// 方法1: 双重循环function map(entry) { const result = {}; for (const key in entry) { const value = entry[key]; const keyMap = key.split('.'); if (!result[keyMap[0]]) { result[keyMap[0]] = {}; } let tmp = result[keyMap[0]]; let length = keyMap.length; for (let i = 1; i &lt; length; i++) { if (!tmp[keyMap[i]]) { if (i === length - 1) { tmp[keyMap[i]] = value; } else { tmp[keyMap[i]] = {}; } } tmp = tmp[keyMap[i]]; } } return result;}// 方法2: 递归// {&quot;a.b.c.dd&quot;: &quot;abcdd&quot;}// =&gt; {&quot;a.b.c&quot;: {&quot;dd&quot;:&quot;abcdd&quot;}}// =&gt;...// =&gt; {&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;dd&quot;: &quot;abcdd&quot;}}}}function map2(entry) { function getNest(key) { const lastIndex = key.lastIndexOf('.'); const value = entry[key]; if (lastIndex !== -1) { delete entry[key]; const preKey = key.substring(0, lastIndex); const restKey = key.substring(lastIndex + 1); if (!entry[preKey]) { entry[preKey] = { [restKey]: value }; } else { entry[preKey][restKey] = value; } if (/./.test(preKey)) { getNest(preKey); } } } for (const key in entry) { getNest(key); } return entry;}map(entry);map2(entry); react 自定义封装不会反复创建的定时器（setInterval）123456789101112131415161718192021222324import { useRef, useState } from 'react';const useTimer = (step = 1) =&gt; { const timer = useRef(null); const [num, setNum] = useState(0); const start = () =&gt; { const timeout = setInterval(() =&gt; { setNum((num) =&gt; num + 1); }, step * 1000); timer.current = timeout; }; const clear = () =&gt; { setNum(0); clearInterval(timer.current); }; return { num, start, clear, };}; 修改下面代码，顺序输出 0-9912345678910111213141516171819202122232425262728293031323334353637383940// 要求：// 1. 只能修改 setTimeout// 2. 不能修改Math.floor(Math.random() * 1000)// 3. 不能使用全局变量function print(n) { setTimeout(() =&gt; { console.log(n); }, Math.floor(Math.random() * 1000));}for (var i = 0; i &lt; 100; i++) { print(i);}// 答案// 方法1: 立即执行函数function print(n) { setTimeout( (() =&gt; { console.log(n); return () =&gt; {}; })(), Math.floor(Math.random() * 1000) );}for (var i = 0; i &lt; 100; i++) { print(i);}// 方法1: setTimeout第三个参数function print(n) { setTimeout( () =&gt; { console.log(n); }, 10, Math.floor(Math.random() * 1000) );}for (var i = 0; i &lt; 100; i++) { print(i);} for 循环和 splice 的坑12345678910111213141516171819202122232425262728// for循环和splice的坑// 具体描述：在对一个数组执行for循环时，// 删除数组元素，会存在什么问题// 方法1: i--const arr = ['a', 'a', 'a', 'd', 'e', 'f'];for (let i = 0; i &lt; arr.length; i++) { if (arr[i] === 'a') { arr.splice(i, 1); i--; // 需要处理下 i-- }}// 方法2: 倒序const arr = ['a', 'a', 'a', 'd', 'e', 'f'];for (let i = arr.length - 1; i &gt;= 0; i--) { if (arr[i] === 'a') { arr.splice(i, 1); }}// for...inconst arr = ['a', 'a', 'a', 'd', 'e', 'f'];for (let index in arr) { if (arr[index] === 'a') { arr.splice(index, 1); index--; // 仍然会有问题 }}console.log(arr); js 前端面试题，js 实现最多发送三个并发请求，后续有多个请求在等待发送，请设计思路?123456789101112131415161718192021222324252627282930313233343536373839404142434445let tokensRequest = { state: ['token1', 'token2', 'token3'], // 默认三个令牌 最多可并发发送三次请求 queue: [], // 请求队列 waitqueue: [], // 等待队列 // 获取令牌 getToken: function () { return this.state.splice(0, 1)[0]; }, // 归还令牌 backToken: function (token) { this.state.push(token); }, // 请求队列 pushQueue: function (args, type = 'first') { type == 'second' &amp;&amp; (this.queue = []); // 每次push新请求的时候 队列清空 for (var i = 0; i &lt; args.length; i++) { if (this.state.length &gt; 0) { // 看是否有令牌 var token = this.getToken(); // 取令牌 var obj = { token, request: args[i], }; this.queue.push(obj); } else { // 否则推入等待队列 this.waitqueue.push(args[i]); } } }, // 开始执行 start: function () { for (let item of this.queue) { item.request().then((res) =&gt; { console.log(res); this.backToken(item.token); // 令牌归还 if (this.waitqueue.length &gt; 0) { var wait = this.waitqueue.splice(0, 1); this.pushQueue(wait, 'second'); // 从等待队列进去的话 就是第二中的push情况了 this.start(); // 重新开始执行队列 } }); } },}; 持续更新中…","link":"/2022/03/11/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931/"}],"tags":[{"name":"aliyun","slug":"aliyun","link":"/tags/aliyun/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"lerna","slug":"lerna","link":"/tags/lerna/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"dom","slug":"dom","link":"/tags/dom/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"前端安全","slug":"前端安全","link":"/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"react-hooks","slug":"react-hooks","link":"/tags/react-hooks/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"微前端","slug":"微前端","link":"/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"node","slug":"node","link":"/categories/node/"},{"name":"浏览器","slug":"浏览器","link":"/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"http","slug":"http","link":"/categories/http/"},{"name":"lerna","slug":"lerna","link":"/categories/lerna/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"},{"name":"dom","slug":"dom","link":"/categories/dom/"},{"name":"vue3","slug":"vue3","link":"/categories/vue3/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"前端安全","slug":"前端安全","link":"/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"微前端","slug":"微前端","link":"/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面经","slug":"面经","link":"/categories/%E9%9D%A2%E7%BB%8F/"}],"pages":[{"title":"关于","text":"我本将心向明月，奈何明月照沟渠","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}