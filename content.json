{"posts":[{"title":"aliyun服务器实践","text":"创建新的账号默认使用 root 登录，由于 root 权限太高，出于安全考虑，创建 foolishmax（自定义）账号 123456789101112131415161718192021222324252627282930# 新增账号foolishmaxadduser foolishmax# 修改foolishmax的密码passwd foolishmax# 为foolishmax账号添加sudo权限# 找到文件位置 /etc/sudoerswhereis sudoers# 修改权限# u 标识所有者、w 表示写权限 + 表示添加chmod u+w /etc/sudoers# 编辑 /etc/sudoers# 找到 `root ALL=(ALL) ALL`# 再加一行 `work ALL=(ALL) ALL`vim /etc/sudoers# 还原权限chmod u-w /etc/sudoers# 切换foolishmax用户su foolishmax# 切换回rootsu# 输入密码# 切换成功 下载常用工具12345678910111213141516171819// gityum -y install gitgit --version// 安装dockeryum -y install dockerdocker --version// 安装docker-compose// 1. 下载二进制文件wget https://github.com/docker/compose/releases/download/1.24.0/docker-compose-Linux-x86_64// 2.移动文件mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose// 3.赋予可执行权限chmod +x /usr/local/bin/docker-compose// 4.创建软链ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose// 5.测试是否安装成功docker-compose --version 开放端口aliyun 控制台服务 发布测试机思路： 使用 github actions 监听 dev 分支 push 登录测试机，获取最新 dev 分支代码 重建构建镜像 docker-compose build project-name 重启所有容器 docker-compose up -d github actions代码在项目 .github/workflows 目录下面的 .yml 格式文件deplop-dev.yml示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions# github actions 中文文档 https://docs.github.com/cn/actions/getting-started-with-github-actionsname: deploy for devon: push: branches: - 'dev' # 只针对 dev 分支 paths: - '.github/workflows/*' # - '__test__/**' # dev 不需要立即测试 - 'src/**' - 'Dockerfile' - 'docker-compose.yml' - 'bin/*'jobs: deploy-dev: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: set ssh key # 临时设置 ssh key run: | mkdir -p ~/.ssh/ echo &quot;${{secrets.WFP_ID_RSA}}&quot; &gt; ~/.ssh/id_rsa # secret 在这里配置 https://github.com/imooc-lego/biz-editor-server/settings/secrets chmod 600 ~/.ssh/id_rsa ssh-keyscan &quot;182.92.xxx.xxx&quot; &gt;&gt; ~/.ssh/known_hosts - name: deploy # 部署 run: | ssh work@182.92.xxx.xxx &quot; # 【注意】用 work 账号登录，手动创建 /home/work/imooc-lego 目录 # 然后 git clone https://username:password@github.com/imooc-lego/biz-editor-server.git -b dev （私有仓库，使用 github 用户名和密码） # 记得删除 origin ，否则会暴露 github 密码 cd /home/work/imooc-lego/biz-editor-server; git remote add origin https://wangfupeng1988:${{secrets.WFP_PASSWORD}}@github.com/imooc-lego/biz-editor-server.git; git checkout dev; git pull origin dev; # 重新下载最新代码 git remote remove origin; # 删除 origin ，否则会暴露 github 密码 # 启动 docker docker-compose build editor-server; # 和 docker-compose.yml service 名字一致 docker-compose up -d; &quot; - name: delete ssh key # 删除 ssh key run: rm -rf ~/.ssh/id_rsa","link":"/2022/08/02/aliyun%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E8%B7%B5/"},{"title":"docker实践指南","text":"镜像操作 获取镜像 docker pull12# docker pull 从镜像仓库中拉取或者更新指定镜像docker pull ubuntu:18.04 列出已经下载的镜像 docker images123docker images# 列出某一个镜像docker images ubuntu 删除镜像 docker rmi1234567891011121314151617docker rmi 501# ordocker rmi centos# docker prune命令# 删除所有未被tag标记或者未被容器使用的镜像docker image prune# 删除所有未被容器使用的镜像docker image prune -a# 删除所有停止运行的容器docker container prune# 删除所有未被挂载的卷docker volume prune# 删除所有网络docker network prune# 删除docker所有资源docker system prune 上传镜像 docker push12# docker push:将本地的镜像上传到镜像仓库，先登录镜像仓库docker image push mynode:v1 save镜像docker image save nginx:1.20.0 -o nginx.name load镜像docker image load -i ./nginx.name 容器操作列出容器 docker ps12# -a :显示所有的容器，包括未运行的docker ps 停止容器 docker stop12# 停止运行中的容器myrunoobdocker stop myrunoob 启动容器 docker start12# 启动已被停止的容器myrunoobdocker start myrunoob 重启容器 docker restart12# 重启容器myrunoobdocker restart myrunoob 删除容器 docker rm12# 强制删除容器 db01、db02docker rm -f db01 db02 查看容器信息 docker inspect123# 获取容器/镜像的元数据# 获取镜像mysql:5.6的元信息docker inspect mysql:5.6 查看容器中运行的进程信息1docker contaienr top [id] 查看容器日志 docker logs12# 跟踪查看容器mynginx的日志输出docker logs -f mynginx 进入容器控制台 docker exec1234567// 在运行的容器中执行命令// -d:分离模式，在后台运行// -i: 即使没有附加也保持STDIN打开// -t: 分配一个伪终端// docker exec -it &lt;container-id&gt; /bin/sh// 执行 exit 退出 启动 docker 1open /Applications/Docker.app docker runeg1: 1docker run ubuntu:15.10 /bin/echo 'hello world' 各个参数解析： docker：Docker 的二进制执行文件 run：与 docker 组合来运行一个容器 ubuntu:15.10 指定要运行的景象，docker 先从本地主机查找景象是否存在，如不存在，docker 就会从 Docker hub镜像仓库下载公共镜像 /bin/echo ‘hello world’：在启动的容器中执行的命令 注意： 不存在时会出现错误信息： Unable to find image ‘ubuntu:15.10’ locally 之后便会从镜像仓库下载公共镜像 打印 hello world M1-Mac 可能会出现如下警告：WARNING: The requested image’s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested 解决方法：docker run –platform linux/amd64 ubuntu:15.10 /bin/echo ‘hello world’ eg2: 123456// 启动容器 docker run -p xxx:xxx -v=hostPath:containerPath -d --name &lt;container-name&gt; &lt;image-name&gt;// -p 端口映射// -v 数据卷，文件映射// -d 后台运行// --name 定义容器名称docker run -p 81:80 -d --name nginx1 nginx DockerfileDockerfile 是一个用来构建镜像的文本文件，文件内容包含一条条构建镜像所需的指令和说明 12345678910111213#DockerfileFROM node:latestWORKDIR /appCOPY . /appRUN npm set registry https://registry.npm.taobao.orgRUN npm installRUN npm install pm2 -gCMD echo $SERVER_NAME &amp;&amp; echo $AUTHOR_NAME &amp;&amp; npm run start &amp;&amp; npx npm2 logENV SERVER_NAME = 'react-demo'ENV AUTHOR_NAME = 'foolishmax' .dockerignore12.gitnode_modules 始构建镜像在 Dockerfile 文件的存放目录下，执行构建动作 1docker build -t aaa:ccc . -t: 指定要创建的目标镜像名.:Dockerfile文件所在目录，可以指定Dockerfile的绝对路径aaa:镜像名ccc:镜像的标签 查看镜像分层情况docker image history e34293 docker images 查看1234REPOSITORY TAG IMAGE ID CREATED SIZEreact-demo-image latest 35c499bddac6 3 minutes ago 1.22GBnode-test latest 028a51c6e54d 8 months ago 945MBnginx latest f1325989da19 8 months ago 134MB 运行容器1docker run -p 8081:3000 -d --name react-demo-server react-demo-image 查看容器12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf71ef1480035 react-demo-image &quot;docker-entrypoint.s…&quot; 4 seconds ago Up 3 seconds 0.0.0.0:8081-&gt;3000/tcp react-demo-server contaier保存为镜像docker container commit 884 hello/nginx 查看日志docker logs f71ef1480035 1234567891011121314151617181920212223242526# 这两行对应Dockerfile中的CMD变量打印= react-demo= foolishmax&gt; react-demo@0.1.0 start&gt; react-scripts start(node:27) [DEP_WEBPACK_DEV_SERVER_ON_AFTER_SETUP_MIDDLEWARE] DeprecationWarning: 'onAfterSetupMiddleware' option is deprecated. Please use the 'setupMiddlewares' option.(Use `node --trace-deprecation ...` to show where the warning was created)(node:27) [DEP_WEBPACK_DEV_SERVER_ON_BEFORE_SETUP_MIDDLEWARE] DeprecationWarning: 'onBeforeSetupMiddleware' option is deprecated. Please use the 'setupMiddlewares' option.Starting the development server...Compiled successfully!You can now view react-demo in the browser. Local: http://localhost:3000 On Your Network: http://172.17.0.2:3000Note that the development build is not optimized.To create a production build, use npm run build.webpack compiled successfullyCompiling...Compiled successfully!webpack compiled successfully 停止容器// 列出所有containerdocker container ps -a// 列出所有container的iddocker container ps -aq// 停止所有的containerdocker container stop $(docker container ps -aq)// 指定某个id停止容器docker stop f71ef1480035 删除容器// 删除所有的containerdocker container rm $(docker container ps -aq)// 指定某个id删除容器docker rm f71ef1480035 删除镜像docker rmi 35c499bddac6 12Untagged: react-demo-image:latestDeleted: sha256:35c499bddac6675ff20a7d951fc1c1f6770a10430278fec6f2b8d1c866037624 docker-compose.yml 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344version: '3'services: editor-server: # service name build: context: . #当前目录 dockerfile: Dockerfile # 基于Dockerfile构建 image: editor-server #依赖当前dockerfile创建出来的镜像 container_name: editor-server ports: - 8081:3000 #宿主机通过8081访问 editor-redis: image: redis #引用官方redis镜像 container_name: editor-redis ports: - 6378:6379 environment: - TZ=Asia/Shanghai # 设置时区 editor-mysql: image: mysql # 引用官网 mysql 镜像 container_name: editor-mysql restart: always # 出错则重启 privileged: true # 高权限，执行下面的 mysql/init command: --default-authentication-plugin=mysql_native_password # 远程访问 ports: - 3305:3306 # 宿主机可以用 127.0.0.1:3305 即可连接容器中的数据库，和 redis 一样 volumes: - .docker-volumes/mysql/log:/var/log/mysql # 记录日志 - .docker-volumes/mysql/data:/var/lib/mysql # 数据持久化 - ./mysql/init:/docker-entrypoint-initdb.d/ # 初始化 sql environment: - MYSQL_DATABASE=imooc_lego_course # 初始化容器时创建数据库 - MYSQL_ROOT_PASSWORD=Mysql_2019 - TZ=Asia/Shanghai # 设置时区 editor-mongo: image: mongo # 引用官网 mongo 镜像 container_name: editor-mongo restart: always volumes: - '.docker-volumes/mongo/data:/data/db' # 数据持久化,映射本地文件 environment: - MONGO_INITDB_DATABASE=imooc_lego_course - TZ=Asia/Shanghai # 设置时区 ports: - '27016:27017' # 宿主机可以用 127.0.0.1:27016 即可连接容器中的数据库 构建容器 docker-compose build 启动所有服务器 docker-compose up -d,后台启动 查看服务 docker-compose ps (相比较 docker ps 等于多了层作用域) 停止所有服务 docker-compose down 注意：经过以上操作之后需修改.gitignore 文件，增加一行 .docker-volumes/","link":"/2022/07/31/docker%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"},{"title":"Node.js之express","text":"Node.js 之 express 123456789101112131415161718192021222324//引包var express = require('express');//相当于原来的http.createServervar app = express();//公开指定目录app.use('/puclic/', express.static('./public/'));//当省略第一个参数的时候，可以通过省略/public的方式访问//app.use(express.static('./public/'))//当服务器收到get请求 / 的时候，执行回调函数app.get('/', function (req, res) { res.send('hello exporess');});app.get('/about', function (req, res) { res.send('hello world');});//相当于server.listenapp.listen(3000, function () { console.log('app is running at port 3000');}); Express 使用 art-template Express&amp;art-template 官网 Install 12npm install --save art-templatesnpm install --save express-art-template Example 1234567891011121314151617181920var express = require('express');var app = express();// view engine setupapp.engine('art', require('express-art-template'));app.set('view', { debug: process.env.NODE_ENV !== 'production'});app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'art');// routesapp.get('/', function (req, res) { res.render('index.art', { user: { name: 'aui', tags: ['art', 'template', 'nodejs'] } });}); body-parser 在 Express 中没有内置获取表单 POST 请求体的 API，需要引入一个第三方包：body-parser Install 1npm install --save body-parser config 1234567var express = require('express')var bodyParser = require('body-parser')var app = express()//配置 body-parser,req对象上就会多出来一个 body 属性app.use(bodyParser.urlencoded({extended: false}))app.use(bodyParser.json()) use 12345app.use(function(req, res){ res.setHeader('Content-Type', 'text/plain') res.write('hello') res.end()})","link":"/2019/09/08/express%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/"},{"title":"git分布式版本控制系统","text":"使用 git commit 后，如何修改 commit 的信息？ 1git commit --amend gitlab CI/CD 流程生产环境1、推送代码-&gt;编译-&gt;生成的 jar 包发布到私服-&gt;打包为 docker 镜像-&gt;推送到 Harbor 镜像仓库（成功，微信通知，c 结束返回成功|失败，微信通知，ci 结束返回失败）2、运维人员 触发部署到 k8s 集群-&gt;健康检查（成功，微信通知，c 结束返回成功|失败，微信通知，ci 结束返回失败）","link":"/2023/03/28/git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/"},{"title":"jQuery学习","text":"jQuery 学习 入口函数 jQuery 入口函数 1234567$(document).ready(function(){ //执行代码})或者（简写）$(function(){ //执行代码}) javascript 入口函数 123window.onload = function(){ //执行代码} jQuery 的入口函数是在 html 的所有标签 DOM 都加载之后，就会执行包裹的代码，可以执行多次，并且不会覆盖上次。 javascript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完成后，才会执行，只能执行一次，如果第二次会把第一次的执行覆盖。 jQuery 选择器 元素选择器 1$(&quot;p&quot;) id 选择器 1$(&quot;#test&quot;) class 选择器 1$(&quot;.test&quot;) 属性选择器 1$(&quot;[href]&quot;) :empty 选择器 123$(&quot;:empty&quot;)//选择空的元素，既不不含子元素也不包含文本的元素$(&quot;div:empty&quot;) //选择div中为空的div元素 :parent 选择器 12$(&quot;td:parent&quot;)//选取所有带有子元素或文本的&lt;td&gt;标签元素 :contains 选择器 12$(&quot;div:contains('hello')&quot;)//找到div中包含文本hello的指定元素 :has 选择器 12$(&quot;div:has(p)&quot;)//找到包含p标签元素的div 补充 1$(&quot;:button&quot;) //获取所有type为button的&lt;input&gt;元素和&lt;button&gt;元素，去掉冒号，只能获取&lt;button&gt;元素。 常用 jQuery 事件方法 click() 点击事件 123$(&quot;p&quot;).click(function(){ $(this).hide();}) dblclick() 双击事件 123$(&quot;p&quot;).dblclick(function(){ $(this).hide();}) mouseenter() 鼠标指针穿过元素时 123$(&quot;p&quot;).mouseenter(function(){ alert(&quot;您的鼠标移到了p标签元素上！&quot;)}) mouseleave() 鼠标指针离开元素时 123$(&quot;p&quot;).mouseleave(function(){ alert(&quot;您的鼠标离开了该p标签元素！&quot;)}) mouseup() 当在元素上松开鼠标时 123$(&quot;p&quot;).mouseup(()=&gt;{ alert(&quot;鼠标在p标签上松开！&quot;)}) hover() 模拟光标悬停事件 12345678$(&quot;p&quot;).hover( function(){ alert(&quot;你进入了p标签！&quot;); }, function(){ alert(&quot;你离开了p标签！&quot;); }) focus() 当元素获得焦点时 123$(&quot;input&quot;).focus(function(){ $(this).css(&quot;background-color&quot;,&quot;#ccc&quot;);}) blur() 当元素失去焦点时 123$(&quot;input&quot;).blur(function(){ $(this).css(&quot;background-color&quot;,&quot;#fff&quot;);}) keypress,keydown,keyup 123456789101112131415161718//获取按键代码或ASCII码$(window).keydown(function(event){ //通过event.which可以拿到按键代码，如果是keypress事件中则拿到ASCII码。 console.log(event);})//获取事件对象$(window).keypress(function(event){ //获取事件对象，里面包含各种有用的信息。 console.log(event); //console.log(event.which);});//keypress事件获取键入的字符$(window).keypress(function(event){ //event.which是获取ASCII码，前面的函数是将ASCII码转换成字符，空格键和Enter键输出均为空白。 console.log(String.fromCharCode(event.which)); //从event对象中key属性获取字符，但是Enter键的key值为&quot;Enter&quot;，空白键还是空白&quot; &quot;。 console.log(event.key);}); off() 事件移除 12345$(&quot;button&quot;).off() //移除所有button元素身上绑定的事件$(&quot;button&quot;).off(&quot;click&quot;) //移除所有的click事件，移除指定类型$(&quot;button&quot;).off(&quot;click&quot;, test) //移除click事件中的test回调方法，移除指定类型的事件 阻止事件冒泡 123456789$(&quot;.son&quot;).click(function(event){ alert(&quot;son&quot;) //return false; event.stopPropagation(); //阻止事件冒泡})$(&quot;.father&quot;).click(function(){ alert(&quot;father&quot;)}) 阻止默认行为 12345//a标签跳转、submit提交按钮等$(&quot;a&quot;).click(function(event){ alert(&quot;弹出注册框！&quot;); event.preventDefault();}) trigger()、triggerHandler() 自动触发事件 12345678910111213//触发绑定到被选元素的所有事件$(&quot;.father&quot;).click(function(){ alert(&quot;father&quot;);})$(&quot;.father&quot;).trigger(&quot;click&quot;); //方法一:会触发事件冒泡$(&quot;.father&quot;).triggerHandler(&quot;click&quot;); //方法二:只触发事件，不会触发事件冒泡-------------------------------$(&quot;input[type='submit']&quot;).click(function(){ alert(&quot;submit&quot;);})$(&quot;input[type='submit']&quot;).trigger(&quot;click&quot;); //方法一：触发事件的同时，还会触发默认行为。$(&quot;input[type='submit']&quot;).triggerHandler(&quot;click&quot;) //方法二：只触发事件，不触发默认行为。//注意：这里&lt;a&gt;标签有点特殊，这两个方法都不会触发默认行为，如果想使用trigger()触发&lt;a&gt;标签的事件和默认行为的话，可以在&lt;a&gt;标签中添加一个&lt;span&gt;,例如&lt;a href =&quot;#&quot;&gt;&lt;span&gt;百度&lt;/span&gt;&lt;/a&gt; 这种写法。 自定义事件 1234567891011121314/** 想要自定义事件，必须满足两个条件* 1.事件必须是通过on绑定的* 2.事件必须通过trigger来触发*/$(&quot;.son&quot;).on(&quot;myClick&quot;,function(){ alert(&quot;son&quot;);})$(&quot;.son&quot;).trigger(&quot;myClick&quot;);or$(&quot;.son&quot;).triggerHandler(&quot;myClick&quot;); 事件命名空间 12345678910111213141516/** 想要事件的命名空间有效，必须满足两个条件* 1.事件通过on来绑定(自定义事件)* 2.通过trigger()或者triggerHandler()来触发*/$(&quot;.son&quot;).on(&quot;eventName.zs&quot;,function(){ alert(&quot;click zhangsan&quot;);})$(&quot;.son&quot;).on(&quot;eventName.ls&quot;,function(){ alert(&quot;click lisi&quot;);})$(&quot;.son&quot;).trigger(&quot;click.zs&quot;);or$(&quot;.son&quot;).triggerHandler(&quot;click.zs&quot;); 隐藏和显示 hide() 隐藏 html 元素 123$(&quot;#hide&quot;).click(function(){ $(&quot;p&quot;).hide();}) show() 显示 html 元素 123$(&quot;#show&quot;).click(function(){ $(&quot;p&quot;).show();}) 语法 12345678910111213141516$(selector).hide(speed,callback);$(selector).show(speed,callback);//可选的speed参数表示规定显示/隐藏的速度(slow、fast、毫秒)//可选的callback参数是隐藏或显示完成后所执行的函数名称$(&quot;.hidebtn&quot;).click(function(){ $(&quot;div&quot;).hide(1000,&quot;linear&quot;,function(){ alert(&quot;Hide() 方法已完成!&quot;); });});//第二个参数是一个字符串，表示过渡使用哪种缓动函数，jQuery自身提供(linear、swing)//补充：callback函数名后面加上括号，会立刻执行函数体，而不是等到显示/隐藏之后才执行,如add()作为callback参数会立即执行，而add作为参数则不会，callback函数可以是匿名函数，$(selector)选中的元素个数为n个，则callback函数会执行n次。 toggle() 切换 hide()和 show()方法 123$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).toggle();}) 淡入淡出 fadeIn() 用于淡入以隐藏的元素 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeIn(3000);})//语法： $(selector).fadeIn(speed, callback)// 可选的speed参数规定效果的时长(slow、fast、毫秒)// 可选的callback参数是fading完成后所执行的函数名称 fadeOut() 用于淡出可见元素 12345678$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeOut(&quot;slow&quot;);})//语法： $(selector).fadeOut(speed, callback)// 可选的speed参数规定效果的时长(slow、fast、毫秒)// 可选的callback参数是fading完成后所执行的函数名称 fadeToggle() 用于在 fadeIn()与 fadeOut()方法之间进行切换 12345678$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeToggle();})//语法： $(selector).fadeToggle(speed, callback)// 可选的speed参数规定效果的时长(slow、fast、毫秒)// 可选的callback参数是fading完成后所执行的函数名称 fadeTo() 允许渐变为给定的不透明度 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.3);})//语法：$(selector).fadeTo(speed, opacity, callback)//必须的speed参数规定效果时长(slow、fast、毫秒)//必须的opacity规定不透明度(介于0-1之间) 滑动方法 slideDown() 用于元素向下滑动 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).slideDown();})//语法：$(selector).slideDown(speed,callback)//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。//可选的 callback 参数是滑动完成后所执行的函数名称。 slideUp() 用于元素向上滑动 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).slideUp();})//语法：$(selector).slideUp(speed,callback)//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。//可选的 callback 参数是滑动完成后所执行的函数名称。 slideToggle() 在 slideDown()与 slideUp()方法之间进行切换 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).slideToggle();})//语法：$(selector).slideToggle(speed,callback)//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。//可选的 callback 参数是滑动完成后所执行的函数名称。 动画 animate()方法 123456789101112131415//默认情况下，所有html元素都有一个静态位置，且无法移动。//先将p标签元素设置为position:relative/absolute/fixed$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).animate({ left:'250px', opacity:'0.5', height:'400px', width: '400px', paddingLeft:'10px' });});//语法： $(selector).animate({params},speed,callback)// params参数可以操作几乎所有的css属性，但名字要采用camel标记法 stop() 停止动画 1234567891011 $(&quot;#flip&quot;).click(function(){ $(&quot;#panel&quot;).slideDown(5000); });$(&quot;#stop&quot;).click(function(){ $(&quot;#panel&quot;).stop();});语法: $(selector).stop(stopAll,goToEnd)//可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停/止活动的动画，允许任何排入队列的动画向后执行。//可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 jQuery 方法链接 123$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;) .slideUp(2000) .slideDown(2000); jQuery 获取内容和属性 获取内容 text()、html()、val() text() 设置或返回所选元素的文本内容 html() 设置或返回所选元素的内容(包括 html 标记) val() 设置或返回表单字段的值 1234567891011$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).text());})//-----------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).html())})//------------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;input&quot;).val());}); 获取属性 attr() 12345//项目QC刚用过$(&quot;button&quot;).click(function(){ console.log($(&quot;p&quot;).attr(&quot;data-text&quot;));}) 补充： 12345prop()函数返回相应属性或空字符串。attr()函数返回相应属性或undefined1.对于HTML元素本身就带有的固有属性，在处理时使用prop方法2.对HTML元素我们自己定义的DOM属性，在处理时使用attr方法3.具有true和false两个属性的属性，如checked、selected或者disabled使用prop() 设置内容和属性 设置内容 text()、html()、val() 1234567891011$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).text(&quot;hello&quot;));})//-----------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).html(&quot;hello&quot;))})//------------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;input&quot;).val(&quot;hello&quot;));}); text()、html() 以及 val() 的回调函数 123456789$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).text(function(i,orignText){ //i 为被选元素列表中当前元素的下标 //orignText 为原来的值 //return 为返回的新值 return &quot;hello&quot; })}) 设置属性 attr() 12345678910$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).attr(&quot;data-text&quot;,&quot;hello world&quot;);})// 允许同时设置多个属性$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).attr({ &quot;data-text&quot;,&quot;hello world&quot;, &quot;title&quot;,&quot;jQuery学习！&quot; });}) attr() 也存在回调函数(同上) 12345$(&quot;button&quot;).click(function(){ $(&quot;#runoob&quot;).attr(&quot;href&quot;, function(i,origValue){ return origValue + &quot;/jquery&quot;; });}); 删除属性 removeAttr() 12$(&quot;span&quot;).removeAttr(&quot;class name&quot;);//表示同时删除span标签的class和name属性 removeProp() 12$(&quot;span&quot;).removeProp(&quot;class&quot;);//表示删除所有span标签的class属性 jQuery 添加元素 append/prepend 是在选择元素内容嵌入(文本或标签) after/before 实在元素外部追加(文本或标签) 参数可以是多个，可以是一个 list jQuery 删除元素 remove() 方法 123$(&quot;p&quot;).remove()//remove() 方法删除被选元素及其子元素 empty() 方法 123$(&quot;p&quot;).empty()//empty() 方法删除被选元素的子元素而不删除自身 过滤被删除的元素 1234$(&quot;p&quot;).remove(&quot;.italic&quot;)//表示删除所有&lt;p&gt;标签元素中class = &quot;italic&quot;的元素//过滤时，只能作用于同级元素之间 jQuery 获取并设置 CSS 类 addClass() 向不用的元素添加 class 属性，在添加类时可以选取多个元素,也可以设置多个类。 123$(&quot;button&quot;).click(function(){ $(&quot;h1, h3, p&quot;).addClass(&quot;fontColor fontSize&quot;);}) removeClass() 在不同元素中删除指定的 class 属性 123$(&quot;button&quot;).click(function(){ $(&quot;h1, h3, p&quot;).removeClass(&quot;fontSize&quot;);}) toggleClass() 对被选元素进行添加/删除类的切换操作 123$(&quot;.btn2&quot;).click(function(){ $(&quot;h1, h3, p&quot;).toggleClass(&quot;fontColor2&quot;);}) css() 方法 返回 css 属性 1$(&quot;p&quot;).css(&quot;background-color&quot;); 设置 css 属性,可以同时设置多个 1$(&quot;p&quot;).css({&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;}); 尺寸 width()、height() width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距） height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 12$(&quot;p&quot;).width() //获取$(&quot;p&quot;).width(20) //设置 innerWidth()、innerHeight() innerWidth() 方法返回元素的宽度（包括内边距）。 innerHeight() 方法返回元素的高度（包括内边距）。 outerWidth()、outerHeight() outerWidth() 方法返回元素的宽度（包括内边距和边框）。 outerHeight() 方法返回元素的高度（包括内边距和边框）。 offset() 12345$(&quot;.son&quot;).offset().left //元素距离窗口的偏移距离$(&quot;.son&quot;).offset({ left: 20,}) //设置元素距离窗口的偏移距离 position() 123$(&quot;.son&quot;).position().left //获取元素距离定位元素的偏移距离// 注意点：position() 方法只能获取不能设置 scrollTop() 123456789$(&quot;scroller&quot;).scrollTop() //获取元素相对滚动条顶部的偏移$(&quot;scroller&quot;).scrollTop(300) //设置元素相对滚动条顶部的偏移//获取网页滚动的偏移(考虑兼容)$(&quot;body&quot;).scrollTop() + $(&quot;html&quot;).scrollTop() //ie-&gt;body,chrome...-&gt;html//设置网页滚动的偏移(考虑兼容)$(&quot;html,body&quot;).scrollTop(300) 补充：设置了 box-sizing 后，width()=width - padding - border jQuery 遍历祖先 parent() 返回元素的直接父元素 123$(document).ready(function(){ $(&quot;span&quot;).parents();}) parents() 返回被选元素的所有祖先元素，直到文档根元素 1234567$(document).ready(function(){ $(&quot;span&quot;).parents();})//过滤所有祖先，并且是&lt;ul&gt;元素$(document).ready(function(){ $(&quot;span&quot;).parents(&quot;ul&quot;);}) parentsUntil() 返回给定的两个元素之间的所有祖先元素 1234//返回&lt;span&gt;与&lt;div&gt;元素之间的所有祖先元素$(document).ready(function(){ $(&quot;span&quot;).parentsUntil(&quot;div&quot;);}) 后代 children() 返回被选元素的所有直接子元素 1234$(&quot;div&quot;).children();//可以使用可选参数来过滤子元素的搜索$(&quot;div&quot;).children(&quot;p.aaa&quot;); //返回类名为aaa的&lt;p&gt;元素，且是div的直接子元素。 find() 返回被选元素的后代元素，一路向下直到最后一个后代 1$(&quot;div&quot;).find(&quot;span&quot;); 同胞 siblings() 返回被选元素的所有同胞元素，可以使用可选参数过滤搜索。 next() 返回被选元素的下一个同胞元素，只返回一个元素 nextAll() 返回被选元素的所有跟随的同胞元素 nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素 pre()、prevAll()、prevUntil() 同上，方向相反 过滤：缩小搜索元素的范围 first() 返回被选元素的首个元素 1$(&quot;p&quot;).first(); last() 返回被选元素的最后一个元素 1$(&quot;p&quot;).last(); eq() 返回被选元素中带有指定索引号的元素 123$(&quot;p&quot;).eq(1);//索引号从0开始，eq(1)选择的是第二个&lt;p&gt;元素 filter() 允许规定一个标准，返回匹配的元素 123$(&quot;p&quot;).filter(&quot;.className&quot;);//返回带有类名className的所有&lt;p&gt;元素 not() 返回所有不匹配的元素，与 filter()相反 123$(&quot;p&quot;).not(&quot;.className&quot;);//返回所有不带有类名className的&lt;p&gt;元素","link":"/2020/09/05/jquery%E5%AD%A6%E4%B9%A0/"},{"title":"dom基本操作","text":"一、节点节点属性 12345678910111213141516171819Node.nodeName //返回节点名称，只读Node.nodeType //返回节点类型的常数值，只读Node.nodeValue //返回Text或Comment节点的文本值，只读Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI //返回当前网页的绝对路径Node.ownerDocument //返回当前节点所在的顶层文档对象，即documentNode.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode //返回当前节点的父节点Node.parentElement //返回当前节点的父Element节点Node.childNodes //返回当前节点的所有子节点Node.firstChild //返回当前节点的第一个子节点Node.lastChild //返回当前节点的最后一个子节点Node.children //返回当前节点的所有Element子节点Node.firstElementChild //返回当前节点的第一个Element子节点Node.lastElementChild //返回当前节点的最后一个Element子节点Node.childElementCount //返回当前节点所有Element子节点的数目 操作123456789101112131415Node.appendChild(node) //向节点添加最后的子节点Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true) //默认为false(克隆节点),true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode) //在指定子节点前插入新的子节点Node.removeChild(node) //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild) //替换节点Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(node) //返回布尔值，用于检查两个节点是否想等，所谓的相等节点，指的的两个节点的类型、属性、子节点都相同Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个ChildNode.remove() //用于删除当前节点ChildNode.before() //在ChildNode前插入元素节点或者文本节点ChildNode.after() //在ChildNode后插入元素或文本节点ChildNode.replaceWith() //替换该节点的父节点下的子节点，可以为文本或元素对象 Document 节点Document 节点的属性1234567891011121314151617181920212223242526document.doctype //返回当前文档关联的文档类型定义(DTD)document.documentElement //返回当前文档的根节点(html)document.defaultView //返回document对象所在的window对象document.body //返回当前文档的&lt;body&gt;节点document.head //返回当前文档的&lt;head&gt;节点document.activeElement //返回当前文档中获得焦点的那个元素document.links //返回当前文档的所有a元素document.forms //返回页面中所有表单元素document.images //返回页面中所有图片元素document.embeds //返回网页中所有嵌入对象document.scripts //返回当前文档的所有脚本document.styleSheets //返回当前网页的所有样式表document.documentURI //表示当前文档的网址document.URI //返回当前文档的网址document.domain //返回当前文档的域名document.lastModified //返回当前文档最后修改的时间戳document.location //返回location对象，提供当前文档的URL信息document.referrer //返回当前文档的访问来源document.title //返回当前文档的标题document.characterSet //属性返回渲染当前文档的字符集，比如UTF-8document.readyState //返回当前文档的状态document.designMode //控制当前文档是否可编辑，可读写document.compatMode //返回浏览器处理文档的模式document.cookie //用来操作Cookie Document 节点的方法读写方法1234document.open() //用于新建并打开一个文档document.close() //关闭open方法所新建的文档document.write() //用于向当前文档写入内容document.writeIn() //用于向当前文档写入内容，尾部添加换行符 查找节点1234567document.querySelector(selectors) //接收一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点document.querySelectorAll(selectors) //接收一个CSS选择器作为参数，返回所有匹配该选择器的元素节点document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name) //用于选择拥有name属性的HTML元素(比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;object&gt;等)document.getElementById(id) //返回匹配指定id属性的元素节点document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点 生成节点1234document.createElement(tagName) //用来生成HTML元素节点document.createTextNode(text) //用来生成文本节点document.createAttribute(name) //生成一个新的属性对象节点，并返回document.createDocumentFragment() //生成一个DocumentFragment对象 事件方法1234document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture) //注册事件document.removeEventListener(type,listener,capture) //注销事件document.dispatchEvent(event) //触发事件 其他123document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点document.importNode(externalNode,deep) //从外部文档拷贝指定节点，插入当前文档 Element 节点Element 节点的属性特性属性12345678Element.attributes //返回当前元素节点的所有属性节点Element.id //返回指定元素的id属性，可读写Element.tagName //返回指定元素的大写标签名Element.innerHTML //返回该元素包含的HTML代码，可读写Element.outerHTML //返回该元素节点的所有HTML代码，包括自身和所有子元素，可读写Element.className //返回当前元素的class属性，可读写Element.classList //返回当前元素节点的所有class集合Element.dataset //返回元素节点中所有data-*属性 尺寸属性12345678910111213141516Element.clientHeight //返回元素节点可见部分的高度Element.clientWidth //返回元素节点可见部分的宽度Element.clientLeft //返回元素节点左边框的宽度Element.clientTop //返回元素节点顶部边框的宽度Element.scrollHeight //返回元素节点的总高度Element.scrollWidth //返回元素节点的总宽度Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值，通过设置这个属性可以改变元素滚动的位置Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight //返回元素的垂直高度(包含border，padding)Element.offsetWidth //返回元素的水平宽度(包含border，padding)Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop //返回水平位移Element.style //返回元素节点的行内样式 节点相关属性1234567Element.children //包括当前元素节点的所有子元素Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild //返回当前节点的第一个Element子节点Element.lastElementChild //返回当前节点的最后一个Element子节点Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML元素节点Element.offsetParent //返回当前元素节点的最靠近、并且CSS的position属性不等于static的父元素 Element 节点的方法位置方法12getBoundingClientRect() //获取元素位置getClientRects() //返回当前元素在页面上的矩形区域 属性方法1234Element.getAttribute() //读取指定属性Element.setAttribute() //设置指定属性Element.hasAttribute() //返回一个布尔值，表示当前元素节点是否有指定属性Element.removeAttribute() //移除指定属性 查找方法1234Element.querySelector()Element.querySelectorAll()Element.getElementByTagName()Element.getElementByClassName() 事件方法1234567891011121314151617181920Element.addEventListener() //添加事件的回调函数Element.removeEventListener() //移除事件监听函数Element.dispatchEvent() //触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)//event对象var event = window.event||event//事件的目标节点var target = event.target || event.srcElement//事件代理ul.addEventListener('click',function(event){ if(event.target.tagName.toLowerCase() === 'li'){ console.log(event.target.innerHTML) }}) 123456789101112Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString);Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从DOM中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上 二、CSS 操作类名操作1234567891011121314151617181920//ie8以下Element.className //获取元素节点的类名Element.className += ' ' + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className){ return new RegExp(className,'gi').test(element.className);}//移除classfunction removeClass(element,className){ element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'),'');}//ie10element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class style 操作123456789101112131415161718element.setAttribute('style','')element.style.backgroundColor = 'red'element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName]window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,':after')[attrName] 对象Object 对象生成实例对象var o = new Object() 属性Object.prototype //返回原型对象 方法Object.keys(o) //遍历对象的可枚举属性 Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法valueOf() //返回当前对象对应的值 toString() //返回当前对象对应的字符串形式 toLocaleString() //返回当前对象对应的本地字符串形式 hasOwnProperty() //判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性 isPrototypeof() //判断当前对象是否为另一个对象的原型 propertyIsEnumerable() //判断某个属性是否可枚举 Array 对象生成实例对象var a = new Array() 属性a.length //长度 Array.isArray()Array.isArray(a) //用来判断一个值是否为数组 Array 实例的方法a.valueof() //返回数组本身 a.toString() //返回数组的字符串形式 a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。 pop() //用于删除数组的最后一个元素，并返回该元素 join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。 concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。 shift() //用于删除数组的第一个元素，并返回该元素。 unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。 reverse() //用于颠倒数组中元素的顺序，返回改变后的数组 slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。 splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。 map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。 map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。 forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。 filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。 some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。 every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。 reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员） reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员） indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 Number 对象生成对象var n = new Number() Number 对象的属性Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 Number 对象实例的方法toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。 toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。 toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。 toPrecision() //用于将一个数转为指定位数的有效数字。 String 对象生成实例对象var s = new String() String 对象的属性s.length //返回字符串的长度 方法s.chatAt(index) //返回指定位置的字符 s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。 s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示） s.concat(s2) //用于连接两个字符串 s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。 s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。 s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。 s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。 s.trim() //用于去除字符串两端的空格，返回一个新字符串 s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。 s.toUpperCase() //全部转为大写 s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。 s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 Math 对象属性Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。 数学方法Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。 Math.exp()：返回e的指数，也就是常数e的参数次方。 Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 三角函数方法Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值） JSON 对象方法JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。 //（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。 //还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。 JSON.parse() //用于将JSON字符串转化成对象。 console 对象方法console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。 console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。 console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。 console.warn() //输出信息时，在最前面加一个黄色三角，表示警告； console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈 console.table() //可以将复合类型的数据转为表格显示。 console.count() //用于计数，输出它被调用了多少次。 console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。 console.dirxml() //用于以目录树的形式，显示DOM节点。 console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 //这两个方法用于计时，可以算出一个操作所花费的准确时间。 console.time() console.timeEnd() //time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。 console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。 console.profileEnd() //用来结束正在运行的性能测试器。 console.group() console.groupend() //上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。 console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 console.trace() //显示当前执行的代码在堆栈中的调用路径。 console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。 DOM 基本操作 获取 Dom 节点 document 代表整个文档 document.getElementById() document.getElementByTagName() document.getElementByName() //只有部分标签 name 可生效，表单之类的 document.getElementByClassName() querySelector() //静态的，不是实时的，保存的是当时的状态，是一个副本 querySelectorAll() //即使以后元素发生了改变，该值也不会改变 遍历节点树 parentNode -&gt; 父节点（最顶端 parentNode 为#document） childNodes -&gt; 子节点们 firstChild -&gt; 第一个子节点 lastChild -&gt; 最后一个子节点 nextSibling -&gt; 后一个兄弟节点 previousSibling -&gt;前一个兄弟节点 遍历元素节点树 parentElement -&gt; 返回当前元素的父元素节点（IE9 以下不兼容） children -&gt; 返回当前元素的元素子节点 node.childElementCount === node.children.length 返回当前元素的子元素节点个数（IE9 以下不兼容） firstElementChild -&gt; 返回第一个元素节点（IE9 以下不兼容） lastElementChild -&gt; 返回最后一个元素节点（IE9 以下不兼容） nextElementSibling -&gt; 返回后一个元素节点（IE9 以下不兼容） previousElementSibling -&gt; 返回前一个元素节点（IE9 以下不兼容） 节点的类型 元素节点 —— 1 属性节点 —— 2 文本节点 —— 3 注释节点（Comment）—— 8 document —— 9 DocumentFragment —— 11 获取节点类型 nodeType 节点的四个属性 nodeName 元素的标签名，以大写形式表示，只读 nodeValue Text 节点或 Comment 节点的文本内容，可读写 nodeType 该节点的类型，只读 attributes Element 节点的属性集合 节点的一个方法 Node.hasChildNodes() 所有节点都有 hasChildNodes()方法，判断有无子节点，有一个或多个返回 true Dom 基本操作——增 document.createElement() document.createTextNode() document.createComment() document.createDocumentFragment() Dom 基本操作——插 parentNode.appendChild() parentNode.insertBefore(a, b) Dom 基本操作——删 parent.removeChild() child.remove() Dom 基本操作-替换 parent.replaceChild(new, origin) Element 节点的一些属性 innerHTML innerText(火狐不兼容)/textContent(老版本 IE 不兼容) Element 节点的一些方法 ele.setAttribute() ele.getAttribute() 查看元素的几何尺寸 domEle.getBoundingClientRect() 兼容性很好 返回一个对象，里面有 left、top、right、bottom、width、height。 left 和 top 代表元素左上角的 X 和 Y 坐标，right 和 bottom 代表元素右下角的 X 和 Y 坐标 height 和 width 属性老版本 IE 未实现 返回的结果不是“实时的” 查看元素的宽高尺寸dom.offsetWidth dom.offsetHeight 查看元素的位置dom.offsetLeft dom.offsetTop 对于无定位父级的元素，返回相对文档的坐标。 对于有定位的父级元素，返回相对最近的有定位的父级的坐标，无论距离是怎么产生的 dom.offsetParent返回最近的有定位的父级，若无，返回 body，body.offsetParent 返回 nul 让滚动条滚动 window 上的三个方法：scroll()==scrollTo()、scrollBy() scroll()和 scrollTo()将 x、y 坐标传入，让滚动条滚动到当前位置 scrollBy() 会在之前的数据基础上累加，可以利用 scrollBy()实现快速阅读的功能 查询计算样式 window.getComputedStyle(ele, null)[style] 第二个参数 null，放的是伪元素，可以获取伪元素的属性 计算样式只读 返回的计算样式都是绝对值，没有相对单位 -IE8 及以下不兼容（ele.currentStyle[style]） 封装函数，返回元素的第 n 层祖先元素节点 12345678function retParent(elem, n) { while(elem &amp;&amp; n) { elem = elem.parentElement n-- } return elem}var i = document.getElementByTagName('i')[0] 原型上封装函数 myChildren 获取子元素，解决一千浏览器的兼容性问题 123456789101112Element.prototype.myChildren = function () { var child = this.childNodes var len = child.length for (var i = 0;i &lt; len; i++) { if(child[i].nodeType == 1) { arr.push(child[i]) } } return arr}var div = document.getElementByTagName('div')[0] 自己封装 hasChildren()方法，不可用 children 属性 123456789101112Element.prototype.hasChildren = function () { var child = this.childNodes var len = child.length for (var i = 0;i &lt; len; i++) { if(child[i].nodeType == 1) { return true } } return false}var div = document.getElementByTagName('div')[0] 封装函数，返回元素 e 的第 n 个兄弟元素节点，n 为正，返回后面的兄弟元素节点，n 为负，返回前面的，n 为 0，返回自己 12345678910111213141516171819function retSibling(e, n) { while(e &amp;&amp; n) { if(n &gt; 0) { if(e.nextElementSibling) { e.nextElementSibling } else { for(e = e.nextSibling; e &amp;&amp; e.nodeType != 1; e = e.nextSibling) } n-- }else { if(e.previousElementSibling) { e = e.previousElementSibling } else { for(e = e.previousSibling; e &amp;&amp; e.nodeType != 1; e = e.previousSibling) } n++ } }} 封装 insertAfter(),功能类似与 insertBefore(new, origin),直接在 Element.prototype 上编程 12345678Element.prototype.insertAfter = function(new, origin) { var beforeNode = origin.nextElementSibling if (beforeNode == null) { this.appendChild(new) } else { this.insertBefore(new, beforeNode) }} 封装滚动条的 x 轴、y 轴的距离函数 12345678910111213function getScrollOffset() { if (window.pageXOffset) { return { x: window.pageXOffset, y: window.pageYOffset } } else { return { x: document.body.scrollLeft + document.documentElement.scrollLeft, y: document.body.scrollTop + document.documentElement.scrollTop } }} 封装可视区窗口大小的函数 1234567891011121314151617181920function getViewportOffset() { if (window.innerWidth) { return { w: window.innerWidth, h: window.innerHeight } } else { if (document.compatMode === 'BackCompat') { return { w: document.body.clientWidth, h: document.body.clientHeight } } else { return { w: document.documentElement.clientWidth, h: document.documentElement.clientHeight } } }} 封装样式获取的方法 1234567function getStyle(elem, prop) { if(window.getComputedStyle) { return window.getComputedStyle(elem, null)[prop] } else { return elem.currentStyle[prop] }}","link":"/2019/08/11/dom%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"js引擎的预编译和执行","text":"var 的变量提升底层原理 JavaScript引擎，不是逐条解释执行javascript代码，而是按照代码块一段段解释执行， 所谓代码块就是script标签分割的代码块。 js引擎的工作方式分为：预编译和执行代码两个阶段。 1）常见的编译型语言编译阶段：词法分析（生成词法单元）——&gt;语法分析（抽象语法树）——&gt;(语义检查，代码优化)——&gt;代码生成 2）对于解释型语言来说，通过词法分析和语法分析得到抽象语法树之后就开始执行了，在JavaScript 解释器在构造语法树的时候，如果无法构造，就会报语法错误，并结束整个代码块的执行。 而在整个编译阶段，会把“一等公民”function和var创建的变量进行提升。（其中函数提升在变量 提成之前） 3）JavaScript语法采用的是词法作用域，也就是javascript的变量和函数作用域是在定义时 决定的，函数调用时决定的是执行期上下文和作用域链，所以js解释器只需要静态分析就能确定每个 变量、函数的作用域，这种作用域也称为静态作用域。 执行上下文 全局执行上下文：默认的上下文，任何不再函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象(浏览器的情况下)，并且设置 this 的值等于这个全局对象。一个程序只会有一个全局执行上下文。 函数执行上下文：每当函数被调用时，都会为该函数创建一个新的上下文。 Eval 函数执行上下文：执行在 eval 函数内部的代码也会有属于它自己的执行上下文。 执行栈：JavaScript 引擎会以栈的方式来处理多个执行期上下文其他语言叫“调用栈”，类似于数据结构的栈 LIFO(后进先出)，用来存储代码运行时创建的所有执行上下文。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当 JavaScript 引擎第一次遇见脚本时，它会创建一个全局的执行上下文并且压入当前执行栈，每当引擎遇到一个函数调用，会为该函数创建一个新的执行上下文并压入栈的顶部。 引擎会执行那些执行上下文位于栈顶的函数，当函数执行结束时，执行上下文从栈顶弹出，控制流程到达当前栈中的下一个上下文。 当函数执行时，会创建一个成为 执行期上下文的内部对象。 执行期上下文就是 js 代码被解析和执行时的运行环境，函数每次执行都会创建一个独一无二的执行上下文，所以多次调用会产生多个执行上下文，当函数执行完毕，所产生的执行上下文被销毁。 执行上下文的生命周期包括三个阶段：创建阶段-&gt;执行阶段-&gt;挥手阶段 创建阶段会创建变量对象(Variable Object)，建立作用域链，确定 this 指向 1. 创建 Scope chain 2. 创建 AO 3. 设置 this 的值创建 AO 主要做了以下事情： 1. 创建 AO 对象 2. 形参和变量声明存储到 AO 对象 //赋值为 undefined 3. 将形参和实参相统一 4. 函数声明的函数名作为 AO 对象的 key，函数体作为 value 执行阶段会完成变量赋值，函数引用，以及执行其他代码。 AO(Active Object) &amp; VO(Variable Object)的区别？ VO：未进入执行上下文执行阶段之前，变量对象中的属性都不能访问。 AO：进入执行阶段之后，变量对象转变为活动对象，里面的属性都能访问了。 它们都是同一个对象，只是处于执行上下文的不同生命周期，而且只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。 如果函数引用了外部变量的值，则 JavaScript 引擎会为改函数创建一个闭包体（closure），闭包体是一个完全封闭和独立的作用域，他不会在函数调用完毕后就被 js 引擎当作垃圾进行回收，闭包体可以长期存在。 执行上下文总结： 单线程 同步执行，只有栈顶的上下文处于执行中，而其他上下文需要等待 全局上下文只有唯一的一个，它在浏览器关闭时出栈，而且其他所有上下文环境都可以直接访问全局上下文的属性 函数的执行上下文的个数没有限制 每次某个函数被调用，就会有新的执行上下文为其创建，即使是调用的自身函数，也是如此。 JS 执行机制同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入Event Table 并注册函数。 当指定的事情完成时（例如定时器执行完毕，获取数据结束等），Event Table会将这个函数移入Event Queue 主线程内的任务执行完毕为空，会去Event Queue（事件队列）读取对应的函数，进入主线程执行。 上述过程不断重复，称为Event Loop（事件轮询）","link":"/2019/08/13/js%E5%BC%95%E6%93%8E%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"title":"koa-generator快速搭建koa服务","text":"1.全局安装koa-generator脚手架 123npm install -g koa-generator# oryarn global add koa-generator 创建koa项目1234koa2 project-name// 使用ejs引擎koa2 -e project-name 进入项目安装依赖12cd project-nameyarn install 项目运行1234npm start# ornpm run dev# or... 使用 pm2 启动 koa 项目123456// 全局安装npm install -g pm2// 启动项目pm2 start ./bin/www// pm2自动重启pm2 start ./bin/www/ --watch pm2 相关命令（www 是项目名）12345pm2 list #查看所有已启动项目pm2 start #启动pm2 restart www #重启pm2 stop www #停止pm2 delete www #删除","link":"/2022/03/08/koa-generator%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAkoa%E6%9C%8D%E5%8A%A1/"},{"title":"mongo数据库","text":"开启 MongoDB 服务器 1sudo mongod --dbpath /usr/local/var/mongodb 连接 MongoDB 服务器1mongo 退出 MongoDB 服务器1exit 基本命令 show dbs 查看显示所有数据库 db 产看当前操作的数据库 use 数据库名称 切换到指定的数据库（没有会新建） show collections 显示集合 db.cats.find() 查看并显示内容 node 中使用 mongodb 使用第三方 mongoose 来操作 MongoDB 数据库 mongoose 安装npm install mongoose 123456789101112131415//引入包const mongoose = require('mongoose');//连接数据库（数据库不需要存在，在插入第一条语句，就会自动创建）mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});//设计数据库集合结构//创建一个Cat表const Cat = mongoose.model('Cat', { name: String });//实例化一个Cat，实例对象为kittyconst kitty = new Cat({ name: 'Zildjian' });//持久化保存kitty实例kitty.save().then(() =&gt; console.log('meow')); mongoose 的基本使用 生成模型构造函数 1234567891011121314151617181920212223242526272829303132333435var mongoose = require('mongoose');var Schema = mongoose.Schema;//设计集合结构（表结构）schema---&gt;提要，纲要//字段名称就是表结构中的属性名称//值类型//约束的目的：为了保证数的完整性var blogSchema = new Schema({ title: String, author: String, body: String, username: { type: String, required: true }, password: { typte: String, required: true } comments: [{ body: String, date: Date }], date: { type: Date, default: Date.now }, hidden: Boolean, meta: { votes: Number, favs: Number }});//将文档结构发布为模型// 参数一：大写单数表示数据库名称// mongoose会自动将大写单数改为小写复数// 参数二： 架构 Schema// 返回值： 模型构造函数var User = mongoose.model('User', blogSchema)// module.exports = mongoose.model('Student', blogSchema) 基于模型构造函数 生成添加一条数据 123456789101112var admin = new User({ username: 'admin', password: '1245435', ....})admin.save(function(err, ret){ if(err){ console.log('保存失败') } else { console.log('保存成功') }}) 基于模型构造函数 查询数据 12345678910111213141516171819202122232425262728293031323334353637//查询所有数据User.find(function(err, ret){ if(err){ console.log('查询失败') } else { console.log(ret) }})//promise 查询所有User.find() .then(function(data){ console.log(data) })//按条件查询 User.find({ username: 'xx' }, function(err, ret){ if(err){ console.log('查询失败') } else { console.log(ret) }})//查找符合条件的第一个（可以写多个条件）,没有条件的话，为第一条数据 User.findOne({ username: 'xx' }, function(err, ret){ if(err){ console.log('查询失败') } else { console.log(ret) }}) 基于模型构造函数 按条件更新数据 1234567891011//Model.update(conditions, doc, [options], [callback])//Model.findOneAndUpdate([conditions], [update], [options], [callback])User.findByIdAndUpdate('5a7d8f2sd78ag6g',{ username: 'zs'}, function(err, ret){ if(err){ console.log('更新失败') else { console.log('更新成功') }}) 基于模型构造函数 删除数据 123456789User.remove({ username: 'zs'}, function(err, ret){ if(err){ console.log('查询失败') else { console.log(ret) }}) 补充（node 使用 mysql）123456789101112131415161718192021222324252627//引包var mysql = require('mysql');//创建连接var connection = mysql.createConnection({ host : 'localhost', user : 'me', password : 'secret', database : 'my_db'}); //连接数据库connection.connect(); //执行数据操作,可以直接使用 SQL 语句 //查找connection.query('SELECT * FROM `users`', function (error, results, fields) { if (error) throw error; console.log('The solution is: ', results[0].solution);});//添加 connection.query('INSERT INTO users VALUES(NULL, &quot;admin&quot;:&quot;123&quot;)', function (error, results, fields) { if (error) throw error; console.log('The solution is: ', results[0].solution); }); //关闭数据库connection.end(); 阿里云服务器 安装 nodejs 安装 mongod 安装 redis3.1 redis-server 启动 redis3.2 ps axu | grep redis 查看 redis 服务进程 安装 nginx4.1 nginx -s reopen // 重新指定日志打印的文件4.2 nginx - t //检测配置文件是否有语法错误4.3 nginx -s reload // 重新加载配置文件","link":"/2023/05/31/mongo%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"Node.js相关知识","text":"Node.js 是什么? Node.js 是一个 JavaScript 运行时环境，可以解析和执行 js 代码。 构建于 Chrome 的 V8 引擎之上 没有 BOM、DOM，有 EcmaScript 语法。 node 中有很多具名的核心模块 fs 文件操作模块 http 服务器构建模块 path 路径模块 os 操作系统信息模块 在核心模块中提供了一些服务器级别的操作 API - 文件读写 - 网络服务的构建 - 网络通信 - http 服务器 node 都有哪些特性？ 单线程 不会为每个用户连接创建一个新的线程，仅仅使用一个线程，减少了操作系统的线程创建和销毁的时间开销。缺点就是一个用户造成线程的崩溃会导致整个服务的崩溃。 减少内存的开销 事件驱动 event-driven node 中一个时刻只能执行一个事件回调函数，但是执行过程中，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。 非阻塞 I/O I/O 数据传输操作会阻塞代码的执行，极大降低了程序的执行效率,因为一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。非阻塞 I/O 机制，可以将异步操作的处理代码放在回调函数中，从而提高了程序的执行效率。 浏览器的进程和线程 一个程序可以有多个进程 一个进程可以有多个线程 进程在执行 u 欧城中拥有独立的内存单元，而多个线程共享内存。 多个线程之间可以相互通信 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口 线程不能独立执行，必须依存在应用程序中 Node.js 适合开发什么？ 善于 I/O,不善于计算，因为 Node.js 最擅长的就是任务调度，不适合于利用 CPU 进行过多的运算的程序。 当应用程序需要处理大量并发的 I/O,而在向客户端发出响应之前，应用程序内部不需要进行非常复杂处理的时候，Node.js 非常合适。 Node.js 也非常适合与 web socket 配合，开发长连接的实时交互应用程序。 用户表单 考试系统 聊天室 图文直播 nodejs 能做什么？ Node.js 可以生成动态页面内容 Node.js 可以创建，打开，读取，写入，删除和关闭服务器上的文件 Node.js 可以收集表单数据 Node.js 可以添加，删除，修改数据库中的数据 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务器渲染可以被爬虫抓取 例如：京东商品列表是服务端渲染，用户评论是客户端渲染（提高用户体验） 小补充：使用 cnpm 方法一 安装 cnpm npm install --global cnpm 方法二 改变 registry npm install jquery --registry=https://registry.npm.taobao.org 方法三 加入配置选项 npm config set registry https://registry.npm.taobao.org npm config list 用 nodejs 实现读取文件操作 const fs = require(&quot;fs&quot;) //fs 核心模块提供了一个fs.readFile方法，用来读取指定目录下的文件 //fs.readFile有三个参数 // 1. 读取文件的路径 // 2. 读取文件的编码格式 // 3. 当文件读取完成，调用这个callback回调函数来读取文件的结果 fs.readFile('./data/hello.txt','utf-8',function(err,data){ if(err){ console.log(err) //第一个参数是err对象 return } else { console.log(data) //第二个参数才是data数据 } }) 用 nodejs 实现写入文件操作const fs = require('fs') let msg = 'hello world' //fs.writeFile有三个参数 // 1. 第一个参数为写入的文件路径 // 2. 第二个参数为写入的内容 // 3. 第三个参数为可选参数，表示写文件的编码格式 // 4. 第四个参数为回调函数，回调函数只有一个参数err，判断是否写入成功。 fs.writeFile('./data/hello.txt',msg,'utf-8',function(err){ if(err){ console.log('写入错误' + err) } else { console.log('ok') } }) nodejs 如何开启进程，进程如何通讯？ 进程 process VS 线程 thread 进程： 进行资源分配和调度的最小单元，有独立内存空间 线程： 进行运算调度的最小单元，共享进程内存空间 js 是单线程的，但可以多进行执行，如 、WebWorker 为何需要多进程？ 多核 CPU，更适合处理多进程 内存较大，多个进程才能更好的利用（单进程有内存上线） 开启进程两种方法 child_process.fork， cluster.fork 1234567891011121314151617181920212223242526// parent.jsconst http = require('http');const fork = require('child_process').fork;const server = http.createServer((req, res) =&gt; { if (req.url === '/xxx') { // 开启子进程 const computeProcess = fork('./compute.js'); computeProcess.send('start'); computeProcess.on('message', (data) =&gt; { res.end('sum is' + data); }); computeProcess.on('close', () =&gt; { console.log('子进程因报错而退出'); computeProcess.kill(); res.end('error'); }); }});server.listen(3000, () =&gt; { console.log('localhost: 3000 starting...');}); 12345678910111213141516171819// compute.jsfunction getSum() { let sum = 0; for (let i = 0; i &lt; 10000; i++) { sum += i; } return sum;}process.on('message', (data) =&gt; { console.log('子进程id', process.pid); console.log('子进程接收到的数据', data); const sum = getSum(); process.send(sum);}); 123456789101112131415161718192021const http = require('http');const cpuCoreLength = require('os').cpus().length;const cluster = require('cluster');if (cluster.isMaster) { for (let i = 0; i &lt; cpuCoreLength; i++) { cluster.fork(); // 开启子进程 } cluster.on('exit', (worker) =&gt; { console.log('子进程退出'); cluster.fork(); // 进程守护 });} else { const server = http.createServer((req, res) =&gt; { res.writeHead(200); res.end('done'); }); server.listen(3000);} CommonJS 解析 CommonJS 的核心思想是通过 require 方法来同步加载依赖的其他模块，通过 module.export 来导出需要暴露的接口 require 内部逻辑：例如：require(X) 如果 X 是内置模块（比如 require(‘http’)）a. 返回该模块b. 不再继续执行 如果 X 以 ‘./‘或者 ‘../‘开头a. 根据 X 所在父模块，确定 X 的绝对路径b. 将 X 当作文件，依次查找以下文件（.x ｜.x.js | .x.json | .x.node），只要一个存在就返回该文件，不再继续执行c. 把 X 当作目录，依次查找以下文件（.x/package.json | .x/index.js | .x/index.json | .x/index.node），只要一个存在就返回并不再执行 如果 X 不带路径a. 根据 X 所在父模块，确定 X 可能的安装目录，依次往上级目录查找，把 X 当成文件名或目录名加载 找不到抛错’not found’","link":"/2019/08/29/node.js%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"},{"title":"React深入浅出知识链路","text":"react 渲染流程？ React16 以前 React 的组件更新创建虚拟 DOM 和 Diff 的过程是不可中断，如果需要更新组件树层级非常深的话,diff 过程会占用浏览器线程，阻塞 js 执行以及 dom 渲染，基于以上原因 react 团队调整架构将原来数据结构的虚拟 dom 改为 fiber 数据结构，实现由原来不可中断的更新过程变成异步可中断的更新（双缓存机制）吗， React Filber 架构分为三层: Scheduler（调度器，调度任务优先级，高优先级任务进入 Reconciler） Reconciler（协调器，diff 算法找出变化的组件） Renderer（渲染器，将组件渲染到页面） React18 开启 concurrent mode 通过时间切片解决了任务拆分和任务优先级的问题，整个 Fiber 树的更新流程分为 render 阶段和 commit 阶段。 首先在 DOM 挂载和更新的时候会通过 React.createElement(后改为 babel、tsx 更编译工具引入 react/jsx-runtime 包引入),将 react 组件变成 jsx 对象，或者叫 virtual-dom 这些渲染任务会经过 Scheduler 的调度根据优先级的不同，通过帧率动态调整，计算剩余时间，模拟 requestIdleCallback，实现了时间切片，决定哪些任务进入 render 阶段， 在 render 阶段根据 jsx 对象构建新的 workInProgressFiber 树，通过 Reconciler 协调器对比 jsx 和当前 fiber 的差异标记对应的副作用tag，（比如在mount 时 fiber 节点标记为 placement），将有副作用（placement 插入、update 更新、deletetion 删除等）的 fiber 节点加入一条单向循环链表中，子节点副作用存放在父节点。 在 commit 阶段（分为 before mutation、mutation、layout 阶段）会遍历这条链表，执行副作用处理响应的生命周期（如 placement 插入，执行 passive：useEffect 的副作用），然后将处理后的节点渲染到真实 DOM 节点，这个过程会引用不同的渲染器，在浏览器中就是 react-dom，在 canvas 或 svg 中就是 react-art 等。 在 update 时根据最新的 jsx 对象对比 current fiber，在构建新的 workInProgressFiber 树（diff 算法），对比过程同样会收集副作用 更新的时候利用的是在内存中构建并直接替换的双缓存技术，react 中最多会同时存在两颗 fiber 树，屏幕上显示内容对应的 fiber 树为 current fiber 树，正在内存中构建的 fiber 树为 workInProgressFiber 树 两颗缓存树之间的替换操作是在 commit 阶段的 mutation 之后 layout 之前执行的 root.finishedWork = root.current.alternate diff 策略 React 文档中提到即使最前沿的算法，前后两棵树完全比对的算法时间复杂度为 O(n^3)，其中 n 是树中元素的数量。所以为了降低算法复杂度，React 的 diff 策略会预设三个限制 只对同级元素进行 Diff，如果 Dom 节点在两次更新中跨越了层级，那么 React 不会尝试复用它 不同类型的元素不复用，如果元素由 div 变为 p，React 会销毁 div 及其子孙节点，并新建 p 及其子孙节点 通过 key prop 来确定 dom 节点的更新情况 React 可以从同级的节点数量将 Diff 分为单节点 diff 和多节点 diff 单节点 diff 优先判断 key 是否相同，如果 key 相同判断 type 是否相同，只有都相同才会复用 dom 节点，type 不同将其 child 及其兄弟 fiber 都标记删除，如果仅 key 不同仅将其 child 标记删除 多节点 diff，分为三种情况新增、删除和更新，但是更新操作的优先级要更高，因为在日常开发中，更新组件发生的频率更高，所以 diff 会优先判断当前节点是否属于更新操作，而且在 diff 的时候 react 针对同级的 fiber 节点是通过 oldFiber.sibling 指针链接形成的单链表，所以无法使用双指针（从数组头和尾同时遍历提高效率）优化。基于这个原因，react 的 diff 算法的整体逻辑会经历两轮遍历：第一轮处理更新的节点，第二轮处理剩下的不属于更新的节点 当 shouldYield 为 true，以至于 performUnitOfWork 被中断后如何重新启动？ React 架构中的 Scheduler 调度器包含两个功能时间切片、优先级调度 时间切片采用执行时机更靠前的 MessageChannel，如果当前宿主环境不支持 MessageChannel 则使用 setTimeout，而且在 Scheduler 中为任务分配的初始剩余时间为 5ms，随着应用运行会根据 fps 动态调整任务的可执行时间 优先级调度是通过 runWithPriority 实现的，接收一个优先级和一个回调函数，其中不同的优先级对应的是不同时长的任务过期时间 Scheduler 中存在两个队列 timerQueue 保存未就绪任务、taskQueue 保存已就绪任务，当 shouldYield 为 true 时，会在 taskQueue 已就绪任务中通过小顶堆查找时间最早的任务并执行它 配置 delay 代表‘task 需要延迟执行时间’，会先进入 timerQueue，当 delay 对应时间结束后会从 timerQueue 取出进入 taskQueue taskQueue 会根据 task.expirationTime 作为排序依据，值越小代表 task 的优先级越高。 配置 delay 且未到期一定不会执行，配置 delay 且到期或者未配置 delay 会根据 task.expirationTime 排序调度并执行，过期 task 执行时不会被打断 React 优先级队列的实现使用的数据结构为小顶堆 特点：是一颗完全二叉树，除最后一层外，其他层的节点个数都是满的，且最后一层节点靠左排列。堆中每个节点的值都小于等于其子树节点的值 由于堆化操作已经完成对堆的排序，所以 peek 获取最小的值时间复杂度为 O(1) 宏任务选择优先级高到低 在支持 setImmediate 的环境中，node.js 和旧版本 IE 中，使用 setImmediate 调度宏任务，相比 MessageChannel 执行时机更早 在支持 MessageChannel 的环境中（浏览器，worker 中），使用 MessageChannel 调度宏任务，通过 MessagePort 属性发送数据 其余情况使用 setTimeout 调度宏任务，存在最小延迟时间，执行时机晚于上述两个 api PureComponent会对 props 和 state 进行浅比较（可能会因为深层的数据不一致而产生错误的否定判断），跳过不比较的更新，提高组件性能 PureComponent 和 shouldComponentUpdate 的关系PureComponent通过自带的 props 和 state 浅比较实现了shouldComponentUpdate(nextProps, nextState) memomemo接收两个参数： 第一个参数：组件本身，也就是要优化的组件 第二个参数：(preProps, nextProps)=&gt;boolean, 若为 true 则不更新，为 false 则更新 生命周期 v16.0 前四大阶段：Initialization（初始化）、Mounting（挂载）、Update（更新）、Unmounting（卸载） Initailization： constructor()：初始化操作，定义 this.state 的初始内容，只会执行一次 super 的作用：调用基类构造方法，将父组件的 props 注入子组件，供子组件读取（props 只读不可变，state 可变） Mounting componentWillMount：组件挂载到 DOM 前调用，只调用一次不会引起组件重渲染 render：渲染 componentDidMount：组件挂载到 DOM 后调用，只调用一次 Update componentWillReceiveProps(nextProps): 调用与 props 引起的组件更新过程中 shouldComponentUpdate(nextProps, nextState): 性能优化组件，返回 false 停止更新，减少组件的不必要渲染，优化性能 componentWillUpdate(nextProps, nextState):组件更新前调用 componentDidUpdate(prevProps, prevState):组件更新后调用 Unmounting componentWillUnmount：组件被卸载前调用，执行一些清理工作，避免内存泄漏 React v16.4 后移除了：componentWillMount、componentWillReceiveProps、componentWillUpdate新增了：static getDerivedStateFromProps、getSnapshotBeforeUpdate getDerivedStateFromProps(prevProps, prevState):组件创建和更新时调用getSnapshotBeforeUpdate(prevProps, prevState):更新时 DOM 节点渲染前，获取 DOM 信息（如滚动位置），返回值作为参数传递给 componentDidUpdate React v16.8 的 hooks useState useEffect useLayoutEffect：同步，useLayoutEffect 在 DOM 更新之后，浏览器绘制之前，浏览器只会绘制一次，useLayoutEffect 先于 useEffect 前执行，如果在 useEffect 中改变 DOM，可能会导致浏览器再次回流和重绘，useLayoutEffect 的 callback 中代码执行会阻塞浏览器绘制 useReducer useMemo useCallback useRef useImperativeHandle(ref, createHandle, [deps]):createHandle 返回值作为暴露给付组件的 ref 对象 useDebugValue：可用于在 React 开发者工具中显示自定义 hook 的标签 React v18 的 hooks useSyncExternalStore：是一个推荐用于读取和订阅外部数据源的 hook，其方式与选择性的 hydration 和时间切片等并发渲染功能兼容 useTransition：返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。 useDeferredValue：接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。 useId ： 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。 react-dom createPortal: 在 Portal 中提供了一种将子节点渲染到已 DOM 节点中的方式，该节点存在于 DOM 组件的层次结构之外。 flushSync：可以将回调函数中的更新任务，放到一个较高级的优先级中，适用于强制刷新，同时确保了 DOM 会被立即更新 unstable_batchedUpdates :可用于手动批量更新 state，可以指定多个 setState 合并为一个更新请求 虚拟 DOM 的优缺点？优点： 处理了浏览器兼容性问题，避免了用户操作真实 DOM 内容经过 xss 处理，可以防范 xss 攻击 跨平台开发 更新的时候可以实现差异化更新，减少更新 DOM 的操作 缺点： 虚拟 DOM 需要消耗额外的内存 首次渲染不一定会更快 Portal 传送门 可以将 DOM 结构脱离父节点渲染到指定节点位置，并且不会破坏事件传播，事件冒泡会正常工作，生命周期正常执行。常见使用场景：渲染模态框、工具提示、弹出消息等 useEffect 和 useLayoutEffect 的执行时机 useEffect 在 beforeMutation 阶段调度 flushPassiveEffects，在 layout 阶段注册 destroy、create 函数，mutation 阶段执行 destroy 函数，在 commit 阶段完成后，异步执行 flushPassiveEffects，内部执行注册的回调 useLayoutEffect 在 mutation 阶段执行 destroy 销毁函数，在 layout 阶段执行 create 创建函数 getSnapshotBeforeUpdate 生命周期钩子在 beforeMutation 阶段执行","link":"/2021/10/05/react%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF/"},{"title":"typescript知识浅析","text":"TypeScript 中的数据类型 typescript 中为了使编写的代码更规范，更利于维护，增加了类型校验，在 typescript 中主要提供了以下数据类型： unknown (Top Type) 保留静态检查能力，但是不能调用任何方法 布尔类型 bolean 数字类型 number 字符串类型 string 数组类型 array 元组类型 tuple 枚举类型 enum 任意类型 any null 和 undefined void 类型 never 类型 (Bottom Type) 联合类型的过滤 防御性编程，switch 类型收窄 类型之间的并集(|)会向上取顶部类型，即 never | ‘a’ =&gt; ‘a’, unknown | ‘a’ =&gt; unknown;类型之间的交集(&amp;)会向下取底部类型，即 never &amp; ‘a’=&gt;never, unknown &amp; ‘a’ =&gt; ‘a’; ts 中 Object 和 object 这两个类型的区别？ Object 可以被赋值为原始类型，但是 object 只能赋值为复杂数据类型 ts 中 type 和 interface 的区别 type 可以声明基本类型别名，联合类型，元祖等类型 interface 能够声明合并 interface 可以 extends 进行类型扩展，type 可以通过交叉类型(&amp;)实现 interface 的 extend 行为。","link":"/2019/08/23/typescript%E7%9F%A5%E8%AF%86%E6%B5%85%E6%9E%90/"},{"title":"TS进阶题目","text":"在线 TS 地址 typescript 第一题 以下代码为什么会提示错误，应该如何解决上述问题？ 1234567891011type User = { id: number; kind: string;}function createCustomer&lt;T extends User&gt;(u: T): T { return { id: u.id, kind: 'customer' }} 第一种解决方案 1234567891011type User = { id: number; kind: string;}function createCustomer&lt;T extends User&gt;(u: T): User { return { id: u.id, kind: 'customer', }} 第二种解决方案 123456789101112type User = { id: number; kind: string;}function createCustomer&lt;t extends User&gt;(u: T): T { return { ...u, id: u.id, kind: 'customer' }} 第二题 以下函数我们希望参数a和b的类型都是一致的，即a和b同时为number或string类型，当它们的类型不一致时，ts 类型检查器能自动提示对应的错误信息。 123456789101112function f(a: string | number,b: string | number) { if (typeof a === 'string') { return a + ':' + b; } else { return a + b; }}f(1, 2); // OKf('a', 'b'); // OKf('a', 2); // Errorf(1, 'b'); //Error 第一种解决方案 函数重载 1234567891011121314function f(a: string, b: string): string;function f(a: number, b: number): number;function f(a: string | number, b: string | number): string | number { if (typeof a === 'string') { return a + ':' + b; } else { return (a as number) + (b as number); }}f(1, 2); // OKf('a', 'b'); // OKf(1, 'b'); // Errorf('a', 2); // Error 第二种解决方案 自定义路由守卫 1234567891011121314const isStringArray = (params: string[] | number[]): params is string[] =&gt; typeof params[0] === 'string';function f(...args: string[] | number[]) { if (isStringArray(args)) { return args[0] + ':' + args[1]; } else { return args[0] + args[1]; }}f(1, 2); // OKf('a', 'b'); // OKf(1, 'b'); // Errorf('a', 2); // Error 第三种解决方案 范型 123456789101112function f&lt;T extends string | number&gt;(a: T, b: T) { if (typeof a === 'string') { return a + ':' + b; } else { return (a as number) + (b as number); }}f(1, 2); // OKf('a', 'b'); // OKf(1, 'b'); // Errorf('a', 2); // Error 第三题 实现 SetOptional 工具类型，支持把给定的 keys 对应的属性变为可选，参考Partial 实现 SetRequired 工具类型，支持把给定的 keys 对应的属性变成必填，参考 Require 1234567891011121314151617181920212223242526272829// SetOptional 测试用例type Foo = { a: number; b?: string; c: boolean;}type SomeOptional = SetOptional&lt;Foo, 'a' | 'b'&gt;type SomeOptional = { a?: number; //该属性变为可选的 b?: string; //保持不变 c: boolean;}// SetRequired 测试用例type Foo = { a: number; b?: string; c: boolean;}type SomeRequired = SetRequired&lt;Foo, 'a' | 'b'&gt;type SomeRequired = { a: number; //保持不变 b: string; //该属性变为必选的 c: boolean;} 解决方案 1 SetOptional 1234567891011121314type Foo = { a: number; b?: string; c: boolean;}// 对交叉类型进行扁平化处理type Simplify&lt;T&gt; = { [P in keyof T]: T[P]}type SetOptional&lt;T, K extends keyof T&gt; = Simplify&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;&gt;type SomeOptional = SetOptional&lt;Foo, 'a' | 'b'&gt; SetRequired 12345678910111213type Foo = { a: number; b?: string; c: boolean;}type Simplify&lt;T&gt; = { [P in keyof T]: T[P]}type SetRequired&lt;T, K extends keyof T&gt; = Simplify&lt;Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt; &amp; Required&lt;Pick&lt;T, K&gt;&gt;&gt;type SomeRequired = SetRequired&lt;Foo, 'b' | 'c'&gt; 解决方案 2 1234567891011121314151617type Foo = { a: number; b?: string; c: boolean;}type Simplely&lt;T&gt; = { [P in keyof T]: T[P]}type SetOptional&lt;T, K extends keyof T&gt; = Simplely&lt;{ [X in keyof Omit&lt;T, K&gt;]: T[X]; } &amp; { [P in K]?: T[P] }&gt;;type SetRequired&lt;T, K extends keyof T&gt; = Simplely&lt;{ [X in keyof Omit&lt;T, K&gt;]: T[X]; } &amp; { [P in K]-?: T[P] }&gt;;// 测试用例type SomeOptional = SetOptional&lt;Foo, 'a' | 'b'&gt;;type SomeRequired = SetRequired&lt;Foo, 'b' | 'c'&gt;; 解决方案 3 1234567type Simplify&lt;T&gt; = { [P in keyof T]: T[P]}type SetOptional&lt;T, K extends keyof T&gt; = Simplify&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt;;type SetRequired&lt;T, K extends keyof T&gt; = Simplify&lt;Required&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt; 第四题 Pick&lt;T, K extends keyof T&gt; 的作用是将某个类型中的字属性挑出来，得到包含这个类型部分属性的字类型。 123456789101112interface Todo { title: string; description: string; completed: boolean;}type TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;const todo: TodoPreview = { title: &quot;clean room&quot;, completed: false} 问题：如何定义一个ConditionalPick工具类型，支持根据指定的Condition条件来生成新的类型，对应的使用示例如下： 12345678910interface Example { a: string; b: string | number; c: () =&gt; void; d: {}}// 测试用例type StringKeyOnly = ConditionalPick&lt;Example, string&gt;;// =&gt; {a: string} 解决方案 神奇的 as 1234567891011121314interface Example { a: string; b: string | number; c: () =&gt; void; d: {};}type ConditionalPick&lt;T, K&gt; = { [P in keyof T as (T[P] extends K ? P : never)]: T[P]}// 测试用例type StringKeysOnly = ConditionalPick&lt;Example, string&gt;;// =&gt; {a: string} 第五题 定义一个工具类型AppendArgument,为已有函数累心增加指定类型的参数，新增的参数名是x，将作为新函数类型的第一个参数，示例如下： 123456type Fn = (a: number, b: string) =&gt; number;type AppendArgument&lt;F, A&gt; = // 你的实现代码// 测试用例type FinalFn = AppendArgument&lt;Fn, boolean&gt;// (x: boolean, a: number, b: string) =&gt; number; 解决方案 1 延伸阅读 掌握 TS 这些工具类型，让你开发事半功倍 123456type AppendArgument&lt;F extends (...args: any) =&gt; any, A&gt; = (x: A, ...args: Parameters&lt;F&gt;) =&gt; ReturnType&lt;F&gt;type Fn = (a: number, b: string) =&gt; number;type FinalFn = AppendArgument&lt;Fn, boolean&gt;;// (x: boolean, a: number, b: string) =&gt; number; 解决方案 2 延伸阅读 用上这几招，轻松实现 TS 类型提取 123456type AppendArgument&lt;F, T&gt; = F extends (...args: infer Args) =&gt; infer Return ? (x: T, ...args: Args) =&gt; Return : never;type Fn = (a: number, b: string) =&gt; number;type FinalFn = AppendArgument&lt;Fn, boolean&gt;;// (x: boolean, a: number, b: string) =&gt; number 第六题 定义一个 NativeFlat 工具类型，支持把数组类型拍平(扁平化),示例如下： 12345type NativeFlat&lt;T extends any[]&gt; = // 实现代码//测试用例type NativeResult = NativeFlat&lt;[['a'],['b','c'],['d']]&gt;;// =&gt; &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; 在完成NativeFlat工具类型之后，继续实现DeepFlat工具类型，以支持多维数组类型： 123456type DeepFlat&lt;T extends any[]&gt; = unknown // 你的实现代码// 测试用例type Deep = [['a'], ['b', 'c'], [['d']], [[[['e']]]]];type DeepTestResult = DeepFlat&lt;Deep&gt;// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; 解决方案 NativeFlat 123456type NaiveFlat&lt;T extends any[]&gt; = { [P in keyof T]: T[P] extends any[] ? T[P][number] : T[P]}[number]type NaiveResult = NaiveFlat&lt;[['a'], ['b', 'c'], ['d']]&gt;// NaiveResult的结果： &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; DeepFlat 12345678type Deep = [['a'], ['b', 'c'], [['d']], [[[['e']]]]];type DeepFlat&lt;T extends any[]&gt; = { [K in keyof T]: T[K] extends any[] ? DeepFlat&lt;T[K]&gt; : T[K]}[number]type DeepTestResult = DeepFlat&lt;Deep&gt;// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; 第七题 使用类型别名定义一个EmptyObject类型，是的该类型只允许空对象赋值： 1234567type EmptyObject = {}// 测试用例const shouldPass: EmptyObject = {}; // OKconst shouldFail: EmptyObject = { // Error prop: &quot;TS&quot;} 更改以下takeSomeTypeOnly函数类型定义，让参数只允许严格 SomeType 类型的值，示例如下： 123456789101112type SomeType = { prop: string;}function takeSomeTypeOnly(x: SomeType) {return x};// 测试用例const x = {prop: 'a'};takeSomeTypeOnly(x); // OKconst y = {prop: 'a', additionalProp: 'x'};takeSomeTypeOnly(y); // Error 解决方案 EmptyObject 1234567891011// type PropertyKey = string | number | symbol;type EmptyObject = { [K in PropertyKey]: never;}// 测试用例const shouldPass: EmptyObject = {}; // OKconst shouldFail: EmptyObject = { // Error prop: &quot;TS&quot;} takeSomeTypeOnly 12345678910111213141516type SomeType = { prop: string;}type Exclusive&lt;T1, T2 extends T1&gt; = { [K in keyof T2]: K extends keyof T1 ? T2[K] : never;}function takeSomeTypeOnly&lt;T extends SomeType&gt;(x: Exclusive&lt;SomeType, T&gt;) {return x};// 测试用例const x = {prop: 'a'};takeSomeTypeOnly(x); // OKconst y = {prop: 'a', additionalProp: 'x'};takeSomeTypeOnly(y); // Error 第八题 定义一个NonEmptyArray工具类型，用于确保数据为非空数组 1234type NonEmptyArray&lt;T&gt; = // 代码实现const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 解决方案 1 1234type NonEmptyArray&lt;T&gt; = [T, ...T[]];const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 解决方案 2 12345type NonEmptyArray&lt;T&gt; = T[] &amp; {0: T};const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 解决方案 3 12345678type NonEmptyArray&lt;T&gt; = { [P in number]: T;} &amp; { 0: T};const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 第九题 定义一个JoinStrArray工具类型，用于根据指定的Separator分隔符，对字符串数据类型进行拼接，示例如下： 1234567type JoinStrArray&lt;Arr extends string[], Separator extends string, Result extends string = &quot;&quot;&gt; = // 你的实现代码// 测试用例type Names = [&quot;Sem&quot;, &quot;Lolo&quot;, &quot;Kaquko&quot;]type NamesComma = JoinStrArray&lt;Names, &quot;,&quot;&gt; // &quot;Sem,Lolo,Kaquko&quot;type NamesSpace = JoinStrArray&lt;Names, &quot; &quot;&gt; // &quot;Sem Lolo Kaquko&quot;type NamesStars = JoinStrArray&lt;Names, &quot;⭐️&quot;&gt; // &quot;Sem⭐️Lolo⭐️Kaquko&quot; 解决方案 12345678910111213141516171819type JoinStrArray&lt; Arr extends string[], Separator extends string, Result extends string = &quot;&quot;&gt; =Arr extends [infer El,...infer Rest]? Rest extends string[]? El extends string? Result extends &quot;&quot;? JoinStrArray&lt;Rest, Separator,`${El}`&gt;: JoinStrArray&lt;Rest, Separator,`${Result}${Separator}${El}`&gt;: `${Result}`: `${Result}`: `${Result}`type Names = [&quot;Sem&quot;, &quot;Lolo&quot;, &quot;Kaquko&quot;]type NamesComma = JoinStrArray&lt;Names, &quot;,&quot;&gt; // &quot;Sem,Lolo,Kaquko&quot;type NamesSpace = JoinStrArray&lt;Names, &quot; &quot;&gt; // &quot;Sem Lolo Kaquko&quot;type NamesStars = JoinStrArray&lt;Names, &quot;⭐️&quot;&gt; // &quot;Sem⭐️Lolo⭐️Kaquko&quot; 第十题 实现一个Trim工具类型，用于对字符串字面量类型进行去空格处理，示例如下： 123type Trim&lt;V extends string&gt; = // 代码实现type Result = Trim&lt;' foolishmax '&gt; 解决方案 123456type TrimLeft&lt;V extends string&gt; = V extends ` ${infer R}` ? TrimLeft&lt;R&gt; : V;type TrimRight&lt;V extends string&gt; = V extends `${infer R} `? TrimRight&lt;R&gt; : V;type Trim&lt;V extends string&gt; = TrimLeft&lt;TrimRight&lt;V&gt;&gt;;type Result = Trim&lt;' foolishmax '&gt; 第十一题 实现一个*IsEqual&lt;A, B&gt;*工具类型，用于比较两个类型是否相等，示例如下： 123456type IsEqual&lt;A, B&gt; = // 代码实现// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1, {a: 1}}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false 解决方案（原始方案） 1 123456789101112type IsEqual&lt;A, B&gt; = A extends B ? (B extends A ? true : false) : false;// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1}, {a: 1}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false// errortype E3 = IsEqual&lt;true, boolean&gt; // booleantype E4 = IsEqual&lt;1 | 2, 1&gt; // boolean这是因为泛型和*extends*两者结合所产生的*distributive conditionial types*效应导致的 解决方案（稍微优化）2 12345678910111213141516type IsEqual&lt;A, B&gt; = [A] extends [B] ? [B] extends [A] ? true : false : false或type IsEqual&lt;A, B&gt; = [A, B] extends [B, A] ? true : false// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1}, {a: 1}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false// errortype E3 = IsEqual&lt;any, string&gt; // truetype E4 = IsEqual&lt; { name: string }, { readonly name: string }&gt; // true这是因为Ts中any可以赋值为任何类型，任何类型也可以赋值给any，这就意味着any和任意类型之间都是assignable的，对于extends而言就是都可以相互extends的，所以E3是true。readonly不会改变assignable。 解决方案 4 12345678type IsEqual&lt;A, B&gt; =(&lt;G&gt;() =&gt; G extends A ? 1 : 2) extends(&lt;G&gt;() =&gt; G extends B ? 1 : 2) ? true : false;// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1}, {a: 1}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false 第十二题 实现一个Head工具类型，用于获取数组类型的第一个类型，示例如下： 123456type Head&lt;T extends Array&lt;any&gt;&gt; = // 代码实现// 测试用例type H0 = Head&lt;[]&gt; // nevertype H1 = Head&lt;[1]&gt; // 1type H2 = Head&lt;[2,3,4]&gt; // 2 解决方案 1 123456type Head&lt;T extends Array&lt;any&gt;&gt; = T extends [] ? never : T[0];// 测试用例type H0 = Head&lt;[]&gt; // nevertype H1 = Head&lt;[1]&gt; // 1type H2 = Head&lt;[2,3,4]&gt; // 2 解决方案 2 123456type Head&lt;T extends Array&lt;any&gt;&gt; = T extends [head: infer H, ...rest: any[]] ? H : never;// 测试用例type H0 = Head&lt;[]&gt; // nevertype H1 = Head&lt;[1]&gt; // 1type H2 = Head&lt;[2,3,4]&gt; // 2 第十三题 实现一个Tail工具类型，用于获取数组类型除了第一个类型外，剩余的类型，示例如下： 123456type Tail&lt;T extends Array&lt;any&gt;&gt; = // 代码实现// 测试用例type T0 = Tail&lt;[]&gt; //[]type T1 = Tail&lt;[1, 2]&gt; // [2]type T2 = Tail&lt;[1, 2, 3, 4, 5]&gt; //[2, 3, 4, 5] 解决方案 123456type Tail&lt;T extends Array&lt;any&gt;&gt; = T extends [infer A, ...infer B] ? B : [];// 测试用例type T0 = Tail&lt;[]&gt; //[]type T1 = Tail&lt;[1, 2]&gt; // [2]type T2 = Tail&lt;[1, 2, 3, 4, 5]&gt; //[2, 3, 4, 5] 第十四题 实现一个Unshift工具类型，用于把指定类型 E 作为第一个元素添加到T数组类型中，示例如下： 12345type Unshift&lt;T extends any[], E&gt; = // 代码实现// 测试用例type U0 = Unshift&lt;[], 1&gt;; // [1]type U1 = Unshift&lt;[1, 2, 3], 0&gt;; //[0, 1, 2, 3] 解决方案 12345type Unshift&lt;T extends any[], E&gt; = [E, ...T];// 测试用例type U0 = Unshift&lt;[], 1&gt;; // [1]type U1 = Unshift&lt;[1, 2, 3], 0&gt;; //[0, 1, 2, 3] 第十五题 实现一个Shift工具类型，用于移除T数组类型中的第一个类型，示例如下： 12345type Shift&lt;T extends any[]&gt; = // 代码实现// 测试用例type S0 = Shift&lt;[1, 2, 3]&gt;type S1 = Shift&lt;[string, number, boolean]&gt; 解决方案 1234567type Shift&lt;T extends any[]&gt; = T extends [infer A, ...infer B] ? B : [];// 测试用例type S0 = Shift&lt;[1, 2, 3]&gt;; // [2, 3]type S1 = Shift&lt;[string, number, boolean]&gt;; // [number, boolean]type S2 = Shift&lt;[]&gt;; // []type S3 = Shift&lt;[string]&gt;; // [] 第十六题 实现一个Push工具类型，用于把指定类型E作为最后一个元素添加到T数组类型中，示例如下： 12345type Push&lt;T extends any[], E&gt; = // 代码实现// 测试用例type P0 = Push&lt;[], 1&gt;; // [1]type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4] 解决方案 1 12345type Push&lt;T extends any[], E&gt; = T extends [...infer U] ? [...U, E] : never;// 测试用例type P0 = Push&lt;[], 1&gt;; // [1]type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4] 解决方案 2 123456type Push&lt;T extends any[], E&gt; = [...T, E];// 测试用例type P0 = Push&lt;[], 1&gt;; // [1]type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4] 第十七题 实现一个Includes工具类型，用于判断指定的类型E，是否包含在T数组类型中，示例如下： 12345type Includes&lt;T extends any[], E&gt; = // 代码实现// 测试用例type I0 = Includes&lt;[], 1&gt;; // falsetype I1 = Includes&lt;[2, 3], 2&gt;; // true 解决方案 1 12345type Includes&lt;T extends any[], E&gt; = E extends T[number] ? true : false;// 测试用例type I0 = Includes&lt;[], 1&gt;; // falsetype I1 = Includes&lt;[2, 3], 2&gt;; // true 解决方案 2 123456type Includes&lt;T extends any[], E&gt; = T extends [infer A, ...infer R] ? E extends A ? true : Includes&lt;R, E&gt; : false;// 测试用例type I0 = Includes&lt;[], 1&gt;; // falsetype I1 = Includes&lt;[2, 3], 2&gt;; // true 第十八题 实现一个UnionToIntersection工具类型，用于把联合类型转换为交叉类型，示例如下： 12345type UnionToIntersection&lt;U&gt; = // 代码实现// 测试用例type U0 = UnionToIntersection&lt;string | number&gt;; // nevertype U1 = UnionToIntersection&lt;{name: string} | {age: number}&gt;; // {name: string} &amp; {age: number} 解决方案 逆变协变 注释 12345678910type Fun&lt;X&gt; = (...args: X[]) =&gt; void;let f: Fun&lt;string&gt;let g: Fun&lt;string | number&gt;g = f // this cannot be assigned当f赋值给g时，新的g不能使用number类型的参数，我们丢失了g的一部分类型，这就属于 逆变(contra-variance),这个和交集的工作机制类似。当我们把逆变位置放在条件类型时：Typescript会创建一个交集，我们从函数参数中infer了一个类型，TypeScript知道我们必须符合逆变的条件，然后TypeScript会自动创建并集中所有的成分的交集。 123456type UnionToIntersection&lt;U&gt; = (U extends any ? (k: U) =&gt; void : never) extends (k: infer I) =&gt; void ? I : never// 测试用例type U0 = UnionToIntersection&lt;string | number&gt; // nevertype U1 = UnionToIntersection&lt;{ name: string } | { age: number }&gt; // { name: string; } &amp; { age: number; } 第十九题 实现一个 OptionalKeys 工具类型，用来获取对象类型中声明的可选属性，示例如下: 12345678910type Person = { id: string; name: string; age: number; from?: string; speak?: string;}type OptionalKeys&lt;T&gt; = // 代码实现type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot; 解决方案 1 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;}type OptionalKeys&lt;T&gt; = NonNullable&lt;{ [P in keyof T]: undefined extends T[P] ? P : never}[keyof T]&gt;type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot; 解决方案 2 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;}type OptionalKeys&lt;T&gt; = keyof { [P in keyof T as undefined extends T[P] ? P : never]: T[P]}type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot; 解决方案 3 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;};type OptionalKeys&lt;T&gt; = Exclude&lt;{ [P in keyof T]: T extends T[P] ? never : T[P]}[keyof T], undefined&gt;type PersonOptionalKeys = OptionalKeys&lt;Person&gt;; // &quot;from&quot; | &quot;speak 解决方案 4 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;};type OptionalKeys&lt;T&gt; = { [P in keyof T]: (undefined extends T[P] ? P : never)}[keyof T] &amp; keyof Ttype PersonOptionalKeys = OptionalKeys&lt;Person&gt;; // &quot;from&quot; | &quot;speak 第二十题 实现一个Curry工具类型，用来实现函数类型的柯里化处理，示例如下： 123456789type Curry&lt; F extends (...args: any[]) =&gt; any, P extends any[] = Parameters&lt;F&gt;, R = ReturnType&lt;F&gt;&gt; = // 代码实现type C0 = Curry&lt;() =&gt; Date&gt;; // () =&gt; Datetype C1 = Curry&lt;(a:number) =&gt; Date&gt;; // (arg: number) =&gt; Datetype C2 = Curry&lt;(a: number, b: string) =&gt; Date&gt;; // (arg: number)=&gt;(arg: string) =&gt; Date 解决方案 12345678910111213type Curry&lt; F extends (...args: any[]) =&gt; any, P extends any[] = Parameters&lt;F&gt;, R = ReturnType&lt;F&gt;,&gt; = P extends [infer A, ...infer B] ? B extends [] ? (arg: A) =&gt; R : (arg: A) =&gt; Curry&lt;(...arg: B) =&gt; R&gt; : F;type C0 = Curry&lt;() =&gt; Date&gt;; // () =&gt; Datetype C1 = Curry&lt;(a:number) =&gt; Date&gt;; // (arg: number) =&gt; Datetype C2 = Curry&lt;(a: number, b: string) =&gt; Date&gt;; // (arg: number)=&gt;(arg: string) =&gt; Date 第二十一题 实现一个Merge工具类型，用于把两个类型合成一个新的类型，第二类型（SecondType）的Keys将会覆盖第一种类型（FirstType）的Keys，示例如下： 123456789101112type Foo = { a: number; b: string;}type Bar = { b: number;}type Merge&lt;FirstType, SecondType&gt; = // 代码实现type M = Merge&lt;Foo, Bar&gt;; // {a: number, b: number} 解决方案 1 将 FirstType 和 SecondType 做交叉类型，并遍历每一个属性； 如果当前属性名在 SecondType 类型中，则使用 SecondType 类型中的当前属性值； 如果当前属性名在 FirstType 类型中，则使用 FirstType 类型中的当前属性值； 否则为 never； 123456789101112131415161718type Foo = { a: number; b: string;}type Bar = { b: number;}type Merge&lt;FirstType, SecondType&gt; ={ [K in keyof (FirstType &amp; SecondType)] : K extends keyof SecondType ? SecondType[K] : K extends keyof FirstType ? FirstType[K] : never}type M = Merge&lt;Foo, Bar&gt;; // {a: number, b: number} 解决方案 2 先将 FirstType 类型中已经有的，和 SecondType 类型中相同的属性删除； 将前面结果和 SecondType 做交叉类型，获得合并后结果。 123456789101112type Foo = { a: number; b: string;}type Bar = { b: number;}type Merge&lt;F, S&gt; = Omit&lt;F, keyof S&gt; &amp; S;type M = Merge&lt;Foo, Bar&gt;; // {a: number, b: number} 第二十二题 实现一个RequireAtLeastOne工具类型，它将创建一个至少含有一个给定keys的类型，其余keys类型保持原样，示例如下： 123456789101112131415type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;}type RequireAtLeastOne&lt; ObjectType, KeysType extends keyof ObjectType = keyof ObjectType,&gt; = 代码实现const responder: RequireAtLeastOne&lt;Responder, 'text'|'json'&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true} 解决方案 1 1234567891011121314151617181920212223type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;}type RequireAtLeastOne&lt; ObjectType, KeysType extends keyof ObjectType = keyof ObjectType,&gt; = KeysType extends unknown ? ObjectType &amp; { [K in KeysType]-?: ObjectType[K]} : never;// 表示当前类型至少包含 'text' 或 'json' 键const responder: RequireAtLeastOne&lt;Responder, 'text' | 'json'&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true};// @ts-expect-error 因为没有'text'和'json'中的任何一个，报错const responder2: RequireAtLeastOne&lt;Responder, 'text' | 'json'&gt; = { secure: true}; 解决方案 2 12345678910111213141516type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;};type RequireAtLeastOne&lt;ObjectType, KeysType extends keyof ObjectType = keyof ObjectType&gt; = { [K in keyof ObjectType]: K extends KeysType ? ObjectType &amp; Required&lt;Pick&lt;ObjectType, K&gt;&gt; : never;}[keyof ObjectType]// 表示当前类型至少包含 'text' 或 'json' 键const responder: RequireAtLeastOne&lt;Responder, &quot;text&quot; | &quot;json&quot;&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true,}; 解决方案 3 12345678910111213141516type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;};type RequireAtLeastOne&lt;ObjectType, KeysType extends keyof ObjectType = KeysType extends unknown? Omit&lt;ObjectType, KeysType&gt; &amp; Require&lt;Pick&lt;ObjectType, KeysType&gt;&gt;: never// 表示当前类型至少包含 'text' 或 'json' 键const responder: RequireAtLeastOne&lt;Responder, &quot;text&quot; | &quot;json&quot;&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true,}; 第二十三题 实现一个RemoveIndexSignature工具类型，用于移除已有类型中的索引签名，示例如下： 12345678910interface Foo { [key: string]: any; [key: number]: any; [key: symbol]: any; bar(): void;}type RemoveIndexSignature&lt;T&gt; = // 代码实现type R = RemoveIndexSignature&lt;Foo&gt;; // {bar: ()=&gt;void;} 解决方案 123456789101112interface Foo { [key: string]: any; [key: number]: any; [key: symbol]: any; bar(): void;}type RemoveIndexSignature&lt;T&gt; = { [K in keyof T as string extends K ? never : number extends K ? never : symbol extends K ? never : K]: T[K]}type R = RemoveIndexSignature&lt;Foo&gt;; // {bar: () =&gt; void;} 第二十四题 实现一个 Mutable 工具类型，用于移除对象类型上所有属性或者部分属性的 readonly 修饰符，示例如下： 123456789101112type Foo = { readonly a: number; readonly b: string; readonly c: boolean;}type Mutable&lt;T, Keys extends keyof T = keyof T&gt; = // 代码实现const mutableFoo: Mutable&lt;Foo, 'a'&gt; = { a: 1, b: '2', c: true };mutableFoo.a = 3; // okmutableFoo.b = '6'; // Cannot assign to 'b' because it is a read-only property. 解决方案 1 12345678910111213type Foo = { readonly a: number; readonly b: string; readonly c: boolean;}type Mutable&lt;T, Keys extends keyof T = keyof T&gt; ={-readonly [K in Keys]: T[K] } &amp; Pick&lt;T, Exclude&lt;keyof T, Keys&gt;&gt;;const mutableFoo: Mutable&lt;Foo, 'a'&gt; = { a: 1, b: '2', c: true };mutableFoo.a = 3; // okmutableFoo.b = '6'; // Cannot assign to 'b' because it is a read-only property. 解决方案 2 12345678910111213type Foo = { readonly a: number; readonly b: string; readonly c: boolean;}type Mutable&lt;T, Keys extends keyof T = keyof T&gt; ={-readonly [K in Keys]: T[K] : T[K]} &amp; Omit&lt;T, Keys&gt;;const mutableFoo: Mutable&lt;Foo, 'a'&gt; = { a: 1, b: '2', c: true };mutableFoo.a = 3; // okmutableFoo.b = '6'; // Cannot assign to 'b' because it is a read-only property. 第二十五题 实现一个 IsUnion 工具类型，判断指定的类型是否为联合类型，示例如下： 12345type IsUnion&lt;T, U = T&gt; = // 代码实现type I0 = IsUnion&lt;string|number&gt; // truetype I1 = IsUnion&lt;string|never&gt; // falsetype I2 = IsUnion&lt;string|unknown&gt; //false 解决方案 12345type IsUnion&lt;T, U = T&gt; = T extends any ? [U] extends [T] ? false : true : never;type I0 = IsUnion&lt;string|number&gt; // truetype I1 = IsUnion&lt;string|never&gt; // falsetype I2 = IsUnion&lt;string|unknown&gt; //false 知识点： 1.联合类型作为泛型的时候 extends 会触发分发执行 2.联合类型 T 写成[T]就变成了普通类型，extends 的时候不会分发执行 这里第一步T extends any肯定为真，一个其实就是利用其分发的特性，后面的[T]就是一个联合类型拆开后的某一个，因此如果是联合类型的话[U] extends [T]一定为否 第二十六题 实现一个IsNever工具类型，判断指定的类型是否为never类型，示例如下： 12345type IsNever&lt;T&gt; = // 代码实现type I0 = IsNever&lt;never&gt; // truetype I1 = IsNever&lt;never | string&gt; // falsetype I2 = IsNever&lt;null&gt; // false 解决方案 用[]包裹 T，否则泛型参数会被当作一个裸类型处理，走条件式分布类型的判断逻辑，当泛型参数是 any 这种特殊值时，会得到分布后的类型。 12345type IsNever&lt;T&gt; = [T] extends [never] ? true : false;type I0 = IsNever&lt;never&gt; // truetype I1 = IsNever&lt;never | string&gt; // falsetype I2 = IsNever&lt;null&gt; // false 第二十七题 实现一个Reverse工具类型，用于对元祖类型中元素的位置颠倒，并返回该数组，元祖的第一个元素就会变成最后一个，最后一个元素变成第一个。 1234567type Reverse&lt; T extends any[], R extends any[] = []&gt; = // 代码实现type R0 = Reverse&lt;[]&gt; // []type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1] 解决方案 1 1234567type Reverse&lt; T extends any[], R extends any[] = []&gt; = T extends [infer A, ...infer B] ? Reverse&lt;B, [A, ...R]&gt; : R;type R0 = Reverse&lt;[]&gt; // []type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1] 解决方案 2 123456type Reverse&lt; T extends any[]&gt; = T extends [infer A, ...infer B] ? [...Reverse&lt;B&gt;, A] : [];type R0 = Reverse&lt;[]&gt; // []type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1] 第二十八题 实现一个Split工具类型，根据给定的分割符(Delimiter)对包含分割符的字符串进行切割，可用于定义String.prototype.split方法的返回值类型，示例如下： 12345678type Item = `zs, ls, ww`;type Split&lt; S extends string, Delimiter extends string&gt; = // 代码实现type ElementType = Split&lt;Item, ','&gt;; // [&quot;zs&quot;, &quot;ls&quot;,&quot;ww&quot;] 解决方案 1234567891011121314type Item = `zs, ls, ww`;type Split&lt; S extends string, Delimiter extends string,&gt; = S extends `${infer Key}${Delimiter}${infer Rest}`? [Key, ...Split&lt;Rest, Delimiter&gt;]: S extends '' /* 处理空字符串 */? []: [S]type ElementType = Split&lt;Item, ','&gt;; // [&quot;zs&quot;, &quot;ls&quot;,&quot;ww&quot;]type ElementType2 = Split&lt;'a|b|c||d', '|'&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot;]type ElementType3 = Split&lt;'abcdef', ''&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 第二十九题 实现一个ToPath工具类型，用于把属性访问(.或[])路径转换为元祖的形式，示例如下： 1234type ToPath&lt;S extends string&gt; = // 代码实现ToPath&lt;'foo.bar.baz'&gt; // ['foo', 'bar', 'baz']ToPath&lt;'foo[0].bar.baz'&gt; // ['foo', '0', 'bar', 'baz'] 解决方案 12345678910type ToPath&lt;S extends string&gt; = S extends `${infer F}${`[${infer D}]`}${infer R}`? [...ToPath&lt;F&gt;, ...([D] extends [never] ? [] : [D]), ...ToPath&lt;R&gt;]: S extends `${infer F}.${infer R}`? [...ToPath&lt;F&gt;, ...ToPath&lt;R&gt;]: S extends ''? []: [S]type T0 = ToPath&lt;'foo.bar.baz'&gt; // ['foo', 'bar', 'baz']type T1 = ToPath&lt;'foo[0].bar.baz'&gt; // ['foo', '0', 'bar', 'baz'] 第三十题 完善Chainable类型的定义，是的 TS 能成功推断出result变量的类型，调用option方法之后会不断扩展当前对象的类型，使得调用get方法后能获取正确的类型。 12345678910111213141516171819202122declare const config: Chainabletype Chainable = { option(key: string, value: any): any get(): any}const result = config .option('age', 7) .option('name', 'lolo') .option('address', { value: 'XiaMen' }) .get()type ResultType = typeof result// 期望 ResultType 的类型是：// {// age: number// name: string// address: {// value: string// }// } 解决方案 12345678910declare const config: Chainable;type Chainable&lt;T = {}&gt; = { option&lt;K extends string, V extends any&gt;(key: K, value: V): Chainable&lt;{ [P in K]: V } &amp; T&gt;; get(): T;};const result = config.option(&quot;age&quot;, 7).option(&quot;name&quot;, &quot;lolo&quot;).option(&quot;address&quot;, { value: &quot;XiaMen&quot; }).get();type ResultType = typeof result; 第三十一题 实现一个Repeat工具类型，用于根据类型变量C的值，重复T类型并以元祖的形式返回新的类型，示例如下： 12345type Repeat&lt;T, C extends number&gt; = // 代码实现type R0 = Repeat&lt;0, 0&gt;; // []type R1 = Repeat&lt;1, 3&gt;; // [1, 1, 1]type R2 = Repeat&lt;number, 2&gt;; // [number, number] 解决方案 12345type Repeat&lt;T, C extends number, A extends any[]&gt; = A[&quot;length&quot;] extends C ? A : Repeat&lt;T, C, [...A, T]&gt;;type R0 = Repeat&lt;0, 0&gt;; // []type R1 = Repeat&lt;1, 3&gt;; // [1, 1, 1]type R2 = Repeat&lt;number, 2&gt;; // [number, number] 第三十二题 实现一个RepeatString工具类型，用于根据类型变量C的值，重复 T 类型并以字符串的形式返回新的类型，示例如下： 1234567type RepeatString&lt; T extends string, C extends number,&gt; = // 代码实现type S0 = RepeatString&lt;&quot;a&quot;, 0&gt;; // ''type S1 = RepeatString&lt;&quot;ab&quot;, 2&gt;; // 'abab' 解决方案 1234567891011type RepeatString&lt; T extends string, C extends number, S extends string = '', A extends any[] = []&gt; = A[&quot;length&quot;] extends C? S: RepeatString&lt;T, C, `${S}${T}`, [...A, T]&gt;type S0 = RepeatString&lt;&quot;a&quot;, 0&gt;; // ''type S1 = RepeatString&lt;&quot;ab&quot;, 2&gt;; // 'abab' 第三十三题 实现一个ToNumber工具类型，用于实现把数值字符串转换为数值类型，示例如下： 12345type ToNumber&lt;T extends string&gt; = // 代码实现type T0 = ToNumber&lt;&quot;0&quot;&gt;; // 0type T1 = ToNumber&lt;&quot;10&quot;&gt;; // 10type T2 = ToNumber&lt;&quot;20&quot;&gt;; // 20 解决方案 123456type ToNumber&lt;T extends string, S extends any[] = [], L extends number = S[&quot;length&quot;]&gt; =`${L}` extends T ? L : ToNumber&lt;T, [...S, 1]&gt;type T0 = ToNumber&lt;&quot;0&quot;&gt;; // 0type T1 = ToNumber&lt;&quot;10&quot;&gt;; // 10type T2 = ToNumber&lt;&quot;20&quot;&gt;; // 20 第三十四题 实现一个SmallerThan工具类型，用于比较数值类型的大小，示例如下： 12345678type SmallerThan&lt; N extends number, M extends number,&gt; = //代码实现type S0 = SmallerThan&lt;0, 1&gt;; // truetype S1 = SmallerThan&lt;2, 0&gt;; // falsetype S2 = SmallerThan&lt;8, 10&gt;; // true 解决方案 123456789101112type SmallerThan&lt; N extends number, M extends number, S extends any[] = [], L extends number = S[&quot;length&quot;]&gt; = L extends N? L extends M ? false : true: L extends M ? false : SmallerThan&lt;N, M, [...S, 1]&gt;type S0 = SmallerThan&lt;0, 1&gt;; // truetype S1 = SmallerThan&lt;2, 0&gt;; // falsetype S2 = SmallerThan&lt;8, 10&gt;; // true 第三十五题 实现一个Add工具类型，用于实现对数组对应的数值进行加法运算，示例如下： 12345type Add&lt;T, R&gt; = // 代码实现type A0 = Add&lt;5, 5&gt;; // 10type A1 = Add&lt;8, 20&gt;; // 28type A2 = Add&lt;10, 20&gt;; // 30 解决方案 123456789101112type Push&lt;T extends number[], V&gt; = [...T, V];type CreateTuple&lt; T extends number, A extends number[] = []&gt; = A[&quot;length&quot;] extends T ? A : CreateTuple&lt;T, Push&lt;A, 1&gt;&gt;;type Add&lt;T extends number, R extends number&gt; = [...CreateTuple&lt;T&gt;, ...CreateTuple&lt;R&gt;][&quot;length&quot;];type A0 = Add&lt;5, 5&gt;; // 10type A1 = Add&lt;8, 20&gt;; // 28type A2 = Add&lt;10, 20&gt;; // 30 第三十六题 实现一个Filter工具类型，用于根据类型变量F的值进行类型过滤，示例如下： 12345type Filter&lt;T extends any[], F&gt; = // 代码实现type F0 = Filter&lt;[6, &quot;lolo&quot;, 7, &quot;semlinker&quot;, false], number&gt;; // [6, 7]type F1 = Filter&lt;[&quot;kakuqo&quot;, 2, [&quot;ts&quot;], &quot;lolo&quot;], string&gt;; // [&quot;kakuqo&quot;, &quot;lolo&quot;]type F2 = Filter&lt;[0, true, any, &quot;abao&quot;], string&gt;; // [any, &quot;abao&quot;] 解决方案 1234// 本题关键点就是对`any`类型的处理：type A0 = any &amp; 1; // anytype A1 = any &amp; boolean; // anytype A2 = any &amp; never; // never 1234567891011type IsAny&lt;T&gt; = 0 extends (1 &amp; T) ? true : false;type Filter&lt;T extends any[], F&gt; = T extends [infer R1, ...infer R2]? IsAny&lt;R1&gt; extends true? [R1, ...Filter&lt;R2, F&gt;]: [...R1 extends F ? [R1] : [], ...Filter&lt;R2, F&gt;]:[]type F0 = Filter&lt;[6, &quot;lolo&quot;, 7, &quot;semlinker&quot;, false], number&gt;; // [6, 7]type F1 = Filter&lt;[&quot;kakuqo&quot;, 2, [&quot;ts&quot;], &quot;lolo&quot;], string&gt;; // [&quot;kakuqo&quot;, &quot;lolo&quot;]type F2 = Filter&lt;[0, true, any, &quot;abao&quot;], string&gt;; // [any, &quot;abao&quot;] 第三十七题 实现一个Flat工具类型，支持把数组类型拍平（扁平化）,示例如下： 12345type Flat&lt;T extends any[]&gt; = // 代码实现type F0 = Flat&lt;[]&gt;; // []type F1 = Flat&lt;['a', 'b', 'c']&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]type F2 = Flat&lt;['a', ['b', 'c'], ['d', ['e', ['f']]]]&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 解决方案 1 123456789type Flat&lt;T extends any[]&gt; = T extends [infer First, ...infer Rest]? First extends any[]? [...Flat&lt;First&gt;, ...Flat&lt;Rest&gt;]: [First, ...Flat&lt;Rest&gt;]: [];type F0 = Flat&lt;[]&gt;; // []type F1 = Flat&lt;['a', 'b', 'c']&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]type F2 = Flat&lt;['a', ['b', 'c'], ['d', ['e', ['f']]]]&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 解决方案 2 123456789type Flat&lt;T extends any[], S extends any[] = []&gt; = T extends [infer R, ...infer Rest]? R extends any[]? Flat&lt;Rest, Flat&lt;R, S&gt;&gt;: Flat&lt;Rest, [...S, R]&gt;: Stype F0 = Flat&lt;[]&gt;; // []type F1 = Flat&lt;['a', 'b', 'c']&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]type F2 = Flat&lt;['a', ['b', 'c'], ['d', ['e', ['f']]]]&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 第三十八题 实现StartsWith工具类型，判断字符串字面量类型T是否以给定的字符串字面量类型U开头，并根据判断结果返回布尔值，示例如下： 12345type StartsWith&lt;T extends string, U extends string&gt; = // 代码实现type S0 = StartsWith&lt;'123', '12'&gt;; // truetype S1 = StartsWith&lt;'123', '13'&gt;; // falsetype S2 = StartsWith&lt;'123', '1234'&gt;; // false 之后，继续实现EndsWith工具类型，判断字符串字面量类型T是否以给定的字符串字面量类型U结尾，并根据判断结果返回布尔值，示例如下： 12345type EndsWith&lt;T extends string, U extends string&gt; = // 代码实现type E0 = EndsWith&lt;'123', '23'&gt;; // truetype E1 = EndsWith&lt;'123', '13'&gt;; //falsetype E2 = EndsWith&lt;'123', '123'&gt;; //true 解决方案 12345678910111213// StartWithtype StartsWith&lt;T extends string, U extends string&gt; = T extends `${U}${infer R}` ? true : false;type S0 = StartsWith&lt;'123', '12'&gt;; // truetype S1 = StartsWith&lt;'123', '13'&gt;; // falsetype S2 = StartsWith&lt;'123', '1234'&gt;; // false// EndsWithtype EndsWith&lt;T extends string, U extends string&gt; = T extends `${infer Head}${U}` ? true : false;type E0 = EndsWith&lt;'123', '23'&gt;; // truetype E1 = EndsWith&lt;'123', '13'&gt;; //falsetype E2 = EndsWith&lt;'123', '123'&gt;; //true 第三十九题 实现IsAny工具类型，用于判断类型T是否为any类型，示例如下： 12345type IsAny&lt;T&gt; = // 代码实现type I0 = IsAny&lt;never&gt;; // falsetype I1 = IsAny&lt;unknown&gt;; // falsetype I2 = IsAny&lt;any&gt;; // tue 解决方案 1 123456// 思路： 利用任何类型和any交叉都等于any来实现type IsAny&lt;T&gt; = 0 extends 1 &amp; T ? true : false;type I0 = IsAny&lt;never&gt;; // falsetype I1 = IsAny&lt;unknown&gt;; // falsetype I2 = IsAny&lt;any&gt;; // tue 解决方案 2 123456// unknown 只能赋给 unknown 或者 anytype IsAny&lt;T&gt; = [unknown] extends [T] ? ([T] extends [string] ? true : false) : false;type I0 = IsAny&lt;never&gt;; // falsetype I1 = IsAny&lt;unknown&gt;; // falsetype I2 = IsAny&lt;any&gt;; // tue 第四十题 实现AnyOf工具类型，只要数组中任意元素的类型非Falsy类型、{}类型或[]类型，则返回true，否则返回false,如果数组为空的话，则返回false，示例如下： 12345type AnyOf&lt;T extends any[]&gt; = // 代码实现type A0 = AnyOf&lt;[]&gt;; //falsetype A1 = AnyOf&lt;[0,'',false,[],{}]&gt;; //falsetype A2 = AnyOf&lt;[1, &quot;&quot;,false,[],{}]&gt;; true 解决方案 1234567type Falsy = { [p in PropertyKey]: never} | [] | '' | &quot;&quot; | false | 0 | undefined | nulltype AnyOf&lt;T extends any[]&gt; = T extends [infer A, ...infer Rest]? (A extends Falsy ? AnyOf&lt;Rest&gt; : true): false 第四十一题 实现Replace工具类型，用于实现字符串类型的替换操作，具体的使用示例如下： 123456789type Replace&lt; S extends string, From extends string, To extends string&gt; = // 代码实现type R0 = Replace&lt;'', '', ''&gt;; // ''type R1 = Replace&lt;'foobar', 'bar', 'foo'&gt;; // 'foofoo'type R2 = Replace&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoobar' 此外，继续实现ReplaceAll工具类型，用于实现替换所有满足条件的字串，示例如下： 12345678910type ReplaceAll&lt; S extends string, From extends string, To extends string&gt; = // 代码实现type R0 = ReplaceAll&lt;'', '', ''&gt;; // ''type R1 = ReplaceAll&lt;'barfoo', 'bar', 'foo'&gt;; // 'foofoo'type R2 = ReplaceAll&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoofoo'type R3 = ReplaceAll&lt;'foobarfoobar', 'ob', 'b'&gt;; // 'fobarfobar' 解决方案 1234567891011type Replace&lt; S extends string, From extends string, To extends string,&gt; = S extends `${infer H}${From}${infer R}`? `${H}${To}${R}`: S;type R0 = Replace&lt;'', '', ''&gt;; // ''type R1 = Replace&lt;'foobar', 'bar', 'foo'&gt;; // 'foofoo'type R2 = Replace&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoobar' 123456789101112type ReplaceAll&lt; S extends string, From extends string, To extends string,&gt; = S extends `${infer H}${From}${infer R}`? `${H}${To}${ReplaceAll&lt;R, From, To&gt;}`: S;type R0 = ReplaceAll&lt;'', '', ''&gt;; // ''type R1 = ReplaceAll&lt;'barfoo', 'bar', 'foo'&gt;; // 'foofoo'type R2 = ReplaceAll&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoofoo'type R3 = ReplaceAll&lt;'foobarfoobar', 'ob', 'b'&gt;; // 'fobarfobar' 第四十二题 实现IndexOf工具类型，用于获取数组类型中指定项的索引值，若不存在的话，则返回-1字面量类型，示例如下： 123456type IndexOf&lt;A extends any[], Item&gt; = // 代码实现type Arr = [1, 2, 3, 4, 5];type I0 = IndexOf&lt;Arr, 0&gt;; // -1type I1 = IndexOf&lt;Arr, 1&gt;; // 0type I2 = IndexOf&lt;Arr, 3&gt;; // 2 解决方案 12345678910type IndexOf&lt;A extends any[], Item, R extends any[] = []&gt; = A extends [infer H, ...infer Rest]? Item extends H? R[&quot;length&quot;]: IndexOf&lt;Rest, Item, [...R, H]&gt;: -1type Arr = [1, 2, 3, 4, 5];type I0 = IndexOf&lt;Arr, 0&gt;; // -1type I1 = IndexOf&lt;Arr, 1&gt;; // 0type I2 = IndexOf&lt;Arr, 3&gt;; // 2 第四十三题 实现一个Permutation工具类型，当输入一个联合类型时，返回一个包含该联合类型的全排列类型数组。示例如下： 1234type Permutation&lt;T, K = T&gt; = // 代码实现type P0 = Permutation&lt;'a' | 'b'&gt;; // ['a', 'b'] | ['b' , 'a']type P1 = Permutation&lt;'a' | 'b' | 'c'&gt;; //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] | [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;] | [&quot;b&quot;, &quot;a&quot;, &quot;c&quot;] | [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] | [&quot;c&quot;, &quot;a&quot;, &quot;b&quot;] | [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;] 解决方案 12345678type Permutation&lt;T, K = T&gt; = [T] extends [never]? []: K extends K? [K, ...Permutation&lt;Exclude&lt;T, K&gt;&gt;]: nevertype P0 = Permutation&lt;'a' | 'b'&gt;; // ['a', 'b'] | ['b' , 'a']type P1 = Permutation&lt;'a' | 'b' | 'c'&gt;; //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] | [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;] | [&quot;b&quot;, &quot;a&quot;, &quot;c&quot;] | [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] | [&quot;c&quot;, &quot;a&quot;, &quot;b&quot;] | [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;] 第四十四题 实现Unpacked工具类型，用于对类型执行“拆箱”操作，示例如下： 12345678910type Unpacked&lt;T&gt; = // 代码实现// 测试用例type T00 = Unpacked&lt;string&gt;; // stringtype T01 = Unpacked&lt;string[]&gt;; // stringtype T02 = Unpacked&lt;() =&gt; string&gt;; // stringtype T03 = Unpacked&lt;Promise&lt;string&gt;&gt;; // stringtype T04 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;; // stringtype T05 = Unpacked&lt;any&gt;; // anytype T06 = Unpacked&lt;never&gt;; // never 解决方案 12345678910111213141516type Unpacked&lt;T&gt; = T extends (...args: any) =&gt; infer A? A: T extends Promise&lt;infer B&gt;? B: T extends (infer A)[]? A: T// 测试用例type T00 = Unpacked&lt;string&gt;; // stringtype T01 = Unpacked&lt;string[]&gt;; // stringtype T02 = Unpacked&lt;() =&gt; string&gt;; // stringtype T03 = Unpacked&lt;Promise&lt;string&gt;&gt;; // stringtype T04 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;; // stringtype T05 = Unpacked&lt;any&gt;; // anytype T06 = Unpacked&lt;never&gt;; // never 第四十五题 实现JsonifiedObject工具类型，用于对Object对象类型进行序列话操作，示例如下： 123456789101112131415161718192021declare class MyClass { toJSON(): &quot;MyClass&quot;;}type Jsonified&lt;T extends object&gt; = // 代码实现type MyObject = { str: &quot;literalstring&quot;; fn: () =&gt; void; date: Date; customClass: MyClass; obj: { prop: &quot;property&quot;; clz: MyClass; nested: { attr: Date }; };};type JsonifiedMyObject = Jsonified&lt;MyObject&gt;;declare let ex: JsonifiedMyObject;const z1: &quot;MyClass&quot; = ex.customClass;const z2: string = ex.obj.nested.attr; 解决方案 1234567891011121314151617181920212223242526272829declare class MyClass { toJSON(): &quot;MyClass&quot;;}type Jsonified&lt;T extends object&gt; = { [K in keyof T]: T[K] extends { toJSON(): infer Return } ? ReturnType&lt;T[K][&quot;toJSON&quot;]&gt; : T[K] extends (...arg: any[]) =&gt; any ? never : T[K] extends object ? Jsonified&lt;T[K]&gt; : T[K];};type MyObject = { str: &quot;literalstring&quot;; fn: () =&gt; void; date: Date; customClass: MyClass; obj: { prop: &quot;property&quot;; clz: MyClass; nested: { attr: Date }; };};type JsonifiedMyObject = Jsonified&lt;MyObject&gt;;declare let ex: JsonifiedMyObject;const z1: &quot;MyClass&quot; = ex.customClass;const z2: string = ex.obj.nested.attr; 第四十六题 实现RequireAllOrNone工具类型，用于满足以下功能，当设置age属性时，gender属性也会变成必填，示例如下： 1234567891011121314151617interface Person { name: string; age?: number; gender?: number;}type RequireAllOrNone&lt;T, K extends keyof T&gt; = // 你的实现代码const p1: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;};const p2: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1}; 解决方案 123456789101112131415161718192021222324interface Person { name: string; age?: number; gender?: number;}type RequireAllOrNone&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; &amp; ( {[P in K]-?: T[P]} | {[P in K]?: never})const p1: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;};const p2: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1};const p3: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { // error name: &quot;lolo&quot;, age: 7,}; 第四十七题 实现RequireExactlyOne工具类型，用于满足以下功能，即只能包含age或gender属性，不能包含着两个属性，示例如下： 12345678910111213141516171819202122232425interface Person { name: string; age?: number; gender?: number;}// 只能包含Keys中唯一的一个Keytype RequireExactlyOne&lt;T, Keys extends keyof T&gt; = // 你的实现代码const p1: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7,};const p2: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, gender: 1};// Errorconst p3: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1}; 解决方案 12345678910111213141516171819202122232425262728interface Person { name: string; age?: number; gender?: number;}// 只能包含Keys中唯一的一个Keytype RequireExactlyOne&lt;T, Keys extends keyof T, K extends keyof T = Keys&gt; =Keys extends any? Omit&lt;T, K&gt; &amp; Required&lt;Pick&lt;T, Keys&gt;&gt; &amp; Partial&lt;Record&lt;Exclude&lt;K, Keys&gt;, never&gt;&gt;: never;const p1: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7,};const p2: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, gender: 1};// Errorconst p3: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1}; 第四十八题 实现ConsistsOnlyOf工具类型，用于判断LongString字符串类型是否由 0 个或多个Substring字符串类型组成，示例如下： 123456type ConsistsOnlyOf&lt;LongString extends string, SubString extends string&gt; = // 代码实现type C0 = ConsistsOnlyOf&lt;'aaa', 'a'&gt;; // truetype C1 = ConsistsOnlyOf&lt;'ababab', 'ab'&gt;; // truetype C2 = ConsistsOnlyOf&lt;'aBa', 'a'&gt;; // falsetype C3 = ConsistsOnlyOf&lt;'', 'a'&gt;; // true 解决方案 1234567891011type ConsistsOnlyOf&lt;LongString extends string, SubString extends string&gt; =LongString extends ''? true: LongString extends `${SubString}${infer R}`? ConsistsOnlyOf&lt;R, SubString&gt;: falsetype C0 = ConsistsOnlyOf&lt;'aaa', 'a'&gt;; // truetype C1 = ConsistsOnlyOf&lt;'ababab', 'ab'&gt;; // truetype C2 = ConsistsOnlyOf&lt;'aBa', 'a'&gt;; // falsetype C3 = ConsistsOnlyOf&lt;'', 'a'&gt;; // false 第四十九题 项目中定义了接口返回的数据的类型，每层都能灵活扩展一些属性，怎么做呢？ 1234567// 接口返回数据结构type Data = { aaa?: number; bbb: { ccc: number; };}; 解决方案 1234567type DeepRecord&lt;Obj extends Record&lt;keyof any, unknown&gt;&gt; = { [key in keyof Obj]: Obj[key] extends Record&lt;keyof any, unknown&gt; ? DeepRecord&lt;Obj[key]&gt; &amp; Record&lt;keyof any, unknown&gt; : Obj[key];} &amp; Record&lt;keyof any, unknown&gt;;type IData = DeepRecord&lt;Data&gt;; 第五十题 当一个索引为 ‘desc’ | ‘asc’ 的时候，其他索引都是 false 解决方案 123456789type GenerateType&lt;keys extends keyof any, V1, V2&gt; = { [key in keys]: { [key1 in key]: V1; } &amp; { [key2 in Exclude&lt;keys, key&gt;]: V2; };}[keys];type R = GenerateType&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;, &quot;desc&quot; | &quot;asc&quot;, false&gt;; 第五十一题 取出interface中userInfo的类型 1234567interface Result { data?: { userInfo?: { name: string; }; };} 解决方案 1 1234// 简单版 Required// 缺点 层级深了需要写多个Requiredtype UserInfo = Required&lt;Required&lt;Result&gt;[&quot;data&quot;]&gt;[&quot;userInfo&quot;]; 解决方案 2 1234567891011// 递归Required// 缺点数据类型都会变成Requiredtype IsOptional&lt;Key extends keyof Obj, Obj&gt; = {} extends Pick&lt;Obj, Key&gt; ? Key : never;type DeepRequired&lt;T&gt; = { [K in keyof T]-?: IsOptional&lt;K, T&gt; extends never ? T[K] : DeepRequired&lt;T[K]&gt;;};type UserInfo = DeepRequired&lt;Result&gt;[&quot;data&quot;][&quot;userInfo&quot;];","link":"/2022/01/17/typescript%E8%BF%9B%E9%98%B6%E9%A2%98%E7%9B%AE/"},{"title":"vue3核心技术揭秘","text":"vue 的特点（优点） vue 关注视图层，用数据操作的方式代替了 dom 操作 vue 通过响应式的数据绑定实现了数据和视图之间的更新交互 vue 通过组件化开发让工程结构更加明确，更易于维护 vue 通过虚拟 DOM，优化了 DOM 操作，实现了性能提高 vue 拥有自己的 vue-cli/vite 脚手架工具，对良好的工程化性能 vue3 生命周期 onBeforMount -&gt; vue 实例挂载之前执行 onMounted -&gt; vue 实例挂载完成执行 onBeforeUpdate -&gt; 组件内数据发生变化之前执行 onUpdated -&gt; 组件内数据发生变化之后执行 onBeforeUnmount -&gt; 组件销毁之前 onUnmounted -&gt; 组件销毁之后 onActivated -&gt; keep-alive 组件激活时执行 onDeactivated -&gt; keep-alive 组件销毁时执行 onErrorCaptured -&gt; 捕获错误 onRenderTracked -&gt; dev 组件更新时跟踪所有变量和方法 onRenderTriggered -&gt; dev 触发渲染时调用，返回变化新旧值 vue3 相比于 vue2 有哪些不同？ 组合式（composition）api vue2 是选项式（option）api 响应式原理 vue2 响应式原理基础是 Object.defineProperty 深层嵌套递归数据响应式 缺点：无法监听对象或数据新增、删除的元素 解决方案：针对数组原型方法 push、pop、shift、unshift、splice、sort 等进行 hack 处理，提供 Vue.set 监听对象/数组新增属性 tips：Object.defineProperty 可以监听数组已有元素，vue2 没有提供是因为性能问题 vue3 是 Proxy（配合 Reflect） 兼容性：放弃了 IE11 以下 动态属性增删都可以拦截 使用 Reflect 可以修正 Proxy 的 this 指向问题 vue3 使用 Proxy 并不能监听对象内部深层次的属性变化，处理方式是在 getter 中递归响应式，只有真正访问内部属性时才会变成响应式，节约性能 生命周期的变化 vue3 需要添加 on ，使用上需要先引入，vue 可以直接调用 移除了 beforeCrete、created 多根节点 vue3 支持多根节点 异步组件 vue3 提供 Suspense 组件，通过 fallback 插槽提供异步组件渲染兜底的内容，如 loading 等 Teleport vue3 提供 Teleport 组件可将部分组件移动到指定 dom 节点位置，如 Dialog 组件 css 变量 支持在 style 标签中使用 v-bind,给 css 绑定 js 变量 代码打包体积 vue3 的 api 可以被 tree-shaking，使用了 es6module，tree-shaking 依赖于 es6 模块的静态结构特性 虚拟 dom vue3 静态提升：保存静态节点（pathchflag 为 -1）直接复用，添加更新类型标记 pathchflag（为 1 是动态绑定的元素） 事件缓存，可以在第一次渲染后缓存事件，vue2 每次渲染都会传递一个新函数 diff 算法 vue2 双端比较 vue3 最长递归子序列 defineProperty 和 Proxy 的区别？ Object.defineProperty 是 Es5 的方法，Proxy 是 Es6 的方法 defineProperty 是劫持对象属性，Proxy 是代理整个对象； defineProperty 不能监听(重置可以)到对象新增属性和修改新增属性的变化，Proxy 可以 defineProperty 不能监听根据自身数组下标修改数组元素的变化（所以 vue2 提供了 Vue.$set和Vue.$delete） defineProperty 不兼容 IE8，Proxy 不兼容 IE11 defineProperty 不支持 Map、Set 等数据结构 defineProperty 只能监听 get、set，而 Proxy 可以拦截多达 13 种方法； Reflect 是为了在执行对应的拦截操作的方法时能传递正确的 this 上下文 Proxy handler 中的 receiver 指向 正常情况下，receiver指向的是当前的代理对象 特殊情况下，receiver指向引发当前操作的对象（obj） Object.setPrototypeOf(obj, proxy)，访问 obj.name 时如果没有 name 就会根据原型链查找 Proxy 兼容性相对较差，且无法通过 pollyfill 解决；所以 Vue3 不支持 IE11 以下； Proxy 返回的是一个新对象 Proxy 也是不能对对象进行深层次响应的，实现动态递归响应式，只有在使用（get）的时候才会做响应式处理 vue3 响应式原理 activeEffect 解决匿名函数问题 WeakMap、Map、Set 存储对象属性的相关副作用函数 track()实现依赖收集、层级依赖追踪、依赖清理（解决嵌套副作用） trigger()当某个依赖值发生变化时，通过执行副作用函数获得与依赖变化后对应的最新值 v-if 和 v-for 的优先级？v-if 的优先级高于 v-for ref 和 reactive 定义响应式数据ref 原理 ref 内部封装一个 RefImpl 类，并设置 get/set，当通过.value 调用就会触发劫持，从而实现响应式 当接受的对象或数组时，内部仍然是 reactive 去实现的 1234567891011121314151617181920212223242526272829// 源码路径：packages/reactivity/src/ref.tsclass RefImpl&lt;T&gt; { private _value: T private _rawValue: T public dep?: Dep = undefined public readonly __v_isRef = true constructor(value: T, public readonly __v_isShallow: boolean) { this._rawValue = __v_isShallow ? value : toRaw(value) this._value = __v_isShallow ? value : toReactive(value) } get value() { trackRefValue(this) return this._value } set value(newVal) { newVal = this.__v_isShallow ? newVal : toRaw(newVal) if (hasChanged(newVal, this._rawValue)) { this._rawValue = newVal this._value = this.__v_isShallow ? newVal : toReactive(newVal) triggerRefValue(this, newVal) } }} reactive 原理 使用 Proxy 代理传入对象实现响应式 Proxy 拦截数据的更新和获取操作，使用 Reflect 完成原本的操作（get/set） 1234567891011121314151617181920212223242526272829303132333435363738function createReactiveObject( target, isReadonly, baseHandlers, collectionHandlers, proxyMap) { if (!shared.isObject(target)) { { console.warn(`value cannot be made reactive: ${String(target)}`); } return target; } // target is already a Proxy, return it. // exception: calling readonly() on a reactive object if ( target['__v_raw' /* RAW */] &amp;&amp; !(isReadonly &amp;&amp; target['__v_isReactive' /* IS_REACTIVE */]) ) { return target; } // target already has corresponding Proxy const existingProxy = proxyMap.get(target); if (existingProxy) { return existingProxy; } // only specific value types can be observed. const targetType = getTargetType(target); if (targetType === 0 /* INVALID */) { return target; } const proxy = new Proxy( target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers ); proxyMap.set(target, proxy); return proxy;} vue3 中 watch 和 watchEffect 有什么区别？ watch 显式指定依赖源，依赖源变化时执行回调函数 第一个参数为不同形式的数据源 单个 ref 计算属性 getter 函数（要有返回值） 响应式对象(默认时深层遍历)，不能直接侦听响应式对象的属性，应该用一个返回该属性的 getter 函数 以上类型的值组成的数组 第二个参数是数据发生变化时执行的回调函数 接收三个参数：新值、旧值、清理副作用的回调函数（例如清除无效的副作用，等待中的异步请求） 第三个参数是一个可选对象 immediate：在侦听器创建时立即触发回调 deep：深度遍历 flush：回调的触发时机 pre：默认，dom 更新前调用 post：dom 更新后调用 sync：sync 同步调用 onTrack/onTrigger: 用于调试的钩子，在依赖收集和回调函数触发时被调用 其他： watch 的返回值是一个用来停止该副作用的函数 使用同步语句创建的侦听器，会自动绑定到宿主组件实例实例上，并在宿主组件卸载时自动停止 异步回调（setTimeout 等）创建的侦听器，则不会绑定到当前组件上，必须手动停止，以防止内存泄漏 watchEffect 自动收集依赖源，依赖源变化时重新执行自身 接收两个参数 第一个参数是一个回调函数 回调函数的参数为一个 onCleanup 函数，用来清除副作用 第二个参数是一个可选对象 flush：回调的触发时机 pre：默认，dom 更新前调用 post：dom 更新后调用 sync：sync 同步调用 watchEffect 的回调函数会立即执行，即{immediate: true} computed 其实类似一个带输出的同步版本 watchEffect watchEffect 仅会在同步执行期间才会追踪依赖，使用异步回调时，只有在第一个 await 之前访问到的依赖才会被追踪 watchEffect 无法访问侦听数据的新值和旧值 动态新增的依赖也会被收集 使用场景： 大部分时候使用 watch 显示指定依赖以避免不必要的重复触发，也避免在后续代码修改或重构时不小心引入新的依赖 watchEffect 使用于逻辑相对简单，依赖源和逻辑强相关的场景 vue 中动态引入的图片为什么要是 require？因为动态添加 src 被当作静态资源处理了，而动态 src 编译过后的地址与图片编译后的资源地址不一致导致无法正确引入资源，而使用 require 返回的资源文件就是编译后的文件地址，所以可以正确的引入资源 1234567891011// vue文件中使用require动态的引入一张图片&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;!-- 使用require动态引入图片 --&gt; &lt;img :src=&quot;require('../assets/logo.png')&quot; alt=&quot;logo&quot;&gt; &lt;/div&gt;&lt;/template&gt;//最终编译的结果//这张图片是可以被正确打开的&lt;img src=&quot;/img/logo.6c137b82.png&quot; alt=&quot;logo&quot;&gt; 什么是静态资源？ 静态资源就是直接放在项目中的资源，不需要发送请求获取动态资源就是需要发送请求获取资源（数据库连接数据处理） 为什么静态引入图片，没有使用 require 返回的依然是编译后的文件地址？ 因为 webpack 编译 vue 文件时，遇见 src 等属性会默认使用 require 引入资源路径 如 url(./image.png) 会转为 require('./image.png') &lt;img src='./image.png' /&gt; 会被编译为 h('img',{attrs: {src: require('./image.png')}}) 动态引入图片，src 后面的属性值 webpack 会认为是一个变量，根据 v-bind 指令去解析 src 的属性值，并不会通过 require 引入资源路径 引入 public 下面静态资源的时候，也会默认使用 require 引入吗？ 官方：任何放置在public文件夹下的静态资源会被简单的复制，而不经过webpack，你需要通过绝对路径来引用它们 答：不会，使用 require 引入资源的前提是该资源是 webpack 解析的模块，而 public 下的文件压根不会走编译，所以不会使用 require 为什么使用 public 下的资源一定要用绝对路径？ 答：public 文件不会被编译返回的是代码中定义的文件地址，src 下的文件被编译，编译后生成的文件目录（dist）下会找不到对应目录 Vue2、Vue3、React 三者 diff 算法有什么区别？ 严格的 Tree diff 算法的时间复杂度是 O(n*3) vue、react 框架对 tree diff 进行了优化 O(n) 只比较同一层级，不跨级比较 tag 不同则删除重建 子节点通过 key 区分 vdom diff 算法会根据 key 判断元素是否需要删除 匹配了 key，则只移动元素 - 性能较好 未匹配 key，则删除重建 - 性能较差 区别 react 仅右移 vue2 双端比较 vue3 最长递增子序列 KeepAlive 组件实现原理 KeepAlive 是一个内置组件，主要用于组件缓存，它包裹的组件在切换后不会被销毁，而是保留在内存中，避免重复渲染 DOM，include/exclude 用于包含/排除组件，max 用于限制最大缓存实例个数，使用 LRU 缓存算法(最大最小使用缓存)：超过最大数量时移除最久没被访问的实例 Vue-router 三种模式（React-router 也一样） Hash WebHistory MemoryHistory（v4 之前叫做 abstract history） 如何统一监听 Vue 组件报错？ window.onerror 全局监听所有 js 错误 try…catch 中的错误无法被监听到 1234567window.onerror = function (msg, source, line, column, error) { console.log(msg, source, line, column, error);};// orwindow.addEventListener('error', (event) =&gt; { console.log(event);}); errorCaptured 生命周期 监听所有下级组件的错误 返回 false 会阻止向上传播 errorHandler 配置 Vue 全局错误监听，所有组件错误都会汇总到这里 但 errorCaptured 返回 false，不会传播到这里 123app.config.errorHandler = (err, vm, info) =&gt; { console.log(error, vm, info);}; 异步错误 异步回调里面的错误，errorHandler 监听不到 需要使用 window.onerror vue-router 路由钩子const router = createRouter({}); 全局前置守卫 router.beforeEach((to, from)=&gt;{}) 全局解析守卫 router.beforeResolve：和 router.beforeEach 类似，因为它在 每次导航时都会触发，但是确保在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用 全局后置钩子 router.afterEach((to, from)=&gt;{}) 路由独享守卫 beforeEnter:(to, from)=&gt;{} 组件内守卫 onBeforeRouteLeave onBeforeRouteUpdate pinia 原理浅析 通过 createPinia 创建 pinia 实例，在 app.use 的时候执行 pinia 内部的 install 方法 install 方法通过 vue 的 provide 将当前 pinia 实例注入到每个 vue 组件实例中 在业务中使用 useXxx 的时候调用 defineStore 方法，该方法在正真调用的时候才会初始化对应模块的数据参数 defineStore 首先创建一个 store 对象，将 options 上面的 state、getters 利用 vue 的响应式 composition API 进行处理和转换，使之成为响应式数据并挂载在 store 对象上 通过 Object.assign 对这个 store 进行一些扩展 api（reset、$patch 等） 返回 store 对象作为 defineStore 方法的返回值","link":"/2023/03/24/vue3%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"title":"lerna开发","text":"创建 npm 私服 verdaccio 是一个简单、零配置的本地私有化 npm 仓库 123456cnpm install verdaccio -gverdacciohttp://localhost:4873npm adduser --registry http://localhost:4873/npm publish --registry http://localhost: 4873/ lerna 常用命令项目初始化| 命令 | 说明 || — | — || lerna init –independent | 初始化项目 | 创建包| 命令 | 说明 || — | — || lerna create module-1 | 创建 package || lerna add | 安装依赖 || lerna link | 链接依赖 | 开发和测试| 命令 | 说明 || — | — || lerna exec | 执行 shell 脚本 || lerna run | 执行 npm 命令 || lerna clean | 清空依赖|| lerna bootstrap | 重新安装依赖 | package 依赖 1234567891011121.给指定package安装依赖$ lerna add lodash packages/module-1$ lerna add lodash --scope=module-1$ lerna add lodash **/module-1$yarn workspace module-1 add lodash2.给所有package安装依赖$ lerna add lodash3.workspace之间的依赖$ lerna add module-2 packages/module-1$ lerna add module-2 --scope module-1 发布 1$ lerna publish lerna.json version: 当前仓库的版本，independent mode 请设置为 independent. lerna 对于包的管理有两种模式：固定模式 fixed、独立模式 independent。 固定模式所有包是统一的版本号，每次升级所有包统一更新，无论这个包内容是否改变。 *具体体现在 lerna 的配置文件中 lerna.json 中永远会存在一个确定版本号：{“version”: “0.0.1”} 独立模式，每个包都是单独的版本号，每次 lerna 触发发布命令，每个包的版本都会单独变化，具体体现在 lerna 的配置文件 lerna.json 中没有一个确定的版本号，而是{“version”:”independent”} npmClient: 指定运行的客户端程序 默认为 npm ignoreChanges: 一个不包含在lerna changed/publish的 glob 数组，使用这个阻止发布不必要的更新，比如修复README.md 123456789101112131415161718192021222324{ &quot;useWorkspaces&quot;: true, // 使用 workspaces 配置。此项为 true 的话，将使用 package.json 的 &quot;workspaces&quot;，下面的 &quot;packages&quot; 字段将不生效 &quot;version&quot;: &quot;0.1.0&quot;, // 所有包版本号，独立模式-&quot;independent&quot; &quot;npmClient&quot;: &quot;cnpm&quot;, // npm client，可设置为 cnpm、yarn 等 &quot;packages&quot;: [ // 包所在目录，可指定多个 &quot;packages/*&quot; ], &quot;command&quot;: { // lerna 命令相关配置 &quot;publish&quot;: { // 发布相关 &quot;ignoreChanges&quot;: [ // 指定文件或目录的变更，不触发 publish &quot;.gitignore&quot;, &quot;*.log&quot;, &quot;*.md&quot; ] }, &quot;bootstrap&quot;: { // bootstrap 相关 &quot;ignore&quot;: &quot;npm-*&quot;, // 不受 bootstrap 影响的包 &quot;npmClientArgs&quot;: [ // bootstr 执行参数 &quot;--no-package-lock&quot; ] } }} CRA + lerna + react + typescript 项目搭建12345678910111213141.create-react-app demo --template typescript2.cd demo3.npm run eject4.lerna init5.lerna create builder-script6.自定义builder-scripts脚本命令7.自定义 eslintrc、tsconfig、webpack等配置项","link":"/2021/11/01/lerna%E5%BC%80%E5%8F%91/"},{"title":"vue3源码分析","text":"编程范式 命令式：关注过程的一种编程范式，描述了完成一个功能的纤细逻辑与实现 性能好 声明式：不关注过程只关注结果 可维护性强 开发成本（开发周期）、开发体验（心智负担） vue 框架设计原则 vue 封装了命令式的逻辑，而对外暴露了声明式的接口；vue 在可维护性和性能之间进行取舍，找到平衡点，在保证可维护性的基础上，尽可能的减少性能的损耗 vue 组件挂载时会发生如下几件事： 编译：vue 模板会被编译为渲染函数（就是用来返回虚拟 DOM 树的函数） 挂载：运行时渲染器会调用渲染函数，遍历返回虚拟 DOM 树，基于虚拟 DOM 树创建实际的 DOM 节点，此过程会追踪所用到的所有响应式依赖 更新：当依赖发生改变后，副作用会重新执行，创建一个更新后的虚拟 DOM 树，然后运行时会将新旧两颗虚拟 DOM 树进行对比，将必要的更新应用到真实 DOM 节点 带编译时信息的虚拟 DOM vue 中，框架同时控制着编译器和运行时，所以可以通过带编译时信息的虚拟 DOM 做很多编译时优化，例如静态提升、动态类型标记、树结构打平等 react 的实现是纯运行时的，所以 react 的更新算法无法预知新的虚拟 DOM 树会是怎样，所以每次更新总是需要遍历整棵树、对比每个 vnode 上的 props 的区别来更新节点，尽管 DOM 树中有些静态节点不会改变，但在每次重新渲染还会创建新的 vnode，带来了大量不必要的内存压力","link":"/2022/01/02/vue3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"webpack原理","text":"构建 webpack 知识体系分为下面三个层级： 1.基础–会配置 2.进阶–能优化 3.深入–懂原理 一、基础篇 1.简单配置该部分需掌握：1.Webpack 常规配置项有哪些？ 2.常用 loader 有哪些？如何配置？ 3.常用插件 plugin 有哪些？如何配置？4.Babel 如何配置？Babel 插件如何使用？ 1.1 安装依赖需要现在本地安装webpack及webpack-cli 1$ npm install webpack webpack-cli -D 1.2 开始工作webpack 在 4 以后就支持 0 配置打包，我们可以测试一下 新建 webpack-work 项目，新建 ./src/index.js文件，写一段简单的代码 123const a = 'hello foolishmax';console.log(a);module.exports = a; 直接运行npx webpack，启动打包) 打包完成，会有一个提示：The 'mode' option has not been set,... 意思就是我们没有配置 mode（告知 webpack 使用相应模式的内置优化，默认为production，另外还有development、none） 选项 描述 development 开发模式，打包更加快速，省了代码优化步骤 production 生产模式，打包比较慢，开启 tree-shaking 和压缩代码 none 不使用任何默认优化选项 webpack.config.js 中配置： 123module.exports = { mode: 'development',} 1.3 配置文件虽然可以零配置打包，但是实际工作中，还是需要使用配置文件的方式来满足不同项目的需求。 1.跟路径下创建配置文件webpack.config.js 2.新增基本配置信息 1234567891011const path = require('path');module.exports = { mode: 'development', // 模式 entry: './src/index.js', // 打包入口地址 output: { filename: 'bundle.js', // 输出文件名 path: path.join(__dirname, 'dist') // 输出文件目录 }} 1.4 loader这里我们把入口文件改成 css 文件，看下打包结果如何 1.新增./src/main.css 1234567body { margin: 0 auto; padding: 0 20px; max-width: 800px; background: #f4f8fb;} 2.修改 entry 配置 1234567891011const path = require('path');module.exports = { mode: 'development', entry: './src/main.css', output: { filename: 'bundle.js', path: path.join(__dirname, 'dist') }} 3.运行打包命令： npx webpack这里的报错信息是因为：webpack 默认支持处理 js 文件，其他类型都处理不了，需要借助 loader 来对不同类型的文件进行处理。 4.安装css-loader来处理 CSS 1npm install css-loader -D 5.配置资源加载模块 12345678910111213141516171819const path = require('path');module.exports = { mode: 'development', entry: './src/main.css', output: { filename: 'bundle.css', path: path.join(__dirname, 'dist') }, module: { rules: [ // 转换规则 { test: /.css$/, // 匹配所有css文件 use: 'css-loader', //对应的loader名称 } ] }} 6.重新运行打包命令npx webpack,就可以打包成功了 总结：loader 就是将 webpack 不认识的内容转化为认识的内容 插件（plugin）插件可以贯穿 webpack 打包的生命周期，执行不同的任务 1.新建./src/index.html文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 如果想要打包后的资源文件，例如 js 或者 css 文件可以自动引入到 html 中，就需要使用插件html-webpack-plugin来做这件事情。 2.本地安装 html-webpack-plugin 1npm install html-webpack-plugin -D 3.配置插件 12345678910111213141516171819202122232425const HtmlWebpackPlugin = require('html-webpack-plugin');const path = require('path');module.exports = { mode: 'development', entry: './src/main.js', output: { filename: 'bundle.js', path: path.join(__dirname, 'dist') }, module: { rules: [ // 转换规则 { test: /.css$/, // 匹配所有css文件 use: 'css-loader', //对应的loader名称 } ] }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', }) ]} 运行一下打包，打开 dist 目录下的 index.html 文件 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 可以看到它自动引入打包好的 bundle.js 1.6 自动清空打包目录每次打包的时候，打包目录都会遗留上次打包的文件，为了保持打包目录的纯净，打包前需将上次打包目录清空。 1.安装 clean-webpack-plugin 1$ npm install clean-webpack-plugin -D 2.配置 123456789101112const HtmlWebpackPlugin = require('html-webpack-plugin');const {CleanWebpackPlugin} = require('clean-webpack-plugin');const path = require('path');module.exports = { plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', }), new CleanWebpackPlugin() ]} 1.7 区分环境本地环境 需要更快的构建速度 需要打印 debug 信息 需要 live reload 或者 hot reload 功能 需要 sourcemap 方便定位问题 … 生产环境： 需要更小的包体积，代码压缩+tree-shaking 需要进行代码分割 需要压缩图片体积 … 掘金 webpack 常用 loader 和 plugin12345678910111213样式：style-loader、css-loader、less-loader、sass-loader文件：file-loader、url-loader编译：babel-loader、ts-loader校验：eslint-loader常用的pluginhtml-webpack-pluginwebpack-bundle-analyzer 打包分析HotModuleReplacementPlugin 热更新自己写webpack插件：主要就是通过访问compliler和compilation拦截webpack的执行 如何利用 webpack 来优化前端性能？123456789101112131415用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件，利用cssnano（css-loader?minimize）来压缩css利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现提取公共代码。 谈谈你对 webpack 的理解？webpack 是一个打包模块化 js 的工具，在 webpack 里一切文件皆模块，通过 loader 转换，通过 plugin 注入钩子，最后输出由多个模块组合成的文件，webpack 专注构建模块化。WebPack 可以看做是模块的打包机器：它做的事情是，分析你的项目结构，找到 js 模块及其它的一些浏览器不能直接运行的拓展语言，例如：Scss，TS 等，并将其打包为合适的格式以供浏览器使用。 说说 webpack 与 grunt、gulp 的不同？三者都是前端构建工具，grunt 和 gulp 在早期比较流行，现在 webpack 相对来说比较主，不过一些轻量化的任务还是会用 gulp 来处理，比如单独打包 CSS 文件等。 webpack 是基于入口的,webpack 会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader 来处理不同的文件，用 Plugin 来扩展 webpack 功能。 grunt 和 gulp 是基于任务和流（Task、Stream）的。类似 jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据，整条链式操作构成了一个任务，多个任务就构成了 web 的构建流程。 所以，从构建来说，gulp 和 grunt 需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系；webpack 需要开发者找到入口，并需要清楚对于不同的资源应该使什么 Loader 做何种解析和加工对于知识背景来说，gulp 更像后端开发者的思路，需要对于整个流程了如指掌 webpack 更倾向于前端开发者的思路 什么是 bundle,什么是 chunk，什么是 module? bundle：是由 webpack 打包出来的文件 chunk：代码块，一个 chunk 由多个模块组合而成，用于代码的合并和分割 module：是开发中的单个模块，在 webpack 的世界，一切皆模块，一个模块对应一个文件，webpack 会从配置的 entry 中递归开始找出所有依赖的模块 Loader 和 Plugin 的不同？不同的作用Loader 直译为”加载器”。Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。 Plugin 直译为”插件”。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法Loader 在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin 在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。 描述一下编写 loader 或 plugin 的思路？Loader 像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个 Loader 通过链式操作，将源文件一步步翻译成想要的样子。编写 Loader 时要遵循单一原则，每个 Loader 只做一种”转义”工作。 每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback()方法，将内容返回给 webpack。 还可以通过 this.async()生成一个 callback 函数，再用这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发 loader 的工具函数集——loader-utils。相对于 Loader 而言，Plugin 的编写就灵活了许多。 webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 构建打包优化（webpack-bundle-analyzer 分析各个打包文件）速度优化: exclude/include 通过 exclude、include 配置来确保转译尽可能少的文件 cache thread-loader resolve.alias webpack 直接根据对应别名的目录查找模块，减少搜索时间 模块懒加载 externals + CDN vite 为什么快？ vite 借助了浏览器对 ESM 规范的支持，采取了和 webpack 不同的 unbundle 机制，unbundle 机制中模块之间的依赖关系的解析是由浏览器实现的（浏览器本身支持 ESM 的规范），不会对源文件做合并捆绑操作webpack 工作机制：构建模块依赖图，然后再将模块依赖图分解为最终供浏览器使用的几个输出文件。所以 webpack 在这些阶段也做了一些优化，loader 的缓存功能，webpack5 的持久化缓存等 构建 module graph 的过程可以简单归纳为: 获取配置文件中 entry 对应的 url (这个 url 一般为相对路径);resolve - 将 url 解析为绝对路径，找到源文件在本地磁盘的位置，并构建一个 module 对象；load - 读取源文件的内容;transform - 使用对应的 loader 将源文件内容转化为浏览器可识别的类型；parse - 将转化后的源文件内容解析为 AST 对象，分析 AST 对象，找到源文件中的静态依赖(import xxx from ‘xxx’) 和动态依赖(import(‘xx’))对应的 url, 并收集到 module 对象中；遍历第 5 步收集到的静态依赖、动态依赖对应的 url，重复 2 - 6 步骤，直到项目中所有的源文件都遍历完成。 分解 module graph 的过程也可以简单归纳为: 预处理 module graph，对 module graph 做 tree shaking；遍历 module graph，根据静态、动态依赖关系，将 module graph 分解为 initial chunk、async chunks；优化 initial chunk、 async chunks 中重复的 module；根据 optimization.splitChunks 进行优化，分离第三方依赖、被多个 chunk 共享的 module 到 common chunks 中；根据 chunk 类型，获取对应的 template；遍历每个 chunk 中收集的 module，结合 template，为每个 chunk 构建最后的输出内容；将最后的构建内容输出到 output 指定位置； vite 的快：快速的冷启动和热更新 vite 的慢：首屏性能和懒加载性能 不对源文件做合并捆绑操作，会导致大量的 http 请求 把本该在 dev server 启动时做的工作（resolve、load、transform、parse 等）放在了响应浏览器请求的过程中 但是第二次就快了，再次 reload 页面时 dev server 会将之前已经完成转换的内容缓存起来 前端 webpack 分包 默认情况下 webpack 会将所有代码构建成一个单独的包，随着项目的推进，包体积会越来越大导致应用响应耗时增长。 两个弊端： 资源冗余，用户访问内容只有一部分，但是客户端加载了整个代码包，浪费资源 缓存失效，所有资源打成一个包后只修改一个字符也会导致客户端重新下载整个资源，缓存命中率低 解决： 通过 webpack 的 optimization 属性来配置分包规则 webpack5 和 webpack4 的区别？ 可以参考 webpack 官网的从 v4 升级到 v5 的版本迁移解决方案 tree Shaking -只支持 esmodule，但是 vue、react 框架都是用 babel-loader 编译的，可以设置 modules：false 防止 babel 将模块类型转译为 commonjs 类型，导致 tree-shaking 失效 webpack5 中 mode=’production’自动开启 tree-shaking 代码压缩 webpack4 需要下载 terser-webpack-plugin 插件 webpack5 内置了这个插件，并在 mode=’production’时自动开启 js 压缩功能 sideEffects 副作用 optimization.sideEffects = true 开启副作用功能 package.json 中设置 sideEffects:false 标记所有模块无副作用 webpack 在打包前会检查项目所属的 package.json 文件中的 sideEffects 标识，如果没有副作用那么这个模块就不需要打包。 webpack 缓存 webpack4 的缓存配置需要安装对应缓存插件 webpack5 内置 cache 缓存机制，直接配置。 使用持久化缓存cache: {type: ‘filesystem’， // cache 会在开发模式下设置成 memory，并在生产模式下把 chache 给禁用掉cacheDirectory: path.join(__dirname, ‘node_modules/.cac/webpack’)} loader 的优化，通过 type 替换 loader 启动服务 webpack4 是通过 webpack-dev-server 启动服务 webpack5 内置 webpack serve 启动 模块联邦（微前端） 实现应用程序之间的隔离 热更新 webpack的构建流程 从入口文件entry出发，分析module模块并递归整个项目模块间的依赖关系 加载执行响应loader将module模块解析成webpack能够识别的有效模块，生成模块依赖图 编译过程触发多个事件钩子，执行配置的plugin插件 将解析后的模块分组生成chunk 根据output输出配置生成最后的bundle","link":"/2021/10/27/webpack%E5%8E%9F%E7%90%86/"},{"title":"vue响应式系统实现","text":"源码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274const bucket = new WeakMap();// 用一个全局变量存储当前激活的effect函数let activeEffect;// effect栈const effectStack = [];function effect(fn, options = []) { const effectFn = () =&gt; { // 调用cleanup函数完成清除工作 cleanup(effectFn); // 当调用effect注册副作用函数时，将副作用函数赋值给activeEffect activeEffect = effectFn; // 调用副作用函数之前将当前副作用函数压入栈顶 effectStack.push(effectFn); // 把fn的执行结果存储在res中 const res = fn(); // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并将activeEffect还原为之前的值 effectStack.pop(); activeEffect = effectStack[effectStack.length - 1]; return res; }; // 将options挂载到effectFn上 effectFn.options = options; // 用来存储所有与该副作用函数相关的依赖集合 effectFn.deps = []; // 只有非lazy的时候，才执行 if (!options.lazy) { effectFn(); } return effectFn;}// computedfunction computed(getter) { // 用来缓存上一次计算的值 let value; // dirty标志，用来识别是否需要重新计算值，为true时则意味着“脏”，需要计算 let dirty = true; const effectFn = effect(getter, { lazy: true, scheduler() { if (!dirty) { dirty = true; // 当计算属性依赖的响应式数据变化时，手动调用trigger函数触发响应 trigger(obj, &quot;value&quot;); } }, }); const obj = { get value() { if (dirty) { value = effectFn(); dirty = false; } // 当读取value时，手动调用track函数进行追踪 track(obj, &quot;value&quot;); return value; }, }; return obj;}// watchfunction watch(source, cb, options = {}) { let getter; // 如果是函数，说明用户传递的不再是一个响应式数据，而是一个getter函数，直接把source赋值给getter if (typeof source === &quot;function&quot;) { getter = source; } else { // 否则调用traverse递归读取响应式数据属性 getter = () =&gt; traverse(source); } //定义旧值和新值 let oldValue, newValue; // cleanup用来存储用户注册的国旗回调 let cleanup; // 定义onInvalidate函数 function onInvalidate(fn) { // 将过期回调存储到cleanup中 cleanup = fn; } // 提取调度器scheduler为一个独立的job函数 const job = () =&gt; { // 在scheduler中重新执行副作用函数，得到的是新值 newValue = effectFn(); // 在调用糊掉函数cb之前，先调用过期回调 if (cleanup) { cleanup(); } // 将旧值和新值作为回调函数的参数 cb(newValue, oldValue); // 更新旧值，不然下次会得到错误的旧值 oldValue = newValue; }; // 使用effect注册副作用函数时，开启lazy选项，并把返回值存储到effectFn中一边后续手动调用 const effectFn = effect(() =&gt; getter(), { lazy: true, scheduler: job, }); if (options.immediate) { // 当immediate为true时立即执行job，从而触发回调执行 job(); } else { // 手动调用副作用函数，拿到的值就是旧值 oldValue = effectFn(); }}function traverse(value, seen = new Set()) { // 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做 if (typeof value !== &quot;object&quot; || value === null || seen.has(value)) return; // 将数据添加到seen中，代表便利地读取过了，避免循环引用引起的死循环 seen.add(value); // 暂时不考虑数组等其他结构 // 假设value是一个对象，使用for...in读取对新啊个的每一个值，并递归调用traverse进行处理 for (const k in value) { traverse(value[k], seen); } return value;}function cleanup(effectFn) { // 遍历effectFn.deps数组 for (let i = 0; i &lt; effectFn.deps.length; i++) { // deps是依赖集合 const deps = effectFn.deps[i]; // 将effectFn从依赖集合中移除 deps.delete(effectFn); } // 最后需要重置effectFn.deps数组 effectFn.deps.length = 0;}// 在get拦截函数内调用track函数追踪变化function track(target, key) { // 没有activeEffect，直接return if (!activeEffect) return target[key]; // 根据target从“桶”中取得depsMap，也是一个Map类型：key --&gt; effects let depsMap = bucket.get(target); // 如果不存在depsMap，新建一个Map并与target关联 if (!depsMap) { bucket.set(target, (depsMap = new Map())); } // 根据key从depsMap中取得deps，它是一个Set类型， // 里面存储着所有与当前key相关联的副作用函数：effects let deps = depsMap.get(key); if (!deps) { depsMap.set(key, (deps = new Set())); } // 最后将当前激活的副作用函数添加到“桶”中 deps.add(activeEffect); // deps就是一个与当前副作用函数存在联系的依赖集合 // 将其添加到activeEffect.deps数组中 activeEffect.deps.push(deps);}// 在set函数拦截内调用trigger函数出发变化function trigger(target, key) { // 根据target从桶中取出depsMap，它是 key --&gt; effects const depsMap = bucket.get(target); if (!depsMap) return; // 根据key取得所有副作用函数effects const effects = depsMap.get(key); // 在调用forEach遍历Set集合时，如果一个值已经被访问过了， // 但该值被删除并重新添加集合，如果此时forEach遍历还没结束 // 该值会重新被访问，就会导致无限循环执行。 // 解决方法：构造另一个Set集合遍历它 const effectsToRun = new Set(); // 执行副作用函数 effects &amp;&amp; effects.forEach((effectFn) =&gt; { // 如果trigger触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行 if (effectFn !== activeEffect) { effectsToRun.add(effectFn); } }); effectsToRun.forEach((effectFn) =&gt; { // 如果一个副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递 if (effectFn.options.scheduler) { effectFn.options.scheduler(effectFn); } else { // 否则直接执行副作用函数 effectFn(); } });}const data = { text: &quot;hello world&quot;, ok: false, foo: 1, bar: 2 };const obj = new Proxy(data, { // 拦截读取操作 get(target, key) { // 将副作用函数activeEffect添加到存储副作用函数的桶中 track(target, key); // 返回属性值 return target[key]; }, // 拦截设置操作 set(target, key, newVal) { // 设置属性值 target[key] = newVal; // 把副作用函数从桶中取出并执行 trigger(target, key); },});let temp1, temp2;// watchwatch( () =&gt; obj.foo, (newValue, oldValue) =&gt; { console.log(&quot;数据变化了&quot;, newValue, oldValue); }, { immediate: true, });obj.foo++;// computed// const sum = computed(() =&gt; obj.foo + obj.bar);// effect(() =&gt; {// console.log(sum.value);// });// obj.foo++;// lazy// const effectFn = effect(// () =&gt; {// console.log(obj.text);// },// {// lazy: true,// }// );// effectFn();// 嵌套的effect与effect栈// effect(function effectFn1() {// console.log(&quot;effectFn1 执行&quot;);// effect(function effectFn2() {// console.log(&quot;effectFn2 执行&quot;);// temp2 = obj.ok;// });// temp1 = obj.text;// obj.text += &quot;1&quot;;// });// 分支切换与cleanup// effect(() =&gt; {// console.log('effect run');// document.body.innerText = obj.ok ? obj.text : &quot;not&quot;;// obj.text = 'foolishmax'// });// 不存在的属性不添加响应式// setTimeout(() =&gt; {// obj.text = &quot;hello vue3&quot;;// // obj.notExist = 'hello vue3'// }, 3000);","link":"/2022/08/07/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"title":"前端安全","text":"前端安全 你知道哪些前端攻击？该如何预防？ xss Cross Site Script 跨站脚本攻击 手段：将 js 代码插入到网页内容中，渲染时执行 js 代码 预防：特殊字符替换（前端或后端） 输入检查，对于用户输入进行格式检查。 csrf Cross Site Request Forgery 跨站请求伪造 手段：诱导用户去访问另一个网站的接口，伪造请求 预防：严格的跨域限制 + 验证码机制 csrf 详细过程 用户登录 A 网站，有了 A 网站的 cookie 诱导用户到 B 网站，并发起 A 网站的请求 A 网站的 API 发现有 cookie，认为是用户自己操作的 csrf 预防手段 严格的跨域请求限制，如判断 referer（请求来源） 为 cookie 设置 SameSite，禁止跨域传递 cookie Chrome 51 开始，浏览器的 Cookie 新增加了一个 SameSite 属性，用来防止 CSRF 攻击 和用户追踪（第三方恶意获取 cookie），限制第三方 Cookie，从而减少安全风险。 关键接口使用短信验证码 token 验证 点击劫持 click jacing 手段：诱导界面上蒙一个透明 iframe，诱导用户点击 预防：让 iframe 不能跨域加载 X-FRAME-OPTIONS 响应头是用来给浏览器指示允许一个页面可否在&lt;frame&gt;,&lt;iframe&gt; 或者 &lt;object&gt; 中展现的标记。网站可以使用此功能，来确保自己网站内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。 DDos Distribute denial-of-service 分布式拒绝服务 手段：分布式的、大规模的流量访问，使服务器瘫痪 预防：软件层不好做，需硬件预防（如阿里云 WAF） SQL 注入 手段：提交内容时写入 SQL 语句，破环数据库 预防：处理输入的内容，替换特殊字符 什么是跨域？解决跨域的方法有哪些? 同源策略 是一种浏览器的安全策略 协议、域名、端口号必须完全一致 不同源的客户端脚本在没有明确的授权的情况下，不能读取对方的资源 跨域 指一个域下的文档或脚本尝试去请求另一个域下的资源。 解决跨域 jsonp postMessage 跨域 WebSocket 协议跨域 CORS（跨域资源共享，服务端设置 Access-Control-Allow-Origin，前端无需设置，若要带 cookie 请求，前后端都要设置） nginx 反向代理接口跨域 document.domain(两个页面通过 js 强制设置 document.domain 为基础主域，针对基础域名相同的情况) window.name + iframe location.hash + iframe …","link":"/2019/10/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"title":"前端模块化","text":"前端模块化 把复杂的代码按照功能的不同划分成不同的模块单独维护，提高开发效率，方便后期维护。服务端规范主要是 CommonJS，例如 nodejs。客户端主要有 AMD（异步模块定义，推崇依赖前置 requirejs）、CMD（通用模块定义，推崇依赖就近，seajs），但是随着 ES6 的普及，前端的这些第三方的模块化实现已经在渐渐的淘汰 模块化的演进： 基于文件划分模块的方式 每个模块暴露一个全局对象，所有模块成员都挂载在这个对象中，例如 jQuery 库把它的 api 都放在了 window.$下面，但zepto也是在window.$下容易命名冲突 使用 IIFE 为模块提供私有空间 利用 IIFE 的参数作为依赖声明使用 模块化规范（AMD、CMD、CommonJS、ESM 等） CommonJS 解析 CommonJS 的核心思想是通过 require 方法来同步加载依赖的其他模块，通过 module.export 来导出需要暴露的接口 require 内部逻辑：例如：require(X) 如果 X 是内置模块（比如 require(‘http’)）a. 返回该模块b. 不再继续执行 如果 X 以 ‘./‘或者 ‘../‘开头a. 根据 X 所在父模块，确定 X 的绝对路径b. 将 X 当作文件，依次查找以下文件（.x ｜.x.js | .x.json | .x.node），只要一个存在就返回该文件，不再继续执行c. 把 X 当作目录，依次查找以下文件（.x/package.json | .x/index.js | .x/index.json | .x/index.node），只要一个存在就返回并不再执行 如果 X 不带路径a. 根据 X 所在父模块，确定 X 可能的安装目录，依次往上级目录查找，把 X 当成文件名或目录名加载 找不到抛错’not found’","link":"/2023/03/31/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"title":"单页面应用前端路由原理","text":"什么是单页面应用？ 单页面应用是指第一次进入页面的时候会请求一个 html 文件，切换到其他组件的时候，虽然路径会发生相应的变化，但是没有新的 html 文件请求，原理是 js 会感知到 url 的变化，js 会动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这时候的路由不是后端做的而是由前端来做，来判断页面到底显示哪个组件，这个过程就是单页面的应用。 单页面应用的优缺点优点：页面切换快，因为页面每次切换的时候，并不需要做 html 文件的请求，这样就减少的很多 http 发送的时延。 缺点：单页面应用的首屏加载时间比较慢，首屏加载需要一次 html 请求和一次 js 请求，时间相对较慢，而且 SEO 效果差，因为搜索引擎只认识 html 中的内容，但是单页面应用中内容很多需要靠 js 渲染出来，搜索引擎不识别这部分内容，就会导致 SEO 效果不好。 什么是多页面应用？多页面应用是指每一次页面跳转的时候，服务器都会返回一个新的 html 文档，这种类型的应用叫做多页应用。 多页面应用的优缺点优点：首屏加载快，SEO 效果好，因为客户端向服务端发起请求的时候，服务器之返回了一个 html 页面，所以加载比较快。 缺钱：页面切换比较慢 单页面应用和多页面应用的区别1.应用构成不同多页面应用是由多个不同的页面构成，单页面应用是一个外壳页面和多个页面片段构成。 2.页面跳转方式不同多页面应用的页面跳转是从一个页面跳转到另一个页面，而单页面则是把一个页面判断删除或隐藏，加载另一个页面片段。 3.跳转后公共资源是否重新加载跳转后多页面应用需要重新进行加载，但是单页面不需要重新加载 4.用户体验不同多页面应用首屏加载快但是切换慢，单页面应用首屏加载慢但是切换快 5.页面传递数据方式不同多页面应用依靠 url、cookie、localstorage 来传递数据，单页面应用则是靠组件进行通信，相对更加简单。 前端路由的原理前端路由的原理本质上就是通过不刷新浏览器的请求下修改 url、检测 url 的变化，截获 url 的地址，通过解析、匹配路由规则从而实现 UI 的更新，路由的实现通常有两种实现：hash 模式、history 模式 hash 路由的原理在 hash 模式下，在 url 中#后面的部分表示的是一个客户端状态，当这部分发生变化的时候，浏览器本身就不会刷新，这样就满足了第一个条件，即在不刷新浏览器的情况下修改浏览器链接，同时通过监听 hashChange 事件来监听 url 中 hash 值的变化，触发相关函数，改变相关组件。 history 路由的原理history 模式利用 html5 中 history API，history.pushState 和 history.replaceState 这两个方法可以在不刷新页面的情况下，操作浏览器的历史记录，然后通过 popState 事件来监听 url 的变化，从而触发相关函数，改变相关组件。 history.back()、history.forward()、history.go()会触发 popstate 事件history.pushState()、history.replaceState 不会出发 popstate 事件，需要对 replaceState 和 pushState 创建全局 Event 事件，然后 window.addEventListener 监听我们加的 event 事件手动触发 popstate：history.pushState({}, ‘’, ‘/new-path’);window.dispatchEvent(new PopStateEvent(‘popstate’));","link":"/2022/03/14/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/"},{"title":"垃圾回收机制","text":"谈谈 JS 垃圾回收机制？ V8 垃圾回收机制常见的内存泄漏原因：全局变量过多引起内存泄漏闭包dom 事件未清除循环引用eval 垃圾收集器会定期（周期性）的找出那些不再继续使用的变量，释放其内存，因为开销比较大，所以会按照固定的时间间隔周期性的执行 最常用的两种方法：标记清除（常用）和引用计数 标记清除：变量进入作用域，进行标记，离开作用域进行清除回收 引用计数：就是跟踪记录每个值被引用的次数，引用一次加 1，删除减 1，引用计数为 0 时，进行回收，（循环引用可能会导致内存泄漏） V8 会把堆分为新生代和老生代 新生代（副垃圾回收器） 存放生存时间短的对象 通常只支持 1 ～ 8M 的容量 分为对象区和空闲区 对对象区域中的垃圾做标记，标记完成进入垃圾清理阶段，把存活的对象复制到空闲区域，把这些对象有序的排列起来 完成复制后，对象区和空闲区进行角色翻转 老生代（主垃圾回收器） 对象存放生存时间久 对象占用空间大 采用：标记清除算法 和 标记压缩算法 副垃圾回收器采用对象晋升策略：移动那些经过两次垃圾回收依然还存活的对象到老生代中 V8 实现了精准式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。 新生代算法新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。 老生代算法老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是 标记清除算法 和 标记压缩算法。在将算法前，先来说下什么情况下对象会出现在老生代空间中：● 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间。● To 空间的对象占比大于 25%。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。 以下情况会启动 标记清除算法：● 某一空间没有分块的时候● 空间中对象超过一定限制● 空间不能保证新生代中的对象移动时 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动 压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清除不需要的内存。 垃圾回收Javascript中的内存管理是自动执行的，而且是不可见的。在我们创建基本类型、对象、函数 时，这些都需要内存，当不需要某样东西时，JavaScript引擎会利用垃圾回收机制清除它。 在局部作用域中，当函数执行完毕，局部变量也就没必要存在了，因此垃圾收集器很容易 做出判断回收。但是全局变量什么时候需要自动释放内存空间很难判断，因此在开发中， 需要尽量避免使用全局变量。 可达性JavaScript 中内存管理的主要概念是可达性。 当一些值以某种方式可访问或可用，它们会被存储在内存中，叫做可达值。 一些固有可达值，由于显而易见的原因无法删除。例如： 本地函数的局部变量或参数 当前嵌套调用链上的其他函数的变量和参数 全局变量等 这些值 称为 根 如果引用或引用链 可以从根访问任何其他值，则认为该值是可访问的。 一个对象引用另一个对象的属性，则该对象是为可达性。 JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除哪些不可访问的对象。 内部算法v8 的垃圾回收策略基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同的算法。 新生代采用 Scavenge 算法(赋值算法) Scavenge 为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分为 from 和 to 两个空间。每次 gc,会将 from 空间的存活对象复制到 to 空间。然后两个空间角色对换(又称反转)。 该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。 老生代采用 Mark-Sweep(标记清除)和 Mark-Compact(标记整理) 标记-清除算法，定期执行一下“垃圾回收”步骤： 垃圾回收器获取根并“标记”它们 然后访问并标记所有来自它们的引用 然后访问标记的对象 并 标记它们的引用 以此类推，知道有为访问的引用为止 除了标记的对象外，所有对象都被删除。 Mark-Compact 算法(标记整理) 标记清除存在一个问题，清除死亡对象后会造成内存空间不连续，这时候 v8 会使用Mark-Compact 算法(标记整理)，它会在标记完成之后将活着的对象往一端移动，移动完成后直接清理掉边界外的内存。 Reference Counting(引用计数算法) 引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为 0 则直接回收内存。 很明显，引用计数最大的优势是暂停时间短 优化 增量回收：如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分，然后各个部分分别执行，这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。 空闲时间收集：垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。 v8 的内存限制 64 位系统最大约为 1.4G 32 位系统最大约为 0.7G","link":"/2019/10/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"title":"WEB前端性能优化","text":"WEB 前端性能优化常见方法前端性能优化针对不用资源有不同的性能优化方式 内容优化 + (1)减少HTTP请求数：因为一个完整的请求要经过 DNS寻址，与服务器建立连接，发送数据， 等待服务器响应，接受数据等消耗时间成本和资源成本的复杂过程。 - 常见解决方法： + 资源和并和压缩：合并多个 CSS 文件和 js 文件并使用相应的工具对 js、css、图片等进行压缩处理 + 雪碧图（精灵图）：减少请求数 + 合理设置 http 缓存：原则就是能缓存的越多越好，越久越好，通过 http header 中设置 Expires 过期时间，或者 Last-Modifed 进行请求验证 + 减少 http 请求头、配置多个域名和 CDN 加速、使用缓存（HTTP 缓存、浏览器缓存、应用缓存）、优化 cookie + （2）避免重定向：减少不必要的 http 跳转 + （3）延迟加载组件，预加载组件，图片懒加载 + （4）减少 DOM 元素数量：页面中存在大量 DOM 元素，会导致 JavaScript 遍历 DOM 的效率变慢。 服务器优化 （1）使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度 （2）Gzip 压缩 （3）设置 ETag：ETags（Entity tags，实体标签）是 web 服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。 （4）提前刷新缓冲区 （5）避免空的图像 src Cookie 优化 （1）减少 Cookie 的大小 （2）针对 Web 组件使用域名无关的 Cookie CSS 优化 将 CSS 代码放在 HTML 页面的顶部 避免使用 CSS 表达式 使用来代替@import 避免使用 Filters JavaScript 优化 (1) 将 JavaScript 脚本放在页面的底部。 (2) 将 JavaScript 和 CSS 作为外部文件来引用：在实际应用中使用外部文件可以提高页面速度，因为 JavaScript 和 CSS 文件都能在浏览器中产生缓存。 (3) 最小化 DOM 的访问：使用 JavaScript 访问 DOM 元素比较慢。 (4) document.getElement…将获取到的元素长度提取出来 (5) 尽量减少会产生 reflow 和 repaint 的操作，因为它们都是需要消耗资源的 (6) 慎用 with，with 他会修改编译时的词法作用域，修改了执行环境，访问非局部属性的时候，会从指定 obj 作用域上开始查找，相当于增长了作用域长度，而过长的作用域链会造成查找性能下降。 (7) 慎用 eval 和 Function,需要 js 引擎将源代码转换成可执行代码，这是很消耗资源的操作，同时，也不利于压缩工具进行压缩。 (8) 减少作用域链的查找，访问非本作用域下的变量，在循环遍历的时候使用局部变量缓存该变量，遍历结束后再重写那个变量，尤其是全局变量处于作用域的最顶端，访问时查找次数最多 图像优化 (1)优化图片大小 （2）通过 CSS Sprites 优化图片 （3）不要在 HTML 中使用压缩图片 （4）favicon.ico 要小而且可缓存 robots.txt搜索引擎蜘蛛访问网站时会第一个访问 robots.txt 文件，robots.txt 用于指导搜索引擎蜘蛛禁止抓取网站的某些内容和只允许抓取哪些内容，放在站点根目录。 dns-prefetch &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.bootcss.com&quot;&gt; 使用 dns-prefetch 对项目中使用的域名进行 DNS 预解析，减少 DNS 查询。 URL 优化越短越好避免太多参数目录层次尽量少文件及目录名具有描述性字母全部小写连词符使用-而不是_URL 中包括关键字 TDK 优化TDK 为 title，description，keywords 三个的统称。title：分隔符一般有 ， - ,其中对百度比较友好，-对谷歌比较友好，title 长度 pc 端一般30 个中文，移动端 20 个，超过会截断为省略号。 其他标签语义化img 设置 alt 属性不需要跟踪爬行的链接，设置 rel = “nofollow” [参考]：（https://segmentfault.com/a/1190000008829958）","link":"/2019/07/17/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"常见设计模式","text":"SOLID 五大设计原则 S 单一职责原则 一个程序只做好一件事，如果功能过于复杂就拆分开，每个部分保持独立 O 开放封闭原则 对修改封闭，对扩展开放 L 李氏置换原则 子类能覆盖父类 I 接口独立原则 保持接口的单一独立，避免出现胖接口 D 依赖倒置原则 面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 常见的设计模式 工厂模式、单例模式、构造函数模式、建造者模式、代理模式、命令模式、观察者模式、适配器模式、职责链模式、装饰器模式、策略模式等 工厂模式 jquery、react createElement 单例模式 自定义事件 EventBus 全局唯一 Vuex Redux 的 store 全局唯一 12345678910111213141516class SingleTon { private constructor() {} private static instance: SingleTon | null; static getInstance(): SingleTon { if (SingleTon.instance === null) { SingleTon.instance = new SingleTon(); } return SingleTon.instance; }}SingleTon.getInstance(); // 正确SingleTon.instance; // 报错new SingleTon(); // 报错 策略模式 定义一系列算法，将它们封装起来，目的就是将算法的使用和算法的实现分离开来 策略类的实现由两部分组成 策略类：封装具体算法实现 环境类：接收请求，并把请求委托给一个策略类 123456789101112131415var obj = { A: function (salary) { return salary * 4; }, B: function (salary) { return salary * 3; }, C: function (salary) { return salary * 2; },};var calculateBouns = function (level, salary) { return obj[level](salary);};console.log(calculateBouns('A', 10000)); // 40000 代理模式 常用的场景 - 缓存代理 - 虚拟代理 123456789101112131415// 缓存代理var proxyMult = (function () { var cache = {}; return function () { var args = Array.prototype.join.call(arguments, ','); if (args in cache) { return cache[args]; } return (cache[args] = mult.apply(this, arguments)); };})();proxyMult(1, 2, 3, 4); // 输出:24proxyMult(1, 2, 3, 4); // 输出:24// 当第二次调用 proxyMult(1, 2, 3, 4) 时，本体 mult 函数并没有被计算，proxyMult 直接返回了之前缓存好的计算结果","link":"/2019/09/27/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"实现精简版useSize","text":"ahooks是阿里开源的一套 React Hooks 库，里面封装了大量好用的 Hooks，最近也在项目中频繁使用到了库中useSize这个钩子函数，于是就学习了一下它的源码实现，并且实现了一个精简版useSize。 要点一：ResizeObserver监听 Element 内容区域的边界框改变 要点二：requestAnimationFrame优化高频刷新情况下的数据更新 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import { MutableRefObject, useCallback, useEffect, useLayoutEffect, useRef, useState,} from &quot;react&quot;;type TargetValue&lt;T&gt; = T | undefined | null;type TargetType = HTMLElement | Element | Window | Document;export type BasicTarget&lt;T extends TargetType = Element&gt; = | (() =&gt; TargetValue&lt;T&gt;) | TargetValue&lt;T&gt; | MutableRefObject&lt;TargetValue&lt;T&gt;&gt;;type Size = { width: number; height: number };export default function useSize(target: BasicTarget): Size | undefined { const [state, setState] = useState&lt;Size | undefined&gt;(); const ref = useRef(0); const [resizeObserver, setResizeObserver] = useState&lt;ResizeObserver&gt;(); const setRafState = useCallback( (value: Size | ((prevState?: Size) =&gt; Size)) =&gt; { cancelAnimationFrame(ref.current); ref.current = requestAnimationFrame(() =&gt; { setState(value); }); }, [] ); useEffect( () =&gt; () =&gt; { resizeObserver?.disconnect(); cancelAnimationFrame(ref.current); }, [] ); useLayoutEffect(() =&gt; { if (!target) return; let targetEl: TargetValue&lt;TargetType&gt;; if (&quot;current&quot; in target) { targetEl = target.current; } else if (typeof target === &quot;function&quot;) { targetEl = target(); } else { targetEl = target; } if (!targetEl) return; const resizeObserver = new ResizeObserver((entries) =&gt; { entries.forEach((entry) =&gt; { const { clientWidth, clientHeight } = entry.target; setRafState({ width: clientWidth, height: clientHeight, }); }); }); setResizeObserver(resizeObserver); resizeObserver?.observe(targetEl); }, []); return state;} 具体使用12345678910111213export default function App() { const ref = useRef(null); const size = useSize(ref); return ( &lt;div ref={ref} style={{ border: &quot;1px solid red&quot; }}&gt; &lt;p&gt;Try to resize the preview window &lt;/p&gt; &lt;p&gt; width: {size?.width}px, height: {size?.height}px &lt;/p&gt; &lt;/div&gt; );} 仅作为自己的学习积累，有什么需要改进的地方请大家多多批评指点 😅！","link":"/2022/08/04/%E5%AE%9E%E7%8E%B0%E7%B2%BE%E7%AE%80%E7%89%88useSize/"},{"title":"微前端源码剖析","text":"为什么需要微前端？ 将不同的功能按照不同维度拆分成多个子应用（将子应用打包成一个个 lib），当路径切换时通过主应用来加载这些子应用当路径切换时通过主应用来加载这些子应用当路径切换时通过主应用来加载这些子应用 核心：先拆-&gt;后合 微前端解决的问题？ 不同团队（技术栈不同），开发同一个应用 每个团队开发的模块独立开发，独立部署 增量迁移 实现微前端技术方案？ 实现微前端考虑要点 如何进行应用拆分 如何进行应用通信 如何进行应用隔离 技术方案 iframe 通过 postMessage 通信 自带的沙箱机制可以进行应用隔离 缺点：用户体验差，弹框只能在 iframe 中、内部刷新切换状态丢失等 Web Components 将前端应用程序分解为自定义 html 元素 通过 CustomEvent 通信 Shadow DOM 天生的作用域隔离 缺点：兼容问题、学习成本、调试困难 single-spa 通过路由劫持，采用 SystemJS，子应用暴露固定钩子 bootstrap、mount、unmount 接入协议 基于 props 进行通信 无沙箱机制，需要自己实现 JS 沙箱和 CSS 沙箱 缺点：学习成本、无沙箱机制、应用改造、资源重复加载问题 Module federation 通过模块联邦将组件打包导出 共享模块通信 无 CSS 沙箱和 JS 沙箱 缺点：需要 webpack5 百度 EMP 微前端框架 qiankun(基于 single-spa) 沙箱（sandbox、快照、window.proxy） 样式隔离（shadowDom、scopedCss） micro-app（基于 webComponent） webComponent 允许用户自定义一个元素，名字随便起 shadowDom 样式隔离是 webComponent 的一部分 支持组件的模版、插槽、生命周期、属性等 简易版 single-spa 源码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a onclick=&quot;go('#/a')&quot;&gt;a应用&lt;/a&gt; &lt;a onclick=&quot;go('#/b')&quot;&gt;b应用&lt;/a&gt; &lt;!-- navigation-event.js --&gt; &lt;script&gt; // 对用户的路径切换 进行劫持，劫持后，重新调用reroute方法，进行计算应用的加载 function urlRoute() { reroute(arguments); } window.addEventListener('hashchange', urlRoute); window.addEventListener('popstate', urlRoute); // 浏览器历史切换的时候会执行此方法 // 但是当路由切换的时候 我们触发single-spa的addEventLister, 应用中可能也包含addEventLister // 需要劫持原生的路由系统，保证当我们加载完后再切换路由 const capturedEventListeners = { hashchange: [], popstate: [], }; const listentingTo = ['hashchange', 'popstate']; const originalAddEventListener = window.addEventListener; const originalRemoveEventListener = window.removeEventListener; window.addEventListener = function (eventName, callback) { // 有要监听的事件， 函数不能重复 if ( listentingTo.includes(eventName) &amp;&amp; !capturedEventListeners[eventName].some( (listener) =&gt; listener === callback ) ) { return capturedEventListeners[eventName].push(callback); } return originalAddEventListener.apply(this, arguments); }; window.removeEventListener = function (eventName, callback) { // 有要监听的事件， 函数不能重复 if (listentingTo.includes(eventName)) { capturedEventListeners[eventName] = capturedEventListeners[ eventName ].filter((fn) =&gt; fn !== callback); return; } return originalRemoveEventListener.apply(this, arguments); }; function callCaptureEventListeners(e) { if (e) { const eventType = e[0].type; if (listentingTo.includes(eventType)) { capturedEventListeners[eventType].forEach((listener) =&gt; { listener.apply(this, e); }); } } } function patchFn(updateState, methodName) { return function () { const urlBefore = window.location.href; const r = updateState.apply(this, arguments); // 调用此方法 确实发生了路径的变化 const urlAfter = window.location.href; if (urlBefore !== urlAfter) { // 手动派发popstate事件 window.dispatchEvent(new PopStateEvent('popstate')); } return r; }; } window.history.pushState = patchFn(window.history.pushState, 'pushState'); window.history.replaceState = patchFn( window.history.replaceState, 'replaceState' ); &lt;/script&gt; &lt;!-- app.helpers.js --&gt; &lt;script&gt; // app status const NOT_LOADED = 'NOT_LOADED'; // 没有被加载 const LOADING_SOURCE_CODE = 'LOADING_SOURCE_CODE'; // 路径匹配了 要去加载这个资源 const LOAD_ERROR = 'LOAD_ERROR'; // 启动的过程 const NOT_BOOTSTRAPED = 'NOT_BOOTSTRAPED'; // 资源加载完毕了 需要启动，此时还没有启动 const BOOTSTRAPING = 'BOOTSTRAPING'; // 启动中 const NOT_MOUNTED = 'NOT_MOUNTED'; // 没有被挂载 // 挂载流程 const MOUNTING = 'MOUNTING'; // 正在挂载 const MOUNTED = 'MOUNTED'; // 挂载完成 // 卸载流程 const UNMOUNTING = 'UNMOUNTING'; // 卸载中 // 加载正在下载应用 LOADING_SOURCE_CODE，激活已经运行了 // 看一下这个应用是否正在被激活 function isActive(app) { return app.status === MOUNTED; // 此应用正在被激活 } // 看一下此应用是否被激活 function shouldBeActive(app) { return app.activeWhen(window.location); } function getAppChanges() { const appsToLoad = []; const appsToMount = []; const appsToUnmount = []; apps.forEach((app) =&gt; { let appShouldBeActive = shouldBeActive(app); switch (app.status) { case NOT_LOADED: case LOADING_SOURCE_CODE: // 1） 标记当前路径下 哪些应用要被加载 if (appShouldBeActive) { appsToLoad.push(app); } break; case NOT_BOOTSTRAPED: case BOOTSTRAPING: case NOT_MOUNTED: // 2) 当前路径下 哪些应用要被挂在 if (appShouldBeActive) { appsToMount.push(app); } break; case MOUNTED: // 3） 当前路径下 哪些应用要被卸载 if (!appShouldBeActive) { appsToUnmount.push(app); } break; default: break; } }); return { appsToLoad, appsToMount, appsToUnmount }; } &lt;/script&gt; &lt;!-- lifecycles --&gt; &lt;script&gt; // load function flattenArrayToPromise(fns) { fns = Array.isArray(fns) ? fns : [fns]; return function (props) { // redux return fns.reduce( (rPromise, fn) =&gt; rPromise.then(() =&gt; fn(props)), Promise.resolve() ); }; } function toLoadPromise(app) { return Promise.resolve().then(() =&gt; { if (app.status !== NOT_LOADED) { // 此应用加载完毕了 return app; } app.status = LOADING_SOURCE_CODE; // 正在加载应用 // loadApp 对于之前的内容 System.import() return app.loadApp(app.customProps).then((v) =&gt; { const { bootstrap, mount, unmount } = v; app.status = NOT_BOOTSTRAPED; app.bootstrap = flattenArrayToPromise(bootstrap); app.mount = flattenArrayToPromise(mount); app.unmount = flattenArrayToPromise(unmount); return app; }); }); } // mount function toMountPromise(app) { return Promise.resolve().then(() =&gt; { if (app.status !== NOT_MOUNTED) { return app; } return app.mount(app.customProps).then(() =&gt; { app.status = MOUNTED; return app; }); }); } // unmount function toUnmountPromise(app) { return Promise.resolve().then(() =&gt; { if (app.status !== MOUNTED) { return app; } app.status = UNMOUNTING; // app.unmount 方法用户可能写的是一个数组。。。。。 return app.unmount(app.customProps).then(() =&gt; { app.status = NOT_MOUNTED; }); }); } // bootstrap function toBootstrapPromise(app) { return Promise.resolve().then(() =&gt; { if (app.status !== NOT_BOOTSTRAPED) { // 此应用加载完毕了 return app; } app.status = BOOTSTRAPING; return app.bootstrap(app.customProps).then(() =&gt; { app.status = NOT_MOUNTED; return app; }); }); } &lt;/script&gt; &lt;!-- reroute --&gt; &lt;script&gt; // 后续路径变化 也需要走这里， 重新计算哪些应用被加载或者写在 let appChangeUnderWay = false; let peopleWaitingOnAppChange = []; function reroute(event) { // 如果多次触发reroute 方法我们可以创造一个队列来屏蔽这个问题 if (appChangeUnderWay) { return new Promise((resolve, reject) =&gt; { peopleWaitingOnAppChange.push({ resolve, reject, }); }); } // 获取app对应的状态 进行分类 const { appsToLoad, appsToMount, appsToUnmount } = getAppChanges(); // 加载完毕后 需要去挂载的应用 if (started) { appChangeUnderWay = true; // 用户调用了start方法 我们需要处理当前应用要挂载或者卸载 return performAppChange(); } // 先拿到应用去加载 -》 return loadApps(); function loadApps() { // 应用的加载 return Promise.all(appsToLoad.map(toLoadPromise)).then( callEventListener ); // 目前我们没有调用start } function performAppChange() { // 将不需要的应用卸载掉, 返回一个卸载的promise // 1) 稍后测试销毁逻辑 const unmountAllPromises = Promise.all( appsToUnmount.map(toUnmountPromise) ); // 流程加载需要的应用 -》 启动对应的应用 -》 卸载之前的 -》 挂载对应的应用 // 2) 加载需要的应用（可能这个应用在注册的时候已经被加载了） // 默认情况注册的时候 路径是 /a , 但是当我们start的时候应用是/b const loadMountPromises = Promise.all( appsToLoad.map((app) =&gt; toLoadPromise(app).then((app) =&gt; { // 当应用加载完毕后 需要启动和挂载，但是要保证挂载前 先卸载掉来的应用 return tryBootstrapAndMount(app, unmountAllPromises); }) ) ); // 如果应用 没有加载 加载 -》启动挂载 如果应用已经加载过了 挂载 const MountPromises = Promise.all( appsToMount.map((app) =&gt; tryBootstrapAndMount(app, unmountAllPromises) ) ); function tryBootstrapAndMount(app, unmountAllPromises) { if (shouldBeActive(app)) { // 保证卸载完毕在挂载 return toBootstrapPromise(app).then((app) =&gt; unmountAllPromises.then(() =&gt; toMountPromise(app)) ); } } return Promise.all([loadMountPromises, MountPromises]).then(() =&gt; { // 卸载完毕后 callEventListener(); appChangeUnderWay = false; if (peopleWaitingOnAppChange.length &gt; 0) { peopleWaitingOnAppChange = []; // 多次操作 我缓存起来，。。。。 } }); } function callEventListener() { callCaptureEventListeners(event); } } &lt;/script&gt; &lt;!-- registerApplication --&gt; &lt;script&gt; const apps = []; function registerApplication(appName, loadApp, activeWhen, customProps) { const registeration = { name: appName, loadApp, activeWhen, customProps, status: NOT_LOADED, }; apps.push(registeration); reroute(); // 重写路由 } &lt;/script&gt; &lt;!-- start --&gt; &lt;script&gt; let started = false; // 默认没有调用start方法 function start() { started = true; // 用户启动了 reroute(); } &lt;/script&gt; &lt;!-- 入口 --&gt; &lt;script type=&quot;module&quot;&gt; let app1 = { bootstrap: [ async () =&gt; console.log('app1 bootstrap1'), async () =&gt; console.log('app1 bootstrap2'), ], mount: [ async (props) =&gt; { // new Vue().$mount()... console.log('app1 mount1', props); }, async () =&gt; { // new Vue().$mount()... console.log('app1 mount2'); }, ], unmount: async (props) =&gt; { console.log('app1 unmount'); }, }; let app2 = { bootstrap: async () =&gt; console.log('app2 bootstrap1'), mount: [ async () =&gt; { // new Vue().$mount()... return new Promise((resolve, reejct) =&gt; { setTimeout(() =&gt; { console.log('app2 mount'); resolve(); }, 1000); }); }, ], unmount: async () =&gt; { console.log('app2 unmount'); }, }; registerApplication( 'a', async () =&gt; app1, (location) =&gt; location.hash.startsWith('#/a'), { a: 1 } ); registerApplication( 'b', async () =&gt; app2, (location) =&gt; location.hash.startsWith('#/b'), { a: 1 } ); // 开启路径的监控，路径切换的时候 可以调用对应的mount unmount start(); // 这个监控操作 应该被延迟到 当应用挂挂载完毕后再行 window.addEventListener('hashchange', function () { console.log(window.location.hash, 'p----'); }); &lt;/script&gt; &lt;script&gt; function go(url) { // 用户调用pushState replaceState 此方法不会触发逻辑reroute history.pushState({}, null, url); } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2023/03/22/%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%89%96%E6%9E%90/"},{"title":"集合","text":"什么是数据结构与算法？ 数据结构就是在计算机中，存储和组织数据的方式。 + 常见的数据结构： &lt;img src=&quot;http://vamknight.com/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png&quot;&gt; &lt;!--more--&gt; 算法（Algorithm）的定义： 算法就是解决问题的方法/步骤，数据结构的实现离不开算法。 一个有限指令集，每条指令的描述不依赖于语言 接受一些输入（有些情况不需要输入） 产生输出 一定在有限步骤之后终止 集合 集合通常是由一组无序的，不能重复的元素构成。可以看成是一种特殊的数组，特殊之处在于里面的元素没有顺序就意味着不能通过下标值进行访问，不能重复意味着相同的对象在同一个集合中只能存在一份。 集合都有哪些常见的操作方法呢？ add(value)：向集合添加一个新的项。 remove(value)：从集合移除一个值。 has(value)：如果值在集合中，返回 true，否则返回 false。 clear()：移除集合中的所有项。 size()：返回集合所包含元素的数量。与数组的 length 属性类似。 values()：返回一个包含集合中所有值的数组。 集合之间都有哪些操作呢？ 并集：对于两个给定的集合，返回一个包含两个集合中所有元素的新集合。 交集：对于两个给定的集合，返回一个包含两个集合中公有元素的新集合。 差集：对于两个给定的集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的新集合。 子集：验证一个给定集合是否是另一个集合的子集。 集合封装的完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// 封装集合的构造函数function Set() { // 使用一个对象来保存集合的元素 this.items = {} // 集合的操作方法 // 判断集合中是否有某个元素 Set.prototype.has = function (value) { return this.items.hasOwnProperty(value) } // 向集合中添加元素 Set.prototype.add = function (value) { // 1.判断集合中是否已经包含了该元素 if (this.has(value)) return false // 2.将元素添加到集合中 this.items[value] = value return true } // 从集合中删除某个元素 Set.prototype.remove = function (value) { // 1.判断集合中是否包含该元素 if (!this.has(value)) return false // 2.包含该元素, 那么将元素删除 delete this.items[value] return true } // 清空集合中所有的元素 Set.prototype.clear = function () { this.items = {} } // 获取集合的大小 Set.prototype.size = function () { return Object.keys(this.items).length /* 考虑兼容性问题, 使用下面的代码 var count = 0 for (var value in this.items) { if (this.items.hasOwnProperty(value)) { count++ } } return count */ } // 获取集合中所有的值 Set.prototype.values = function () { return Object.keys(this.items) /* 考虑兼容性问题, 使用下面的代码 var keys = [] for (var value in this.items) { keys.push(value) } return keys */ } //集合之间的操作 //并集 Set.prototype.union = function (otherSet) { //this:集合对象A //otherSet:集合对象B //1.创建新的集合 var unionSet = new Set() //2.将A集合中所有的元素添加到新集合中 var values = this.values() for(var i = 0; i &lt; values.length; i++) { unionSet.add(values[i]) } //3.取出B集合中的元素，判断是否需要添加到新集合 values = otherSet.values() for(var i = 0; i &lt; values.length; i++) { unionSet.add(values[i]) } return unionSet } //交集 Set.prototype.intersection = function (otherSet) { var intersectionSet = new Set() var values = this.values() //取出A集合一个个元素，判断是否同时存在于B中，存在B中，则添加到新集合中 for (var i = 0; i &lt; values.length; i++) { var item = values[i] if (otherSet.has(item)) { intersectionSet.add(item) } } return intersectionSet } //差集 Set.prototype.difference = function (otherSet) { var differenceSet = new Set() var values = this.values() //取出A集合一个个元素，判断是否同时存在于B中，不存在B中，则添加到新集合中 for (var i = 0; i &lt; values.length; i++) { var item = values[i] if (!otherSet.has(item)) { differenceSet.add(item) } } return differenceSet } // 子集 Set.prototype.subset = function (otherSet) { var values = this.values() for (var i = 0; i &lt; values.length; i++) { var item = values[i] if (!otherSet.has(item)) { return false } } return true }} 队列（Queue） 队列是一种受限的线性表，先进先出（FIFO First In First Out）。 它只允许在表的前端（front）进行删除操作 在表的后端（rear）进行插入操作 常见应用场景： + 队列主要用在和时间有关的地方，特别是操作系统中，队列是实现多任务的重要机制。 + 消息机制可以通过队列来实现，进程调度也是使用队列来实现。 队列有哪些常见的操作呢？ enqueue(element): 向队列尾部添加一个（或多个）新的项。 dequeue(): 移除队列的第一项，并返回被移除的元素。 front(): 返回队列中第一个元素，队列不做任何改动。 isEmpty(): 如果队列中不包含任何元素，返回 true，否则返回 false。 size(): 返回队列包含的元素个数，与数组 length 类似。 toString(): 将队列中的内容，转成字符串形式。 队列常见操作的封装： 1234567891011121314151617181920212223242526272829303132333435363738//封装队列function Queue() { //属性 this.items = [] //将元素加入到队列中 Queue.prototype.enqueue = function(element) { this.items.push(element) } //从队列中删除前端元素 Queue.prototype.dequeue = function() { return this.items.shift() } //查看前端的元素 Queue.prototype.front = function() { return this.items[0] } //查看队列是否为空 Queue.prototype.isEmpty = function() { return this.items.length == 0 } //查看队列中元素的个数 Queue.prototype.size = function() { return this.items.length } //toString方法 Queue.prototype.toString = function() { var resultString = '' for (var i = 0; i&lt; this.items.length; i++) { resultString += this.items[i] + ' ' } return resultString }}//调用队列函数var queue = new Queue()queue.enqueue(20)alert(queue) 面试题： 击鼓传花 12345678910111213141516171819//面试题: 击鼓传花function passGame(nameList, num) { //创建一个队列结构 var queue = new Queue() //将所有人加入到队列中 for(var i = 0; i &lt; nameList.length; i++) { queue.enqueue(nameList[i]) } //开始数数字 while (queue.size() &gt; 1) { //不是num重新加入队列末尾 //是num从队列中删除 for (var i = 0; i&lt; num - 1; i++) { queue.enqueue(queue.dequeue()) } queue.dequeue() } return queque.front()} 封装优先队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//封装优先级队列function PriorityQueue() { //内部创建一个构造类 function QueueElement(element, priority) { this.element = element this.priority = priority } //属性 this.items = [] //实现队列元素的插入 PriorityQueue.prototype.enqueue = function(element, priority) { //创建QueueElement对象 var queueElement = new QueueElement(element, priority) //判断为队列是否为空 if (this.items.length == 0) { this.items.push(queueElement) } else { var added = false for (var i = 0; i &lt; this.items.length; i++) { if (queueElement.priority &lt; this.items[i].priority) { this.items.splice(i, 0, queueElement) added = true break } } if (!added) { this.items.push(queueElement) } } } //从队列中删除前端元素 PriorityQueue.prototype.dequeue = function() { return this.items.shift() } //查看前端的元素 PriorityQueue.prototype.front = function() { return this.items[0] } //查看队列是否为空 PriorityQueue.prototype.isEmpty = function() { return this.items.length == 0 } //查看队列中元素的个数 PriorityQueue.prototype.size = function() { return this.items.length } //toString方法 PriorityQueue.prototype.toString = function() { var resultString = '' for (var i = 0; i&lt; this.items.length; i++) { resultString += this.items[i].element + '-' + this.items[i].priority + ' ' } return resultString }}//测试代码var pq = new PriorityQueue()pq.enqueue('a',10)pq.enqueue('b',100)pq.enqueue('c',50)alert(pq) 链表 什么是链表？ + 链表的元素在内存中不必是连续的空间，链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。 相对于数组，链表都有哪些优势？ 内存空间不是比是连续的. 可以充分利用计算机的内存. 实现灵活的内存动态管理。 链表不必在创建时就确定大小, 并且大小可以无限的延伸下去。 链表在插入和删除数据时, 时间复杂度可以达到 O(1). 相对数组效率高很多。 相对于数组，链表都有哪些缺点？ + 链表访问任何一个位置的元素时, 都需要从头开始访问.(无法跳过第一个元素访问任何一个元素)。 + 无法通过下标直接访问元素, 需要从头一个个访问, 直到找到对应的问题。 链表的数据结构： 链表有哪些常见操作？ + append(element)：向列表尾部添加一个新的项 + insert(position, element)：向列表的特定位置插入一个新的项。 + update(position, element): 修改某一个位置上的元素。 + remove(element)：从列表中移除一项。 + indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。 // 链表中的属性 this.length = 0 this.head = null // 链表尾部追加元素方法 LinkedList.prototype.append = function (element) { // 1.根据新元素创建节点 var newNode = new Node(element) // 2.判断原来链表是否为空 if (this.head === null) { / + removeAt(position)：从列表的特定位置移除一项。 this.next = null}/ 链表尾空this.head = newNode} else { // 链表不为空// 2.1.定义变量, 保存当前找到的节点var current = this.headwhile (current.next) {current = current.next} // 2.2.找到最后一项, 将其next赋值为node current.next = newNode } // 3.链表长度增加1 this.length++ } // 链表的toString方法 LinkedList.prototype.toString = function () { // 1.定义两个变量 var current = this.head var listString = &quot;&quot; // 2.循环获取链表中所有的元素 while (current) { listString += &quot;,&quot; + current.element current = current.next } // 3.返回最终结果 return listString.slice(1) } // 根据下标删除元素 LinkedList.prototype.insert = function (position, element) { // 1.检测越界问题: 越界插入失败 if (position &lt; 0 || position &gt; this.length) return false // 2.定义变量, 保存信息 var newNode = new Node(element) var current = this.head var previous = null index = 0 // 3.判断是否列表是否在第一个位置插入 if (position == 0) { newNode.next = current this.head = newNode } else { while (index++ &lt; position) { previous = current current = current.next } newNode.next = current previous.next = newNode } // 4.length+1 this.length++ return true } //update方法 LinkedList.prototype.update = function (position, newData) { if (position &lt; 0 || position &gt;= this.length) return null var current = this.head var index = 0 while (index++ &lt; position) { current = current.next } current.data = newData return true } // 根据位置移除节点 LinkedList.prototype.removeAt = function (position) { // 1.检测越界问题: 越界移除失败, 返回null if (position &lt; 0 || position &gt;= this.length) return null // 2.定义变量, 保存信息 var current = this.head var previous = null var index = 0 // 3.判断是否是移除第一项 if (position === 0) { this.head = current.next } else { while (index++ &lt; position) { previous = current current = current.next } previous.next = current.next } // 4.length-1 this.length-- // 5.返回移除的数据 return current.element } // 根据元素获取链表中的位置 LinkedList.prototype.indexOf = function (element) { // 1.定义变量, 保存信息 var current = this.head index = 0 // 2.找到元素所在的位置 while (current) { if (current.element === element) { return index } index++ current = current.next } // 3.来到这个位置, 说明没有找到, 则返回-1 return -1 } // 根据元素删除信息 LinkedList.prototype.remove = function (element) { var index = this.indexOf(element) return this.removeAt(index) } // 判断链表是否为空 LinkedList.prototype.isEmpty = function () { return this.length == 0 } // 获取链表的长度 LinkedList.prototype.size = function () { return this.length } // 获取第一个节点 LinkedList.prototype.getFirst = function () { return this.head.element } } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- 以上操作的都是单向链表，下面来认识一下双向链表。- 单向链表的缺点： + 只能从头遍历到尾，也就是链表的相连的过程是单向的，实现的原理是上一个链表中有一个指向下一个的引用。 + 我们可以轻松的到达下一个节点，但是回到上一个节点是很难的，只能从头遍历。 + 但是，实际开发中，经常会遇到回到上一个节点的情况。- 双向链表： + 既可以从头遍历到尾，又可以从尾遍历到头。 + 也就是链表相连的过程是双向的。 + 实现的原理就是既有先前连接的引用，也有一个向后连接的引用。 + 双向链表可以有效的解决单向链表的问题。- 双向链表的一些缺点： + 每次在插入或删除某一个节点时，需要处理四个引用，实现起来比较复杂。 + 相对于单向链表占用的内存更大一些。- 双向链表的结构图：&lt;img src=&quot;http://vamknight.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png&quot;&gt;- 双向链表的特点： + 可以使用一个head和一个tail分别指向头部和尾部的节点。 + 每个节点都是由三部分组成：前一个节点的指针（prev）、保存的元素（item）、后一个节点的指针（next）。 + 双向链表的第一个节点的prev是null。 + 双向链表的最后一个节点的next是null。- 双向链表都有哪些常见操作？ + append(element)：向列表尾部添加一个新的项 + insert(position, element)：向列表的特定位置插入一个新的项。 + update(position, element): 修改某一个位置上的元素。 + get(position): 获取对应位置的元素。 + remove(element)：从列表中移除一项。 + indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。 + removeAt(position)：从列表的特定位置移除一项。 + isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。 + size()：返回链表包含的元素个数。与数组的length属性类似。 + toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。 + forwardString(): 返回正向遍历的节点字符串形式。 + backwardString(): 返回反向遍历的节点字符串形式。- 双向链表常见方法的封装： // 创建双向链表的构造函数function DoublyLinkedList() {// 创建节点构造函数function Node(element) {this.element = elementthis.next = nullthis.prev = null // 新添加的} // 定义属性 this.length = 0 this.head = null this.tail = null // 新添加的 // 定义相关操作方法 // 在尾部追加数据 DoublyLinkedList.prototype.append = function (element) { // 1.根据元素创建节点 var newNode = new Node(element) // 2.判断列表是否为空列表 if (this.head == null) { this.head = newNode this.tail = newNode } else { this.tail.next = newNode newNode.prev = this.tail this.tail = newNode } // 3.length+1 this.length++ } // 在任意位置插入数据 DoublyLinkedList.prototype.insert = function (position, element) { // 1.判断越界的问题 if (position &lt; 0 || position &gt; this.length) return false // 2.创建新的节点 var newNode = new Node(element) // 3.判断插入的位置 if (position === 0) { // 在第一个位置插入数据 // 判断链表是否为空 if (this.head == null) { this.head = newNode this.tail = newNode } else { this.head.prev = newNode newNode.next = this.head this.head = newNode } } else if (position === this.length) { // 插入到最后的情况 // 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么? this.tail.next = newNode newNode.prev = this.tail this.tail = newNode } else { // 在中间位置插入数据 // 定义属性 var index = 0 var current = this.head var previous = null // 查找正确的位置 while (index++ &lt; position) { previous = current current = current.next } // 交换节点的指向顺序 newNode.next = current newNode.prev = previous current.prev = newNode previous.next = newNode } // 4.length+1 this.length++ return true } // 根据位置删除对应的元素 DoublyLinkedList.prototype.removeAt = function (position) { // 1.判断越界的问题 if (position &lt; 0 || position &gt;= this.length) return null // 2.判断移除的位置 var current = this.head if (position === 0) { if (this.length == 1) { this.head = null this.tail = null } else { this.head = this.head.next this.head.prev = null } } else if (position === this.length -1) { current = this.tail this.tail = this.tail.prev this.tail.next = null } else { var index = 0 var previous = null while (index++ &lt; position) { previous = current current = current.next } previous.next = current.next current.next.prev = previous } // 3.length-1 this.length-- return current.element } // 根据元素获取在链表中的位置 DoublyLinkedList.prototype.indexOf = function (element) { // 1.定义变量保存信息 var current = this.head var index = 0 // 2.查找正确的信息 while (current) { if (current.element === element) { return index } index++ current = current.next } // 3.来到这个位置, 说明没有找到, 则返回-1 return -1 } // 根据元素删除 DoublyLinkedList.prototype.remove = function (element) { var index = this.indexOf(element) return this.removeAt(index) } // 判断是否为空 DoublyLinkedList.prototype.isEmpty = function () { return this.length === 0 } // 获取链表长度 DoublyLinkedList.prototype.size = function () { return this.length } // 获取第一个元素 DoublyLinkedList.prototype.getHead = function () { return this.head.element } // 获取最后一个元素 DoublyLinkedList.prototype.getTail = function () { return this.tail.element } // 遍历方法的实现 // 正向遍历的方法 DoublyLinkedList.prototype.forwardString = function () { var current = this.head var forwardStr = &quot;&quot; while (current) { forwardStr += &quot;,&quot; + current.element current = current.next } return forwardStr.slice(1) } // 反向遍历的方法 DoublyLinkedList.prototype.reverseString = function () { var current = this.tail var reverseStr = &quot;&quot; while (current) { reverseStr += &quot;,&quot; + current.element current = current.prev } return reverseStr.slice(1) } // 实现toString方法 DoublyLinkedList.prototype.toString = function () { return this.forwardString() } } 1 栈 我们知道数组是一种线性结构，可以在数组的任意位置插入或删除数据。但有些时候，我们为了实现某种功能，必须对这种 任意性 加以限制，而我们的栈和队列就是比较常见的 受限的线性结构。 栈是一种先进后出或**后进先出(LIFO Last In First Out)**的数据结构，栈内的元素只能通过列表的一端访问，这一端称为栈顶，因为数据只能在栈顶添加或删除，所以只要数据的保存满足“先进后出或后进先出”的原理，都优先考虑使用栈。 栈的结构示意图： 栈常见有哪些操作？ push（element）：添加一个新元素到栈顶位置。 pop（）：移除栈顶的元素，同时返回被移除的元素。 peek（）：返回栈顶的元素，不对栈做任何修改。 isEmpty（）：如果栈里没有任何元素返回 true，否则返回 false。 size（）：返回栈里的元素个数，类似数组中的 length。 toString（）：将栈结构的内容以字符形式返回。 栈常见操作的封装： 1234567891011121314151617181920212223242526272829303132333435function Stack() { this.items = [] //将元素压入栈 Stack.prototype.push = function(element) { this.items.push(element) } //从栈中移除元素 Stack.prototype.pop = function() { return this.items.pop() } //查看栈顶元素 Stack.prototype.peek = function() { return this.items[this.items.length - 1] } //判断栈是否为空 Stack.prototype.isEmpty = function() { return this.items.length == 0 } //判断栈中元素个数 Stack.prototype.size = function() { return this.items.length } //toString方法 Stack.prototype.toString = function() { var resultString = '' for (var i = 0; i&lt; this.items.length; i++) { resultString += this.items[i] + ' ' } return resultString }}//栈的使用var s = new Stack()s.push(23)alert(s) 12345678910111213141516171819//函数十进制转为二进制function dec2bin(decNumber) { //定义栈对象 var stack = new Stack() while (decNumber &gt; 0) { //获取余数放入栈中 stack.push(decNumber % 2) //获取除后的结果,作为下次操作的对象 decNumber = Math.floor(decNumber / 2) } //从栈中取出0和1 var binaryString = '' while (!stack.isEmpty()) { binaryString += stack.pop() } return binaryString}//调用函数alert(dec2bin(100)) 数据结构与算法 五大算法 贪心算法 分治算法 动态规划 回溯法 分支限界法 冒泡排序1234567891011function bubleSort(arr) { var len = arr.length; for (let outer = len ; outer &gt;= 2; outer--) { for(let inner = 0; inner &lt;=outer - 1; inner++) { if(arr[inner] &gt; arr[inner + 1]) { [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]] } } } return arr;} 选择排序1234567891011function selectSort(arr) { var len = arr.length; for(let i = 0 ;i &lt; len - 1; i++) { for(let j = i ; j&lt;len; j++) { if(arr[j] &lt; arr[i]) { [arr[i],arr[j]] = [arr[j],arr[i]]; } } } return arr} 插入排序123456789101112function insertSort(arr) { for(let i = 1; i &lt; arr.length; i++) { //外循环从1开始，默认arr[0]是有序段 for(let j = i; j &gt; 0; j--) { //j = i,将arr[j]依次插入有序段中 if(arr[j] &lt; arr[j-1]) { [arr[j],arr[j-1]] = [arr[j-1],arr[j]]; } else { break; } } } return arr;} 快速排序12345678910111213141516function quickSort(arr) { if(arr.length &lt;= 1) { return arr; //递归出口 } var left = [], right = [], current = arr.splice(0,1); for(let i = 0; i &lt; arr.length; i++) { if(arr[i] &lt; current) { left.push(arr[i]) //放在左边 } else { right.push(arr[i]) //放在右边 } } return quickSort(left).concat(current,quickSort(right));} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173//创建列表类function ArrayList() { this.array = [] //方法 //插入方法 ArrayList.prototype.insert = function(item){ this.array.push(item) } //toString 方便测试 ArrayList.prototype.toString = function(){ return this.array.join('-') }}&lt;!--var arr = new ArrayList()--&gt;&lt;!--arr.insert(1)--&gt;&lt;!--arr.insert(2)--&gt;&lt;!--arr.insert(3)--&gt;//实现排序算法//冒泡排序ArrayList.prototype.bubbleSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.反向循环, 因此次数越来越少 for (var i = length - 1; i &gt;= 0; i--) { // 3.根据i的次数, 比较循环到i位置 for (var j = 0; j &lt; i; j++) { // 4.如果j位置比j+1位置的数据大, 那么就交换 if (this.array[j] &gt; this.array[j+1]) { // 交换 this.swap(j, j+1) } } }}ArrayList.prototype.swap = function (m, n) { var temp = this.array[m] this.array[m] = this.array[n] this.array[n] = temp}//选择排序ArrayList.prototype.selectionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 从0位置开始取出数据, 直到length-2位置 for (var i = 0; i &lt; length - 1; i++) { // 3.内层循环: 从i+1位置开始, 和后面的内容比较 var min = i for (var j = min + 1; j &lt; length; j++) { // 4.如果i位置的数据大于j位置的数据, 那么记录最小的位置 if (this.array[min] &gt; this.array[j]) { min = j } } // 5.交换min和i位置的数据 this.swap(min, i) }}//插入排序ArrayList.prototype.insertionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后 for (var i = 1; i &lt; length; i++) { // 3.记录选出的元素, 放在变量temp中 var j = i var temp = this.array[i] // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环 while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) { this.array[j] = this.array[j-1] j-- } // 5.将选出的j位置, 放入temp元素 this.array[j] = temp }}//希尔排序ArrayList.prototype.shellSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.根据长度计算增量 var gap = Math.floor(length / 2) // 3.增量不断变量小, 大于0就继续排序 while (gap &gt; 0) { // 4.实现插入排序 for (var i = gap; i &lt; length; i++) { // 4.1.保存临时变量 var j = i var temp = this.array[i] // 4.2.插入排序的内层循环 while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) { this.array[j] = this.array[j - gap] j -= gap } // 4.3.将选出的j位置设置为temp this.array[j] = temp } // 5.重新计算新的间隔 gap = Math.floor(gap / 2) }}//快速排序 // 选择枢纽 ArrayList.prototype.median = function (left, right) { // 1.求出中间的位置 var center = Math.floor((left + right) / 2) // 2.判断并且进行交换 if (this.array[left] &gt; this.array[center]) { this.swap(left, center) } if (this.array[center] &gt; this.array[right]) { this.swap(center, right) } if (this.array[left] &gt; this.array[right]) { this.swap(left, right) } // 3.巧妙的操作: 将center移动到right - 1的位置. this.swap(center, right - 1) // 4.返回pivot return this.array[right - 1] } // 快速排序实现 ArrayList.prototype.quickSort = function () { this.quickSortRec(0, this.array.length - 1) } ArrayList.prototype.quickSortRec = function (left, right) { // 0.递归结束条件 if (left &gt;= right) return // 1.获取枢纽 var pivot = this.median(left, right) // 2.开始进行交换 // 2.1.记录左边开始位置和右边开始位置 var i = left var j = right - 1 // 2.2.循环查找位置 while (true) { while (this.array[++i] &lt; pivot) { } while (this.array[--j] &gt; pivot) { } if (i &lt; j) { // 2.3.交换两个数值 this.swap(i, j) } else { // 2.4.当i&lt;j的时候(一定不会=, 看下面解释中的序号3), 停止循环因为两边已经找到了相同的位置 break } } // 3.将枢纽放在正确的位置 this.swap(i, right - 1) // 4.递归调用左边 this.quickSortRec(left, i - 1) this.quickSortRec(i + 1, right) } 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// 封装ArrayList function ArrayList() { this.array = [] ArrayList.prototype.insert = function (item) { this.array.push(item) } ArrayList.prototype.toString = function () { return this.array.join() } ArrayList.prototype.bubbleSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.反向循环, 因此次数越来越少 for (var i = length - 1; i &gt;= 0; i--) { // 3.根据i的次数, 比较循环到i位置 for (var j = 0; j &lt; i; j++) { // 4.如果j位置比j+1位置的数据大, 那么就交换 if (this.array[j] &gt; this.array[j+1]) { // 交换 this.swap(j, j+1) } } } } ArrayList.prototype.selectionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 从0位置开始取出数据, 直到length-2位置 for (var i = 0; i &lt; length - 1; i++) { // 3.内层循环: 从i+1位置开始, 和后面的内容比较 var min = i for (var j = min + 1; j &lt; length; j++) { // 4.如果i位置的数据大于j位置的数据, 记录最小的位置 if (this.array[min] &gt; this.array[j]) { min = j } } this.swap(min, i) } } ArrayList.prototype.insertionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后 for (var i = 1; i &lt; length; i++) { // 3.记录选出的元素, 放在变量temp中 var j = i var temp = this.array[i] // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环 while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) { this.array[j] = this.array[j-1] j-- } // 5.将选出的j位置, 放入temp元素 this.array[j] = temp } } ArrayList.prototype.shellSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.根据长度计算增量 var gap = Math.floor(length / 2) // 3.增量不断变量小, 大于0就继续排序 while (gap &gt; 0) { // 4.实现插入排序 for (var i = gap; i &lt; length; i++) { // 4.1.保存临时变量 var j = i var temp = this.array[i] // 4.2.插入排序的内存循环 while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) { this.array[j] = this.array[j - gap] j -= gap } // 4.3.将选出的j位置设置为temp this.array[j] = temp } // 5.重新计算新的间隔 gap = Math.floor(gap / 2) } } ArrayList.prototype.swap = function (m, n) { var temp = this.array[m] this.array[m] = this.array[n] this.array[n] = temp } // 选择枢纽 ArrayList.prototype.median = function (left, right) { // 1.求出中间的位置 var center = Math.floor((left + right) / 2) // 2.判断并且进行交换 if (this.array[left] &gt; this.array[center]) { this.swap(left, center) } if (this.array[center] &gt; this.array[right]) { this.swap(center, right) } if (this.array[left] &gt; this.array[right]) { this.swap(left, right) } // 3.巧妙的操作: 将center移动到right - 1的位置. this.swap(center, right - 1) // 4.返回pivot return this.array[right - 1] } // 快速排序实现 ArrayList.prototype.quickSort = function () { this.quickSortRec(0, this.array.length - 1) } ArrayList.prototype.quickSortRec = function (left, right) { // 0.递归结束条件 if (left &gt;= right) return // 1.获取枢纽 var pivot = this.median(left, right) // 2.开始进行交换 var i = left var j = right - 1 while (true) { while (this.array[++i] &lt; pivot) { } while (this.array[--j] &gt; pivot) { } if (i &lt; j) { this.swap(i, j) } else { break } } // 3.将枢纽放在正确的位置 this.swap(i, right - 1) // 4.递归调用左边 this.quickSortRec(left, i - 1) this.quickSortRec(i + 1, right) } } 哈希表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174// 创建HashTable构造函数function HashTable() { // 定义属性 this.storage = [] this.count = 0 this.limit = 8 // 定义相关方法 // 判断是否是质数 HashTable.prototype.isPrime = function (num) { var temp = parseInt(Math.sqrt(num)) // 2.循环判断 for (var i = 2; i &lt;= temp; i++) { if (num % i == 0) { return false } } return true } // 获取质数 HashTable.prototype.getPrime = function (num) { while (!isPrime(num)) { num++ } return num } // 哈希函数 HashTable.prototype.hashFunc = function(str, max) { // 1.初始化hashCode的值 var hashCode = 0 // 2.霍纳算法, 来计算hashCode的数值 for (var i = 0; i &lt; str.length; i++) { hashCode = 37 * hashCode + str.charCodeAt(i) } // 3.取模运算 hashCode = hashCode % max return hashCode } // 插入数据方法 HashTable.prototype.put = function (key, value) { // 1.获取key对应的index var index = this.hashFunc(key, this.limit) // 2.取出数组(也可以使用链表) // 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ] [ [k,v] ] ] var bucket = this.storage[index] // 3.判断这个数组是否存在 if (bucket === undefined) { // 3.1创建桶 bucket = [] this.storage[index] = bucket } // 4.判断是新增还是修改原来的值. var override = false for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] if (tuple[0] === key) { tuple[1] = value override = true } } // 5.如果是新增, 前一步没有覆盖 if (!override) { bucket.push([key, value]) this.count++ if (this.count &gt; this.limit * 0.75) { var primeNum = this.getPrime(this.limit * 2) this.resize(primeNum) } } } // 获取存放的数据 HashTable.prototype.get = function (key) { // 1.获取key对应的index var index = this.hashFunc(key, this.limit) // 2.获取对应的bucket var bucket = this.storage[index] // 3.如果bucket为null, 那么说明这个位置没有数据 if (bucket == null) { return null } // 4.有bucket, 判断是否有对应的key for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] if (tuple[0] === key) { return tuple[1] } } // 5.没有找到, return null return null } // 删除数据 HashTable.prototype.remove = function (key) { // 1.获取key对应的index var index = this.hashFunc(key, this.limit) // 2.获取对应的bucket var bucket = this.storage[index] // 3.判断同是否为null, 为null则说明没有对应的数据 if (bucket == null) { return null } // 4.遍历bucket, 寻找对应的数据 for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] if (tuple[0] === key) { bucket.splice(i, 1) this.count-- // 缩小数组的容量 if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) { var primeNum = this.getPrime(Math.floor(this.limit / 2)) this.resize(primeNum) } } return tuple[1] } // 5.来到该位置, 说明没有对应的数据, 那么返回null return null } // isEmpty方法 HashTable.prototype.isEmpty = function () { return this.count == 0 } // size方法 HashTable.prototype.size = function () { return this.count } // 哈希表扩容 HashTable.prototype.resize = function (newLimit) { // 1.保存旧的数组内容 var oldStorage = this.storage // 2.重置属性 this.limit = newLimit this.count = 0 this.storage = [] // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中 oldStorage.forEach(function (bucket) { // 1.bucket为null, 说明这里面没有数据 if (bucket == null) { return } // 2.bucket中有数据, 那么将里面的数据重新哈希化插入 for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] this.put(tuple[0], tuple[1]) } }).bind(this) }}","link":"/2019/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"title":"标准项目流程","text":"项目开发三大要素 工作流程（15 个流程） 需求分析： PD、PM、用户 PRD 评审： 产品、交互、前端、后端、测试 交互/UI（稿）评审： 产品、交互、UI、前端、后端、测试 技术方案评审： 前端、后端、测试 接口设计评审： 前端、后端 代码开发： 前端、后端 前后端联调： 前端、后端、测试 冒烟用例： 前端、后端 提测：前端、后端 测试：测试 预发验收：用户、PD 发布上线/验证：用户、PD 观察用户数据：PM、后端、测试 复盘：ALL 敏捷迭代：下一轮循环 人员 用户（C 端用户、B 端用户） 产品(PD)/项目经理(PM) UI 设计师 交互设计师（UE） 前端开发 后端开发 测试 文档 产品需求文档（PRD-product requirement document） 交互稿 UI 稿 技术方案 接口文档 冒烟测试用例 测试用例 发布日志 上线报告 复盘文档 PRD 包含哪些部分（五部分）？ 需求背景（业务价值） 需求简介（列表） 业务架构（产品结构、业务逻辑） 产品原型（全局说明） 非功能性需求 考虑点： 投入产出比 ROI（return on inverstment） 产品效果 PV、UV 技术选型 可控性 稳定性 适用性 易用性","link":"/2023/05/29/%E6%A0%87%E5%87%86%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B/"},{"title":"脚手架开发","text":"脚手架开发 开发脚手架的核心目标：提升前端研发效能 内容： 创建项目+通用代码 埋点 http 请求 工具方法 组件库 git 操作 创建仓库 代码冲突 远程代码同步 创建版本 发布打 tag 构建和发布上线 依赖安装和构建 资源上传 cdn 域名绑定 测试/正式服务器 脚手架核心价值将研发过程： 自动化：项目重复代码拷贝/git 操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化、数据化，使得研发过程可量化 自动化构建工具：jenkins、trvis 通常需要 git hooks 触发，在服务端运行需要定制化操作，整个过程比较复杂 脚手架执行原理：以 vue-cli 为例子 在终端输入 vue create xxx 终端解析出 vue 命令 终端在环境变量中找到(相当于 which vue，找不到提示 commond not found) vue 命令 根据 node/bin/目录下 vue 命令（软连接）连接到 node 全局依赖 lib/node_modules 包下的 vue.js 终端利用 node(/usr/bin/env node) 执行 vue.js vue.js 解析 command/options vue.js 执行 command 执行完毕，退出 疑问： 为什么全局安装@vue/cli 会添加 vue 命令？答： 在 package.json 中的 {bin: {‘vue’: ‘bin/vue.js’}}配置 全局安装 npm install -g @vue/cli 时发生了什么？答：首先会把@vue/cli 这个项目安装在 node 的 lib/node_modules 目录下，然后检查项目中 package 中是否存在 bin 属性，如果存在的话会在 node 的 bin 目录下创建一个对应的软连接 执行 vue 命令发生了什么？答：操作系统会找到 which vue 的目录路径并执行这个路径的文件（先去环境变量中找对应命令，拿到目录执行） 怎么直接执行一个 js 文件，不通过 node？答：在文件顶部写 #！/usr/bin/env node,相当于告诉操作系统去环境变量中找 node 命令去执行这个文件；/usr/bin/env node xxx.js = xxx.js(顶部添加指令) = node test.js 创建软连接命令： ln -s /Users/foo/xxx.js vue 脚手架开发难点： 分包：将复杂的系统拆分成若干个模块 命令注册：vue create、vue add 等 参数解析 vue command options(全称、简称) params,帮助信息：Usage： vue &lt;’xxx’&gt; [‘options’]; Options: xxx 命令行交互（让用户选择或者输入） 日志打印 命令行文字变色 网络通信：http/websocket 文件处理 从应用角度看如何开发一个脚手架： 开发 npm 项目，项目中包含一个 bin/vue.js 文件，并将项目发布到 npm 将 npm 项目安装到 node 的 lib/node_modules 中 在 node 的 bin 目录下配置 vue 软连接到 lib/node_modules/@vue/cli/bin/vue.js 执行 vue 的命令时就可以找到 vue.js 执行","link":"/2023/04/04/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/"},{"title":"微信小程序","text":"微信小程序 文件主要目录及文件作用 component 组件文件夹 navBar 底部组件 navBar.js 底部组件的 js 代码 navBar.json 底部组件的配置文件 navBar.wxml 底部组件的 html 代码 navBar.wxss 底部组件的 css 代码 pages 页面文件夹 index 首页 index.js 首页的 js 代码 index.json 首页的配置文件 index.wxml 首页的 html 代码 index.wxss 首页的 css 代码 public 图片文件夹 utils 工具文件夹 api.js 控制 api 的文件 md5.js 工具：MD5 加密文件 timestamp.js 工具：事件戳文件 app.json 设置全局的基础数据等 app.wxss 公共样式，可通过 import 导入更多 project.config.json 项目配置文件 微信小程序生命周期 onLoad(): 页面加载时触发，一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow(): 页面显示/切入前台时触发，每次打开页面都会调用一次。 onReady(): 页面初次渲染完成时触发，一个页面只会调用一次。 onHide(): 页面隐藏/切入后台时触发，当 navigateTo 或底部 tab 切换时调用。 onUnload(): 页面卸载时触发。 app.json 是对当前小程序的全局配置，讲述三个配置各个项的含义? pages 字段：用于描述当前小程序所有页面路径，为了让微信客户端知道当前小程序页面定义在那个目录。 window 字段：小程序所有页面的顶部背景颜色，文字颜色定义等。 tab 字段：小程序全局顶部 tab 或底部 tab。 小程序的 wxss 和 css 有哪些不一样的地方？ 新像素单位 rpx 样式可直接使用 import 导入 小程序 wxml 和标准的 html 的异同？都是用来描述页面的结构，都是由标签、属性等构成。 标签名字不一样，且小程序标签更少，单一标签更多。 多了一些 wx:if 这样的属性和双大括号这样的表达式。 wxml 只能在微信小程序开发者工具中预览，html 可以在浏览器内预览。 组件封装不同，wxml 对组件进行了重新封装。 小程序运行在 JS Core 内，没有 DOM 树和 window 对象，小程序无法使用 window 对象和 document对象。 小程序 wxss 和 css 的异同？都是用来描述页面的样子 wxss 具有 css 大部分的特性，也做了一些扩充和修改。 wxss 新增了尺寸单位，wxss 在底层支持新的尺寸单位 rpx。 wxss 仅支持部分 css 选择器。 wxss 提供全局样式和局部样式。 小程序页面间有哪些传递数据的方法？ 使用全局变量实现数据传递 页面跳转或重定向时，使用 url 带参数传递数据 使用组件模板 template 传递参数 使用数据库传递数据","link":"/2019/10/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"title":"浏览器的缓存机制","text":"前言 缓存机制 强制缓存优先于协商缓存进行， 若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存， 若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存 若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中； 生效则返回 304，继续使用缓存 强缓存强缓存：不会向服务器发送请求，直接从缓存中读取资源，可以通过HTTP Header实现：Expires 和Cache-Control。 + Expires：缓存过期时间，用来指定资源到期的时间，是服务端的具体的时间点，结合Last-modified 使用，Expires是HTTP/1.0的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 + Cache-Control(http/1.1)：和多个指令(private、no-store、no-cache)配合使用，实现资源缓存。 + Expires和Cache-Control同时存在，Cache-Control优先级高于Expires。 协商缓存协商缓存就是强缓存失效后，浏览器携带缓存表示向服务器发起请求，由服务器根据缓存表示决定 是否使用缓存的过程，主要有以下两种情况： + 协商缓存生效，返回304和Not Modified + 协商缓存失效，返回200和请求结果。 + 协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。 + ETag是服务器响应请求时，返回当前资源文件的一个唯一标识（有服务器生成），只要资源有变化 ，ETag就会重新生成。 http 缓存？ 强制缓存 强制缓存过期后会去服务端重新请求 协商缓存 服务端缓存策略 服务端判断客户端资源，是否和服务端资源一样 一致则返回 304，否则返回 200 和最新的资源 在 Response Headers 中，有两种： Last-Modified 资源的最后修改时间 Etag 资源的唯一标识 Last-Modified 和 Etag 会优先使用 Etag Last-Modified 只能精确到秒级 如果资源被重复生成，而内容不变，则 Etag 更精确 综述 刷新操作对缓存的影响？ 正常操作：地址输入 url，跳转链接，前进后退等 强制缓存有效，协商缓存有效 手动刷新：F5，点击刷新按钮，右击菜单刷新 强制缓存失效，协商缓存有效 强制刷新：ctrl + F5 强制缓存失效，协商缓存失效","link":"/2019/07/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"计算机网络","text":"http 和 https 的区别 http 是超文本传输协议，信息是明文传输，https 是更加安全的 ssl 加密传输协议http 默认是 80 端口，https 默认是 443 端口https 需要申请 CA 证书https 是 http + ssl/tls（数字证书）进行组合的更加安全的传输协议 https 工作原理（非对称加密） 1.服务端向客户端传递证书作为公钥 2.客户端对证书进行解析，判断证书的办法机构和过期时间等，如果都没有问题，生成一个随机值作为私钥，然后使用证书进行加密发送给服务端 3.服务端解密得到客户端私钥 4.之后双方利用私钥进行加密解密，完成信息的通信 HTTP 协议 1.0、1.1、2.0 有什么区别？ HTTP 1.0 最基础的 HTTP 协议 支持基本的 GET、POST 方法 HTTP 1.1 缓存策略 cache-control、E-tag 等 支持长连接 Connection: keep-alive,一次 TCP 连接多次请求 支持断点续传，状态码 206 支持新的方法 PUT、DELETE 等，可用于 Restful API HTTP 2.0 头部数据压缩：http2.0 使用 HPACK 算法对 header 对头部数据进行压缩，体积变小后，网络传输速度会更快 http/1.1 版本的头部信息是本文，而 http/2.0 头部数据就是二进制 多路复用，一次 TCP 连接中可以多个 HTTP 并行请求 服务端推送 301 和 302 的区别301 表示资源被永久移除，浏览器在拿到状态码后跳转到一个新的 URL 地址，可从相应头的 location 首部中获取，搜索引擎在抓取新内容的同时也将就地址交换为重定向之后的网址。 302 表示地址资源还在，仍可以访问，搜索引擎会抓取新的内容而保存旧的地址，seo 302 优于 301. 重定向的原因：网站调整（改变网页目录结构）页面被移到一个新地址页面扩展名改变 .php -&gt;.html如果不做重定向会返回 404 页面，会白白流失用户访问量。 1XX 信息性状态码，表示接受的请求正在处理2XX 成功状态码，表示请求被正常处理完毕3XX 重定向状态码，表示需要进行附加操作以完成请求4XX 客户端错误状态码，表示服务器无法处理请求400 Bad Request 请求出现语法错误401 被请求的页面需要用户名和密码403 forbidden 请求页面的访问被禁止404 资源未找到5XX 服务器错误状态码，表示服务器处理请求出错502 网关错误503 服务器超负载或者停机维护，无法处理请求504 网关超时 HTTP 协议和 UDP 协议有什么区别？ 网络协议 HTTP 协议在应用层 TCP、UDP 协议在传输层 TCP 协议 有连接，有断开 稳定传输 UDP 协议 无连接，无断开 不稳定传输，但效率高 如视频会议、语音通话 UDP &amp; TCP 的区别 相同点： UDP 协议 和 TCP 协议 都是运输层协议 不同点： UDP 特点： 无连接 —— 知道对端的 IP 和端口号就直接进行传输，不需要建立连接 不可靠 —— 没有确认机制，没有重传机制，即使因为网络故障无法发送到对方，UDP 协议也不会给应用层返回任何错误信息 面向数据报 传输速 度块 TCP 特点： 面向连接，在客户端和服务器进行交换数据前，必须先在双方之间建立一个TCP 连接 可靠传输，具有确认应答机制、超时重传机制、拥塞控制、流量控制、滑动窗口机制、延迟应答等。 面向字节流 UDP 的响应速度优于 TCP，安全性和数据可靠性不如 TCP UDP 一般用在网络负担非常重，但对响应速度要求高，数据类型都是短消息的情况下 网络模型OSI(open system interconnect)参考模型 应用层（为应用程序提供网络服务） 表示层（数据格式化，加密等） 会话层（建立、维护管理会话连接） 传输层（建立、维护管理到端连接） 网络层（IP 寻址和路由选择） 寻址就是根据 IP 地址找到具体的设备 路由就是选择数据传输的线路 数据链路层（控制网络层和物理层之间通信） 物理层（通过光缆、无线电波等方式连接组网） TCP/IP 模型 应用层（应用层就是向用户提供通信服务的活动，提供用户程序接口 HTTP、FTP、DNS） 传输层（传输层为两台主机上的应用程序提供端到端的通信 TCP，UDP） 网络层（网络层实现数据包的选路和转发） 数据链路层（ARP 地址解析协议、RARP 逆地址解析协议，使用物理地址寻找一台机器） WebSocketWebSocket是html5定义的新协议，特点是即时通信、替代轮训 与传统http协议不同，实现了浏览器和服务器的全双工通信 HTTP 和 WebSocket 相同点： 都是基于 TCP 可靠传输协议 不同点： WebSocket 是全双工通信协议，通信双方可以同时发送和接收消息，http 是单向的 WebSocket 没有 Request 和 Response 概念 WebSocket 需要依赖 http 协议进行一次握手，握手成功后直接从 TCP 通道传输，与 http 无关 WebSocket 数据格式较轻量，数据包头部较小，http 协议每次通信需要携带完成头部信息 WebSocket 无跨域问题 WebSocket 多了两个属性 Upgrade: webSocket、Connection: Upgrade，服务端返回 101 成功状态码 单工、半双工和全双工通信 单工通信：指消息只能单向传输的工作方式，数据信息从一端到另一端是单向的。例如：广播 半双工通信：可以双向通信，但必须交替进行。例如：对讲机 全双工通信：指在通信的任意时刻，都允许数据同时在两个方向上传输，通讯双方都设置了发送器和接收器。 DNS 负载均衡当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用 DNS 负载均衡技术，它的原理是在 DNS 服务器中为同一个域名配置多个 IP 地址,在应答 DNS 查询时,DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 强缓存和协商缓存强缓存：（expires、Cache-Control）在过期时间内，浏览器再次加载资源时，不会向服务器发起请求，直接从缓存中读取资源 协商缓存：向服务器发送请求，服务器会根据请求头（request header）的一些参数（Etag、last-modified）来判断是否命中协商缓存，首先根据 Etag 的值判断请求的文件有没有被修改，如果 Etag 一致则没有被修改，命中协商缓存返回 304，如果不一致则返回新的资源并带上新的 Etag 返回 200 状态码。如果没有 Etag 值，则对比 If-Modified-Since 和请求文件的最后修改时间，一致则命中协商缓存返回 304，不一致则返回新的 last-modified 和 200 状态码 http 协议的特点1.支持客户/服务器模式 2.简单快速：客户向服务器发送请求时，只需传送请求方法和路径。 3.灵活：http 允许传输任意类型的数据对象（Content-Type 内容编码类型） application/x-www-form-urlencoded 常见 post 提交数据格式（key-value 格式）application/json 4.无连接：限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。（原因是早期服务器需要同时面对全世界数十万、上百万的客户端的网页访问，但是每次客户端与服务端传输的数据关联性很低，就会导致大部分通过会很空闲，无端占用资源） （解决无连接）Keep-Alive：使客户端到服务端之间的 Http 连接保持，不会断开，当再次对服务器发送请求时，keep-Alive 功能避免了重新建立连接 5.无状态：Http 是一个无状态协议，就是每个请求都是独立的，数据传输完毕不会记录任何信息。缺点就是如果后续处理需要前面的信息，就必须重传，就会导致每次连接传送的数据量增加，如果服务器不需要前面信息的时候应答就会很快。 （解决无状态）怎样保持 http 连接状态呢Cookie（每次 http 请求的时候，客户端都需要发送响应的 cookie 信息到服务端，服务端根据 cookie 判断来自哪个客户端）服务端生成 cookie，客户端保存 Session服务端生成一个 sessionid，在客户端下次请求的时候在 cookie 里面记录这个 sessionid，然后发送给服务端，服务端再根据 cookie 中的 sessionid 来识别客户端返回资源数据。 禁用 cookie 怎么办？url 重写，每次 http 请求的时候，在 url 后面拼接 sid=**参数 withCredentials:指定在涉及到跨域请求时，是否携带 cookie 信息，默认为 falseAccess-Control-Allow-Credentials: true cookie 和 session 的区别 存取方式不同： cookie 只能保存 ASCII 字符串，session 能够存储任意类型的数据 隐私策略不同 cookie 是存在客户端，session 是存在服务器的 浏览器的支持不同，浏览器可以禁用 cookie 权限身份验证一般都是通过 sessionid 来进行用户身份验证，sessionid 一般会存放在 redis 中。 用户向服务端发送用户名和密码进行登陆 服务器验证通过后，服务器为用户创建一个 session，并将 session 信息存储起来 服务器向用户返回一个 sessionid，写入用户的 cookie 当用户保持登陆状态时，每次后续请求都会一起发送给后端 服务器将存储在 cookie 中的 sessionid 和存储在内存或者数据库中的 sessin 信息进行一个比较，验证用户身份，然后返回响应信息 注意： 1.依赖 session 的关键业务一定要确保客户端开启了 cookie 2.注意 session 的过期时间 一般在 http header 的 Authorization 字段中添加 token 禁用 cookie 之后 session 还能用吗？url 重写，例如 https://javascript.cn/?session_id=xxx缺点是安全性降低，可以对 sessionid 进行一次加密后传输 get 和 post 的区别 url 可见性：get 参数 url 可见，post 参数 url 不可见 数据传输：get 通过拼接 url 进行传递参数，post 通过 body 体传输参数 缓存性：get 请求可以缓存，post 请求不可以缓存 get 请求网页回退时，不产生影响，post 请求网页回退会重新发请求 传输数据：get 一般传输数据大小不超过 4k，post 可以传输大量数据 post 较 get 安全性较高，get 是不安全的因为 url 可见，可能会泄漏私密信息 http 常见的请求头字段Accept: 浏览器可接受的数据类型Accept-Charset: 浏览器可接受的字符集Accept-Encoding：浏览器能够进行解码的数据编码方式Accept-Language： 浏览器所希望的语言种类Connection：是否需要持久连接，值“Keep-Alive”，HTTP1.1 默认进行持久连接Cookie：cookie 信息content-typeIf-Modified-Since：内容被修改才会返回User-Agent：浏览器类型 响应头：content-Length: 表示内容长度content-type：文档类型Date：当前时间Expires：指定缓存过期时间Last-Modified：文档过期时间 xss（跨域脚本攻击）csrf（跨站请求伪造）csrf: 需要用户先登陆网站 A，获取 cookie，利用的是网站 A 本身的漏洞，去请求网站 A 的 api，—进行 token 验证，referer 验证，只接收本站的请求 xss：向网站 A 注入 js 代码，然后执行 js 代码，篡改网站 A 的内容，破坏页面正常结构，插入恶意广告。—编码转换 正向代理和反向代理1234正向代理是客户端代理，服务端不知道是哪个客户端发起的请求反向代理是服务端代理，客户端不知道是哪个服务端提供的资源 三次握手为什么需要三次握手？两次握手第二次结束后，服务端并不能保证客户端已经接收到了第二次的应答信息，如此一来服务器会一直保持通信过程，因为 TCP 通信会占用端口，造成资源浪费。 防止已失效的连接请求报文段突然又传送到服务端，产生错误。如上述情况，如果 client 没有再次向 server 发出确认，server 收不到确认就不会建立连接，可以避免 server 端一直等待浪费资源。 四次挥手 https://blog.csdn.net/rememberyf/article/details/80309148 什么是 HTTPS 中间人攻击？如何预防？ HTTPS 加密传输 HTTP 明文传输 HTTPS 加密传输 HTTP + TLS/SSL 答案 使用正规厂商的加密证书可以防止中间人攻击 WebSocket 和 HTTP 有什么区别？ WebSocket 支持端对端通讯 可以由 client 发起，也可以由 server 发起 用于：消息通知，直播间讨论区，聊天室，协同编辑 client 1234567891011121314const { WebSocketServer } = require('ws');const wsServer = new WebSocketServer({ port: 3000 });wsServer.on('connection', (ws) =&gt; { console.log('connection'); ws.on('message', (msg) =&gt; { console.log('收到了信息', msg.toString()); setTimeout(() =&gt; { ws.send('服务端已经收到了信息' + msg.toString()); }, 2000); });}); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241- server```typescriptconst ws = new WebSocket('ws://127.0.0.1:3000');ws.onopen = () =&gt; { console.log('opened'); ws.send('client opened');};ws.onmessage = (event) =&gt; { console.log('收到了信息', event.data);};const btn = document.getElementById('btn');btn.addEventListener('click', () =&gt; { console.log('clicked'); ws.send('当前时间' + Date.now());});```- WebSocket 连接过程 - 先发起一个 http 请求 - 成功之后再升级到 WebSocket 协议，再通讯- WebSocket 和 HTTP 区别？ - WebSocket 协议名是 ws://,可双端发起请求 - WebSocket 没有跨域限制 - 通过 send 和 onmessage 通讯（HTTP 通过 req 和 res）- ws 可升级为 wss（like https） ```typescript import { createServer } from 'https'; import { readFileSync } from 'fs'; import { WebSocketServer } from 'ws'; const server = createServer({ cert: readFileSync('/path/to/cert.pem'), key: readFileSync('/path/to/key.pem'), }); const wss = new WebSocketServer({ server }); ```- 实际项目推荐 socket.io,API 更简洁## WebSocket 和 HTTP 长轮询的区别？- 区别 - HTTP 长轮询：客户端发起请求，服务端阻塞，不会立即返回 - WebSocket：客户端可发起请求，服务端也可发起请求- 注意 - HTTP 长轮询，需处理 timeout，即 timeout 之后重新发请求## ajax- xhr.readyState - 0 (未初始化)还没有调用 send()方法 - 1 (载入)已调用 send()方法，正在发送请求 - 2 (载入完成) send()方法执行完成，已经接收到全部响应内容 - 3 (交互) 正在解析响应内容 - 4 (完成) 响应内容解析完成，可以在客户端调用- xhr.status - 2xx 表示成功处理请求，如 200 - 3xx 需要重定向，浏览器直接跳转，如 301、302、304 - 4xx 客户端请求错误，如 404、403 - 5xx 服务端错误## 常见状态码？信息响应- 101 协议切换成功响应- 200 成功- 204 请求成功，不返回任何内容- 206 分块请求成功重定向- 301 永久重定向（配合 location，浏览器自动处理）- 302 临时重定向（配合 location，浏览器自动处理）- 304 资源未被修改（协商缓存 ）客户端响应- 400 无法被服务器理解- 401 未授权- 403 禁止访问- 404 资源未找到- 405 没有权限,请求方法(get/post 等)错误服务端响应- 500 服务器错误- 503 服务不可达- 504 网关超时- 本身状态码就是一种约定，一种协议和规范，不要尝试违反规范，例如 IE 浏览器## http 常见 methods？- 传统 methods - get 获取服务器的数据 - post 向服务器提交数据- 新的 methods - get 获取数据 - post 新建数据 - patch/put 更新数据 - delete 删除数据## Restful API- 一种新的 API 设计方法- 传统 API 设计：把每个 url 当作一个功能- Restful API 设计：把每个 url 当作一个唯一的资源- 原则 - 不使用 url 参数 - 传统 API 设计：/api/list?pageIndex=2 - Restful API 设计：/api/list/2 - 用 method 表示操作类型 - 传统 API 设计 - post 请求 /api/create-blog - post 请求 /api/update-blog?id=100 - get 请求 /api/get-blog?id=100 - Restful API 请求 - post 请求 /api/blog - patch 请求 /api/blog/100 - get 请求 /api/blog/100## 常见 http headers？- Request Headers - Accept 浏览器可接收的数据格式 - Accept-Encoding 浏览器可接收的压缩算法，如 gzip - Accept-Languange 浏览器可接收的语言，如 zh-CN - Connection: keep-alive 一次 TCP 连接重复使用 - cookie - Host 如：www.baidu.com - Cache-Control - User-Agent （简称 UA）浏览器信息 - Content-type 发送数据的格式，如 application/json- Response Headers - Content-type 返回数据的格式，如 application/json - Content-length 返回数据的大小，多少字节 - Content-Encoding 返回数据的压缩算法，如 gzip - Set-Cookie - Expires - Etag - date- 自定义 header- 缓存相关的 headers - Cache-Control Expires - Last-Modified If-Modified-Since - Etag If-None-Match## TCP 协议如何保证传输的可靠性- 校验和- 确认应答 + 序列号- 超时重传- 流浪控制- 拥塞控制- TCP 的连接管理- 滑动窗口## http 和 https 的区别- http 是一种一种广泛使用的网络协议，是一个客户端和服务器请求和应答的标准。- http 工作在 TCP 协议的 80 端口，https 工作在 TCP 协议的 443 端口- http 协议运行在 TCP 协议之上，所有的传输内容都是明文，https 运行在 SSL/TLS 之上， SSL/TLS 运行在 TCP 之上，所有的传输内容都是经过加密的。- https 是以安全为目标的 http 通道，是 http 的安全版。是 http 加上 SSL 层对传输的信息和 url 做了一些加密处理，更加安全## 为什么 https 不会被截取信息- 完成 TCP 三次同步握手- 客户端验证服务器数字证书，通过，进入步骤 3- DH 算法协商对称加密算法的密钥、hash 算法的密钥- SSL 安全加密隧道协商完成- 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性； 用协商的 hash 算法进行数据完整性保护，保证数据不被篡改## 如何处理 TCP 的粘包?发生 TCP 粘包或拆包有很多原因，现列出常见的几点：要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。关键点：如何给每个数据包添加边界信息发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。## 请说说 HTTPS 的握手过程？HTTPS 的握手过程主要包括以下步骤：客户端向服务端发送一个加密过的客户端随机数和客户端支持的加密算法列表，同时请求建立 SSL/TLS 连接。服务端在接收到请求后，向客户端发送一个包含服务端随机数、服务器支持的加密算法列表以及服务器的数字证书的报文。客户端在接收到服务器的响应后，会对证书进行校验。如果证书被认为是合法的，那么客户端将使用证书中包含的公钥对一个随机数进行加密，并将加密后的随机数发送给服务端。服务端在接收到客户端的响应后，使用私钥对加密的随机数进行解密，得到客户端生成的随机数。同时，服务端也会生成一个加密的会话密钥，并使用客户端和服务端的随机数以及协商出的加密算法对该密钥进行加密，最后将加密后的密钥发送给客户端。客户端接收到服务端发送的加密的会话密钥后，使用服务端公布的公钥进行解密，得到原始的会话密钥。客户端和服务端都会使用会话密钥进行加密和解密，从而实现安全的通信。这个过程中，客户端和服务端会进行多次来回的通信，以建立安全的 SSL/TLS 连接。其中数字证书的校验和会话密钥的生成都是关键步骤，它们保证了通信的安全性。## 请说说什么是数字证书？它有什么作用?- 数字证书是一种加密技术，用于验证在线交互中的身份和信息安全性。它是由可信任的第三方机构（例如数字证书颁发机构）颁发的一份电子文档，其中包含了一些加密信息，如公钥、数字签名等。数字证书的作用是确保通信双方的身份和数据的完整性和保密性。- 在使用数字证书进行加密通信时，服务端会向证书颁发机构申请一份数字证书。数字证书包含了服务端的公钥，以及一些描述服务端身份的信息，例如域名、组织名称等。客户端在与服务端建立连接时，会向服务端请求数字证书，并验证证书的真实性和合法性。如果验证成功，客户端就可以使用服务端的公钥加密数据并发送给服务端了。同时，服务端也可以使用客户端的公钥进行数据的加密和验证。这样就可以确保通信过程中的数据不被窃听或篡改。- 数字证书的使用广泛，特别是在网站安全和电子商务领域。它可以用来验证网站的真实性和合法性，确保网站访问过程中的信息安全。此外，数字证书还可以用于文件签名、电子邮件加密等其他领域。","link":"/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"获取唯一id的三种方法","text":"uuid 1234567891011const UUID = (len = 32) =&gt; { return &quot;xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx&quot; .replace(/[xy]/g, function replace(c) { /* eslint-disable no-bitwise */ const r = (Math.random() * 16) | 0; const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8; return v.toString(16); }) .substring(0, len);}; nanoid1234567891011121314151617const nanoid = (t = 21) =&gt; { let e = &quot;&quot;, r = crypto.getRandomValues(new Uint8Array(t)); for (; t--; ) { let n = 63 &amp; r[t]; e += n &lt; 36 ? n.toString(36) : n &lt; 62 ? (n - 26).toString(36).toUpperCase() : n &lt; 63 ? &quot;_&quot; : &quot;-&quot;; } return e;}; 原生方法1const id = URL.createObjectURL(new Blob()).substr(-36)","link":"/2022/01/04/%E8%8E%B7%E5%8F%96%E5%94%AF%E4%B8%80id%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"面试手写篇","text":"数组去重 12345678910111213141516171819202122232425262728293031323334353637383940// indexOffunction unique(arr) { let res = []; for (let i = 0; i &lt; arr.length; i++) { if (res.indexOf(arr[i]) &lt; 0) { res.push(arrp[i]); } } return res;}// includesfunction unique(arr) { let res = []; for (let item of arr) { if (!res.includes(item)) { res.push(item); } } return res;}// 利用filter + indexOffunction unique(arr) { const res = arr.filter(function (item, index, array) { return array.indexOf(item) === index; }); return res;}// 利用Es6中的Set数据结构(扩展运算符)const unique = (arr) =&gt; [...new Set(arr)];// Array.form 方法将set结构转换为数组const unique = (arr) =&gt; Array.from(new Set(arr)); 数组扁平化123456789101112131415let arr = [1, [2, [3]]];// let res = arr.flat(Infinity)// let res = JSON.parse(JSON.stringify(arr).replace(/\\[|\\]/g,&quot;&quot;))function flatArr(arr) { let res = arr.reduce((accu, curr) =&gt; { return accu.concat(Array.isArray(curr) ? flatArr(curr) : curr); }, []); return res;}console.log(flatArr(arr)); 浅拷贝12345678910111213141516171819202122// 只考虑对象类型function shallowCopy(obj) { if (typeof obj !== 'object') return; let newObj = obj instanceof Array ? [] : {}; if (obj === null) return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key]; } } return newObj;}// Object.assign()// arr.slice(0)// arr.concat()// 扩展运算符 深拷贝123456789101112131415161718192021// 只考虑普通对象属性，不考虑内置对象和函数function deepCone(obj) { if (typeof obj !== 'object') return; let newObj = obj instanceof Array ? [] : {}; if (obj === null) return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]; } } return newObj;}// JSON.parse(JSON.stringify())// lodash: _.cloneDeep() 实现一个 compose(组合)函数12345678910111213141516171819202122function compose(...fn) { if(!fn.length) return (v) =&gt; v; if(fn.length === 1) return fn[0]; return fn.reduce((accu, curr) =&gt; (...args) =&gt; accu(curr(...args)) );}例子：function fn1(x) { return x + 1;}function fn2(x) { return x + 2;}function fn3(x) { return x + 3;}function fn4(x) { return x + 4;}const res = compose(fn1, fn2, fn3, fn4);console.log(res(5)); // 5+4+3+2+1=15 函数柯里化 函数柯里化就是让我们传递参数的方式不在局限于一次传完，可以分步，所以柯里化的核心就在于等到接收到的参数等于函数参数时再调用函数把所有参数传递进去 1234567891011121314151617181920212223242526function curry(fn, ...args) { // 需要柯里化的函数fn，也可以支持初始参数的传入 return function () { //参数缓存在args里面,合并上次参数和本次参数 args = [...args, ...arguments]; // 判断参数个数，不够继续递归 if (args.length &lt; fn.length) { return curry(fn, ...args); } else { //参数足够返回函数执行结果 return fn.apply(null, args); } };}function bar(a, b, c) { return a + b + c;}const f = curry(bar);console.log(f(1)(2)(3));console.log(f(1, 2)(3));console.log(f(1, 2, 3)); assign12345678910111213141516171819Object.assign = function (target, ...source) { if (target === null || target === undefined) { throw new TypeError('Cannot convert undefined or null to object'); } let result = Object(target); source.forEach(function (obj) { if (obj !== null) { for (let key in obj) { if (obj.hasOwnProperty(key)) { result[key] = obj[key]; } } } }); return result;}; 防抖函数12345678910111213function debounce(func, wait) { let timeout; return function () { clearTimeout(timeout); timeout = setTimeout(() =&gt; { func.apply(this, arguments); }, wait); };}// 搜索联想，用户在不断输入时，用防抖来节约请求资源// window触发resize的时候 节流函数12345678910111213141516function throttle(func, wait) { const previous = 0; return function () { const now = +new Date(); if (now - previous &gt; wait) { func.apply(this, arguments); previous = now; } };}// 鼠标不断点击触发，可以使其单位时间内只触发一次// 监听滚动事件// 防止高频点击提交 如何把字符串中大小写取反1234567let str = 'LiBoShi';str = str.replace(/[a-zA-Z]/g, (content) =&gt; { return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();}); 从 S 中查找 T 字符串，找到返回索引值，没有则返回-1，类似 indexOf12345678910111213141516171819// 普通方法function myIndexOf(T) { let index = -1; for (let i = 0; i &lt;= this.length - T.length; i++) { if (this.substr(i, T.length) === T) { return (index = i); } } return index;}String.prototype.myIndexOf = myIndexOf;// 正则方法function myIndexOf(T) { let reg = new RegExp(T); let res = reg.exec(this); return res === null ? -1 : res.index;} new 操作符1234567891011121314151617// 构造一个全新的对象// 新对象会被执行[[prototype]]连接// 新对象绑定到函数调用的this// 如果函数没有返回其他对象，那么返回对象本身，否则返回其他对象function newFn(fn, ...args) { const obj = Object.create(fn.prototype); const result = fn.apply(obj, args); return typeof result === 'object' &amp;&amp; result !== null ? result : obj;}function Person(name) { this.name = name;}const p = newFn(Person, 'Jerome');console.log('p.name :&gt;&gt; ', p.name); // p.name :&gt;&gt; Jerome call12345678910111213141516171819202122232425Function.prototype.myCall = function (context, ...args) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;};// 使用let obj = { desc: function (from, to) { console.log(`${this.name}来自${from}去往${to}`); },};let person = { name: 'lbs',};obj.desc.myCall(person, '北京', '上海'); apply1234567891011Function.prototype.myApply = function (context, args = []) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;}; bind12345678910111213Function.prototype.myBind = function (content, ...args) { const fn = this; return function newFn(...newFnArgs) { // 检测 New // 如果当前函数的this指向的是构造函数中的this 则判定为new 操作 if (this instanceof newFn) { return new fn(...args, ...newFnArgs); } return fn.myApply(context, [...args, ...newFnArgs]); };}; instanceof1234567891011// 1. 通过left.__proto__.__proto__这种方式从下往上的获取原型对象// 2. 通过Object.create(null)的实例是没有原型链// 3. 有原型链的实例的尽头都是Objectfunction _instanceof(left, right) { if (!left.__proto__) return false; if (right === Object || left.__proto__ === right.prototype) return true; return _instanceof(left.__proto__, right);}_instanceof(/123/, RegExp); 手写 Object.is123456789function is(x, y) { if (x === y) { // x,y都为0，但是1 / +0 = +Infinity,1 / -0 = -Infinity 是不一样的 return x !== 0 || y !== 0 || 1 / x === 1 / y; } else { //NaN === NaN = false是不对的，做一个拦截操作 return x !== x &amp;&amp; y !== y; }} ajax12345678910111213141516171819202122232425262728function ajax(method, url, headers, body) { return new Promise((resolve, reject) =&gt; { let req = null; try { req = new XMLHttpRequest(); } catch { req = new ActiveXObject('Microsoft.XMLHTTP'); } req.open(method, url); for (let key in headers) { req.setRequestHeader(key, headers[key]); } req.onreadystatechange(() =&gt; { if (req.readystate === 4) { if (req.status &gt;= 200 &amp;&amp; req.status &lt;= 300) { resolve(req.responseText); } else { reject(req); } } }); req.send(body); });} map123456789101112Array.prototype.map = function (fn, toThis) { const arr = this; const result = []; const _this = toThis || Object.create(null); for (let i = 0; i &lt; arr.length; i++) { const item = fn.call(_this, arr[i], i, arr); result.push(item); } return result;}; 手写 promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161class Promise1 { static PENDING = 'pending'; static FULFILLED = 'fulfilled'; static REJECTED = 'rejected'; constructor(executor) { this.status = Promise.PENDING; //默认状态，进行中 this.value = null; //成功值 this.reason = null; // 失败原因 // 解决异步问题 this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; try { executor(this.resolve.bind(this), this.reject.bind(this)); } catch (e) { this.reject(e); } } resolve(value) { if (this.status === Promise.PENDING) { this.status = Promise.FULFILLED; this.value = value; setTimeout(() =&gt; { this.onFulfilledCallbacks.forEach((cb) =&gt; cb(this.value)); }); } } reject(reason) { if (this.status === Promise.PENDING) { this.status = Promise.REJECTED; this.reason = reason; setTimeout(() =&gt; { this.onRejectedCallbacks.forEach((cb) =&gt; cb(this.reason)); }); } } then(onFulfilled, onRejected) { if (typeof onFulfilled !== 'function') { onFulfilled = () =&gt; this.value; } if (typeof onRejected !== 'function') { onRejected = () =&gt; this.reason; } return new Promise1((resolve, reject) =&gt; { if (this.status === Promise.PENDING) { return new Promise1((resolve, reject) =&gt; { this.onFulfilledCallbacks.push(() =&gt; { this.parse(onFulfilled(this.value), resolve, reject); }); }); return new Promise1((resolve, reject) =&gt; { this.onRejectedCallbacks.push(() =&gt; { this.parse(onRejected(this.value), resolve, reject); }); }); } if (this.status === Promise.FULFILLED) { setTimeout(() =&gt; { return new Promise1((resolve, reject) =&gt; { this.parse(onFulfilled(this.value), resolve, reject); }); }); } if (this.status === Promise.REJECTED) { setTimeout(() =&gt; { return new Promise1((resolve, reject) =&gt; { this.parse(onRejected(this.reason), resolve, reject); }); }); } }); } parse(result, resolve, reject) { try { if (result instanceof Promise1) { result.then(resolve, reject); } else { resolve(result); } } catch (error) { reject(error); } } static resolve(value) { return new Promise1((resolve, reject) =&gt; { if (value instanceof Promise1) { value.then(resolve, reject); } else { resolve(value); } }); } static reject(reason) { return new Promise1((resolve, reject) =&gt; { reject(reason); }); } static all(promises) { const result = []; return new Promise1((resolve, reject) =&gt; { promises.forEach((promise) =&gt; { promise.then( (value) =&gt; { result.push(value); if (result.length === promises.length) { resolve(result); } }, (reason) =&gt; { reject(reason); } ); }); }); } static race(promises) { return new Promise1((resolve, reject) =&gt; { promises.forEach((promise) =&gt; { promise.then( (value) =&gt; { resolve(value); }, (reason) =&gt; { reject(reason); } ); }); }); }}let aaa = new Promise1((resolve, reject) =&gt; { resolve('lbs'); // reject('error')}).then((value) =&gt; { console.log(value); return '666';});aaa.then(() =&gt; { console.log(123);});console.log(aaa); 手写 promise.allSettled1234567891011121314151617181920212223242526272829303132333435function PromiseAllSettled(promiseArr) { return new Promise((resolve, reject) =&gt; { if (!Array.isArray(promiseArr)) { reject(new TypeError('arguments must be an array')); } const res = []; let count = 0; for (let i = 0; i &lt; promiseArr.length; i++) { Promise.resolve(promiseArr[i]) .then((value) =&gt; { res[i] = { status: 'fulfilled', value, // 出题：输入一个 Promise 实例数组，输出最快、最慢的实例，以及每个实例的响应时长 //加一个执行时间计算 cost: Date.now() - startTime, }; }) .catch((reason) =&gt; { res[i] = { status: 'rejected', reason, //加一个执行时间计算 cost: Date.now() - startTime, }; }) .finally(() =&gt; { count++; if (count == promiseLen) { resolve(res); } }); } });} 手写 event bus12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class EventEmitter { constructor() { this.events = {}; this.maxListeners = maxListeners || Infinity; } emit(event, ...args) { const cbs = this.events[event]; if (!cbs) { console.log('没有这个事件函数'); return this; } cbs.forEach((cb) =&gt; cb.apply(this, args)); return this; } on(event, cb) { if (!this.events[event]) { this.events[event] = []; } if ( this.maxListeners !== Infinity &amp;&amp; this.events[event].length &gt;= this.maxListeners ) { console.log('当事件超过了最大监听数'); return this; } this.events[event].push(cb); return this; } once(event, cb) { const fn = (...args) =&gt; { this.off(event, fn); cb.apply(this, args); }; this.on(event, func); return this; } off(event, cb) { if (!cb) { this.events[event] = null; } else { this.events[event] = this.events[event].filter((item) =&gt; item !== cb); } return this; }} 继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 构造函数继承function Person() { this.name = 'lbs';}function Student() { Person.call(this); this.age = 18;}const s = new Student();// 原型链继承function Person() { this.name = 'lbs';}function Student() { this.age = 18;}Student.prototype = new Person();const s = new Student();//寄生式组合继承function Person(obj) { this.name = obj.name;}function Student(obj) { Person.call(this, obj); this.age = obj.age;}// object.create()// 方法创建一个新对象，使用现有的对象来提供新创建对象的__proto__Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;// 或者：Student.prototype = Object.create(Person.prototype, { constructor: { value: Student, enumerable: false, writable: true, configurable: true, },});const student = new Student({ name: 'lbs', age: 18 });console.log(student); createElement 手写1234567891011121314151617181920212223242526272829303132333435363738394041424344const symbolFor = Symbol.for;const REACT_ELEMENT_TYPE = symbolFor('react.element');const RESERVED_PROPS = { key: true, ref: true, __self: true, __source: true,};function createElement(type, config, children) { const props = {}; let key = null; if (config !== null) { key = config.key; } for (let propName in config) { if (!RESERVED_PROPS.hasOwnProperty(propName)) { props[propName] = config[propName]; } } const childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = children; } else if (childrenLength &gt; 1) { const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } props.children = childArray; } const element = { $$typeof: REACT_ELEMENT_TYPE, type, key, props, };} 编写正则，验证一个 6 ～ 16 位的字符串，必须同时包含大小写字母和数字1234567正向预查 ？= 必须反向预查 ？！必须不let reg = /(?!^[a-zA-Z]+$)(?!^[0-9]+$)(?!^[a-z0-9]+$)(?!^[A-Z0-9]+$)^[a-zA-Z0-9]{6,16}$/;补充：数字、字母、下划线组成字符串，必须有_let reg = /(?=_)\\w/;let reg = /(?!^[a-zA-Z0-9]+$)^\\w{1,10}$/; 限制1-10位 获取所有属性为 name，值为 value 的元素集合12345678910111213141516171819202122232425// 正则\\b单词边界function getElements(property, value) { let elements = document.getElementsByTagName('*'); let arr = []; elements = Array.from(elements); elements.forEach((item) =&gt; { // 当前元素property对应的值 let itemValue = item.getAttribute(propertype); if (property === 'class') { const reg = new RegExp(`\\b${value}\\b`); if (reg.test(itemValue)) { arr.push(item); } } if (itemValue === value) { arr.push(item); } }); return arr;} 英文字母汉字组成的字符串，用正则给英文单词前后加空格12345678let str = '中国hello你好';let reg = /\\b[a-z]+\\b/gi;str = str .replace(reg, (value) =&gt; { return ` ${value} `; }) .trim(); // 去除首尾空格 js 实现斐波那契数列的几种方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1.递归function fibonacci(n) { if (n === 1 || n === 2) { return 1; } return fibonacci(n - 1) + fibonacci(n - 2);}// 2.尾递归(每次调用都在收集结果，避免了线性递归不收集结果只依次展开消耗内存的坏处)function fibonacci(n, res1 = 1, res2 = 1) { if (n &lt;= 2) return res2; return fibonacci(n - 1, res2, res1 + res2);}// 循环function fibonacci(n) { let num1 = 1; let num2 = 2; let sum = 1; for (let i = 3; i &lt; n; i++) { sum = num1 + num2; num1 = num2; num2 = sum; } return sum;}// 数组function fibonacci(n) { const arr = [0, 1, 1]; if (n &lt; 0) { throw new Error('输入的数字不能小于0'); } if (n &gt;= 3) { for (let i = 3; i &lt;= n; i++) { arr[i] = arr[i - 1] + arr[i - 2]; } } return arr[n];} js 并发调度器12345678910111213141516171819202122232425262728293031323334353637383940414243//题目：// 延迟函数const sleep = (time) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, time));// 同时进行的任务最多2个const scheduler = new Scheduler(2);// 添加异步任务// time: 任务执行的时间// val: 参数const addTask = (time, val) =&gt; { scheduler.add(() =&gt; { return sleep(time).then(() =&gt; console.log(val)); });};addTask(1000, '1');addTask(500, '2');addTask(300, '3');addTask(400, '4');// 答：class Scheduler { constructor(max) { this.max = max; this.count = 0; this.queue = []; } add(p) { this.queue.push(p); this.start(); } start() { if (this.count &gt;= this.max || !this.queue.length) return; this.count++; this.queue .shift()() .finally(() =&gt; { this.count--; this.start(); }); }} 并发加载1234567891011121314151617181920212223242526272829303132333435363738394041function limitLoad(urls, handler, limit) { let promises = []; const limitUrls = urls.slice(0, limit); const restUrls = urls.slice(limit); promises = limitUrls.map((url, index) =&gt; { return handler(url).then(() =&gt; { return index; }); }); let p = Promise.race(promises); for (let i = 0; i &lt; restUrls.length; i++) { p = p.then((index) =&gt; { promises[index] = handler(restUrls[i]).then(() =&gt; { return index; }); return Promise.race(promises); }); }}function loadImg(url) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(url.info + '---OK!!!'); resolve(); }, url.time); });}let urls = [ { info: 1, time: 2000 }, { info: 2, time: 1000 }, { info: 3, time: 3000 }, { info: 4, time: 4000 }, { info: 5, time: 5000 },];limitLoad(urls, loadImg, 3); 前端内存处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781. 内存的生命周期 内存分配：声明变量、函数对象的时候，js会自动分配内存 内存使用 内存回收2. js中的垃圾回收机制 引用计数：缺点循环引用无法清除 标记清除3. 常见内存泄漏 全局变量（记得手动回收） 未被清除的定时器 闭包 dom的引用4. 怎么避免内存泄漏 减少不必要的全局变量 使用完数据，及时解除引用实现sizeOf，传入object，计算其所占字节大小number: 8 字节string: 2 字节boolean; 4 字节const seen = new WeakSet();function sizeOfObject(obj) { if (obj === null) { return 0; } let bytes = 0; const keys = Object.keys(obj); for(let i = 0; i &lt; keys.length; i++) { const key = keys[i]; bytes += calculator(key); if (typeof obj[key] === 'object' &amp;&amp; obj[key] !== null) { if (seen.has(obj[key])) { continue; } seen.add(obj[key]) } bytes += calculator(obj[key]) }}function calculator(obj) { const objType = typeof obj; switch(objType) { case 'string': { return obj.length * 2 } case 'boolean': { return 4 } case 'number': { return 8 } case 'object': { if (Array.isArray(obj)) { return obj.map(calculator).reduce((accu, curr) =&gt; { return accu + curr }, 0) } else { return sizeOfObject(obj) } } default: { return 0 } }} 数据结构就是在计算机中存储和组织数据的方式。 算法（Algorithm）解决问题的逻辑或步骤 封装函数使字符串以驼峰式命名 已知字符串 foo = ‘get-element-by-id’,写一个函数将其转换为驼峰式命名“getElementById” 123456var foo = 'get-element-by-id';var arr = foo.split('-');for (var i = 1; i &lt; arr.length; i++) { arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1);}console.log(arr.join('')); 1234567891011//封装function toString(foo) { var arr = foo.split('-'); for(var i = 1; i &lt; arr.length; i++) { arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1) } return arr.join('');}console.log(toString('get-element-by-id')) 把 the-first-name 变成 theFirstName 123456var reg = /-(\\w)/gvar str = &quot;the-first-name&quot;console.log(str.replace(reg, function($, $1){ return $1.toUpperCase()})) 把 aabb 换成 bbaa 12345678var reg = /(\\w)\\1(\\w)\\2/g;var str = 'aabb';// console.log(str.replace(reg,&quot;$2$2$1$1&quot;));//&quot;bbaa&quot;console.log( str.replace(reg, function ($, $1, $2) { return $2 + $2 + $1 + $1; })); 正则简单的去重 123var str = &quot;aaaabbbbbccccc&quot;;var reg = /(\\w)\\1*/g;console.log.replace(reg,&quot;$1&quot;));//abc 定制化输出特定数组 随机生成一个长度为 10 的整数类型的数据 例如 [2, 10, 3, 35, 5, 11, 10, 11, 20] 将其排列成一个新数组，要求新数组形式如下： [[2, 3, 5], [10, 11],[20],[35]] 12345678910111213141516171819202122232425262728// 1. 获取随机数 0-99function getRandomNumber(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min);}let arr = Array.from({ length: 10 }, () =&gt; getRandomNumber(0, 99));// 2. 去重(没必要)arr = [...new Set(arr)];// 3. 排序arr.sort((a, b) =&gt; a - b);// 4. 存储 0-9 10-19 20-29const map = {};arr.forEach((item) =&gt; { const key = Math.floor(item / 10); if (!map[key]) { map[key] = []; } map[key].push(item);});const result = [];for (const key in map) { result.push(map[key]);}console.log(result); 深度比较 isEqual123456789101112131415161718192021222324252627function isEqual(obj1, obj2) { //其中一个为值类型或null if (!isObject(obj1) || !isObject(obj2)) { return obj1 === obj2; } //判断是否两个参数是同一个变量 if (obj1 === obj2) { return true; } //判断keys数是否相等 const obj1Keys = Object.keys(obj1); const obj2Keys = Object.keys(obj2); if (obj1Keys.length !== obj2Keys.length) { return false; } //深度比较每一个key for (let key in obj1) { if (!isEqual(obj1[key], obj2[key])) { return false; } } return true;} 根据数组的 key 去重1234567891011121314151617const dedup = (data, getKey = () =&gt; {}) =&gt; { const dateMap = data.reduce((pre, cur) =&gt; { const key = getKey(cur); if (!pre[key]) { pre[key] = cur; } return pre; }, {}); return Object.values(dateMap);};let data = [ { id: 1, v: 1 }, { id: 2, v: 2 }, { id: 1, v: 1 },];console.log(dedup(data, (item) =&gt; item.id)); react 自定义封装不会反复创建的定时器（setInterval）123456789101112131415161718192021222324import { useRef, useState } from 'react';const useTimer = (step = 1) =&gt; { const timer = useRef(null); const [num, setNum] = useState(0); const start = () =&gt; { const timeout = setInterval(() =&gt; { setNum((num) =&gt; num + 1); }, step * 1000); timer.current = timeout; }; const clear = () =&gt; { setNum(0); clearInterval(timer.current); }; return { num, start, clear, };}; 修改下面代码，顺序输出 0-9912345678910111213141516171819202122232425262728293031323334353637383940// 要求：// 1. 只能修改 setTimeout// 2. 不能修改Math.floor(Math.random() * 1000)// 3. 不能使用全局变量function print(n) { setTimeout(() =&gt; { console.log(n); }, Math.floor(Math.random() * 1000));}for (var i = 0; i &lt; 100; i++) { print(i);}// 答案// 方法1: 立即执行函数function print(n) { setTimeout( (() =&gt; { console.log(n); return () =&gt; {}; })(), Math.floor(Math.random() * 1000) );}for (var i = 0; i &lt; 100; i++) { print(i);}// 方法2: setTimeout第三个参数function print(n) { setTimeout( () =&gt; { console.log(n); }, 10, Math.floor(Math.random() * 1000) );}for (var i = 0; i &lt; 100; i++) { print(i);} for 循环和 splice 的坑12345678910111213141516171819202122232425262728// for循环和splice的坑// 具体描述：在对一个数组执行for循环时，// 删除数组元素，会存在什么问题// 方法1: i--const arr = ['a', 'a', 'a', 'd', 'e', 'f'];for (let i = 0; i &lt; arr.length; i++) { if (arr[i] === 'a') { arr.splice(i, 1); i--; // 需要处理下 i-- }}// 方法2: 倒序const arr = ['a', 'a', 'a', 'd', 'e', 'f'];for (let i = arr.length - 1; i &gt;= 0; i--) { if (arr[i] === 'a') { arr.splice(i, 1); }}// for...inconst arr = ['a', 'a', 'a', 'd', 'e', 'f'];for (let index in arr) { if (arr[index] === 'a') { arr.splice(index, 1); index--; // 仍然会有问题 }}console.log(arr); 复杂度 程序执行时需要的计算量和内存空间 复杂度是数量级，不是具体的数字 一般是针对一个具体的算法，而非一个完整的系统 将一个数组旋转 K 步 输入一个数组[1, 2, 3, 4, 5, 6, 7] k=3,即旋转 3 步 输出[5, 6, 7, 1, 2, 3, 4] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @param arr 原数组 * @param k 步数 * 时间复杂度O(n^2),空间复杂度O(1) */function rotate1(arr: number[], k: number): number[] { const length = arr.length; if (!k || length === 0) return arr; const step = Math.abs(k % length); for (let i = 0; i &lt; step; i++) { const n = arr.pop(); if (n != null) { // unshift内置api时间复杂度位O(n),开销比较大 arr.unshift(n); } } return arr;}/** * @param arr 原数组 * @param k 步数 * 时间复杂度O(1)，空间复杂度O(n) */function rotate2(arr: number[], k: number): number[] { const length = arr.length; if (!k || length === 0) return arr; const step = Math.abs(k % length); const part1 = arr.slice(-step); const part2 = arr.slice(0, length - step); const part3 = part1.concat(part2); return arr;}/** * 性能测试 */const arr = [];for (let i = 0; i &lt; 10 * 10000; i++) { arr.push(i);}console.time('rotate1');rotate1(arr, 9 * 10000);console.time('rotate1');console.time('rotate2');rotate2(arr, 9 * 10000);console.time('rotate2'); 两个栈实现一个队列 请用两个栈实现一个队列 API：add delete length 123456789101112131415161718192021222324252627282930313233343536class Queue { private stack1: number[] = []; private stack2: number[] = []; add(n: number) { this.stack1.push(n); } delete(): number | null { let res; while (stack1.length) { const n = stack1.pop(); if (n != null) { stack2.push(n); } } res = stack2.pop(); while (stack2.length) { const n = stack2.pop(); if (n != null) { stack1.push(n); } } return res || null; } get length(): number { return this.stack1.length; }} 定义一个 js 函数，反转单向链表链表是一种物理结构(非逻辑结构),类似数组数组需要一段连续的内存空间，而链表是零散的链表节点的数据结构{ value, next?, prev? } 链表 vs 数组都是有序结构链表：查询慢 O(n),新增和删除快 O(1)数组：查询快 O(1),新增和删除慢 O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465interface ILinkListNode { value: number; next?: ILinkListNode;}/** * 创建链表 * @param arr 数组 */function createLinkList(arr: number[]): ILinkListNode { const length = arr.length; if (length === 0) throw new Error('arr is empty'); let curNode: ILinkListNode = { value: arr[length - 1], }; if (length === 1) return curNode; for (let i = length - 2; i &gt;= 0; i--) { curNode = { value: arr[i], next: curNode, }; } return curNode;}const arr = [100, 200, 300];const list = createLinkList(arr);console.info('list', list);/** * 反转单向链表，返回反转后的head node * @param listNode 需要操作的链表 */function reverseLinkList(listNode: ILinkListNode): ILinkListNode { let prevNode: ILinkListNode | undefined; let curNode: ILinkListNode | undefined; let nextNode: ILinkListNode | undefined = listNode; while (nextNode) { // 第一个元素，删除next指针，防止循环引用 if (curNode &amp;&amp; !prevNode) { delete curNode.next; } // 反转指针 if (curNode &amp;&amp; prevNode) { curNode.next = prevNode; } prevNode = curNode; curNode = nextNode; nextNode = nextNode?.next; } // 处理链表最后一个元素 curNode!.next = prevNode; return curNode!;}const reverseList = reverseLinkList(list);console.info('reverseList', reverseList); 栈(封装)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function Stack() { this.items = []; // 1. 将元素压入栈 Stack.prototype.push = function (element) { this.items.push(element); }; // 2.从栈中取出元素 Stack.prototype.pop = function () { return this.items.pop(); }; // 3.查看一下栈顶元素 Stack.prototype.peek = function () { return this.items[this.items.length - 1]; }; // 4.判断栈是否为空 Stack.prototype.isEmpty = function () { return !this.items.length; }; // 5.获取栈中元素个数 Stack.prototype.size = function () { return this.item.length; }; // 6. toString方法 Stack.prototype.toString = function () { let res = ''; for (let i = 0; i &lt; this.items.length; i++) { res += `${this.items[i]} `; } return res; };}const stack = new Stack();// 实例：将十进制转换成二进制function dec2bin(decimalNumber) { let stack = new Stack(); let binary = ''; while (decimalNumber &gt; 0) { stack.push(decimalNumber % 2); decimalNumber = Math.floor(decimalNumber / 2); } while (!stack.isEmpty()) { binary += stack.pop(); } return binary;} 深度封装 typeof 判断function myTypeof(val) { var type = typeof(val) var res = { '[object Object]' : 'object', '[object Array]' : 'array', '[object Number]' : 'object number', '[object String]' : 'object string', '[object Boolean]' : 'object boolean' } if (val === null) { return 'null' } else if (type == 'object') { var str = Object.prototype.toString.call(val) return res[str] } else { return type } } 翻转链表12345678910111213141516171819202122232425262728293031323334// 递归var reverseList = function (head) { if (head === null || head.next === null) return head; let res = reverseList(head.next); head.next.next = head; head.next = null; return res;};// 循环var reverseList = function (head) { let pre = null; let cur = head; if (cur === null || cur.next === null) { return cur; } while (cur) { const t = cur.next; cur.next = pre; pre = cur; cur = t; // cur.next = null // cur.next.next = cur // cur = cur.nexxt } return pre;}; 打乱数组1. 常见的sort打乱数组的方法 function shuffle(arr) { return arr.sort (function () { return Math.random() - 0.5 }) } var arr = [1,2,3,4,5,6,7] shuffle(arr) 更加简洁的ES6写法 function shuffle(arr) { return arr.sort(() =&gt; Math.random() - 0.5) } 但是这种写法有问题，并不能真正地随机打乱数组，经过大量的实验发现 每个元素仍然有很大的几率出现在它原来的位置附近。 2.洗牌算法 从最后一个数据开始往前，每次随机一个位置，将两者的位置进行交换，直到数组交换完毕。 ES6实现： function shuffle(arr) { let i = arr.length; while(i) { let j = Math.floor(Math.random() * i--); [arr[j], arr[i]] = [arr[i], arr[j]]; } return arr } var arr = [1,2,3,4,5,6,7] shuffle(arr) 用链表实现队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253interface ILinkListNode { value: number; next: ILinkListNode | null;}class Queue { private head: ILinkListNode | null = null; private tail: ILinkListNode | null = null; private len = 0; // 入队，在tail位置 add(n: number) { const newNode: ILinkListNode = { value: n, next: null, }; if (this.head === null) { this.head = newNode; } if (this.tail) { this.tail.next = newNode; } this.tail = newNode; this.len++; } // 出队，在head位置 delete(): number | null { if (this.head === null || this.len &lt;= 0) return null; const value = this.head.value; this.head = this.head.next; this.len--; return value; } get length(): number { return this.len; }}const queue = new Queue();queue.add(100);queue.add(200);queue.add(300);console.log('length', queue.length); //3console.log(queue.delete()); //100console.log('length2', queue.length); //2 链表和数组，哪个实现队列更快？ 空间复杂度都是 O(n) add 时间复杂度：链表 O(1)，数组 O(1); delete 时间复杂度：链表 O(1)，数组 O(n); 二叉搜索树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//满二叉树：每层节点数都达到最大值，第n层节点数为2^(n - 1),总节点数为2^n -1(2的n次方减一)//完全二叉树：除最后一层外，其他各层节点数都达到最大个数，最后一层所有节点集中在最左边class Node { constructor(value) { this.value = value; this.left = null; this.right = null; }}class BinarySearchTree { constructor() { this.root = null; } // 插入前比较 insertNode(node, newNode) { // 右侧插入 if (newNode.value &gt; node.value) { if (node.right === null) { node.right = newNode; } else { this.insertNode(node.right, newNode); } } else if (newNode.value &lt; node.value) { // 左侧插入 if (node.left === null) { node.left = newNode; } else { this.insertNode(node.left, newNode); } } } // 插入 insert(value) { let newNode = new Node(value); if (this.root === null) { this.root = newNode; } else { this.insertNode(this.root, newNode); } } preOrderTraversalNode(node, callback) { if (node === null) return; callback(node.value); this.preOrderTraversalNode(node.left, callback); this.preOrderTraversalNode(node.right, callback); } // 先序遍历 preOrderTraversal(callback) { this.preOrderTraversalNode(this.root, callback); } inOrderTraversalNode(node, callback) { if (node === null) return; this.inOrderTraversalNode(node.left, callback); callback(node.value); this.inOrderTraversalNode(node.right, callback); } // 中序遍历 inOrderTraversal(callback) { this.inOrderTraversalNode(this.root, callback); } postOrderTraversalNode(node, callback) { if (node === null) return; this.postOrderTraversalNode(node.left, callback); this.postOrderTraversalNode(node.right, callback); callback(node.value); } // 中序遍历 postOrderTraversal(callback) { this.postOrderTraversalNode(this.root, callback); } //最大值 max() { let node = this.root; while (node.right !== null) { node = node.right; } return node.value; } // 最小值 min() { let node = this.root; while (node.left !== null) { node = node.left; } return node.value; } // 寻找指定值是否存在 search(val) { let node = this.root; while (node !== null) { if (val &lt; node.value) { node = node.left; } else if (val &gt; node.value) { node = node.right; } else { return true; } } }}var bst = new BinarySearchTree();bst.insert(3);bst.insert(2);bst.insert(5);// bst.preOrderTraversal((nodeValue) =&gt; {// console.log(nodeValue)// })// bst.inOrderTraversal((nodeValue) =&gt;{// console.log(nodeValue)// })// bst.postOrderTraversal((nodeValue) =&gt;{// console.log(nodeValue)// })// console.log(bst.max())console.log(bst.search(5));console.log(bst); 求一个二叉搜索树（BST）的第 k 小值 前序(根左右)，中序(左根右)，后序(左右根) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394interface ItreeNode { value: number; left: ItreeNode | null; right: ItreeNode | null;}let bstTree: ItreeNode = { value: 5, left: { value: 3, left: { value: 2, left: null, right: null, }, right: { value: 4, left: null, right: null, }, }, right: { value: 7, left: { value: 6, left: null, right: null, }, right: { value: 8, left: null, right: null, }, },};/** * 二叉树前序遍历 * @param node tree node */function preOrderTraverse(node: ItreeNode | null) { if (node === null) return; console.log(node.value); preOrderTraverse(node.left); preOrderTraverse(node.right);}/** * 二叉树中序遍历 * @param node tree node */function inOrderTraverse(node: ItreeNode | null) { if (node === null) return; inOrderTraverse(node.left); console.log(node.value); inOrderTraverse(node.right);}/** * 二叉树后序遍历 * @param node tree node */function postOrderTraverse(node: ItreeNode | null) { if (node === null) return; postOrderTraverse(node.left); postOrderTraverse(node.right); console.log(node.value);}/** * 求二叉搜索树第k值 * @param node bst tree * @param k 第k个值 */function getKthValue(node: ItreeNode | null, k: number) { if (node === null) return; let arr: number[] = []; function inOrderTraverse(node: ItreeNode | null) { if (node === null) return arr; inOrderTraverse(node.left); arr.push(node.value); inOrderTraverse(node.right); } inOrderTraverse(node); return arr[k - 1];} 斐波那契数列123456789101112131415161718192021222324252627282930313233/** * 斐波那契数列（递归） * @param n * 时间复杂度O(2^n) */function fibonacci(n: number): number { if (n &lt;= 0) return 0; if (n === 1) return 1; return fibonacci(n - 1) + fibonacci(n - 2);}/** * 斐波那契数列（循环） * @param n * 时间复杂度O(n) */function fibonacci(n: number): number { if (n &lt;= 0) return 0; if (n === 1) return 1; let n1 = 1; // 记录n-1的结果 let n2 = 0; // 记录n-2的结果 let res = 0; for (let i = 2; i &lt;= n; i++) { res = n1 + n2; n2 = n1; n1 = res; } return res;} 青蛙跳台阶（动态规划思想解决问题） 一只青蛙，一次可以跳 1 级，也可以跳 2 级 问：青蛙跳到 n 级台阶，总共有多少种方式？ 1// 答案同上一题 将数组中的 0 移动到末尾 如输入[1, 0, 3, 0, 11, 0],输出[1, 3, 11, 0, 0, 0] 只移动 0 ，其他顺序不变 必须在原数组进行操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * (嵌套循环) * @param arr number arr * 时间复杂度 O(n^2) */function moveZero1(arr: number[]): void { const length = arr.length; if (length === 0) return; let zeroCount = 0; for (let i = 0; i &lt; length - zeroCount; i++) { if (arr[i] === 0) { arr.push(0); arr.splice(i, 1); // O(n) i--; zeroCount++; } }}/** * (双指针) * @param arr number arr * 时间复杂度 O(n) */function moveZero2(arr: number[]): void { const length = arr.length; if (length === 0) return; let i; let j = -1; // 指向第一个 0 for (i = 0; i &lt; length; i++) { if (arr[i] === 0) { if (j &lt; 0) { j = i; } } if (arr[i] !== 0 &amp;&amp; j &gt;= 0) { const n = arr[i]; arr[i] = arr[j]; arr[j] = n; j++; } }}const arr = [0, 1, 2, 0, 3, 0, 0, 4];// moveZero1(arr);moveZero2(arr);console.log(arr); 两数之和123456789101112131415161718function twoSum(nums: number[], target: number): number[] { let tempMap: Map&lt;number, number&gt; = new Map(); let index: number | undefined; let result: number[] = []; for (let i = 0, length = nums.length; i &lt; length; i++) { index = tempMap.get(target - nums[i]); if (index !== undefined) { result = [index, i]; break; } tempMap.set(nums[i], i); } return result;} 计算字符串中连续最多的字符以及次数 输入’abbbcccccccddeee1234412’ 计算得到连续最多的字符是’c’,7 次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @param str * 时间复杂度： O(n) */interface IRes { char: string; length: number;}function findContinuousChar1(str: string): IRes { const res: IRes = { char: '', length: 0, }; const length = str.length; if (length === 0) return res; let tempLength = 0; // 临时记录当前连续字符的长度 for (let i = 0; i &lt; length; i++) { tempLength = 0; // 重置 for (let j = i; j &lt; length; j++) { if (str[i] === str[j]) { tempLength++; } if (str[i] !== str[j] || j === length - 1) { if (tempLength &gt; res.length) { res.char = str[i]; res.length = tempLength; } if (i &lt; length - 1) { i = j - 1; // 跳步 } break; } } } return res;}/** * 双指针 * @param str * 时间复杂度： O(n) */interface IRes { char: string; length: number;}function findContinuousChar2(str: string): IRes { const res: IRes = { char: '', length: 0, }; const length = str.length; if (length === 0) return res; let tempLength = 0; // 临时记录当前连续字符的长度 let i = 0; let j = 0; for (; i &lt; length; i++) { if (str[i] === str[j]) { tempLength++; } if (str[i] !== str[j] || i === length - 1) { // 如果不相等或者 i 循环到了末尾 if (tempLength &gt; res.length) { res.char = str[j]; res.length = tempLength; } tempLength = 0; if (i &lt; length - 1) { j = i; // 让 j 追上 i i--; } } } return res;}const str = 'abbbcccccccddeee1234412';console.log(findContinuousChar1(str)); 对称数（回文） 求 1 - 10000 之间的所有对称数（回文） 例如：0， 1， 2， 11， 22， 101， 232，1221 12345678910111213141516171819202122232425262728293031323334353637function findPalindromeNumbers1(max: number): number[] { const res: number[] = []; if (max &lt; 0) return res; for (let i = 1; i &lt;= max; i++) { // 转换为字符转 -&gt; 转换为数组 -&gt; 再反转 -&gt; 比较 const s = i.toString(); if (s === s.split('').reverse().join('')) { res.push(i); } } return res;}console.log(findPalindromeNumbers1(200));function findPalindromeNumbers2(max: number): number[] { const res: number[] = []; if (max &lt;= 0) return res; for (let i = 1; i &lt;= max; i++) { let n = i; let rev = 0; // n: 123 // rev: 321 while (n &gt; 0) { rev = rev * 10 + (n % 10); n = Math.floor(n / 10); } if (i === rev) res.push(i); }}console.log(findPalindromeNumbers2(200)); 最长回文串123456789101112131415161718192021function longestPalindrome(s: string): string { let res = ''; for (let i = 0; i &lt; s.length; i++) { // 寻找长度为奇数的回文子串(以当前元素向两边扩散) const s1 = palindrome(s, i, i); // 寻找长度为偶数的回文子串(以s[i],s[i + 1])向两边扩散 const s2 = palindrome(s, i, i + 1); res = res.length &gt; s1.length ? res : s1; res = res.length &gt; s2.length ? res : s2; } return res;}function palindrome(s, l, r) { // 左右指针，从s[l]和s[r]向两边扩散，找到最长回文串 while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s[l] == s[r]) { l--; r++; } return s.substr(l + 1, r - l - 1);} 判断字符串是否括号匹配 一个字符串 s 可能包含{}()[]三种括号 判断 s 是否是括号匹配的 如（a{b}c）匹配，而{a(b 或者{a(b}c)就是不匹配的 栈 vs 数组栈：逻辑结构，理论模型，不管如何实现，不受任何语言的限制。数组：物理结构，真实的功能实现，受限于编程语言。 12345678910111213141516171819202122232425262728293031323334353637function isMatch(left: string, right: string): boolean { if (left === '{' &amp;&amp; right === '}') return true; if (left === '(' &amp;&amp; right === ')') return true; if (left === '[' &amp;&amp; right === ']') return true; return false;}function matchBracket(str: string): boolean { const length = str.length; if (length === 0) return true; const stack = []; const leftSymbols = '{[('; const rightSymbols = ')]}'; // 时间复杂度O(n),空间复杂度O(n) for (let i = 0; i &lt; length; i++) { const s = str[i]; if (leftSymbols.includes(s)) { // 左括号，压栈 stack.push(s); } else if (rightSymbols.includes(s)) { const top = stack[stack.length - 1]; // 判断右括号是否匹配 if (isMatch(top, s)) { stack.pop(); } else { return false; } } } return stack.length === 0;} 高效的字符串前缀匹配 有一个英文单词库（数组），里面有几十万个英文单词 输入一个字符串，快速判断是不是某一个单词的前缀 （说明思路，不用写代码） 思路一： 遍历单词库数组 indexOf 判断前缀 实际时间复杂度超过 O(n),因为 indexOf 的计算量 思路二（对象取 key 时间复杂度为 O(1)）： 英文字母一共就 26 个，可以提前把单词库数组拆分为 26 个 第一层 26 个，第二层、第三层，继续拆分… 最后把单词库拆分为一颗树 1234567891011121314// 树结构const wordsTree = { a: { a: {...} b: {...} }, b: { a: {...} }, c: { a: {...} } ...} 数字千分位格式化 将数字千分位格式化，输出字符串 如输入数字 12050100，输出字符串 12,050,100 (注意：逆序判断) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @param n * 使用数组 */function format1(n: number): string { n = Math.floor(n); // 只考虑整数 const reverseArr = n.toString().split('').reverse(); return reverseArr.reduce((prev, curr, index) =&gt; { if (index % 3 === 0) { if (prev) { return curr + ',' + prev; } else { return curr; } } else { return curr + prev; } }, '');}/** * @param n * 使用字符串 */function format2(n: number): string { n = Math.floor(n); let res = ''; const str = n.toString(); const length = str.length; for (let i = length - 1; i &gt;= 0; i--) { const j = length - i; if (j % 3 === 0) { if (i === 0) { res = str[i] + res; } else { res = ',' + str[i] + res; } } else { res = str[i] + res; } } return res;}把&quot;1000000000&quot;变成&quot;100.000.000&quot;这种写法，把后面往前面查，三位加个点var str = '100000000';var reg = /(?=(\\B)(\\d{3})+$)/g;console.log(str.replace(reg, '.')) || //&quot;100.000.000&quot;string.replace(/\\B(?=(\\d{3})+(?!\\d))/g, '.') || //先行断言?=,后行断言(?!\\d)(25435345.22).toLocaleString('en-US'); 切换字母大小写 输入一个字符串，切换其中字母的大小写 如：输入字符串 12aBc34，输出字符串 12AbC34 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 正则表达式 * @param s */function switchLetterCase1(s: string): string { let res = ''; const length = s.length; if (length === 0) return res; const reg1 = /[a-z]/; const reg2 = /[A-Z]/; for (let i = 0; i &lt; length; i++) { const c = s[i]; if (reg1.test(c)) { res += c.toUpperCase(); } else if (reg2.test(c)) { res += c.toLowerCase(); } else { res += c; } } return res;}/** * ASCII 编码 * @param s */function switchLetterCase2(s: string): string { let res = ''; const length = s.length; if (length === 0) return res; const reg1 = /[a-z]/; const reg2 = /[A-Z]/; for (let i = 0; i &lt; length; i++) { const c = s[i]; const code = c.charCodeAt(0); if (code &gt;= 65 &amp;&amp; code &lt;= 90) { res += c.toLowerCase(); } else if (code &gt;= 97 &amp;&amp; code &lt;= 122) { res += c.toUpperCase(); } else { res += c; } } return res;} 「扁平数组」转「树形结构」12345678910111213141516171819function treeing(arr) { let tree = []; let map = {}; for (let item of arr) { const newItem = (map[item.id] = { ...item, children: [], }); if (map[item.pid]) { const parent = map[item.pid]; parent.children.push(newItem); } else { tree.push(newItem); } } return tree;} 「树形结构」转「扁平结构」12345678910function flatten(tree, arr = []) { tree.forEach((item) =&gt; { const { children, ...rest } = item; arr.push(rest); if (children.length) { flatten(children, arr); } }); return arr;} 将树状结构转换为属性平铺的结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 题目const entry = { a: { b: { c: { dd: 'abcdd', }, }, d: { ee: 'adee', }, f: 'af', },};const output = { 'a.b.c.dd': 'abcdd', 'a.d.ee': 'adee', 'a.f': 'af',};// 解答// 方法1: 递归function flatObj(obj, preKey = '', result = {}) { for (const key in obj) { if (obj.hasOwnProperty(key)) { const newKey = `${preKey}${key}`; if (typeof obj[key] === 'object') { flatObj(obj[key], `${newKey}.`, result); } else { result[newKey] = obj[key]; } } } return result;}// 方法2: while循环-队列function flatObj2(obj) { const queue = Object.entries(obj); const result = {}; while (queue.length) { const [key, value] = queue.pop(); for (const [k, v] of Object.entries(value)) { if (typeof v === 'object') { queue.push([`${key}.${k}`, v]); } else { result[`${key}.${k}`] = v; } } } return result;}// 测试用例flatObj(entry);flatObj2(entry); 将平铺属性的数据结构转换为树状数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 题目const entry = { 'a.b.c.dd': 'abcdd', 'a.d.ee': 'adee', 'a.f': 'af',};const output = { a: { b: { c: { dd: 'abcdd', }, }, d: { ee: 'adee', }, f: 'af', },};// 答案// 方法1: 双重循环function map(entry) { const result = {}; for (const key in entry) { const value = entry[key]; const keyMap = key.split('.'); if (!result[keyMap[0]]) { result[keyMap[0]] = {}; } let tmp = result[keyMap[0]]; let length = keyMap.length; for (let i = 1; i &lt; length; i++) { if (!tmp[keyMap[i]]) { if (i === length - 1) { tmp[keyMap[i]] = value; } else { tmp[keyMap[i]] = {}; } } tmp = tmp[keyMap[i]]; } } return result;}// 方法2: 递归// {&quot;a.b.c.dd&quot;: &quot;abcdd&quot;}// =&gt; {&quot;a.b.c&quot;: {&quot;dd&quot;:&quot;abcdd&quot;}}// =&gt;...// =&gt; {&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;dd&quot;: &quot;abcdd&quot;}}}}function map2(entry) { function getNest(key) { const lastIndex = key.lastIndexOf('.'); const value = entry[key]; if (lastIndex !== -1) { delete entry[key]; const preKey = key.substring(0, lastIndex); const restKey = key.substring(lastIndex + 1); if (!entry[preKey]) { entry[preKey] = { [restKey]: value }; } else { entry[preKey][restKey] = value; } if (/./.test(preKey)) { getNest(preKey); } } } for (const key in entry) { getNest(key); } return entry;}map(entry);map2(entry); 实现 jsonp，传入 url、callback 和 callbackName 三个参数1234567891011121314151617181920function jsonp(url, callback, callbackName) { const script = document.createElement('script'); script.src = `${url}?type=jsonp&amp;callbackName=${callbackName}}`; script.onload = callback; document.body.appendChild(script); window[callbackName] = function (data) { console.log(data); document.body.removeChild(script); };}jsonp( 'http://www.xxx.com/xxx', function (data) { console.log(data); }, 'fn'); 实现计时器 timer，仅暴露 start、stop、reset 方法1234567891011121314151617181920212223242526function Timer() { let second = 0; let refId = null; const clear = function () { if (refId !== null) { clearInterval(refId); } }; const start = function () { refId = setInterval(() =&gt; { console.log(second); second += 1; }, 1000); }; const stop = function () { clear(); }; const reset = function () { second = 0; clear(); }; return { start, stop, reset };} 点击页面链接时，验证连接是否在*.taobao.com 下，如果不是弹框提示123456789101112131415161718192021 &lt;a class=&quot;link&quot; href=&quot;http://www.taobao.com&quot;&gt;淘宝&lt;/a&gt; &lt;a class=&quot;link&quot; href=&quot;http://www.jd.com&quot;&gt;京东&lt;/a&gt; &lt;script&gt;const links = document.getElementsByClassName('link')const listener = function(e) { const href = e.target.getAttribute('href') if (href.indexOf('.taobao.com') === -1) { const result = confirm('确定离开吗') if (result === false) { e.preventDefault() e.stopPropagation() } }} // 绑定事件 for (let i = 0, len = links.length; i &lt; len; i++) { link[i].addEventListener('click', listener, false) } &lt;/script&gt; 实现 destructuringArray 方法123456function destructuringArray(arr, str) { const variables = str.replace(/[\\[\\]]/g, ''); //正则去除[] return new Function(`str=${arr};return {${variables}}`)();}destructuringArray([1, [2, 4], 3], '[a,[b],c]'); // {a: 1, b: 2, c: 3} 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。123456789101112131415161718192021222324252627282930313233343536373839class LRUCache { cache: Map&lt;number, number&gt;; constructor(public capacity: number) { this.cache = new Map(); this.capacity = capacity; } get(key: number): number { if (this.cache.has(key)) { const value = this.cache.get(key); this.cache.delete(key); this.cache.set(key, value); return value; } return -1; } put(key: number, value: number): void { if (this.cache[key]) { this.cache.delete(key); } else { if (this.cache.size &gt;= this.capacity) { this.cache.delete(this.cache.keys().next().value); } } this.cache.set(key, value); }}const lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 比较版本号1234567891011121314151617181920function Compare(verson1, verson2) { let v1Arr = verson1.split('.'); let v2Arr = verson2.split('.'); let i = 0; let j = 0; while (i &lt; v1Arr.length || j &lt; v2Arr.length) { let str1 = v1Arr[i] || 0; let str2 = v2Arr[j] || 0; if (str1 - str2 &gt; 0) { return 1; } else if (str1 - str2 &lt; 0) { return -1; } i++; j++; } return 0;}// Compare(&quot;2.0.1&quot;,&quot;2&quot;) 1 找出字符串中重复次数最多的字符123456789101112131415161718192021function findMaxStr(str) { let res = {}; for (let i = 0; i &lt; str.length; i++) { if (!res[str.charAt(i)]) { res[str.charAt(i)] = 1; } else { res[str.charAt(i)] = res[str.charAt(i)] + 1; // 如果有，增加一次 } } let iMax = 0; let target = ''; for (let key in res) { if (res[key] &gt; iMax) { iMax = res[key]; // iMax要被重写 target = key; } } console.log('res:', res); console.log('出现次数最多的是:' + target + ', 出现' + iMax + '次');}findMaxStr('sabcdEs'); 实现 url 的 parse 解析？1234567891011121314151617181920212223242526272829function parseUrl(url) { const parser = document.createElement('a'); parser.href = url; return { protocol: parser.protocol, host: parser.host, hostname: parser.hostname, port: parser.port, pathname: parser.pathname, search: parser.search, hash: parser.hash, params: (function(){ let ret = {}, let seg = a.search.replace(/^\\?/,'').split('&amp;'), for (let i = 0;i&lt;seg.length;i++) { if (!seg[i]) { continue; } let s = seg[i].split('='); ret[s[0]] = s[1]; } return ret; })(), };}// Example usage:const url = 'https://www.example.com:8080/path/to/page?query=string#hash';const parsedUrl = parseUrl(url);console.log(parsedUrl); 实现对象数组 group12345678910111213141516171819202122232425262728293031function group(arr, fn) { const result = {}; for (let index = 0; index &lt; arr.length; index++) { const element = arr[index]; const category = fn(element, index, arr); if (result[category]) { result[category].push(element); } else { result[category] = [element]; } } return result;}const orderList = [ { nickName: 'steven', productName: '西瓜', price: 29, province: 'henan', }, { nickName: '对方的', productName: '杨梅', price: 22, province: 'shanxi', },];const result = group(orderList, ({ province }) =&gt; province);console.log(result); 怎么可以使用 for-of 来遍历对象12345678910111213141516171819202122232425// 手动实现Symbol.iterator迭代器函数Object.prototype[Symbol.iterator] = function () { const keys = Object.keys(this); let index = 0; return { next: () =&gt; { const value = this[keys[index]]; const done = index &gt; keys.length - 1; index++; return { value, done, }; }, };};const obj = { key: '1', value: '2',};for (const item of obj) { console.log(item);} 实现 lodash.get123456789101112function get(obj, path, dftValue = 'undefined') { let newPath = []; if (Array.isArray(path)) { newPath = path; } else { newPath = path.replace(/\\[/g, '.').replace(/\\]/, '').split('.'); } return newPath.reduce((obj = {}, key) =&gt; obj[key], obj);}const object = { a: [{ b: { c: 3 } }] };console.log(get(object, 'a[0].b.c')); 数组随机排序 shuffle123456789101112131415// 简单有缺陷// ECMAScript标准提到对于同一组a、b的值，compareFn(a, b)需要总是返回相同的值,sort采用原地算法// 且vs引擎中丨阿宇数组部分的sort源码，考虑性能原因，对于短数组（小于等于22）使用插入排序，长数组（大于22）使用快速排序function shuffle(arr) { arr.sort(() =&gt; Math.random() - 0.5);}// es6洗牌算法function shuffle(arr) { let i = arr.length; while (--i) { let j = Math.floor(Math.random() * i); [arr[j], arr[i]] = [arr[i], arr[j]]; }} 二分查找 O(log2n)123456789101112131415161718// elements有序function binarySearch(elements, value, _start, _end) { let end = _end || elements.length - 1; let start = _start || 0; let povitIndex = Math.floor((start + end) / 2); if (elements[povitIndex] === value) { return povitIndex; } if (value &lt; elements[povitIndex]) { return binarySearch(elements, value, 0, povitIndex - 1); } else { return binarySearch(elements, value, povitIndex + 1, end); } return false;} 冒泡排序 O(n^2) 重复地遍历要排序的数组，比较相邻的元素并交换位置，直到整个数组都已经排序 123456789101112131415161718192021function bubbleSort(elements) { let elementLength = elements.length; for (let i = 0; i &lt; elementLength - 1; i++) { for (let j = 0; j &lt; elementLength - i - 1; j++) { if (elements[j] &gt; elements[j + 1]) { let temp = elements[j]; elements[j] = elements[j + 1]; elements[j + 1] = temp; } } } console.log(elements);}let elements = [2, 4, 3, 7, 5];bubbleSort(elements);// console.log(elements) 快速排序 O(最好 nlogn,最慢 n^2,平均 nlog2n) 基本思想是选择一个基准元素，然后将数组中的元素分为小于基准元素和大于基准元素的两部分，再对这两部分分别进行排序 12345678910111213141516171819202122232425262728/** * @param arr * 时间复杂度：O(nlogn) */function quickSort1(arr: number[]): number[] { const length = arr.length; if (length === 0) return arr; const midIndex = Math.floor(length / 2); const midValue = arr.splice(midIndex, 1)[0]; const left: number[] = []; const right: number[] = []; // 注意： splice会改变原数组，不能直接使用length for (let i = 0; i &lt; arr.length; i++) { const n = arr[i]; if (n &lt; midValue) { left.push(n); } else { right.push(n); } } return quickSort1(left).concat(midValue, quickSort1(right));}const arr = [2, 7, 5, 2, 3, 1];console.log(quickSort1(arr)); 插入排序(n^2) 将数组分为已排序和未排序两部分，然后将未排序部分的第一个元素插入到已排序部分的正确位置上 12345678910111213141516171819function insertSort(arr) { let handle = [arr[0]]; for (let i = 1; i &lt; arr.length; i++) { let newItem = arr[i]; for (let j = handle.length - 1; j &gt;= 0; j--) { if (newItem &gt; handle[j]) { handle.splice(j + 1, 0, newItem); break; } if (j === 0) { handle.unshift(newItem); } } } return handle;}let arr = [2, 1, 5, 4, 8, 6];console.log(insertSort(arr)); 选择排序（n^2） 将数组分为已排序和未排序两部分，然后从未排序部分选择最小的元素并放到已排序部分的末尾 1234567891011121314151617function selectSort(arr) { let index; for (let i = 0; i &lt; arr.length - 1; i++) { index = i; for (let j = i + 1; j &lt; arr.length; j++) { if (arr[index] &gt; arr[j]) { index = j; } } if (index !== i) { [arr[i], arr[index]] = [arr[index], arr[i]]; } } return arr;}let arr = [6, 4, 9, 8, 1, 3, 2];console.log(selectSort(arr)); 归并排序（nlogn） 将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序的数组 123456789101112131415161718192021222324// 合并两个有序的数组function merge(left, right) { let temp = []; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) { if (left[0] &lt; right[0]) { temp.push(left.shift()); } else { temp.push(right.shift()); } } return temp.concat(left, right);}// 分治思想，归并排序function mergeSort(arr) { if (arr.length == 1) { return arr; } else { let mid = parseInt(arr.length / 2); let left = arr.slice(0, mid); let right = arr.slice(mid); return merge(mergeSort(left), mergeSort(right)); }} 合并两个有序数组？12345678910111213141516171819202122232425262728function mergeArr(arr1, arr2) { let mergedArr = []; let pointer1 = 0; let pointer2 = 0; while (pointer1 &lt; arr1.length &amp;&amp; pointer2 &lt; arr2.length) { if (arr1[pointer1] &lt; arr2[pointer2]) { mergedArr.push(arr1[pointer1]); pointer1++; } else { mergedArr.push(arr2[pointer2]); pointer2++; } } while (pointer1 &lt; arr1.length) { mergedArr.push(arr1[pointer1]); pointer1++; } while (pointer2 &lt; arr2.length) { mergedArr.push(arr2[pointer2]); pointer2++; } return mergedArr;} 持续更新中","link":"/2022/03/31/%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E7%AF%87/"},{"title":"面试知识css篇","text":"盒模型 标准盒模型：width 和 height 属性只包含 content 内容区 IE 盒模型：width 和 height 包含了 border、padding 和 content flex 常用属性，grid 布局flex 属性：1.flex-direction 属性，决定主轴方向2.flex-wrap 属性，控制换行3.flex-flow 属性，flex-direction 和 flex-wrap 的简写形式，默认值 flex-flow: row nowrap;4.justify-content 属性，项目主轴上的对齐方式5.align-item 属性，项目在交叉轴上的对齐方式6.align-content 属性，多个轴线的时候在元素交叉轴的对齐方式，只有一根轴线时不起作用flex（子元素的属性）：1.order 属性,定义项目的排列顺序，数值越小，排列越靠前，默认为 0.2.align-self 属性，允许单个项目与其他项目不一样的对齐方式，会覆盖 align-items 属性.3.flex 属性，flex-grow、flex-shrink、flex-basis 简写，默认为 0 1 autoauto(1 1 auto) none(0 0 auto)4.flex-grow 属性，定义项目的放大比例，默认为 0，即如果存在剩余空间也不放大，1 等分，一个项目为 2，其他为 1，则前者占据空间是其他的两倍。5.flex-shrink 属性，定义项目的缩小比例，默认为 1，空间不足则缩小，如果所有项目都为 1，则等比例缩小，如果有的项目为 0，则空间不足时为 0 的不缩小，负值无效6.flex-basis 属性，项目占据的固定空间 calc, support, media 各自的含义及用法？1234567891011121314151617@support 主要用于检测浏览器是否支持css的某个属性，相当于条件语句，支持的话写一套样式，不支持写另外一套样式，例如:@supports (display: grid) { div { display: grid; }}@supports not (display: grid) { div { float: right; }}calc(): 用于动态计算值，支持 + - * / 运算 @media查询：可以针对不同的媒体类型定义不同的样式; img 标签 title 和 alt 属性 alt: 图片加载失败时，显示在网页上的替代文字 title: 鼠标放在图片上的提示文字 SVG 和 Canvas 的区别？ svg:表示以 XML 格式定义图像的可伸缩矢量图形。 canvas：通过 js 来绘制 2D 图形 Canvas 不支持事件处理器，SVG 支持事件处理器 由于 Canvas 和 SVG 的工作机制不同，Canvas 是逐像素进行渲染的，一旦图形绘制完成，就不会继续被浏览器关注。而 SVG 是通过 DOM 操作来显示的。SVG 适合带有大型渲染区域的应用程序，比如地图。而 Canvas 适合有许多对象要被频繁重绘的图形密集型游戏。 绘制的图片格式不同，canvas 位图，svg 矢量图 svg 通过标签 fill 属性可以调整颜色 JS 如何设置获取盒子模型对应的宽和高？ dom.style.width/height dom.currentStyle.width/height (ie 支持) window.getComputedStyle(dom).width/height dom.getBoundingClientRect().width/height CSS 权重（256 进制）1. ！import 权值：infinite 无穷大 2. 内联样式， 权值1000 3. ID选择器， 权值： 100 4. 类、伪类、属性选择器， 权值： 10 5.标签、伪元素选择器， 权值： 1 6.通配符选择器 *，子选择器 &gt;,相邻选择器 +，权值： 0 权值相等，后来居上 html5 的新特性1. 添加了article、aside、audio、video、footer、header、nav、section标签 2. 添加了canvas画布和svg渲染矢量图片 3. 添加了一些语义化的标签 header、footer、main、section... 4. input的type值新添加了很多属性（email，search，color，number...） 5. 添加了地理位置定位功能 Geolocation API 6. 添加了web Storage存储功能，localStorage和sessionStorage 7. 使用html5，通过创建cache manifest文件，可以轻松地创建web应用的离线版本 8. web worker创造多线程环境，是运行在后台的javaScript。 9。 服务端推送（EventSource用于接受服务端发送事件通知） CSS3 新添加的特性？1. 媒体查询 2. transform，transition，translate，scale，rotate等相关动画效果 3. box-shadow，text-shadow等特效 4. CSS3 @font-face规则，可以引入任意字体 5. CSS3 @keyframes规则，创建动画(配合animation使用) 6. 2D、3D转化 7. 添加了border-radius、border-image、column-count、resize、box-sizing 、outline-offset等属性 样式导入方式及优先级？ 引入方式 行内样式 内联式 外链式 导入式: @import url(reset.css) 各种方式的优先级 行内样式 &gt; 外链式 &gt; 内联式 &gt; @import 导入式 选择器优先原则：!important &gt; 行间样式 &gt; ID 选择器 &gt;class 选择器｜伪类选择器｜属性选择器 &gt;元素选择器｜伪元素选择器 &gt; 通配符选择器｜子选择器选择器｜相邻兄弟选择器 BFCBFC(block formatting context)翻译为“块级格式化上下文”，它会生成独立的渲染区域(不影响外面的元素，同时也不受外部元素的影响)，它有一下规则： 内部的 box 会在垂直方向上一个接一个的放置。 内部 box 在垂直方向上的距离由 margin 决定，同属一个 BFC 内的相邻 box 会发生 margin 重叠。 BFC 的区域不会与 float box 发生重叠。 计算 BFC 的高度时，浮动元素也参与计算(清除浮动) 触发 BFC 的条件： float 属性不为 none position 为 absolute 或者 fixed display 为 inline-block、table-cell、table-caption、flex、inline-flex overflow 不为 visible 有哪些常见的 meta 标签？ 指定文档编码 &lt;meta charset = &quot;UTF-8&quot;&gt; name 属性 1.&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;：在移动设备浏览器上，禁用缩放（zooming） 功能，用户只能滚动屏幕。 2.&lt;meta name=”description” content=””&gt;：告诉搜索引擎，当前页面的主要内容是xxx。 3.&lt;meta name=”keywords” content=””&gt;：告诉搜索引擎，当前页面的关键字。 4.&lt;meta name=”author” content=””&gt;：告诉搜索引擎，标注网站作者是谁。 5.&lt;meta name=”copyright” content=””&gt;：标注网站的版权信息。 http-equiv 属性(http 协议的响应头报文) 1.&lt;meta http-equiv=”Set-Cookie” content=”cookievalue=xxx; expires=Friday,12-Jan-2001 18:18:18 GMT; path=/”&gt;:如果网页过期， 那么存盘的cookie将被删除。必须使用GMT的时间格式。 2.&lt;meta http-equiv='expires' content='时间' &gt;：用于设定网页的到期时间。 一旦网页过期，必须到服务器上重新传输。 3.&lt;meta http-equiv=”Refresh” content=”5;URL”&gt;：告诉浏览器在 【数字】秒后跳转到【一个网址】 4.&lt;meta http-equiv=”content-Type” content=”text/html; charset=utf-8″&gt;： 设定页面使用的字符集。 -5.&lt;meta http-equiv=”Pragma” content=”no-cache”&gt;：禁止浏览器从本地 计算机的缓存中访问页面内容。访问者将无法脱机浏览。 6.&lt;meta http-equiv=”Window-target” content=”_top”&gt;：用来防止 别人在iframe(框架)里调用自己的页面，这也算是一个非常实用的属性。 7.&lt;meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'&gt; :强制浏览器按照特定的版本标准进行渲染。但不支持IE7及以下版本。如果是 ie浏览器就用最新的ie渲染，如果是双核浏览器就用chrome内核。 一、为什么会有白屏和 FOUC 呢？ 浏览器再渲染的时候没有请求到或请求时间过长造成的，那么浏览器怎么应对的呢？ 白屏：CSS 全部载入解析完成后渲染展示页面，如果没有加载完，就会出现白屏。 FOUC(Flash of Unstyled Content)无样式内容闪烁：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式表加载渲染之后，再重新显示文档，造成页面闪烁。 使用 link 标签将样式表放在顶部标签中，防止白屏问题出现。 将 JS 放在标签底部，原因如下： 脚本会阻塞后面内容的呈现 脚本会阻塞其后组件的下载 什么是 DOCTYPE 及其作用？ DOCTYPE 是 document type（文档类型）的缩写。 写法：(声明了浏览器就会进入标准模式，按照 W3C 标准渲染页面) DOCTYPE 的作用： DOCTYPE 是用来声明文档类型和 DTD 规范的，校验文件和代码的合法性。 告诉浏览器通过哪种规范（文档类型，DTD）来解析文档。 DTD（document type definition）文档类型定义是一系列的语法规则，用来定义 XML或 HTML 的文件类型。浏览器会根据它来判断文档类型，决定使用哪种协议来解析，以及切换浏览器的模式。 浏览器模式 为了能够很好的显示满足标准的页面，又能最大程度兼容不合法的 HTML，浏览器厂商会提供两种浏览器模式。 标准模式：根据 W3C 标准来渲染页面。 混杂模式（兼容模式、怪异模式）：浏览器采用更加宽松、向后兼容的方式来渲染页面。 CSS-清除浮动 原文链接 什么是 CSS 清除浮动? 在非 IE 浏览器（如 Firefox）下，当容器的高度为 auto，且容器的内容中有浮动（float 为 left 或 right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的 CSS 处理，就叫 CSS 清除浮动。 清除浮动的方法 方法一：使用带 clear 属性的空元素 12345在浮动元素后使用一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt;来进行清理。优点：简单，代码少，浏览器兼容好。缺点：需要添加大量的无语义的html元素，代码不够优雅，后期不容易维护。 方法二：使用 CSS 的 overflow 属性 1给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动。 方法三：给浮动的元素的容器添加浮动（不太推荐） 12给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 方法四：使用邻接元素处理 1什么都不做，给浮动元素后面的元素添加clear:both属性。 方法五：使用 CSS 的：after 伪元素 12345678910给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。.clearfix::after{ content: &quot;020&quot;; display: block; height: 0; clear: both; visibility: hidden; } getomputedstyle 和 style 的区别？ getComputedStyle 方法是只读的，只能获取样式，不能设置；而 element.style 能读写。 getComputedStyle 方法获取的是最终应用在元素上的所有 Css 属性样式(即使没有 css 代码)，而 element.style 只能获取元素 style 属性中的 css 样式。 getComputedStyle 可以获取伪元素的样式。 兼容性：getComputedStyle 方法在 IE6~IE8 是不支持的。 为什么要语义化？根据内容的结构化，选择合适的标签，便于开发者阅读和写出更优雅的代码的同时利于 SEO 的优化。 为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 用户体验：例如 title、alt 用于解释名词或解释图片信息、label 标签的活用； 有利于 SEO ：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息： 爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页 便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。 在 less 中如何将 px 转换为 vw？123456789101112.pxToVW (@px, @attr: width) { @vw: (@px / 750) * 100; @{attr}:~&quot;@{vw}vw&quot;;}.title{ .pxToVW(300,width) .pxToVW(32,font-size)}这里是指，设计图是按照750px的宽度进行设计的,title 中所有的值都是直接取的设计图的值，通过函数进行统一换算 px % em rem vw/vh有什么区别？ px 基本单位，是绝对单位（其他的都是相对单位） % 是相对于父元素的宽度比例 em 相对于当前元素或与之最近的设置了 font-size 的父元素的 font-size rem 相对于根元素的 font-size vw 屏幕宽度的 1% vh 屏幕高度的 1% vmin 取 vw、vh 两者中的最小值 vmax 取 vw、vh 两者中的最大值 offsetHeight、scrollHeight、clientHeight 区别？ offsetHeight、offsetWidth: border + padding + content clientHeight、clientWidth: padding + content scrollHeight、scrollWidth: padding + 实际内容尺寸，包括溢出的不可见部分 HTMLCollection 和 NodeList 区别？ Node 和 Element DOM 是一棵树，所有节点都是 Node Node 是 Element 的基类 Element 是其他 HTML 元素的基类，如 HTMLDivElement HTMLCollection 和 NodeList HTMLCollection 是 Element 的集合（elem.children） NodeList 是 Node 集合（elem.childNodes） HTMLCollection 不会包含 Text 和 Comment 节点，NodeList 则会包含 HTMLCollection 和 NodeList 都不是数组，而是“累数组” 1234// 转换const arr1 = Array.from(list);const arr2 = Array.prototype.slice.call(list);const arr3 = [...list]; 如何理解 HTML 语义化？ 让人更容易读懂（增加代码可读性） 让搜索引擎更容易读懂（SEO） 块状元素 &amp; 内联元素？ 块级元素 display: block/table; div、h1、h2、table、ul、ol、p 等 内联元素 display: inline/inline-block; span、img、input、button 等； 如下代码，请问 div 的 offsetWidth 是多大？12345678910&lt;style&gt; #div { width: 100px; padding: 10px; margin: 10px; border: 1px solid #ccc; }&lt;/style&gt;&lt;div id=&quot;div&quot;&gt;&lt;/div&gt; offsetWidth = (内容宽度 + 内边距 + 边框)，无外边距 答案： 100 + 10 + 1 * 2 = 122px 可以通过：box-sizing: border-box; 使得 offsetWidth=100 margin 纵向重叠问题 如下代码，A 和 B 之间的距离是多少？ 1234567891011121314&lt;style&gt; p { font-size: 16px; line-height: 1; margin-top: 10px; margin-bottom: 15px; }&lt;/style&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;B&lt;/p&gt; 相邻元素的 margin-top 和 margin-bottom 会发生重叠 空白内容 p 标签也会重叠 答案：15px margin 负值问题 margin-top 和 margin-left 负值，元素向上、向左移动 margin-right 负值，右侧元素左移，自身不受影响 margin-bottom 负值，下方元素上移，自身不受影响 BFC 理解与应用 block format context，块级格式化上下文 一块独立渲染区域，内部元素的渲染不会影响边界以外的元素 形成 BFC 的常见条件 float 不是 none position 是 absolute 或 fixed overflow 不是 visible(hidden、auto、scroll) display 是 flex、inline-block 等 常见应用： 清除浮动 阻止 margin 重叠 float 布局 实现圣杯布局和双飞翼布局 目的 三栏布局，中间一栏最先加载和渲染 两侧内容固定，中间内容随着宽度自适应 一般用于 PC 网页 实现 使用 float 布局 两侧使用 margin 负值，以便和中间内容横向重叠 防止中间内容被两侧覆盖，一个用 padding，一个用 margin css 定位 absolute 和 relative 定位 relative 依据自身定位 absolute 依据最近一层的定位元素定位 定位元素：absolute、relative、fied、body 居中对齐 水平居中 inline 元素：text-align: center block 元素：margin: auto absolute 元素：left:50% + margin-left 负值 垂直居中 inline 元素：line-height 的值等于 height 的值 absolute 元素：top: 50% + margin-top 负值 absolute 元素：transform(-50%, -50%) absolute 元素：top,left,bottom,right=0 + margin: auto css-图文样式 line-height 如何继承 如下代码，p 标签的行高是多少？ 1234567891011121314&lt;style&gt; body { font-size: 20px; line-height: 200%; /* 40px */ line-height: 1.5; /* 16 * 1.5 = 24 */ line-height: 30px; /* 30px */ } p { font-size: 16px; }&lt;/style&gt;&lt;body&gt; &lt;p&gt;AAA&lt;/p&gt;&lt;/body&gt; 答案： 40px 具体数值，如 30px，则继承该值 写比例，如 2/1.5，则继承当前元素 font-size 的比例 写百分比，如 200%，则继承计算出来的值 css-响应式 常见长度单位 px，绝对长度单位 em，相对长度单位，相对于父元素 rem，相对长度单位，相对于根元素，常用与响应式布局 响应式布局常用方案 media-query，根据不同屏幕宽度设置根元素 font-size rem，基于根元素的相对单位 rem 的弊端：“阶梯”性 1234567891011121314151617181920212223242526272829&lt;style&gt; @media only screen and (max-width: 374px) { html { font-size: 86px; } } @media only scrren and (min-width: 375px) and (max-width: 413px) { html { font-size: 100px; } } @media only scrren and (min-width: 414px) { html { font-size: 110px; } } body { font-size: 0.16rem; } #div { width: 1rem; /* 100px */ }&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt;div&lt;/div&gt;&lt;/body&gt; 网页视口尺寸 window.screen.height // 屏幕高度 window.innerHeight // 网页视口高度 vh 网页视口高度的 1/100 vw 网页视口宽度的 1/100 vmax 取两者最大值；vmin 取两者最小值 document.body.clientHeight // body 高度 inline、block 和 inline-block 的区别？ block 块级元素 单独占一行，宽度自动填充父元素宽度 可以设置 width、height 可以设置 padding、margin 块级元素可以包含行内元素和其他块级元素 inline 内联元素（行内元素） 不会单独占一行，多个元素并排一行，宽度随内容变化 设置 width、height 无效 可以设置水平方向的 padding、margin，但是垂直方向设置无效（如 padding-top）无效 行内元素只能包含数据和其他行内元素 inline-block 行内块元素 不会单独占一行 可以设置 width、height 可以设置 padding、margin，垂直方向也可以设置生效 css 穿参给 js 的方法12345678910@media (any-hover: none) { body::before { content: 'hoverNone'; display: none; }}// js获取const hover = getComputedStyle(document.body, '::before').content;hover就是content对应的值 判断元素是否在可视窗口内1234567891011121314151617181920212223242526272829303132333435363738// 方法一：offsetTop - scrollTop &lt;= 视口高度function isInViewPortOfOne(element) { // 获取可视窗口的高度。兼容所有浏览器 const screenHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; // 获取滚动条滚动的高度 const scrollTop = document.documentElement.scrollTop; // 获取元素偏移的高度。就是距离可视窗口的偏移量。 const offsetTop = element.offsetTop; // 加100是为了提前加载 return offsetTop - scrollTop &lt;= screenHeight + 100;}// 方法二：getBoundingClientRect().top &lt;= 视口高度function isInViewPortOfTwo(el) { const screenHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; return el.getBoundingClientRect()?.top &lt;= screenHeight + 100;}// 方法三：IntersectionObserver// io 为 IntersectionObserver对象 - 由IntersectionObserver()构造器创建var io = new IntersectionObserver((entries) =&gt; { // entries 为 IntersectionObserverEntry对象数组 entries.forEach((item) =&gt; { // item 为 IntersectionObserverEntry对像 // isIntersecting是一个Boolean值，判断目标元素当前是否可见 if (item.isIntersecting) { // div 可见时 进行相关操作 console.log(item.target.innerText); io.unobserve(item.target); //停止监听该div DOM节点 } });}); // 不传options参数，默认根元素为浏览器视口const divArr = [...document.querySelectorAll('.item')];divArr.forEach((div) =&gt; io.observe(div)); // 遍历监听所有div DOM节点","link":"/2019/09/06/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86css%E7%AF%87/"},{"title":"面试知识javascript篇","text":"[toc] 从浏览器地址栏输入 url 到显示页面的步骤 * 先检查搜索关键字是否符合url规则，然后将其组装成完成url进行访问 * 检查缓存，浏览器检查本地强缓存是否可用，如果命中强缓存就直接从缓存中返回资源 - 根据http header中的expires、cache-control来判断是否命中强缓存 * DNS解析，如果未命中强缓存，则向服务器发起请求，通过递归查询和迭代查询解析域名来获取对应IP地址 - 浏览器IP缓存 - 操作系统IP缓存 - 本地hosts文件 - 路由器缓存 - 本地DNS服务器以递归方式进行查询缓存记录 - 若没有缓存记录就向根DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器， 本地DNS服务器把对应关系暂存在缓存中（以便下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。 * 客户端发送HTTP请求 * 建立TCP连接，三次握手 * 发起http请求 * 负载均衡：服务端网关收到http请求后，可能会进行一系列负载均衡处理，通过反向代理分配给对应集群中的服务器去执行 * 服务端返回响应：服务端收到请求后，根据请求头中缓存标识（If-Modified-Since/If-None-Match）来判断缓存是否生效， 生效返回304状态码，未命中缓存返回200状态码和标识（Last-Modified/Etag） * 浏览器接收到http响应后，根据connection: keep-alive判断保持连接或者四次挥手断开TCP连接 * 浏览器缓存响应头中缓存标识字段（Last-Modified/Etag） * 解析HTML文档，此时document.readystate为loading * 构建DOM树，浏览器从上到下解析html文档生成DOM节点树 * 构建CSSOM树，浏览器解析遇到样式进行异步下载，构建CSSOM树（不会阻塞DOM树构建，但是会阻塞渲染，防止css规则不断变化） * 构建渲染树，根据DOM节点树和CSSOM树构建渲染树Render * 遇到图片异步下载，遇到不带async和defer的script时，阻塞html的解析并下载且执行 * 带async的script标签，不会中断html解析并行下载脚本，下载完成后中断html解析并执行脚本，优先级高于defer,但是无序 * 带defer的script标签，不会中断html解析并行下载脚本，当浏览器解析完html时，DOMContentLoaded事件即将触发时执行脚本 * 文档解析完成，document.readystate变为interactive,触发DOMContentLoaded事件 * 等待图片加载或所有异步脚本加载执行完成，document.readystate变为complete,window触发load事件 * 布局Layout，根据Render树计算每个节点在屏幕上的位置布局 * 绘制Paint，绘制节点到屏幕上，涉及到构建图层树、绘制列表、光栅化（合成线程）和显示等。 其他：dns-prefetch:前端网络性能优化的一种措施，提前解析之后可能遇到的域名，使解析结果缓存到系统缓存中，缩短 DNS 解析时间，进而提高网站的访问速度 dns-prefetch 原理：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP(运行商)DNS 缓存-&gt;根域名服务器-&gt;顶级域名服务器-&gt;主域名服务器 dns-prefetch 将解析后的 IP 缓存放在系统缓存中dns-prefetch 与 preconnect 预连接提示配对 12&lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com/&quot; crossorigin&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://fonts.gstatic.com/&quot;&gt; Note：如果页面需要建立与许多第三方域的连接，则将它们预先连接会适得其反。 preconnect 提示最好仅用于最关键的连接。对于其他的，只需使用 即可节省第一步的时间 DNS 查找。 扩展：收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？ 你知道哪些前端攻击？该如何预防？ xss Cross Site Script 跨站脚本攻击 手段：将 js 代码插入到网页内容中，渲染时执行 js 代码 预防：特殊字符替换（前端或后端） 输入检查，对于用户输入进行格式检查。 csrf Cross Site Request Forgery 跨站请求伪造 手段：诱导用户去访问另一个网站的接口，伪造请求 预防：严格的跨域限制 + 验证码机制 csrf 详细过程 用户登录 A 网站，有了 A 网站的 cookie 诱导用户到 B 网站，并发起 A 网站的请求 A 网站的 API 发现有 cookie，认为是用户自己操作的 csrf 预防手段 严格的跨域请求限制，如判断 referer（请求来源） 为 cookie 设置 SameSite，禁止跨域传递 cookie Chrome 51 开始，浏览器的 Cookie 新增加了一个 SameSite 属性，用来防止 CSRF 攻击 和用户追踪（第三方恶意获取 cookie），限制第三方 Cookie，从而减少安全风险。 关键接口使用短信验证码 token 验证 点击劫持 click jacing 手段：诱导界面上蒙一个透明 iframe，诱导用户点击 预防：让 iframe 不能跨域加载 X-FRAME-OPTIONS 响应头是用来给浏览器指示允许一个页面可否在&lt;frame&gt;,&lt;iframe&gt; 或者 &lt;object&gt; 中展现的标记。网站可以使用此功能，来确保自己网站内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。 DDos Distribute denial-of-service 分布式拒绝服务 手段：分布式的、大规模的流量访问，使服务器瘫痪 预防：软件层不好做，需硬件预防（如阿里云 WAF） SQL 注入 手段：提交内容时写入 SQL 语句，破环数据库 预防：处理输入的内容，替换特殊字符 性能优化（空间换时间） 性能优化原则 多使用内存、缓存 减少 CPU 计算，减少网络加载耗时 适用于所有编程的性能优化-空间换时间 减少资源体积：压缩代码 减少访问次数：合并代码，SSR 服务器渲染，缓存，精灵图 缓存（webpack contenthash） 静态资源加 hash 后缀，根据文件内容计算 hash 文件内容不变，则 hash 不变则 url 不变 url 和文件不变，则会自动触发 http 的缓存机制，返回 304 SSR 服务器端渲染：将网页和数据一起加载，一起渲染 非 SSR（前后端分离）：先加载网页，后加载数据，再渲染数据 DNS 预解析 减少 cookie 大小，http 请求会携带 cookie 使用 http2 头部压缩 避免重定向：当页面发生了重定向，就会延迟整个 HTML 文档的传输。在 HTML 文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。 渲染优化 css 放在 head，js 放在 body 最下面 尽早开始执行 js，用 DOMContentLoaded 触发 懒加载（图片懒加载-IntersectionObserver，下滑更多等） 对 DOM 查询进行缓存 减少 DOM 数量，大数据量分页、虚拟列表 合并频繁的 DOM 操作,document.createDocumentFragment()，减少 dom 操作次数 节流 throttle、防抖 debounce 使用 loading 图，提高用户视觉体验 使用 GPU 加速：使用 transform、opacity，要慎用低端机 GPU 差，占用较多内存，因此是否开启硬件加速，要用测试结果决定 使用 requestAnimationFrame 来实现视觉变化 三方资源 第三方资源、库使用 CDN 压缩图片体积，减少图片大小 图片使用 webp 格式，减少图片体积 preload 预先加载 css 文件或者字体文件、js 文件等 浏览器需要先把 html 页面加载回来，才能知道下一步去加载那些 js、css 或字体文件，中间时间就被浪费掉了 可以在等待 html 响应的同时把重要的静态资源文件也加载回来 你对闭包了解多少？解释一下作用域链是如何产生的 解释一下js执行山下文的创建、执行过程 解释一下闭包所产生的变量放在哪里 闭包的定义：闭包就是能够读取其他函数内部变量的函数。 闭包的底层实现原理 js 执行上下文： 1234567891011121314151617181920212223242526272829js运行三部曲1.语法分析2.预编译3.解释执行js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。预编译的环境需要个环境，这个环境就是执行上下文。js执行上下文分为三种：1.全局执行上下文：代码开始执行时首先进入的环境2.函数执行上下文：函数调用时，会开始执行函数中的代码3.eval执行上下文：不建议使用执行上下文的周期，分为两个阶段1.创建阶段 创建词法环境 生成变量对象VO，建立作用域链 确认this指向，并绑定this2.执行阶段 进行变量赋值，函数引用以及执行代码预编译发生在函数执行前，预编译四部曲：1.创建AO对象2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined3.将形参和实参相统一4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）5.最后程序输出变量值的时候，就是从AO对象中拿（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包） js 的执行机制js 是单线程的，处理 js 任务只能一个一个顺序执行，js 中把任务分为了同步任务和异步任务，同步任务进入主线程先执行，异步任务进入 Event Table 并注册函数，指定事情完成后，Event Table 就会将函数移入到事件队列 Event Queque 中，等待主线程任务执行完毕，就会从事件队列中取出对应事件进入主线程执行。 macro-task（宏任务）：包括整体代码 script、setTimeout、setInterval、IO 操作、UI 交互、postMessage 等micro-task（微任务）：Promise.then、process.nextTick、MutationObserve 等微任务先于宏任务先执行（除了 script）执行过程不同任务进入不同的 event queue js 先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，遇到宏任务放到宏任务事件队列中。 然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，以此类推。 简单说下原型链 原型链是由原型对象组成的，每个对象都有proto属性，指向了创建该对象的构造函数的原型，proto将对象连接起来组成了原型链。 原型链：用来实现继承和共享属性的有限对象链。 每个对象都有proto（隐式原型）属性，指向创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 proto 来访问。 对象的隐式原型等于对象的构造函数的显式原型：obj.proto === Object.prototype 访问属性的时候，js 引擎会调用内部的默认[[Get]]操作，[[Get]]操作首先会检查对象本身是否包含这个属性如果对象没有这个属性，则对象可以通过proto来寻找不属于该对象的属性，proto将对象和原型连接起来形成原型链 Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎创建。 defer 和 async 有什么区别？ 区别 如何监听未处理的异常 try…catch 无法捕捉到语法错误，只能捕捉运行时错误 可以拿到出错的信息(出错的文件，行号，列号) window.onerror 由于 try…catch 只能捕获块里面的错误，全局的一些错误可以用 window.onerror window.addEventListener(‘error’,callback):捕获资源错误 window.addEventListener(‘unhandledrejection’,callback):捕获 promise 类型错误 vue.config.errorHandler: vue 错误 componentDidCatch：错误边界函数 本地存储 客户端的本地存储： localStorage - 生命周期永久生效，除非手动删除，否则关闭页面也会存在 - 可以在同一浏览器多窗口共享 - 以键值对的形式存储使用 方法： 存储数据：localStorage.setItem(key, value) 获取数据：localStorage.getItem(key) 删除数据：localStorage.removeItem(key) 删除所有数据：localStorage.clear() sessionStorage 声明周期为关闭浏览器窗口 在同一个窗口中数据可以共享 以键值对的形式存储 方法： 存储数据：sessionStorage.setItem(key, value) 获取数据：sessionStorage.getItem(key) 删除数据：sessionStorage.removeItem(key) 删除所有数据：sessionStorage.clear() localStorage 和 sessionStorage cookie 和 session IndexDB 离线存储，当网络断开，可以从浏览器中读取数据，用来做一些离线应用 Cookie 包含字段 name: cookie 名称 value: 值 domain: cookie 生效的域名 path: cookie 生效的路径 expires/max-age: cookie 过期时间 size: 大小 HttpOnly: 用户端不可更改 存储用户信息，通过在客户端记录信息确定用户身份，最大为 4kb 会话 Cookie，若不设置过期时间，表示这个 cookie 的生命周期为浏览器会话期间，浏览器关闭，cookie 就消失，会话 cookie 会保存在内存中而不是硬盘上。 持久 Cookie，若设置了过期时间，浏览器会把 cookie 保存在硬盘上，关闭浏览器仍然有效直到超过设定的过期时间。 cookie 数据始终在同源的 http 请求中携带(即使不需要)，即会在浏览器和服务器之间来回传递。 Cookie 具有不可跨域名性，例如浏览器访问百度不会带上谷歌的 cookie 监测是否支持 web Storage 1.通过 window.sessionStorage,window.localStorage 判断浏览器是否支持 2.通过 try{}catch{} 执行一下 storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。 服务端的存储： Session Session 服务器端一种记录客户端状态的机制 cookie 数据存放在客户的浏览器上，session 将数据存放在服务器端 Session 相对 Cookie 来说比较安全，别人可以分析本地存放的 cookie 进行 cookie 欺骗 Session 会在一定时间内保存在服务器上，访问量较多的时候会比较占用服务器的性能，考虑到减轻服务器性能方面的时候，应当使用 cookie 可以将登陆等重要信息保存在 session，其他信息放在 cookie 中 localStorage 超过最大限制（5M）怎么处理？ localstorage 一般最大容量为 5M，意思是每个域名（假如为 a.com）下最大 localstorage 容量为 5M，我们可以通过 iframe 创建 b.com 域框架用于存储 a.com 剩下的数据，然后通过 postMessage 读写数据。 通常对于不同页面的脚本，只有在同源策略下才能通信，但是 window.postMessage(message,targetOrigin)方法提供了一种受控机制来规避此限制。 而且 localStorage 本身定位也不是大数据量的存储方案 浏览器提供了大数据量的本地存储的方案：IndexedDB 一般存储数据大小在 250M 以上 可以使用 localforage 插件（yarn add localforage），api 基本和 localStorage 类似，学习成本低 cookie cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据 cookie 追踪用户在不同页面的访问信息。 cookie 特点 1.大小限制，cookie 大小限制在 4KB 以内 2.宽带限制，cookie 数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。 3.安全风险，cookie 会频繁的在网络中传送，不加密的情况下是有安全风险的。 4.操作复杂 123456function setCookie(name: string, value: string) { const exp = new Date(); //过期时间设置为一天 exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000); document.cookie = `${name}=${escape(value);expires=${exp.toString()}}`;} fetch 和 axiosfetch取消发送 1.创建一个AbortController实例 2.该实例具有signal属性 3.将signal传递给fetch option 4.调用AbortController的abort属性来取消所有使用该信号的fetch axios取消发送 1.const cancelToken = axios.CancelToken 2.const source = CancelToken.source() 3.axios.get('/xxx',{cancelToken: source.token}) 箭头函数中的 this 箭头函数中的 this 是在定义函数的时候绑定的（继承自父执行上下文中的 this），而不是执行函数时绑定。 箭头函数没有 this，所以不能用作构造函数。 Map 和 Set 两种新的数据结构的区别？ Map 类似 Object 是一种键值对集合，区别在于 Map 的键不仅限于字符串，其他各种类型的值都可以作为 Map 的键 Set 是类似数组的一种数据结构，不同点在于 Set 中没有重复的值 js 的 new 操作符都做了些什么？1234567891011121314151617181920212223241. 创建一个空的js对象{}2. 将空对象的隐式原型__proto__指向构造函数的原型3. 将空对象作为构造函数的上下文（改变this指向）4. 对构造函数返回值做判断实现：function newFn(fn, ...args) { const obj = Object.create(fn.prototype); const result = fn.apply(obj, args); return typeof result === 'object' &amp;&amp; result !== null ? result : obj;}function Person(name) { this.name = name;}const p = newFn(Person, 'Jerome');console.log('p.name :&gt;&gt; ', p.name); // p.name :&gt;&gt; Jerome补充：在new的时候，会对构造函数的返回值做一些判断1. 如果返回值是基础类型数据，则忽略返回值2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效 es6 新特性1.let和const 2.模版字符串 3.箭头函数 4.函数可以设置默认参数值 5.扩展运算符 6.对象和数组的解构 7.class 图片懒加载原理 浏览器是否发起请求是根据标签的 src 属性 所以懒加载的关键是：在图片没有进入可视区域时，先不给的 src 属性赋值，等到图片进入可是区域再给 data-src -&gt; src 赋值。 // 方法一：offsetTop - scrollTop &lt;= 视口高度 // 方法二：getBoundingClientRect().top &lt;= 视口高度 screenHeight // 方法三：IntersectionObserver 为什么 try/catch 不能捕获到 promise 的错误？ try-catch 主要用于捕获同步函数的异常，如果 try 里面的异步方法出现了异常，此时 catch 是无法捕获到异常的。ES6 中 Promise 对象的实例提供了 catch() 方法，表示异步捕获异常。 原因：当异步函数抛出异常时，对于宏任务而言，执行函数时已经将该函数推入栈，此时并不在 try-catch 所在的栈，所以 try-catch 并不能捕获到错误。对于微任务而言，比如 promise，promise 的构造函数的异常只能被自带的 reject 也就是.catch 函数捕获到。 requestIdleCallback 和 requestAnimationFrame 有什么区别？requestIdleCallback(callback, timeout): · 低优先级 · 兼容性不好 · 执行时机：浏览器空闲时被调用 · 指定timeout，回调任务就会被放进事件循环队列，强制执行，但是会影响性能 requestAnimationFrame(callback): · 高优先级 · 执行时机：下次重绘前执行传入的回调函数 - 补充 - 两者都是宏任务(其实也算不上，重要的是执行时机) 如何阻止冒泡?W3C的方法e.stopPropagation(),IE使用e.cancelBubble = true; 封装： //阻止冒泡行为 function stopBubble(e) { //如果提供了事件对象，则这是一个非IE浏览器 if (e &amp;&amp; e.stopPropagation) e.stopPropagation() //IE的方法 else window.event.cancelBubble = true } 如何阻止默认事件？W3C的方法是e.preventDefault(),IE使用e.returnValue = false 封装： //阻止浏览器的默认行为 function stopDefault (e) { if (e &amp;&amp; e.preventDefault) e.preventDefault() //IE中阻止默认事件的方法 else window.event.returnValue = false return false } 补充：事件绑定的封装function addEvent(element,type,handle) { if(element.addEventListener){ element.addEventListener(type,handle,false); }else if(element.attachEvent){ element.attachEvent('on'+type,function () { handle.call(element); }) }else { element['on'+type] = handle; } } 如何判断一个对象是否为数组1. Array.prototype.isPrototypeOf(obj)方法，判断Array.prototype是不是在obj的原型链中， 如果在，则返回true，否则返回false。 2. obj instanceof Array 3. Object.prototype.toString.call(obj); //(===&quot;[object Array]&quot;) 4.Array.isArray(obj) Http 的持久连接和管线化1. 什么是持久连接？ HTTP1.1规定了默认保持持久连接，数据传输完成也保持TCP连接不断开，等待同域名下 继续使用这个通道传输数据,在一个TCP连接上传输多个HTTP请求和响应。 持久连接避免了重新建立连接，大大减少了建立和关闭连接的消耗和延迟，HTTP的连接是建立 在TCP协议之上的，建立一条TCP连接需要三次握手，TCP连接关闭需要四次挥手，这些都需要时间。 2. 什么是管线化？ 持久连接： 请求1 ——&gt; 响应1 ——&gt; 请求2 ——&gt; 响应2 管线化： 请求1 ——&gt; 请求2 ——&gt; 响应1 ——&gt; 响应2 管线化机制需要通过持久化连接完成。 持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后， 才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。 实现并行发送请求。 只有GET和HEAD请求可以进行管线化，而POST有所限制。 初次建立连接不应启动管线机制，因为对方服务器不一定支持HTTP1.1版本的协议。 为什么利用多个域名来存储网站资源会更有效？1.CDN 是构建在网络之上的内容分发网络，可以使用户就近获取资源，减低网络拥塞，提高用户 访问的响应效率以及命中率。 2.突破浏览器的并发限制，同一时间针对同一域名下的请求有一定的数量限制，超过限定数目 的请求会被阻塞。 3.节约cookie带宽 4.减少主域名的连接数，优化页面响应速度 5.防止不必要的安全问题 基本数据类型基本数据类型：Null、Undefined、String、Boolean、Number ES6：Symbol ES10：Bigint（可以突破安全整数限制，安全的存储和操作最大整数之外的整数，不会损失精度） Object.seal 和 Object.freezeObject.seal 当前属性的值只要原来可写就可以改变 不能向对象新增属性 已有属性都变得不可配置，也就是不可删除 Object.freeze 不能向对象新增属性 不能删除已有属性 不能修改已有属性的 enumable、writable、configurable 不能修改已有属性的值 该对象的原型也不能修改 牛客学习 超链接 a 标签的 href 的属性值是 url，里面必须包含协议，没有协议就会解析成相对路径。 HTTP 状态码分类： 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接受并处理。 200 服务端成功处理了请求并返回内容 3** 重定向，需要进一步的操作以完成请求 301 永久重定向 302 临时重定向 304 资源未被修改，返回一个 304 状态吗然后从本地缓存中加载请求的资源 4** 客户端错误，请求包含语法错误或无法完成请求。 404 （页面丢失）未找到资源 403 服务器拒绝请求 408 （请求超时） 服务器等候请求时发生超时 5** 服务器错误，服务器在处理请求的过程中发生错误 503 服务器暂时不可用 504 服务器内部错误 HTTP 协议的特征： C/S(客户端/服务器)模式：只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过 HTTP 来发送，客户端和服务器指定合适的 MIME-type 内容类型。 简单快速 灵活 无连接：限制每次连接只处理一个请求，收到客户的应答后即断开连接，可以节省传输时间。 无状态：对于事物处理没有记忆能力，意味着如果后续处理需要前面的信息，则必须重传，这样就会导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就会很快。 get 和 post 的请求区别？ 区别一： get 重点是从服务器上获取资源 post 重点是向服务器发送数据 区别二： get 传输数据通过 url 请求，以 field（字段）=value 的形式放在 url 后，用“？”连接，多个请求数据间用“&amp;”连接，过程用户可见。 post 传输数据放在请求体（request body）中发送给服务器，用户不可见。 区别三： get 传输数据大小有限制，但效率较高 post 可以传输大量数据，所以上传文件用 post 方式 区别四： get 请求不安全，因为参数直接暴露在 url 上，不能用来传递敏感信息。 post 较 get 安全性较高。 区别五： get 方式只能支持 ASCII 字符，向服务传的中文字符可能会乱码。 post 支持标准字符集，可以正确传递中文字符。 区别六： get 在浏览器回退是无害的，而 post 会再次提交请求。 区别七 get 请求会被浏览器主动 cache（缓存），而 post 不会除非手动设置。 iframe 有哪些缺点？ iframe 会阻塞主页面的 onload 事件 通过 oIframe.contentWindow 寻找子 window 对象 通过 window.parent 寻找父级窗体 通过 window.top 寻找顶级窗体 window.location.hash 解决父页面向子页面传值 window.name 解决子页面向父页面传值 不利于 SEO，搜索引擎的检索程序无法解读这种页面（百度 spider 不收录，浏览器对 iframe 框架的兼容问题） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 如果需要使用 iframe，最好通过 javascript 动态给 iframe 添加 src 属性值。 xhtml 和 html 有什么区别？ 性能方面 XHTML 兼容性好，兼容各大浏览器、手机以及 PDA，使浏览器可以快速正确编译网页 书写习惯方面 HTML 标签不区分大小写，XHTML 所有标签必须小写 XHTML 必须成双成对 HTML 对标签顺序要求不严格，XHTML 标签顺序必须正确 等等 html 和 xml 的区别？ xml 被设计用来传输和存储数据，其焦点是数据的内容 html 被设计用来显示数据，其焦点是数据的外观 html 旨在显示信息，而 xml 旨在传输信息 xml 在定义标记时区分大小写，而 html 不区分大小写 link 和@import 的区别：两者都是外部引用 CSS 的方式，但有一定的区别 + link是XHTML标签，除了加载CSS外，还可以加载其他文件；@import只能加载CSS。 + 解析到link时，页面会同步加载Css；@import在页面加载完后加载Css。 + link是XHTML标签，无兼容问题；@import是在**CSS2.1**之后提出的，只有再IE5以上才能识别。 + link可以js动态引入，@import不行 + @import的最佳写法： @import url(style.css),其他写法：@import 'style.css'、 @import &quot;style.css&quot;、@import url('style.css')、@import url(&quot;style.css&quot;) viewport 1234&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt; // width 设置 viewport 宽度，为一个正整数，或字符串‘device-width’// device-width 设备宽度// height 设置 viewport 高度，一般设置了宽度，会自动解析出高度，可以不用设置// initial-scale 默认缩放比例（初始缩放比例），为一个数字，可以带小数// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数// user-scalable 是否允许手动缩放 单行文本溢出省略号 overflow: hidden; text-overflow:ellipsis; white-space: nowrap; 多行文本溢出省略号 display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; 换行标签 word-wrap: break-word 浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？ 在线的情况下：浏览器发现 html 头部有 manifest 属性，会请求 manifest 文件，如果是第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并进行离线缓存。如果已经离线存储了，浏览器会使用离线的资源加载页面，然后浏览器会比对新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不要做任何操作，如果文件改变，就会重新下载文件中的资源并进行离线存储。 离线的情况下：浏览器就直接使用离线存储的资源。 如何清除 token 浏览器关闭会出发 beforeunload ，unload 这两个事件。 浏览器刷新也会触发，还会触发load事件 方案一 123window.onbeforeunload = function () { localStorage.removeItem(&quot;token&quot;)} 缺点： 刷新也会清空 token 方案二 123456789101112131415window.onunload = function() { localStorage.setItem(&quot;lastTime&quot;,new Date().getTime())}window.onload = function() { let lastTime = localStorage.getItem(&quot;lastTime&quot;); const interval = 3 * 1000; // 如果时间间隔大于3s，则清除token if (!lastTime || new Date().getTime() - lastTime &gt; interval) { localStorage.remove(&quot;token&quot;); console.log(&quot;remove token&quot;); } else { console.log(&quot;time is less than not remove token&quot;); }} 补充可以使用 sessionStorage 代替 localStorage 来存储 token，当关闭浏览器时会自动清除 token，sessionStorage 不是持久化的本地存储，而是会话级别的存储，而 localStorage 是持久化的本地存储，除非主动删除数据，否则数据是不会过期的。 npm1234567891011121314151617181920212223242526272829303132333435363738// 举个例子：&quot;dependencies&quot;: { &quot;jquery&quot;: &quot;^13.4.6&quot;, // 只锁定主版本号 major &quot;jquery&quot;: &quot;~13.4.6&quot;, // 锁定主版本号和次版本号 major + minor &quot;jquery&quot;: &quot;13.4.6&quot;, // 锁定版本 &quot;jquery&quot;: &quot;*&quot;, // 最新版本}// major: 13, minor: 4, patch: 6$ npm info jquery // 查看 jquery 信息$ npm view jquery versions // 查看 jquery 所有版本$ npm list | grep gulp // 过滤 gulp$ npm outdated // 查看过期版本$ npm update //更新版本$ npm cache clean --force // 清楚缓存$ npm ls // 查看项目引用了哪些包$ npm unpublish --force // 从npm卸载包// 执行顺序$ npm run script1 &amp; npm run script2 //并行执行$ npm run script1 &amp;&amp; npm run script2 // 继发执行// cross-env: 运行跨平台设置和使用环境变量的脚本// cross-env可以设置NODE_ENV环境变量，process.env.NODE_ENV === 'production'$ npm install --save-dev cross-env// {// &quot;scripts&quot;: {// &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;// }// }$ npm config get registry // 查看当前源$ npm config set registry https://registry.npm.taobao.org //切换镜像源// npx// --no-install: 让npx强制使用本地模块，不下载远程模块，如果本地不存在，就会报错$ npx --no-install http-server// --ignore-existing: 忽略本地的同名模块，强制安装远程模块$ npx --ignore-existing http-server URI 和 URL 有什么区别？ URL(Uniform Resource Identifier): 统一资源定位符 如：https://upos-sz-staticks3.bilivideo.com/cmaskboss/164203142_30_1.jpg URI(Uniform Resource Locator): 统一资源标识符 如：164203142_30_1.jpg URN(Uniform Resource Name): 统一资源名称 如：urn:isbn:9787115318893 (国际标准图书编号)，类似身份证 URL 是 URI 的子集 日期Date.now() //获取当前时间毫秒数 var dt = new Date() //构造一个实例对象 dt.getTime() //获取毫秒数 dt.getFullYear() //年 dt.getMonth() //月（0-11） dt.getDate() //日 （0-31） dt.getHours() //小时（0-23） dt.getMinutes() //分钟（0-59） dt.getSeconds() //秒（0-59） dt.getDay() //星期几（0-6） 浏览器如何缓存 html meta 标签控制缓存 &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cahce&quot;&gt; //告诉浏览器当前页面不被缓存 http 头信息控制缓存 Expires ——&gt; 过期时间 Cache-Control 响应头信息(no-cache、no-store、max-age、public) Chrome 打开一个页面需要启动多少线程？分别有哪些线程？最新Chrome浏览器包括：一个浏览器(Browser)主进程、一个GPU进程、一个网络(NetWork) 进程、多个渲染进程和多个插件进程 进程： 浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU 进程：Chrome 刚开始的时候是没有 GPU 进程的，而 GPU 使用的使用初衷是为了实现3D CSS 效果，之后随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 称为浏览器普遍的需求，最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程：主要负责网页的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，最近才独立出来，称为一个单独的进程。 插件进程：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 线程： js 线程 UI 渲染线程 事件线程 定时器触发线程 http 请求线程 插件线程 [js] 请说说写一个拖拽组件的思路及注意事项?123456789首先，其实拖拽效果的思路是很简单的。主要就是三个步骤：1.onmousedown的时候，启动可拖拽事件，记录被拖拽元素的原始坐标参数。2.onmousemove的时候，实时记录鼠标移动的距离，结合被拖拽元素第一阶段的坐标参数，计算并设置新的坐标值。3.onmouseup的时候，关闭可拖拽事件，记录新的坐标值。注意：这里主要是通过绝对定位的top和left来确定元素的位置的，因此被拖拽元素的css一定要设置绝对定位。 箭头函数 箭头函数的特点 没有 arguments 无法通过 apply、call、bind 改变 this 某些箭头函数代码难以阅读 for…in 和 for…of 有什么区别 key 和 value for…in 遍历得到 key for…of 遍历得到 value 适用于不同的数据类型 遍历对象： for…in 可以，for…of 不可以 遍历 Map、Set：for…of 可以，for…in 不可以 遍历 generator：for…of 可以，for…in 不可以 可枚举 vs 可迭代 for…in 用于可枚举（Object.getOwnPropertyDescriptors(obj)）数据，如对象、数组、字符串 for…of 用于可迭代(arr[Symbol.iterator])数据，如数组、字符串、Map、Set for await…of 有什么作用？ for await…of 用于遍历多个 Promise 12345678910111213141516171819202122232425262728293031323334353637383940function createPromise(value) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(value); }, 1000); });}(async function () { const p1 = createPromise(100); const p2 = createPromise(200); const p3 = createPromise(300); const list = [p1, p2, p3]; const list2 = [100, 200, 300]; // ---------------同时调用---------------- // 方式一 // const res1 = await p1; // console.log(res1); // const res2 = await p2; // console.log(res2); // const res3 = await p3; // console.log(res3); // 方式二 // Promise.all(list).then((res) =&gt; console.log(res)); // 方式三 // for await (let res of list) { // console.log(res); // } // -----------------逐步调用--------------- for (let value of list2) { const res = await createPromise(value); console.log(res); }})(); JS 严格模式有什么特点？ 特点（’use strict’） 全局变量必须先声明 禁止使用 with this 指向 undefined 而不是 window 函数参数不能重名 eval 有单独作用域，不推荐使用 HTTP 跨域请求时为什么发送 options 请求？ options 请求是对 CORS 跨域请求之间的一次预检查，获取服务器是否允许本次请求，检查成功才会正式发起请求，是浏览器自行处理的 JS 内存泄漏如何检测？场景有哪些？ 垃圾回收 GC 引用计数 标记清除 场景 意外的全局变量 遗忘的定时器 使用不当的闭包 遗漏的 DOM 元素 网络回调 内存泄漏属于非预期的，闭包是主动行为，闭包非内存泄漏 可以使用 chrome devtools 的 performance 和 memory 工具类检测 js 内存 参考 vdom 真的很快吗？ js 直接操作 dom 才是最快的，vdom 并不快 但是 vdom 是最合适“数据驱动视图”的技术方案 遍历数组，for 和 forEach 哪个快？ 时间复杂度都是 O(n) 结论： for 更快 forEach 每次都要创建一个函数来调用，而 for 不会创建函数 函数需要独立的作用域，会有额外的开销 请描述 JS Bridge 的原理 什么是 JS Bridge？ js 无法直接调用 native API 需要通过一些特定的“格式”来调用 这些“格式”就统称 JS-Bridge，例如微信 JSSDK JS Bridge 的常见实现方式 注册全局 API URL Scheme 移动端 H5 click 有 300ms 延迟，如何解决？ 背景：double tap to zoom 初期解决方案 FastClick 监听 touchend 事件(touchstart touchend 会先于 click 触发) 使用自定义 DOM 事件模拟一个 click 事件 把默认的 click 事件(300ms 之后触发)禁止掉 1234567window.addEventListener( 'load', function () { FastClick.attach(document.body); }, false); 现代浏览器的改进（width=device-width） 123456&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;id=edge&quot;&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt; 网络请求中，token 和 cookie 有什么区别？ cookie http 无状态，每次请求都要带 cookie，以帮助识别身份 服务端也可以向客户端 set-cookie，cookie 大小限制 4kb 默认有跨域限制：不可跨域共享、传递 cookie token vs cookie cookie 是 http 规范，而 token 是自定义传递 cookie 会默认被浏览器存储，而 token 需自己存储 token 默认没有跨域限制 JWT(JSON Web Token) 前端发起登录，后端验证成功之后，返回一个加密的 token 前端自行存储这个 token（其中包含了用户信息，加密了） 以后访问服务端的接口，都带着这个 token，作为用户信息 Session 和 JWT 哪个更好？ session 优点 原理简单，易于学习 用户信息存储在服务端，可以快速封禁某个用户 缺点 占用服务端内存，硬件成本高 多进程，多服务器时，不好同步-需要使用第三方缓存，如 redis 默认有跨域限制 JWT 优点 不占用服务器内存 多进程、多服务器不受影响 没有跨域限制 缺点 用户信息存储在客户端，无法快速封禁某用户 万一服务器密钥被泄漏，则用户信息全部丢失 token 体积一般大于 cookie，会增加请求的数据量 答案 如有严格管理用户信息的需求（保密、快速封禁），推荐 session 如没有特殊要求，则使用 JWT 如何实现 SSO 单点登录？ 基于 cookie（主域名相同） cookie 默认不可跨域共享，但有些情况下可设置共享 主域名相同，如www.baidu.com,image.baidu.com 设置 cookie domain 为主域名，即可共享 cookie SSO（主域名不相同，cookie 无法共享） Map 和 WeakMap 的区别和应用场景？ Map： key 可以是任意数据类型 key 是强引用，只要键不释放，就会一直占着内存不会被 GC 能轻易转化为数据（扩展运算符），weakmap 做不到 WeakMap: key 只能是非 null 的对象引用 key 是弱引用，没有其他引用存在时会被 GC key 随时会被回收，所以 key 不可枚举，没有 size 等属性 Map 场景： 频繁的读写和查询 键值复杂的情况 重绘 repaint 重排 reflow（回流） 有什么区别？ 重绘 repaint 元素外观改变，如颜色、背景色 但元素的尺寸、定位不变，不会影响到其他元素的位置 重排 relfow 重新计算尺寸和布局，可能会影响其他元素的位置 如元素高度增加，可能会使相邻元素位置下移 区别 重排比重绘影响更大，消耗更大 所以，要尽量避免无意义的重排 减少重排的方法 集中修改样式，或直接切换 css、class 修改之前先设置 display: none,脱离文档流 使用 BFC 特性，不影响其他元素位置 频发触发（resize、scroll）使用节流和防抖 使用 createDocumentFragment 批量操作 DOM 优化动画，使用 CSS3 和 requestAnimationFrame 如何实现网页多标签通讯？ 使用 WebSocket 无跨域限制 需要服务端支持，成本高 localStorage（跨域不共享） 同域的 A 和 B 两个页面 A 页面设置 localStorage B 页面可监听到 localStorage 值的修改 SharedWorker(必须同域) SharedWorker 是 WebWorker 的一种 WebWorker 可开启子进程执行 JS，但不能操作 DOM SharedWorker 可单独开启一个进程，用于同域页面通讯 网页和 iframe 如何通讯？ 使用 postMessage 通讯 注意跨域的限制和判断 123456789// 父传子window.iframe1.contentWindow.postMessage('hello', '*');// 子传父window.parent.postMessage('world', '*');// 接收window.addEventListener('message', (event) =&gt; { console.log(event.origin); console.log(event.data);}); 请描述 koa2 洋葱圈模型？ koa2 一个简约、流行的 nodejs 框架 通过中间件组织代码 多个中间件以“洋葱圈模型”执行 代码执行过程 洋葱圈模型(类似捕获冒泡) H5 页面如何进行首屏优化？ 路由懒加载 适用于 SPA 路由拆分，优先保证首页加载 服务端渲染 SSR 传统前后端分离（SPA）渲染页面的过程复杂 SSR 渲染页面过程简单，所有性能好 如果是纯 H5 页面，SSR 是性能优化的终极方案 App 预取 如果 H5 在 App WebView 中展示，可使用 App 预取 用户访问列表页面时，App 预加载文章首屏内容 用户进入 H5 页面，直接从 App 中获取内容，瞬间展示首屏 分页 针对列表页 默认只展示第一页内容 上滑加载更多 图片懒加载 lazyload 针对详情页 默认只展示文本内容，然后出发图片懒加载 注意：提前设置图片尺寸，尽量只重绘不重排 Hybrid 提前将 HTML、JS、CSS 下载到 App 内部 在 App webview 中使用 file：// 协议加载页面文件 再用 Ajax 获取内容并展示（也结合 App 预取） 后端一次性返回 10w 条数据，你该如何渲染？ 设计不合理，后端调整(分页) 自定义中间层 自定义 nodejs 中间层，获取并拆分这 10w 条数据 前端对接 nodejs 中间层，而不是服务端 成本比较高 虚拟列表 只渲染可视区域 如果一个 H5 很慢，你该如何排查性能问题？ 前端性能指标 First Paint（FP） First ContentFul Paint（FCP） DomContentLoaded（DCL） Largest Contentful Paint（LCP） Load（L） Chrome devtools Performance 可查看上述性能指标，并有网页快照 Network 可以查看各个资源的加载时间 lighthouse（第三方性能评测工具） 12// terminallighthouse https://www.imooc.com/ --view --preset=desktop 通过以上工具来判读是加载慢还是渲染慢 加载慢 优化服务端硬件配置，使用 CDN 路由懒加载，大组件异步加载-减少主包的体积 优化 http 缓存策略 渲染慢 优化服务端接口（如 ajax 获取数据慢） 优化全段组件内部逻辑 服务端渲染 SSR BOM API navigator screen location history 为何要将 css 文件放在 head 标签中呢？ css 放在 body 标签尾部时，DOMTree 构建完成之后便开始构建 RenderTree，并计算布局渲染网页，等加载解析完 css 之后，开始构建 CSSOMTree，并和 DOMTree 重新构建 RenderTree，重新计算布局渲染网页 css 放在 head 中，先加载 css，之后解析 css 构建 CSSOMTree，同时构建 DOMTree，CSSOMTree 和 DOMTree 都构建完成之后开始构建 Render Tree，计算布局网页 两者对比，css 放在 head 中比放在 body 标签尾部少了一次构建 RenderTree，一次计算布局和一次渲染网页，因此性能会更好，并且 css 放在 body 标签尾部会在网页中短暂出现裸奔的 html，不利于用户体验 为什么建议把 script 标签放在 body 最后？ js 的下载和执行会阻塞 DOMTree 的构建，即会中断 DOMTree 的更新，所以如果把 script 标签放在首屏范围内的 HTML 代码中会截断首屏的内容。 普通 script 标签放在 body 底部，做与不做 async 或者 defer 处理都不会影响首屏时间，但是会影响 DomContentLoad 和 load 的时间，进而影响依赖他们的代码的执行的开始时间 123456window.addEventListener('load', function () { // 页面的全部资源加载完成后才会执行，包括图片、视频等});document.addEventListener('DOMContentLoaded', function () { // DOM 渲染完成后即可执行，此时图片、视频可能还没有加载完}); ES6 新增的声明方式 let、const 不属于顶层对象 window 不允许重复声明 不存在变量提升 暂时性死区（不能在变量声明之前去使用） 块级作用域 如何给所有 async 函数添加 try/catch？babel 插件： 借助 AST 抽象语法树，遍历查找代码中的 await 关键字· 词法分析、语法分析生成 AST 抽象语法树 找到 await 节点后，从父路径中查找声明的 async 函数，获取该函数的 body（函数中包含的代码） 创建 try/catch 语句，将原来的 async 的 body 放入其中· 通过 bebel-template 插件以字符串形式的代码构建 AST 树节点，生成 try/catch 节点 最后将 try/catch 语句替换 async 的 body 全局捕获 Promise 类型错误： window.addEventListener(‘unhandledrejection’, callback) async/await 和 promise 的区别？ promise 的出现是为了解决传统 callback 函数导致的回调地狱问题，但是它本身的语法造成纵向的回调链，遇到复杂的业务场景语法也不美观。 async await 可以说是改良版的 promise，或者说是 promise 的语法糖，可以让异步代码同步化，语法更加美观。 async/await 本质也是 Generator 函数的语法糖，使得异步操作更加方便。就是 Generator 函数（*）的替换为 async、yield 替换为 await Generator 需要调用 next 执行，而 async 函数内置执行器，函数调用后自动执行 async/await = Generator 函数 + 内置自动执行器 Object.create(proto, propertiesObject)、new Object()和{}有什么区别？ {}创建对象时，不会调用构造函数，js 引擎会创建一个空对象，然后改变 this 指向新创建的对象 new 则需要经历：2.1 先创建空对象2.2 设置原型链，设置新对象的 constructor 属性为构造函数的名称，设置新对象的proto指向构造函数的 prototype 对象2.3 调用新对象并调整 this 指向新对象2.4 最后如果返回值为非 null 对象直接返回该返回值，否则返回新对象 Object.create 方法支持两个参数，第一个参数作为新创建对象的原型，第二个为可选参数作为新创建对象的属性 {}字面量创建对象的性能比 new 和 Object.create 要好 {} 和 new 所创建的对象继承 Object 原型链的属性和方法，Object.create 通过第一个参数指定原型，可以通过 Object.create(Object.prototype) Object.create(null)创建的对象没有任何属性和方法 document.ready 和 window.onload 的区别? document.ready 表示 dom 文档解析完成，但是不包含异步脚本和图片等的加载,onload 需要所有文件都加载完成 ready 可以执行多次，onload 只会后者覆盖前者 ready 快于 onload 为什么 setTimeout 有最小 4ms 延迟？ 原因在于如果浏览器允许 0ms，会导致 javascript 引擎过度循环，因为浏览器本身也是建立在 event loop 之上的，如果 js 引擎通过 0ms timer 不断的唤起系统，那么 event loop 就会阻塞，导致 CPU spining（快速旋转），有个故事就是英特尔团队发现 chrome 不正常的电量消耗，就是因为 0ms timer 导致 CPU spining，后果就是计算机没办法进入低功耗模式，所以耗电特别快。后来 chrome 将 timer 的时间间隔做了限制为 1ms。 不同浏览器的最低延迟不一样，比如 chrome 的最低时延是 1ms，而如果 timer 嵌套层级很多，那么最低是 4ms，具体嵌套层级的阈值不同浏览器也不一致，HTML Standard 规定是 &gt;5, chrome 是 &gt;=5; 如果判断是 PC 端还是移动端 屏幕宽度：window.screen、window.innerWidth 屏幕方向：window.orientation pc 端为 undefined navigator.userAgent 正则去匹配 常见移动端适配方案？ 媒体查询@media 分别为不同屏幕尺寸的移动设备编写不同尺寸的 css 属性 rem 适配方案 使用 flexible 阿里早期开源的移动端适配解决方案 postcss-pxtorem 插件实现 px 到 rem 的转换 viewport 适配方案 设置 meta 标签 使用 postcss-px-to-viewport 插件将 px 自动转换为 vw 可以通过插件的 ignoring 特性标注不需要转换的属性 缺点：就是转换的时候如不能完全整除就会产生像素差 如何判断JS对象是否为空？ 结合getOwnPropertySymbols 和 getOwnPropertyNames 123456const a = {[Symbol()]: 'a'}const b = {a: 'a'}const c = {}console.log(Object.getOwnPropertyNames(a).length === 0 &amp;&amp; Object.getOwnPropertySymbols(a).length === 0 ); // falseconsole.log(Object.getOwnPropertyNames(b).length === 0 &amp;&amp; Object.getOwnPropertySymbols(b).length === 0 ); // falseconsole.log(Object.getOwnPropertyNames(c).length === 0 &amp;&amp; Object.getOwnPropertySymbols(c).length === 0 ); // true Reflect.ownKeys() 123456const a = {[Symbol()]: 'a'}const b = {a: 'a'}const c = {}console.log(Reflect.ownKeys(a).length === 0) // falseconsole.log(Reflect.ownKeys(b).length === 0) // falseconsole.log(Reflect.ownKeys(c).length === 0) // true","link":"/2021/10/04/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86javascript%E7%AF%87/"},{"title":"代码的艺术","text":"一流代码的特性 正确和性能 鲁棒性 高效 可读性和可维护 简洁 简短 可测试 共享和重用 共享 可移植 运维和运营 可监控/可观测 可运维 可扩展 好的代码从哪里来？编码前：需求分析，系统设计编码中：编写代码，单元测试编码后：集成测试、上线、持续运营/迭代改进 一个好的系统/产品是以上过程持续迭代的结果","link":"/2023/06/16/%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"title":"如何优化网站以符合谷歌的Core Web Vitals标准","text":"为什么要做Core Web Vitals?网站响应速度越快，在谷歌中的排名越高的机会就越大 谷歌排名的主要因素（优先级从高到低） 高质量的内容 在Google排名因素里绝对以‘内容为王，外链为皇’，如果能创造对用户来说独特、新颖、且有帮助的内容，那么Google搜索引擎会将结果页面排到更高位置。 Google特别关注内容质量，无论如何优化网站，如果内容没有价值，就不要期望能获得更高的排名。 那么，什么才算是高质量的内容呢？ 原创、独特、有价值的内容 如果内容重复或者跟其他网站类似，那么就会对SEO产生负面影响，对于新网站来说Google可能就不会去索引你的页面，网站就不会获得排名。如果经常发布重复内容，Google会减少抓去你的网站内容的频率。 经常更新内容 通过定期更新网站，为其添加新东西，通过增加内容新鲜度给搜索引擎发出一个积极的信号。如果内容主题涉及到新闻或者某件事的发展趋势，可以通过Google Trends工具找到最新的信息来保持内容的新鲜度。 内容长度 平均长度1890个词的文章会排在第一页，但对字数的限制没有一个硬性规定。更好的解决办法是撰写具有深度的内容，能够完全回答用户的问题并提供详细的解决方案。 内容结构和组织方式 组织合理、结构清晰的网页，可以让访客更轻松的、更方便的阅读并找到问题的解决方案。 优化文章的结构和组织可以使用多个标题和副标题（H2、H3、H4等），还可以使用列表的形式组织内容，好处就是Google会为不同的关键词筛选带列表形式的高质量内容，将其展示为答案盒子。 通过整理内容的结构和组织方式，内容的可读性将大大提高，正反馈就是提高了用户体验，增加了停留时间（Dwell Time）间接的增加了提高排名的机会。 反向链接 Google排名算法中第二优先级排名因素就是反向链接。 如果你的网站能从权重高的网站获得反向链接，通过这些链接相当于给Google传递了一个信号，即你的内容是值得信赖的，因为有这么多不同的网站都可以为你做担保。 通过这些反向链接（入站链接）可以为你的网站带来更多流量，就有极大的可能获取更高的排名。 搜索意图 你的网站内容是否匹配用户的搜索意图对Google排名的影响非常重要。 这就意味着如果你想写关于某个主题的内容，一定要匹配搜索意图，如果想为某个搜索关键字排名，则应该制作视频或者信息图表等。 通过匹配搜索意图，可以回答这些问题并创建人们正在寻找的内容。 网站加载速度 提高网站加载速度不仅可以提高Google搜索引擎的排名，还可以降低网站的跳出率，提高其转换率，提供更高的用户体验。 可以使用Google免费的工具PageSpeed Insights来检查你的网站加载速度，PageSpeed Insights会生成网页的实际性能报告，并能提供如何改进响应网页的建议。 如何提高网站的加载速度？ 移动友好 在GSMA智库近日发布了《2023年全球移动经济报告发展》报告，报告显示截至2022年底，全球独立移动用户数为54亿，其中移动互联网用户数为44亿，且自从Google在2019年提出移动优先的口号，所以网站自适应移动端就称为了关键。 这就意味着Google会优先使用你的网站移动版去索引和排名，如果想快速提升你的网站排名，那么就需要让你的网站变成移动端友好型网站。 域名权威 “域名权威”是 SEO 相关的术语，指网站的域名在某领域相关内容具有权威性，一般域名建站时间越久、反链越多、流量越大、搜索引擎点击数越高、跳出率越低，域名就越权威。 通过专注在自己的领域，创造出更优秀的内容，可以通过关键词分析工具，找到访客感兴趣的主题，围绕这些主题打造高质量内容增加话题的权威性。 如此，Google变为逐渐把你的网站当作该主题领域的权威专家，提高你的网站的域名权威，从而提高网站在搜索引擎的排名 关键词优化 关键词即用户搜索框输入的内容，它如实的反馈了用户的需求，所以找准关键词，也就意味着锁定了目标用户。 所以你的网站中包含了你的受众群体正在搜索的关键词是非常关键的。 如何做网站关键词优化？ ·标题：在SEO标题的开始就包含目标关键词 ·元描述：写吸引人的描述，然后添加关键词，告诉用户这个页面是做什么的，提高用户的自然搜索点击率 ·图片alt文字：可以将关键词添加到alt文本中告诉Google这是什么 ·锚文本：Google使用锚文本来查找页面内容，给关键词加上锚文本链接帮助Google识别页面内容 ·使用LSI关键词：用户会搜索除主要关键词之外的其他相关词条，这些词条被称LSI（潜在语义索引）关键词，通过在页面上包含这些内容，可以帮助Google找出有关内容。 ·避免关键词堆砌：不可不断重复主要关键词，这是一种不好的SEO做法。 ·在H2和H3中添加关键词：通过关键词变体来进一步优化内容组织结构 ·URL中添加关键词 网站结构 站内结构决定了网站是否容易被收录，是否方便用户浏览，是否符合蜘蛛的爬取等等。 网站结构是指网站中页面之间的层次关系。从用户角度来讲，能够使用户方便快捷的在网站中浏览内容，不至于迷失。对搜索引擎来说，优化网站结构，可以帮助蜘蛛快速抓取网站内容 网站安全 HTTPS会影响网站的排名，HTTPS保证了您的站点是否在用户的浏览器和Web服务器之间建立了安全连接，它可以加密网站和用户浏览器之间的数据 用户体验 网站的整体的用户体验也是影响Google排名的一个重要因素，但是Google是如何衡量的呢？Google使用了一个名为RankBrain的人工智能程序，该程序结合了其他的排名要素，例如：·自然搜索点击率（CTR）：通过提高网站链接的点击率，可以提高排名·停留时间（Dwell Time）：从搜索结果到你的网站后的停留时间·跳出率：进入网站到离开网站没有任何交互，Google会任务该页面不相关，不会对其进行排名 总结： 以上就是本文的所有内容，希望你能够习惯这篇关于影响Google排名10大因素的文章。 参考： SEO站内优化：网站结构优化怎么做网站关键词优化？PageSpeed Insights优化网站加载速度的14个技巧什么是自然搜索点击率（Organic CTR）？什么是跳出率及如何保持网站较低跳出率 谷歌如何评估网站性能？性能度量应用程序（如浏览器开发工具）报告技术度量，例如 阻塞时间：等待下载开始所花费的时间。 DNS解析：将主机名解析为IP地址以索引资产的时间。 连接时间：初始化TCP连接的时间。 首字节时间（TTFB）：请求和响应第一个字节之间的总时间。 接受时间：检索整个资产的时间 DOM加载时间：下载和呈现HTML文档对象模型的时间，分析和修改DOM的脚本可以可靠运行的第一个点。 页面加载时间：下载页面和所有资产（图像、样式表、脚本等）的时间 总页面重量：所有资产总大小，通常报告为压缩（下载）和未压缩大小 DOM元素数：页面上HTML元素的总数，元素越多，页面处理时间越长 首次内容绘制（FCP）：浏览器第一个元素像素之前所有的时间 首个有意义慧智（FMP）：主页内容对用户可见之间所花费的时间。 交互时间（TTI）：页面完全交互并能够可靠响应用户输入所花费的时间。 首次CPU空间（FCI）：CPU呈现页面并运行所有初始化脚本，等待进一步输入的时间 CPU使用率：呈现页面和响应用户输入时所需的处理活动 每秒布局数：浏览器必须重新计算样式和页面布局的速率 以上这些可以用于确定特定的瓶颈，如服务器负载、CMS缓存、浏览器缓存、下载速度和javascript效率。但无法确定页面提供的用户体验是否良好。如：应用程序可以快速下载并显示，但第一次交互后会变得无响应，因为它正在执行大量未优化javascript代码。 什么是Core Web Vitals? 最大内容绘制（LCP）：加载性能 首次输入延迟（FID）：交互性能 累计布局偏移（CLS）：视觉稳定性 最大内容绘制 LCP本质上代表的是可用内容在页面上呈现的速度有多快？ LCP分数低的常见原因： 在客户端上生成的页面内容，而不是在服务器上生成的内容需要更长的时间，LCP客户端渲染（CSR） &gt; 服务端渲染（SSR），顺便提一下SSR更有利于首屏渲染，CSR更利于页面交互 服务端限制，服务端响应慢 HTML中国呢引用了阻塞CSS和javascript，导致延迟页面加载 大型图像或视频占用网络带宽，导致需要更长的渲染时间 如何提高LCP分数： 升级服务器和/或主机服务。确保下载速度即使在高使用率时也保持快速。 激活服务器压缩和HTTP/2+。没有理由不这样做！ 减少服务器工作。删除未使用的代码和CMS插件，然后启用有效缓存。 确保浏览器可以有效缓存文件。在HTTP头中设置适当的Expires、Last Modified和/或ETag哈希，以便不再请求文件。 使用内容交付网络（CDN）在地理位置更靠近用户的服务器上拆分负载和托管资源。 优化你的图像。将它们减少到最小尺寸，并使用适当的格式来最小化文件大小。确保尽早请求最大内容块中的任何图像；预加载可能会有所帮助。 通过添加loading=”lazy”属性延迟加载图像。添加宽度和高度属性，以确保在图像完成加载之前在页面上保留适当的空间。 最小化第三方请求，并将移动资产考虑到主域以避免无关DNS查找。 最小化请求文件的数量和大小，尤其是在HTML的顶部。 确保仅加载所需的web字体。切换到web安全字体以获得最佳性能。 删除未使用的JavaScript和CSS文件。 连接并缩小JavaScript和CSS文件。 避免CSS@import语句-它们是串联的渲染块和加载样式。 避免Base64编码-它会增加文件大小并需要额外的处理。 考虑关键的联机CSS。在页面顶部的&lt;link&gt;块中嵌入基本的“折叠上方”CSS，然后异步加载更多样式表。 稍后使用异步、延迟或ES模块JavaScript运行脚本。在服务工作者中执行长时间运行的JavaScript进程。 首次输入延迟 FID本质上代表网页对用户的输入、点击和滚动等操作的响应速度有多快？ FID分数低的常见原因： FID和TBT分数低通常是由占用处理器的客户端代码引起的，例如： 大量的呈现阻塞CSS和JavaScript，这会在下载和解析代码时停止页面加载 加载页面时立即运行的大型流程密集型脚本 长时间运行或优化较差的JavaScript任务 默认情况下，浏览器运行在单个线程上，一次只能处理一个任务。如果一个JavaScript函数需要一秒钟的时间来执行，那么所有其他渲染过程都会在这一秒钟内被阻塞。页面无法响应用户输入、更新DOM、显示动画等。甚至GIF动画也可以在旧浏览器中被阻塞。 如何提高FID分数： 在服务器上生成并缓存尽可能多的静态HTML内容。尽量不要依赖客户端JavaScript框架为每个人呈现相同的HTML。 确保浏览器可以有效缓存文件。在HTTP头中设置适当的Expires、Last Modified和/或ETag哈希，以便不再请求文件。 采用渐进式增强技术，因此在JavaScript运行之前，该界面可以在HTML和CSS中使用。 删除未使用的JavaScript和CSS文件。 连接并缩小JavaScript和CSS文件。 避免过度使用昂贵的CSS属性，如框阴影和过滤器。 稍后使用异步、延迟或ES模块JavaScript运行脚本。 最小化对分析、社交媒体小部件、论坛等的第三方JavaScript请求。这些请求可以快速加载到数兆字节的JavaScript。 根据需要延迟加载JavaScript组件，例如聊天窗口小部件、视频播放器等。 延迟加载不太重要的脚本，如分析、广告和社交媒体工具。 将长时间运行的JavaScript任务分解为一系列较小的作业，这些作业在短时间的requestIdleCallback、setTimeout或requestAnimationFrame延迟后执行。 考虑在Web工作者中使用一个后台线程来执行长时间运行的JavaScript进程。 累计布局偏移 CLS本质上代表页面内容是否会意外移动或者跳转尤其是在初始加载期间 通过以下指标相乘计算累计布局偏移CLS： 影响分数：视口中国呢所有不稳定元素的总面积（%） 距离分数：不稳定元素移动的最大距离（px），移动像素/视口大小 手动测测CLS： 12345678910111213141516171819let cls = 0;function onLayoutShiftEntry(entry: any) { if (entry.hadRecentInput) { cls += entry.value; } console.log(cls);}const observer = new PerformanceObserver((entries) =&gt; { for (const entry of entries.getEntries()) { onLayoutShiftEntry(entry); }});observer.observe({ type: &quot;layout-shift&quot;, buffered: true });// 主动触发observer.takeRecords().forEach((entry) =&gt; onLayoutShiftEntry(entry)); 累积布局偏移分数低的常见原因： CLS分数低通常是由于加载页面资产和动态或未调整大小的DOM元素速度慢造成的： 页面上的空间不用于图像、iFrame、广告等。 内容被动态地注入DOM，通常是在网络请求广告、社交媒体小部件等之后。 Web字体加载会导致不可见文本（FOIT）或未设置样式文本（FOUT）的明显闪烁。 如何提高累积布局偏移分数：客户端审计可以发现问题，但通常是确保在内容下载之前为内容预留空间。为最大内容绘制建议的服务器优化提示将有一些好处，但可能会有进一步的改进： 在HTML的&lt;img&gt;和&lt;iframe&gt;标记中添加宽度和高度属性，或者使用新的CSS纵横比属性确保在下载资产之前在页面上保留适当的空间。 为封装第三方内容（如广告和小部件）的容器元素设置适当的尺寸。 确保尽早请求显示在页面顶部的图像和其他资产-预加载可能会有所帮助。 尽量减少Web字体的使用，并考虑在可能的时候使用常用的OS字体。 加载web字体并将CSS字体显示设置为可选或交换。确保使用大小相似的回退字体，以最小化布局偏移。 避免向页面顶部插入元素，除非页面响应用户操作（如单击）。 确保在输入触发器的500毫秒内完成用户交互。 使用CSS变换和不透明度可以获得更高效的动画，而不会导致重新布局。 考虑关键的联机CSS。在页面顶部的&lt;link&gt;块中嵌入基本的“折叠上方”CSS，然后异步加载其他样式表。 必要时，考虑包容，一种新的CSS特性，允许您识别页面的孤立子树。浏览器可以通过渲染或不渲染特定的DOM内容块来优化处理。","link":"/2023/06/25/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%BD%91%E7%AB%99%E4%BB%A5%E7%AC%A6%E5%90%88%E8%B0%B7%E6%AD%8C%E7%9A%84Core-Web-Vitals%E6%A0%87%E5%87%86/"},{"title":"实现一个多人协作在线文档有哪些技术难点？","text":"多人协作提供了稳定、高效、安全的协作环境，这种类似的产品需要克服的技术难点还是很多的，如： 实时同步 实现实时同步的难点在于如何快速传输用户的操作。 常见的做法是websocket等技术，建立持久化连接，实时推送数据。 同时为了减少网络传输量，可以采用差量同步的方式，只传输变化的部分数据。 冲突解决 多个用户同时编辑同一个文档时，可能会冲突。 常见解决方案是采用OT（Operational Transformation）技术，将用户的操作换成操作序列，并在服务器上合并，最后同步给用户，还需要采用锁机制，保证同一时间只有一个用户能够编辑文档。 高并发 在线文档需要支持多人同时访问和编辑，就需要处理高并发的情况。 提高并发性能，可以采用分布式架构、负载均衡等技术 安全性 在线文档需要保证用户数据安全，包括用户身份验证、数据传输加密等。 解决：采用HTTPS协议、SSL证书等技术实现数据传输加密，密码、验证码进行用户身份验证等 数据存储 可以采用分布式数据库、缓存等技术提高数据存储和管理的效率和性能 实时性能 在线文档需要保证实时性能，即用户的操作能够实时生效，不能出现延迟等问题。 解决：采用异步IO、事件驱动等技术，同时对系统进行优化和调整，提高系统性能和响应速度。 两个主要的技术难点就是：实时通信、编辑冲突 实时通信：long pull 或者 websocket 编辑冲突：编辑锁、GUN diff-patch（类似git版本控制diff）、OT（Operational Transformation）、Myer’s diff-patch","link":"/2023/06/29/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%EF%BC%9F/"},{"title":"nginx指南","text":"负载均衡4种策略 轮询：默认方式 weight：在轮询基础上增加权重，也就是轮询到的几率不同 ip_hash：按照ip的hash分配，保证每个访客的请求固定访问一个服务器，解决session问题 fair：按照相应时间来分配，需要安装nginx-upstream-fair插件 123456789101112131415161718// 默认轮询upstream nest-server { server 192.xxx.x.x:3001; server 192.xxx.x.x:3002;}// weightupstream nest-server { server 192.xxx.x.x:3001; server 192.xxx.x.x:3002 weight=2;}// ip_hashupstream nest-server { ip_hash; server 192.xxx.x.x:3001; server 192.xxx.x.x:3002;}","link":"/2023/07/20/nginx%E6%8C%87%E5%8D%97/"},{"title":"如何管理前端团队","text":"个人角度开发人员：业务需求 -&gt; 自己动手 -&gt; 解决问题 管理者：业务需求 -&gt; 分析需求、分解需求 -&gt; 分配任务 -&gt; 跟踪进度 -&gt; 解决问题 如何胜任技术管理者需要提高自己各个方面的能力，主要有以下方面： 技术能力：这是技术管理者的立身之本，肯定需要不断学习、不断精进，如果技不如人肯定无法服众。 业务能力：需要对业务有正确的理解，能理解业务的本质需求，才能让技术实现业务价值。 规划能力： 技术管理者需要明确团队目标、并以结果为导向，做出合理的规划： 1 技术体系规划：项目技术选型（可控性、稳定性、适用性、易用性）、技术文档沉淀等 2 任务规划：根据任务难易程度分配不同开发人员、任务时间安排等 3 人员安排规划：根据组员的实际情况和特点，安排合适的事情给合适的人，使团队利益最大化 沟通协作能力：技术管理者不仅在项目团队内，可能需要跨组或者跨部门进行沟通协作，需要向上级转达战略、任务，和团队内成员沟通清楚需要做什么，为什么这么做 判断能力： 需要全局把控项目，有底气在项目中对事项进行判断和决策： 1 风险判断：业务实现方向有没有问题、任务排期超时等 2 决策判断：某个时间段，应该做哪些内容，哪些做不了 3 诗句判断：针对业务评审的具体实现成本、实现方向等 领导力：技术管理者需要有责任，有担当，团队有问题必然反映到团队负责人身上有问题 架构能力：治理好系统复杂度才是最务实的","link":"/2023/11/09/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F/"}],"tags":[{"name":"aliyun","slug":"aliyun","link":"/tags/aliyun/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"dom","slug":"dom","link":"/tags/dom/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"lerna","slug":"lerna","link":"/tags/lerna/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"前端安全","slug":"前端安全","link":"/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"react-hooks","slug":"react-hooks","link":"/tags/react-hooks/"},{"name":"微前端","slug":"微前端","link":"/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"脚手架","slug":"脚手架","link":"/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"代码","slug":"代码","link":"/tags/%E4%BB%A3%E7%A0%81/"},{"name":"网站","slug":"网站","link":"/tags/%E7%BD%91%E7%AB%99/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"}],"categories":[{"name":"node","slug":"node","link":"/categories/node/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"dom","slug":"dom","link":"/categories/dom/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"vue3","slug":"vue3","link":"/categories/vue3/"},{"name":"lerna","slug":"lerna","link":"/categories/lerna/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"前端安全","slug":"前端安全","link":"/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"浏览器","slug":"浏览器","link":"/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"微前端","slug":"微前端","link":"/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"脚手架","slug":"脚手架","link":"/categories/%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面经","slug":"面经","link":"/categories/%E9%9D%A2%E7%BB%8F/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"关于","text":"我本将心向明月，奈何明月照沟渠","link":"/about/index.html"}]}