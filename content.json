{"posts":[{"title":"13个超实用的JavaScript数组操作技巧","text":"13 个超实用的 JavaScript 数组操作技巧 1.数组去重12345let fruits = [&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;&quot;watermelon&quot;,&quot;apple&quot;,&quot;orrage&quot;]//第一种方法let uniqueFruits = Array.from(new Set(fruits))//第二种方法let uniqueFruits2 = [...new Set(fruits)] 2.替换数组中的特定值1234// 使用.splice(start,value to remove,valueToAdd),返回删除对象，并修改原数组let fruits = [&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;,&quot;watermelon&quot;,&quot;apple&quot;,&quot;orrage&quot;]fruits.splice(0,2,&quot;potato&quot;,&quot;tomato&quot;)console.log(fruits) 3.不使用.map()映射数组123456789101112let friends = [ { name: 'John', age: 22 }, { name: 'Peter', age: 23 }, { name: 'Mark', age: 24 }, { name: 'Maria', age: 22 }, { name: 'Monica', age: 21 }, { name: 'Martha', age: 19 },]let friendsNames = Array.from(friends, ({name}) =&gt; name)console.log(friendsNames)//returns [&quot;John&quot;, &quot;Peter&quot;, &quot;Mark&quot;, &quot;Maria&quot;, &quot;Monica&quot;, &quot;Martha&quot;] 4.清空数组1234let fruits = [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;grape&quot;, &quot;apple&quot;];//要清空数组，仅需要将数组的长度设置为0fruits.length = 0;console.log(fruits); // returns [] 5.数组转对象12345let fruits = [&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;watermelon&quot;];let fruitsObj = {...fruits};console.log(fruitsObj) // returns {0: &quot;banana&quot;, 1: &quot;apple&quot;, 2: &quot;orange&quot;, 3: &quot;watermelon&quot;} 6.用数据填充数组123let newArray = new Array(10).fill(&quot;1&quot;)console.log(newArray) 7.合并数组123456var fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];var meat = [&quot;poultry&quot;, &quot;beef&quot;, &quot;fish&quot;];var vegetables = [&quot;potato&quot;, &quot;tomato&quot;, &quot;cucumber&quot;];//使用扩展运算符...var food = […fruits, …meat, …vegetables];console.log(food); 8.求数组的交集1234var arr1 = [0,2,3,5,6,8,6]var arr2 = [1,2,3,4,5,6,4]var duplicatedValues = [...new Set(arr1)].filter(item=&gt;arr2.includes(item))console.log(duplicatedValues) 9.从数组中删除虚值1234//虚值有：false、0、null、NaN、undefined、&quot;&quot;.var mixedArr = [0,&quot;blue&quot;,&quot;&quot;,NaN,9,true,undefined,&quot;white&quot;,false]var trueArr = mixedArr.filter(Boolean)console.log(trueArr) 10.从数组中获取随机值123var colors = [&quot;blue&quot;, &quot;white&quot;, &quot;green&quot;, &quot;navy&quot;, &quot;pink&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;];var randomColor = colors[(Math.floor(Math.random() * (color.length)))] 11.反转数组123var colors = [“blue”, “white”, “green”, “navy”, “pink”, “purple”, “orange”, “yellow”, “black”, “brown”];var reversedColors = colors.reverse();console.log(reversedColors); 12.lastIndexOf()方法1234// 查找给定元素的最后依次出现的索引var nums = [1, 5, 2, 6, 3, 5, 2, 3, 6, 5, 2, 7];var lastIndex = nums.lastIndexOf(5);console.log(lastIndex); // returns 9 13.对数组中所有值求和123var nums = [1,5,4,3]var sum = nums.reduce((x,y)=&gt;x+y)console.log(sum)","link":"/2020/07/18/13%E4%B8%AA%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84JavaScript%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"},{"title":"30-seconds-of-code-study","text":"已经迁移至mixin","link":"/2022/02/07/30-seconds-of-code-study/"},{"title":"DOM基本操作","text":"DOM 基本操作 获取 Dom 节点 document 代表整个文档 document.getElementById() document.getElementByTagName() document.getElementByName() //只有部分标签 name 可生效，表单之类的 document.getElementByClassName() querySelector() //静态的，不是实时的，保存的是当时的状态，是一个副本 querySelectorAll() //即使以后元素发生了改变，该值也不会改变 遍历节点树 parentNode -&gt; 父节点（最顶端 parentNode 为#document） childNodes -&gt; 子节点们 firstChild -&gt; 第一个子节点 lastChild -&gt; 最后一个子节点 nextSibling -&gt; 后一个兄弟节点 previousSibling -&gt;前一个兄弟节点 遍历元素节点树 parentElement -&gt; 返回当前元素的父元素节点（IE9 以下不兼容） children -&gt; 返回当前元素的元素子节点 node.childElementCount === node.children.length 返回当前元素的子元素节点个数（IE9 以下不兼容） firstElementChild -&gt; 返回第一个元素节点（IE9 以下不兼容） lastElementChild -&gt; 返回最后一个元素节点（IE9 以下不兼容） nextElementSibling -&gt; 返回后一个元素节点（IE9 以下不兼容） previousElementSibling -&gt; 返回前一个元素节点（IE9 以下不兼容） 节点的类型 元素节点 —— 1 属性节点 —— 2 文本节点 —— 3 注释节点（Comment）—— 8 document —— 9 DocumentFragment —— 11 获取节点类型 nodeType 节点的四个属性 nodeName 元素的标签名，以大写形式表示，只读 nodeValue Text 节点或 Comment 节点的文本内容，可读写 nodeType 该节点的类型，只读 attributes Element 节点的属性集合 节点的一个方法 Node.hasChildNodes() 所有节点都有 hasChildNodes()方法，判断有无子节点，有一个或多个返回 true Dom 基本操作——增 document.createElement() document.createTextNode() document.createComment() document.createDocumentFragment() Dom 基本操作——插 parentNode.appendChild() parentNode.insertBefore(a, b) Dom 基本操作——删 parent.removeChild() child.remove() Dom 基本操作-替换 parent.replaceChild(new, origin) Element 节点的一些属性 innerHTML innerText(火狐不兼容)/textContent(老版本 IE 不兼容) Element 节点的一些方法 ele.setAttribute() ele.getAttribute() 查看元素的几何尺寸 domEle.getBoundingClientRect() 兼容性很好 返回一个对象，里面有 left、top、right、bottom、width、height。 left 和 top 代表元素左上角的 X 和 Y 坐标，right 和 bottom 代表元素右下角的 X 和 Y 坐标 height 和 width 属性老版本 IE 未实现 返回的结果不是“实时的” 查看元素的宽高尺寸dom.offsetWidth dom.offsetHeight 查看元素的位置dom.offsetLeft dom.offsetTop 对于无定位父级的元素，返回相对文档的坐标。 对于有定位的父级元素，返回相对最近的有定位的父级的坐标，无论距离是怎么产生的 dom.offsetParent返回最近的有定位的父级，若无，返回 body，body.offsetParent 返回 nul 让滚动条滚动 window 上的三个方法：scroll()==scrollTo()、scrollBy() scroll()和 scrollTo()将 x、y 坐标传入，让滚动条滚动到当前位置 scrollBy() 会在之前的数据基础上累加，可以利用 scrollBy()实现快速阅读的功能 查询计算样式 window.getComputedStyle(ele, null)[style] 第二个参数 null，放的是伪元素，可以获取伪元素的属性 计算样式只读 返回的计算样式都是绝对值，没有相对单位 -IE8 及以下不兼容（ele.currentStyle[style]） 封装函数，返回元素的第 n 层祖先元素节点 12345678function retParent(elem, n) { while(elem &amp;&amp; n) { elem = elem.parentElement n-- } return elem}var i = document.getElementByTagName('i')[0] 原型上封装函数 myChildren 获取子元素，解决一千浏览器的兼容性问题 123456789101112Element.prototype.myChildren = function () { var child = this.childNodes var len = child.length for (var i = 0;i &lt; len; i++) { if(child[i].nodeType == 1) { arr.push(child[i]) } } return arr}var div = document.getElementByTagName('div')[0] 自己封装 hasChildren()方法，不可用 children 属性 123456789101112Element.prototype.hasChildren = function () { var child = this.childNodes var len = child.length for (var i = 0;i &lt; len; i++) { if(child[i].nodeType == 1) { return true } } return false}var div = document.getElementByTagName('div')[0] 封装函数，返回元素 e 的第 n 个兄弟元素节点，n 为正，返回后面的兄弟元素节点，n 为负，返回前面的，n 为 0，返回自己 12345678910111213141516171819function retSibling(e, n) { while(e &amp;&amp; n) { if(n &gt; 0) { if(e.nextElementSibling) { e.nextElementSibling } else { for(e = e.nextSibling; e &amp;&amp; e.nodeType != 1; e = e.nextSibling) } n-- }else { if(e.previousElementSibling) { e = e.previousElementSibling } else { for(e = e.previousSibling; e &amp;&amp; e.nodeType != 1; e = e.previousSibling) } n++ } }} 封装 insertAfter(),功能类似与 insertBefore(new, origin),直接在 Element.prototype 上编程 12345678Element.prototype.insertAfter = function(new, origin) { var beforeNode = origin.nextElementSibling if (beforeNode == null) { this.appendChild(new) } else { this.insertBefore(new, beforeNode) }} 封装滚动条的 x 轴、y 轴的距离函数 12345678910111213function getScrollOffset() { if (window.pageXOffset) { return { x: window.pageXOffset, y: window.pageYOffset } } else { return { x: document.body.scrollLeft + document.documentElement.scrollLeft, y: document.body.scrollTop + document.documentElement.scrollTop } }} 封装可视区窗口大小的函数 1234567891011121314151617181920function getViewportOffset() { if (window.innerWidth) { return { w: window.innerWidth, h: window.innerHeight } } else { if (document.compatMode === 'BackCompat') { return { w: document.body.clientWidth, h: document.body.clientHeight } } else { return { w: document.documentElement.clientWidth, h: document.documentElement.clientHeight } } }} 封装样式获取的方法 1234567function getStyle(elem, prop) { if(window.getComputedStyle) { return window.getComputedStyle(elem, null)[prop] } else { return elem.currentStyle[prop] }}","link":"/2019/08/11/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"CommonJS、AMD、CMD是什么及区别？","text":"CommonJS、AMD、CMD 是什么及区别？ CommonJS 是服务器端 js 模块化的规范，NodeJS 是这种规范的实现，加载模块使用 require 方法， 导出使用 exports AMD 和 CMD 都是为了解决浏览器端模块化问题而产生的，AMD 规范对应的库 Require.js, CMD 规范对应的库 Sea.js AMD 和 CMD 的区别: AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD 推崇就近依赖，只有在用到的某个模块的时候再去 require 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行，但 RequireJS(AMD)从 2.0 开始，也改为延迟执行 AMD 的 API 默认是一个当多个，CMD 的 API 严格区分，推崇职责单一","link":"/2019/08/13/CommonJS%E3%80%81AMD%E3%80%81CMD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8F%8A%E5%8C%BA%E5%88%AB%EF%BC%9F/"},{"title":"ES6之数字操作","text":"ES6 之数字操作 二进制和八进制 1234567// 二进制Binary，以0（零）开头，第二个位置blet binary = 0B010101console.log(binary) //21//八进制Octal，以0（零）开头，第二个位置Olet b = 0o226;console.log(b) //150 数字验证 Number.isFinite(*) 123456// 可以使用Number.isFinite()进行数字验证，只要是数字，无论是浮点型还是整形都会返回true，其他的返回falselet a = 10/3Number.isFinite(a) //trueNumber.isFinite('foolishmax') //falseNumber.isFinite(NaN) //false NaN 验证： Number.isNaN() 判断是否为整数：Number.isInteger() 转换为整数：Number.parseInt() 转换为浮点型：Number.parseFloat() 最大安全整数：Number.MAX_SAFE_INTEGER 最小安全整数：Number.MIN_SAFE_INTEGER 安全整数判断：Number.isSafeInteger()","link":"/2019/08/12/ES6%E4%B9%8B%E6%95%B0%E5%AD%97%E6%93%8D%E4%BD%9C/"},{"title":"Chrome打开一个页面需要启动多少线程？分别有哪些线程？","text":"Chrome 打开一个页面需要启动多少线程？分别有哪些线程？ 最新Chrome浏览器包括：一个浏览器(Browser)主线程、一个GPU进程、一个网络(NetWork) 进程、多个渲染进程和多个插件进程 线程： 浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU 进程：Chrome 刚开始的时候是没有 GPU 进程的，而 GPU 使用的使用初衷是为了实现3D CSS 效果，之后随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 称为浏览器普遍的需求，最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程：主要负责网页的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，最近才独立出来，称为一个单独的进程。 插件进程：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。","link":"/2019/10/14/Chrome%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E9%9C%80%E8%A6%81%E5%90%AF%E5%8A%A8%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%EF%BC%9F/"},{"title":"100道前端优质面试题","text":"复杂度 程序执行时需要的计算量和内存空间 复杂度是数量级，不是具体的数字 一般是针对一个具体的算法，而非一个完整的系统 将一个数组旋转 K 步 输入一个数组[1, 2, 3, 4, 5, 6, 7] k=3,即旋转 3 步 输出[5, 6, 7, 1, 2, 3, 4] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @param arr 原数组 * @param k 步数 * 时间复杂度O(n^2),空间复杂度O(1) */function rotate1(arr: number[], k: number): number[] { const length = arr.length; if (!k || length === 0) return arr; const step = Math.abs(k % length); for (let i = 0; i &lt; step; i++) { const n = arr.pop(); if (n != null) { // unshift内置api时间复杂度位O(n),开销比较大 arr.unshift(n); } } return arr;}/** * @param arr 原数组 * @param k 步数 * 时间复杂度O(1)，空间复杂度O(n) */function rotate2(arr: number[], k: number): number[] { const length = arr.length; if (!k || length === 0) return arr; const step = Math.abs(k % length); const part1 = arr.slice(-step); const part2 = arr.slice(0, length - step); const part3 = part1.concat(part2); return arr;}/** * 性能测试 */const arr = [];for (let i = 0; i &lt; 10 * 10000; i++) { arr.push(i);}console.time(&quot;rotate1&quot;);rotate1(arr, 9 * 10000);console.time(&quot;rotate1&quot;);console.time(&quot;rotate2&quot;);rotate2(arr, 9 * 10000);console.time(&quot;rotate2&quot;); 判断字符串是否括号匹配 一个字符串 s 可能包含{}()[]三种括号 判断 s 是否是括号匹配的 如（a{b}c）匹配，而{a(b 或者{a(b}c)就是不匹配的 栈 vs 数组栈：逻辑结构，理论模型，不管如何实现，不受任何语言的限制。数组：物理结构，真实的功能实现，受限于编程语言。 12345678910111213141516171819202122232425262728293031323334353637function isMatch(left: string, right: string): boolean { if (left === &quot;{&quot; &amp;&amp; right === &quot;}&quot;) return true; if (left === &quot;(&quot; &amp;&amp; right === &quot;)&quot;) return true; if (left === &quot;[&quot; &amp;&amp; right === &quot;]&quot;) return true; return false;}function matchBracket(str: string): boolean { const length = str.length; if (length === 0) return true; const stack = []; const leftSymbols = &quot;{[(&quot;; const rightSymbols = &quot;)]}&quot;; // 时间复杂度O(n),空间复杂度O(n) for (let i = 0; i &lt; length; i++) { const s = str[i]; if (leftSymbols.includes(s)) { // 左括号，压栈 stack.push(s); } else if (rightSymbols.includes(s)) { const top = stack[stack.length - 1]; // 判断右括号是否匹配 if (isMatch(top, s)) { stack.pop(); } else { return false; } } } return stack.length === 0;} 两个栈实现一个队列 请用两个栈实现一个队列 API：add delete length 123456789101112131415161718192021222324252627282930313233343536class Queue { private stack1: number[] = []; private stack2: number[] = []; add(n: number) { this.stack1.push(n); } delete(): number | null { let res; while (stack1.length) { const n = stack1.pop(); if (n != null) { stack2.push(n); } } res = stack2.pop(); while (stack2.length) { const n = stack2.pop(); if (n != null) { stack1.push(n); } } return res || null; } get length(): number { return this.stack1.length; }} 定义一个 js 函数，反转单向链表链表是一种物理结构(非逻辑结构),类似数组数组需要一段连续的内存空间，而链表是零散的链表节点的数据结构{ value, next?, prev? } 链表 vs 数组都是有序结构链表：查询慢 O(n),新增和删除快 O(1)数组：查询快 O(1),新增和删除慢 O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465interface ILinkListNode { value: number; next?: ILinkListNode;}/** * 创建链表 * @param arr 数组 */function createLinkList(arr: number[]): ILinkListNode { const length = arr.length; if (length === 0) throw new Error(&quot;arr is empty&quot;); let curNode: ILinkListNode = { value: arr[length - 1], }; if (length === 1) return curNode; for (let i = length - 2; i &gt;= 0; i--) { curNode = { value: arr[i], next: curNode, }; } return curNode;}const arr = [100, 200, 300];const list = createLinkList(arr);console.info(&quot;list&quot;, list);/** * 反转单向链表，返回反转后的head node * @param listNode 需要操作的链表 */function reverseLinkList(listNode: ILinkListNode): ILinkListNode { let prevNode: ILinkListNode | undefined; let curNode: ILinkListNode | undefined; let nextNode: ILinkListNode | undefined = listNode; while (nextNode) { // 第一个元素，删除next指针，防止循环引用 if (curNode &amp;&amp; !prevNode) { delete curNode.next; } // 反转指针 if (curNode &amp;&amp; prevNode) { curNode.next = prevNode; } prevNode = curNode; curNode = nextNode; nextNode = nextNode?.next; } // 处理链表最后一个元素 curNode!.next = prevNode; return curNode!;}const reverseList = reverseLinkList(list);console.info(&quot;reverseList&quot;, reverseList); 用链表实现队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253interface ILinkListNode { value: number; next: ILinkListNode | null;}class Queue { private head: ILinkListNode | null = null; private tail: ILinkListNode | null = null; private len = 0; // 入队，在tail位置 add(n: number) { const newNode: ILinkListNode = { value: n, next: null, }; if (this.head === null) { this.head = newNode; } if (this.tail) { this.tail.next = newNode; } this.tail = newNode; this.len++; } // 出队，在head位置 delete(): number | null { if (this.head === null || this.len &lt;= 0) return null; const value = this.head.value; this.head = this.head.next; this.len--; return value; } get length(): number { return this.len; }}const queue = new Queue();queue.add(100);queue.add(200);queue.add(300);console.log(&quot;length&quot;, queue.length); //3console.log(queue.delete()); //100console.log(&quot;length2&quot;, queue.length); //2 链表和数组，哪个实现队列更快？ 空间复杂度都是 O(n) add 时间复杂度：链表 O(1)，数组 O(1); delete 时间复杂度：链表 O(1)，数组 O(n); 实现二分查找 凡有序，必二分 凡二分，时间复杂度必包含 O(logn) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 循环的方式 * @param arr 查找的数组 * @param target 目标对象 * 返回目标索引下标 */function binarySearch1(arr: number[], target: number): number { const length = arr.length; if (length === 0) return -1; let startIndex = 0; let endIndex = length - 1; while (startIndex &lt;= endIndex) { const midIndex = Math.floor((startIndex + endIndex) / 2); const midValue = arr[midIndex]; if (target &lt; midValue) { endIndex = midIndex - 1; } else if (target &gt; midValue) { startIndex = midIndex + 1; } else { return midIndex; } } return -1;}/** * 二分查找-递归的方式 *@param arr 查找的数组 *@param target 目标对象 *@param startIndex *@param endIndex */function binarySearch2( arr: number[], target: number, startIndex?: number, endIndex?: number): number { const length = arr.length; if (length === 0) return -1; if (!startIndex) startIndex = 0; if (!endIndex) endIndex = length - 1; if (startIndex &gt; endIndex) return -1; const midIndex = Math.floor((startIndex + endIndex) / 2); const midValue = arr[midIndex]; if (target &lt; midValue) { return binarySearch2(arr, target, startIndex, midIndex - 1); } else if (target &gt; midValue) { return binarySearch2(arr, target, midIndex + 1, endIndex); } else { return midIndex; }}// 功能测试const arr = [10, 20, 30, 40, 50, 60];const target = 20;console.log(binarySearch1(arr, target));console.log(binarySearch2(arr, target)); 给定一个递增的数组，找出其中和为 n 的两个元素 有一个递增的数组[1, 2, 4, 7, 11, 15]和一个 n = 15 数组中有两个数和为 n，即 4+11=15 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 嵌套循环 时间复杂度：O(n^2) * @param arr 操作数组 * @param n 和 */function findTwoNumbers1(arr: number[], n: number): number[] { const res: number[] = []; const length = arr.length; if (length === 0) return res; // 时间复杂度：O(n^2) for (let i = 0; i &lt; length - 1; i++) { const n1 = arr[i]; let flag = false; for (let j = i + 1; j &lt; length; j++) { const n2 = arr[j]; if (n1 + n2 === n) { res.push(n1, n2); flag = true; break; } } if (flag) break; } return res;}/** * 双指针，时间复杂度 O(n) * @param arr 操作数组 * @param n 和 *//* 思路： 定义i指向头，j指向尾，求arr[i] + arr[j] 如果大于n，则j需要向前移动 如果小于n，则j需要向后移动 */function findTwoNumbers2(arr: number[], n: number): number[] { const res: number[] = []; const length = arr.length; if (length === 0) return res; let i = 0; let j = length - 1; while (i &lt; j) { const n1 = arr[i]; const n2 = arr[j]; const sum = n1 + n2; if (sum &gt; n) { j--; } else if (sum &lt; n) { i++; } else { res.push(n1, n2); break; } } return res;} 求一个二叉搜索树（BST）的第 k 小值 前序(根左右)，中序(左根右)，后序(左右根) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394interface ItreeNode { value: number; left: ItreeNode | null; right: ItreeNode | null;}let bstTree: ItreeNode = { value: 5, left: { value: 3, left: { value: 2, left: null, right: null, }, right: { value: 4, left: null, right: null, }, }, right: { value: 7, left: { value: 6, left: null, right: null, }, right: { value: 8, left: null, right: null, }, },};/** * 二叉树前序遍历 * @param node tree node */function preOrderTraverse(node: ItreeNode | null) { if (node === null) return; console.log(node.value); preOrderTraverse(node.left); preOrderTraverse(node.right);}/** * 二叉树中序遍历 * @param node tree node */function inOrderTraverse(node: ItreeNode | null) { if (node === null) return; inOrderTraverse(node.left); console.log(node.value); inOrderTraverse(node.right);}/** * 二叉树后序遍历 * @param node tree node */function postOrderTraverse(node: ItreeNode | null) { if (node === null) return; postOrderTraverse(node.left); postOrderTraverse(node.right); console.log(node.value);}/** * 求二叉搜索树第k值 * @param node bst tree * @param k 第k个值 */function getKthValue(node: ItreeNode | null, k: number) { if (node === null) return; let arr: number[] = []; function inOrderTraverse(node: ItreeNode | null) { if (node === null) return arr; inOrderTraverse(node.left); arr.push(node.value); inOrderTraverse(node.right); } inOrderTraverse(node); return arr[k - 1];} 斐波那契数列123456789101112131415161718192021222324252627282930313233/** * 斐波那契数列（递归） * @param n * 时间复杂度O(2^n) */function fibonacci(n: number): number { if (n &lt;= 0) return 0; if (n === 1) return 1; return fibonacci(n - 1) + fibonacci(n - 2);}/** * 斐波那契数列（循环） * @param n * 时间复杂度O(n) */function fibonacci(n: number): number { if (n &lt;= 0) return 0; if (n === 1) return 1; let n1 = 1; // 记录n-1的结果 let n2 = 0; // 记录n-2的结果 let res = 0; for (let i = 2; i &lt;= n; i++) { res = n1 + n2; n2 = n1; n1 = res; } return res;} 青蛙跳台阶（动态规划思想解决问题） 一只青蛙，一次可以跳 1 级，也可以跳 2 级 问：青蛙跳到 n 级台阶，总共有多少种方式？ 1// 答案同上一题 将数组中的 0 移动到末尾 如输入[1, 0, 3, 0, 11, 0],输出[1, 3, 11, 0, 0, 0] 只移动 0 ，其他顺序不变 必须在原数组进行操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * (嵌套循环) * @param arr number arr * 时间复杂度 O(n^2) */function moveZero1(arr: number[]): void { const length = arr.length; if (length === 0) return; let zeroCount = 0; for (let i = 0; i &lt; length - zeroCount; i++) { if (arr[i] === 0) { arr.push(0); arr.splice(i, 1); // O(n) i--; zeroCount++; } }}/** * (双指针) * @param arr number arr * 时间复杂度 O(n) */function moveZero2(arr: number[]): void { const length = arr.length; if (length === 0) return; let i; let j = -1; // 指向第一个 0 for (i = 0; i &lt; length; i++) { if (arr[i] === 0) { if (j &lt; 0) { j = i; } } if (arr[i] !== 0 &amp;&amp; j &gt;= 0) { const n = arr[i]; arr[i] = arr[j]; arr[j] = n; j++; } }}const arr = [0, 1, 2, 0, 3, 0, 0, 4];// moveZero1(arr);moveZero2(arr);console.log(arr); 计算字符串中连续最多的字符以及次数 输入’abbbcccccccddeee1234412’ 计算得到连续最多的字符是’c’,7 次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @param str * 时间复杂度： O(n) */interface IRes { char: string; length: number;}function findContinuousChar1(str: string): IRes { const res: IRes = { char: &quot;&quot;, length: 0, }; const length = str.length; if (length === 0) return res; let tempLength = 0; // 临时记录当前连续字符的长度 for (let i = 0; i &lt; length; i++) { tempLength = 0; // 重置 for (let j = i; j &lt; length; j++) { if (str[i] === str[j]) { tempLength++; } if (str[i] !== str[j] || j === length - 1) { if (tempLength &gt; res.length) { res.char = str[i]; res.length = tempLength; } if (i &lt; length - 1) { i = j - 1; // 跳步 } break; } } } return res;}/** * 双指针 * @param str * 时间复杂度： O(n) */interface IRes { char: string; length: number;}function findContinuousChar2(str: string): IRes { const res: IRes = { char: &quot;&quot;, length: 0, }; const length = str.length; if (length === 0) return res; let tempLength = 0; // 临时记录当前连续字符的长度 let i = 0; let j = 0; for (; i &lt; length; i++) { if (str[i] === str[j]) { tempLength++; } if (str[i] !== str[j] || i === length - 1) { // 如果不相等或者 i 循环到了末尾 if (tempLength &gt; res.length) { res.char = str[j]; res.length = tempLength; } tempLength = 0; if (i &lt; length - 1) { j = i; // 让 j 追上 i i--; } } } return res;}const str = &quot;abbbcccccccddeee1234412&quot;;console.log(findContinuousChar1(str)); 快速排序12345678910111213141516171819202122232425262728/** * @param arr * 时间复杂度：O(nlogn) */function quickSort1(arr: number[]): number[] { const length = arr.length; if (length === 0) return arr; const midIndex = Math.floor(length / 2); const midValue = arr.splice(midIndex, 1)[0]; const left: number[] = []; const right: number[] = []; // 注意： splice会改变原数组，不能直接使用length for (let i = 0; i &lt; arr.length; i++) { const n = arr[i]; if (n &lt; midValue) { left.push(n); } else { right.push(n); } } return quickSort1(left).concat(midValue, quickSort1(right));}const arr = [2, 7, 5, 2, 3, 1];console.log(quickSort1(arr)); 对称数 求 1 - 10000 之间的所有对称数（回文） 例如：0， 1， 2， 11， 22， 101， 232，1221 12345678910111213141516171819202122232425262728293031323334353637function findPalindromeNumbers1(max: number): number[] { const res: number[] = []; if (max &lt; 0) return res; for (let i = 1; i &lt;= max; i++) { // 转换为字符转 -&gt; 转换为数组 -&gt; 再反转 -&gt; 比较 const s = i.toString(); if (s === s.split(&quot;&quot;).reverse().join(&quot;&quot;)) { res.push(i); } } return res;}console.log(findPalindromeNumbers1(200));function findPalindromeNumbers2(max: number): number[] { const res: number[] = []; if (max &lt;= 0) return res; for (let i = 1; i &lt;= max; i++) { let n = i; let rev = 0; // n: 123 // rev: 321 while (n &gt; 0) { rev = rev * 10 + (n % 10); n = Math.floor(n / 10); } if (i === rev) res.push(i); }}console.log(findPalindromeNumbers2(200)); 高效的字符串前缀匹配 有一个英文单词库（数组），里面有几十万个英文单词 输入一个字符串，快速判断是不是某一个单词的前缀 （说明思路，不用写代码） 思路一： 遍历单词库数组 indexOf 判断前缀 实际时间复杂度超过 O(n),因为 indexOf 的计算量 思路二（对象取 key 时间复杂度为 O(1)）： 英文字母一共就 26 个，可以提前把单词库数组拆分为 26 个 第一层 26 个，第二层、第三层，继续拆分… 最后把单词库拆分为一颗树 1234567891011121314// 树结构const wordsTree = { a: { a: {...} b: {...} }, b: { a: {...} }, c: { a: {...} } ...} 数字千分位格式化 将数字千分位格式化，输出字符串 如输入数字 12050100，输出字符串 12,050,100 (注意：逆序判断) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @param n * 使用数组 */function format1(n: number): string { n = Math.floor(n); // 只考虑整数 const reverseArr = n.toString().split(&quot;&quot;).reverse(); return reverseArr.reduce((prev, curr, index) =&gt; { if (index % 3 === 0) { if (prev) { return curr + &quot;,&quot; + prev; } else { return curr; } } else { return curr + prev; } }, &quot;&quot;);}/** * @param n * 使用字符串 */function format2(n: number): string { n = Math.floor(n); let res = &quot;&quot;; const str = n.toString(); const length = str.length; for (let i = length - 1; i &gt;= 0; i--) { const j = length - i; if (j % 3 === 0) { if (i === 0) { res = str[i] + res; } else { res = &quot;,&quot; + str[i] + res; } } else { res = str[i] + res; } } return res;} 切换字母大小写 输入一个字符串，切换其中字母的大小写 如：输入字符串 12aBc34，输出字符串 12AbC34 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 正则表达式 * @param s */function switchLetterCase1(s: string): string { let res = &quot;&quot;; const length = s.length; if (length === 0) return res; const reg1 = /[a-z]/; const reg2 = /[A-Z]/; for (let i = 0; i &lt; length; i++) { const c = s[i]; if (reg1.test(c)) { res += c.toUpperCase(); } else if (reg2.test(c)) { res += c.toLowerCase(); } else { res += c; } } return res;}/** * ASCII 编码 * @param s */function switchLetterCase2(s: string): string { let res = &quot;&quot;; const length = s.length; if (length === 0) return res; const reg1 = /[a-z]/; const reg2 = /[A-Z]/; for (let i = 0; i &lt; length; i++) { const c = s[i]; const code = c.charCodeAt(0); if (code &gt;= 65 &amp;&amp; code &lt;= 90) { res += c.toLowerCase(); } else if (code &gt;= 97 &amp;&amp; code &lt;= 122) { res += c.toUpperCase(); } else { res += c; } } return res;} 为何 0.1+0.2 !==0.3? 计算机使用二进制存储数据 整数转二进制没有误差 小数可能无法用二进制准确表达 请说明 ajax、fetch、axios 三者的区别？ ajax(asynchronous javascript xml),一种技术统称 fetch，一个具体的 API axios，第三方库 https://axios-http.com/ 节流和防抖：两者有什么区别？分别用于什么场景？ 防抖 例如：一个搜索输入框，等输入停止后，再出发搜索 123456789101112// 防抖function debounce(fn, delay = 200) { let timer = 0; return function () { if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; { fn.apply(this, arguments); }, delay); };} 节流 drag 或 scroll 期间出发某个回调，要设置一个时间间隔 123456789101112function throttle() { let timer = 0; return function () { if (timer) return; timer = setTimeout(() =&gt; { fn.apply(this, arguments); timer = 0; }, delay); };} px % em rem vw/vh有什么区别？ px 基本单位，是绝对单位（其他的都是相对单位） % 是相对于父元素的宽度比例 em 相对于当前元素的 font-size rem 相对于跟元素的 font-size vw 屏幕宽度的 1% vh 屏幕高度的 1% vmin 取 vw、vh 两者中的最小值 vmax 取 vw、vh 两者中的最大值 箭头函数 箭头函数的特点 没有 arguments 无法通过 apply、call、bind 改变 this 某些肩头函数代码难以阅读 for…in 和 for…of 有什么区别 key 和 value for…in 遍历得到 key for…of 遍历得到 value 适用于不同的数据类型 遍历对象： for…in 可以，for…of 不可以 遍历 Map、Set：for…of 可以，for…in 不可以 遍历 generator：for…of 可以，for…in 不可以 可枚举 vs 可迭代 for…in 用于可枚举（Object.getOwnPropertyDescriptors(obj)）数据，如对象、数组、字符串 for…of 用于可迭代(arr[Symbol.iterator])数据，如数组、字符串、Map、Set for await…of 有什么作用？ for await…of 用于遍历多个 Promise 12345678910111213141516171819202122232425262728293031323334353637383940function createPromise(value) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(value); }, 1000); });}(async function () { const p1 = createPromise(100); const p2 = createPromise(200); const p3 = createPromise(300); const list = [p1, p2, p3]; const list2 = [100, 200, 300]; // ---------------同时调用---------------- // 方式一 // const res1 = await p1; // console.log(res1); // const res2 = await p2; // console.log(res2); // const res3 = await p3; // console.log(res3); // 方式二 // Promise.all(list).then((res) =&gt; console.log(res)); // 方式三 // for await (let res of list) { // console.log(res); // } // -----------------逐步调用--------------- for (let value of list2) { const res = await createPromise(value); console.log(res); }})(); offsetHeight、scrollHeight、clientHeight 区别？ offsetHeight、offsetWidth: border + padding + content clientHeight、clientWidth: padding + content scrollHeight、scrollWidth: padding + 实际内容尺寸 HTMLCollection 和 NodeList 区别？ Node 和 Element DOM 是一棵树，所有节点都是 Node Node 是 Element 的基类 Element 是其他 HTML 元素的基类，如 HTMLDivElement HTMLCollection 和 NodeList HTMLCollection 是 Element 的集合（elem.children） NodeList 是 Node 集合（elem.childNodes） HTMLCollection 不会包含 Text 和 Comment 节点，NodeList 则会包含 HTMLCollection 和 NodeList 都不是数组，而是“累数组” 1234// 转换const arr1 = Array.from(list);const arr2 = Array.prototype.slice.call(list);const arr3 = [...list]; Vue 中 computed 和 watch 的区别？ 用途不同 computed 用于计算产生新的数据，有缓存 watch 用于监听现有数据 扩展知识 computed 有缓存 methods 没有缓存 Vue 组件通讯的方式 props 和 $emit 自定义事件 $attrs $parent $refs provide/inject vuex vuex mutation 和 action 的区别？ mutation: 同步代码 action: 可包含异步代码 JS 严格模式有什么特点？12345&quot;use strict&quot;; //全局开启function fn() { &quot;use strict&quot;; // 局部开启} 特点 全局变量必须先声明 禁止使用 with this 指向 undefined 而不是 window 函数参数不能重名 eval 有单独作用域，不推荐使用 HTTP 跨域请求事为什么发送 options 请求？ 跨域请求 浏览器同源策略 同源策略一般限制 ajax 网络请求，不能跨域请求 server 不会限制&lt;link&gt; &lt;img&gt; &lt;script&gt; &lt;iframe&gt; 加载第三方资源 1234567891011// JSONP// client&lt;script&gt; window.onSuccess = function(data) { console.log(data) }&lt;/script&gt;&lt;script src=&quot;https://www.aaa.com/api/getData&quot;&gt;&lt;/script&gt;// server// https://www.aaa.com/api/getData 返回一段字符串，交给前端执行达到传递数据的目的'onSuccess({data: {/* 数据内容 */}})' 12345678// CORS 配置允许跨域（服务端）response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8080&quot;); // 或者 *response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);response.setHeader( &quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); // 允许跨域接受cookie 答案 options 请求，是跨域请求之前的预检查 浏览器自行发起的 不会影响实际的功能 JS 内存泄漏如何检测？场景有哪些？ 垃圾回收 GC 引用计数 标记清除 场景 意外的全局变量 遗忘的定时器 使用不当的闭包 遗漏的 DOM 元素 网络回调 内存泄漏属于非预期的，闭包是主动行为，闭包非内存泄漏 可以使用 chrome devtools 的 performance 和 memory 工具类检测 js 内存 参考 vdom 真的很快吗？ js 直接操作 dom 才是最快的，vdom 并不快 但是 vdom 是最合适“数据驱动视图”的技术方案 遍历数组，for 和 forEach 哪个快？ 时间复杂度都是 O(n) 结论： for 更快 forEach 每次都要创建一个函数来调用，而 for 不会创建函数 函数需要独立的作用域，会有额外的开销 nodejs 如何开启进程，进程如何通讯？ 进程 process VS 线程 thread 进程： 进行资源分配和调度的最小单元，有独立内存空间 线程： 进行运算调度的最小单元，共享进程内存空间 js 是单线程的，但可以多进行执行，如 、WebWorker 为何需要多进程？ 多核 CPU，更适合处理多进程 内存较大，多个进程才能更好的利用（单进程有内存上线） 开启进程两种方法 child_process.fork， cluster.fork 1234567891011121314151617181920212223242526// parent.jsconst http = require(&quot;http&quot;);const fork = require(&quot;child_process&quot;).fork;const server = http.createServer((req, res) =&gt; { if (req.url === &quot;/xxx&quot;) { // 开启子进程 const computeProcess = fork(&quot;./compute.js&quot;); computeProcess.send(&quot;start&quot;); computeProcess.on(&quot;message&quot;, (data) =&gt; { res.end(&quot;sum is&quot; + data); }); computeProcess.on(&quot;close&quot;, () =&gt; { console.log(&quot;子进程因报错而退出&quot;); computeProcess.kill(); res.end(&quot;error&quot;); }); }});server.listen(3000, () =&gt; { console.log(&quot;localhost: 3000 starting...&quot;);}); 12345678910111213141516171819// compute.jsfunction getSum() { let sum = 0; for (let i = 0; i &lt; 10000; i++) { sum += i; } return sum;}process.on(&quot;message&quot;, (data) =&gt; { console.log(&quot;子进程id&quot;, process.pid); console.log(&quot;子进程接收到的数据&quot;, data); const sum = getSum(); process.send(sum);}); 123456789101112131415161718192021const http = require(&quot;http&quot;);const cpuCoreLength = require(&quot;os&quot;).cpus().length;const cluster = require(&quot;cluster&quot;);if (cluster.isMaster) { for (let i = 0; i &lt; cpuCoreLength; i++) { cluster.fork(); // 开启子进程 } cluster.on(&quot;exit&quot;, (worker) =&gt; { console.log(&quot;子进程退出&quot;); cluster.fork(); // 进程守护 });} else { const server = http.createServer((req, res) =&gt; { res.writeHead(200); res.end(&quot;done&quot;); }); server.listen(3000);} 请描述 JS Bridge 的原理 什么是 JS Bridge？ js 无法直接调用 native API 需要通过一些特定的“格式”来调用 这些“格式”就统称 JS-Bridge，例如微信 JSSDK JS Bridge 的常见实现方式 注册全局 API URL Scheme requestIdleCallback 和 requestAnimationFrame 有什么区别？ 区别 requestAnimationFrame 每次渲染完都会执行，高优先级 requestIdleCallback 空闲时候才执行，低优先级 requestAnimationFrame 比 requestIdleCallback 先执行，因为优先级高 补充 两者都是宏任务 vue 生命周期？ befroeCreate 创建一个空白的 Vue 实例 data、method 尚未被初始化，不可使用 created vue 实例初始化完成，完成相应式绑定 data、method 都已经初始化完成，可以调用 尚未开始渲染模板 beforeMount 编译模板，调用 render 生成 vdom 还没有开始渲染 DOM mounted 完成 DOM 渲染 组件创建完成 开始由“创建阶段”进入“运行阶段” beforeUpdate data 发生变化之后 准备更新 DOM （尚未更新 DOM） updated data 发生变化，且 DOM 更新完成 不要在 updated 中修改 data，可能会导致死循环 beforeUnmount 组件进入销毁阶段（尚未销毁，可以正常使用） 可移除、解绑一些全局事件、自定义事件 unmounted 组件被销毁了 所有子组件也被销毁了 连环问：vue 什么时候操作 dom 比较合适？ mounted 和 updated 都不能保证子组件全部挂载完成 使用 $nextTick 操作 dom 12345mounted() { this.$nextTick(function() { // 仅在整个视图都被渲染之后才会运行的代码 })} 连环问：Ajax 应该放在那个生命周期？ 两个选择：created 和 mounted 推荐：mounted vue3 composition API 生命周期有什么区别？ setup 代替了 beforeCreate 和 created 使用 hooks 函数的形式，如 mounted 改为 onMounted() Vue2、Vue3、React 三者 diff 算法有什么区别？ 严格的 Tree diff 算法的时间复杂度是 O(n*3) vue、react 框架对 tree diff 进行了优化 O(n) 只比较同一层级，不跨级比较 tag 不同则删除重建 子节点通过 key 区分 vdom diff 算法会根据 key 判断元素是否需要删除 匹配了 key，则只移动元素 - 性能较好 未匹配 key，则删除重建 - 性能较差 区别 react 仅右移 vue2 双端比较 vue3 最长递增子序列 Vue-router 三种模式（React-router 也一样） Hash WebHistory MemoryHistory（v4 之前叫做 abstract history） 移动端 H5 click 有 300ms 延迟，如何解决？ 背景：double tap to zoom 初期解决方案 FastClick 监听 touchend 事件(touchstart touchend 会先于 click 触发) 使用自定义 DOM 事件模拟一个 click 事件 把默认的 click 事件(300ms 之后触发)禁止掉 1234567window.addEventListener( &quot;load&quot;, function () { FastClick.attach(document.body); }, false); 现代浏览器的改进（width=device-width） 123456&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;id=edge&quot;&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt; 网络请求中，token 和 cookie 有什么区别？ cookie http 无状态，每次请求都要带 cookie，以帮助识别身份 服务端也可以向客户端 set-cookie，cookie 大小限制 4kb 默认有跨域限制：不可跨域共享、传递 cookie token vs cookie cookie 是 http 规范，而 token 是自定义传递 cookie 会默认被浏览器存储，而 token 需自己存储 token 默认没有跨域限制 JWT(JSON Web Token) 前端发起登录，后端验证成功之后，返回一个加密的 token 前端自行存储这个 token（其中包含了用户信息，加密了） 以后访问服务端的接口，都带着这个 token，作为用户信息 Session 和 JWT 哪个更好？ session 优点 原理简单，易于学习 用户信息存储在服务端，可以快速封禁某个用户 缺点 占用服务端内存，硬件成本高 多进程，多服务器时，不好同步-需要使用第三方缓存，如 redis 默认有跨域限制 JWT 优点 不占用服务器内存 多进程、多服务器不受影响 没有跨域限制 缺点 用户信息存储在客户端，无法快速封禁某用户 万一服务器密钥被泄漏，则用户信息全部丢失 token 体积一般大于 cookie，会增加请求的数据量 答案 如有严格管理用户信息的需求（保密、快速封禁），推荐 session 如没有特殊要求，则使用 JWT 如何实现 SSO 单点登录？ 基于 cookie（主域名相同） cookie 默认不可跨域共享，但有些情况下可设置共享 主域名相同，如www.baidu.com,image.baidu.com 设置 cookie domain 为主域名，即可共享 cookie SSO（主域名不相同，cookie 无法共享） HTTP 协议和 UDP 协议有什么区别？ 网络协议 HTTP 协议在应用层 TCP、UDP 协议在传输层 TCP 协议 有连接，有断开 稳定传输 UDP 协议 无连接，无断开 不稳定传输，但效率高 如视频会议、语音通话 HTTP 协议 1.0、1.1、2.0 有什么区别？ HTTP 1.0 最基础的 HTTP 协议 支持基本的 GET、POST 方法 HTTP 1.1 缓存策略 cache-control、E-tag 等 支持长连接 Connection: keep-alive,一次 TCP 连接多次请求 支持断点续传，状态码 206 支持新的方法 PUT、DELETE 等，可用于 Restful API HTTP 2.0 可压缩 header，减少体积 多路复用，一次 TCP 连接中可以多个 HTTP 并行请求 服务端推送 什么是 HTTPS 中间人攻击？如何预防？ HTTPS 加密传输 HTTP 明文传输 HTTPS 加密传输 HTTP + TLS/SSL 答案 使用正规厂商的加密证书可以防止中间人攻击 defer 和 async 有什么区别？ 区别 prefetch 和 dns-prefetch 有什么区别？ preload 资源在当前页面使用，会优先加载 prefetch 资源在未来页面使用，空闲时加载 1234&lt;head&gt; &lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt; &lt;link rel=&quot;prefetch&quot; href=&quot;other.js&quot; as=&quot;script&quot;&gt;&lt;/head&gt; dns-prefetch 即 DNS 预查询 preconnect 即 DNS 预连接 1234&lt;head&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://www.xxx.com/&quot;&gt; &lt;link rel=&quot;preconnect&quot; href=&quot;https://www.xxx.com&quot;&gt;&lt;/head&gt; 你知道哪些前端攻击？该如何预防？ xss Cross Site Script 跨站脚本攻击 手段：将 js 代码插入到网页内容中，渲染时执行 js 代码 预防：特殊字符替换（前端或后端） csrf Cross Site Request Forgery 跨站请求伪造 手段：诱导用户去访问另一个网站的接口，伪造请求 预防：严格的跨域限制 + 验证码机制 csrf 详细过程 用户登录 A 网站，有了 A 网站的 cookie 诱导用户到 B 网站，并发起 A 网站的请求 A 网站的 API 发现有 cookie，认为是用户自己操作的 csrf 预防手段 严格的跨域请求限制，如判断 referer（请求来源） 为 cookie 设置 SameSite，禁止跨域传递 cookie 关键接口使用短信验证码 点击劫持 click jacing 手段：诱导界面上蒙一个透明 iframe，诱导用户点击 预防：让 iframe 不能跨域加载 DDos Distribute denial-of-service 分布式拒绝服务 手段：分布式的、大规模的流量访问，使服务器瘫痪 预防：软件层不好做，需硬件预防（如阿里云 WAF） SQL 注入 手段：提交内容时写入 SQL 语句，破环数据库 预防：处理输入的内容，替换特殊字符 WebSocket 和 HTTP 有什么区别？ WebSocket 支持端对端通讯 可以由 client 发起，也可以由 server 发起 用于：消息通知，直播间讨论区，聊天室，协同编辑 client 1234567891011121314const { WebSocketServer } = require(&quot;ws&quot;);const wsServer = new WebSocketServer({ port: 3000 });wsServer.on(&quot;connection&quot;, (ws) =&gt; { console.log(&quot;connection&quot;); ws.on(&quot;message&quot;, (msg) =&gt; { console.log(&quot;收到了信息&quot;, msg.toString()); setTimeout(() =&gt; { ws.send(&quot;服务端已经收到了信息&quot; + msg.toString()); }, 2000); });}); server 1234567891011121314const ws = new WebSocket(&quot;ws://127.0.0.1:3000&quot;);ws.onopen = () =&gt; { console.log(&quot;opened&quot;); ws.send(&quot;client opened&quot;);};ws.onmessage = (event) =&gt; { console.log(&quot;收到了信息&quot;, event.data);};const btn = document.getElementById(&quot;btn&quot;);btn.addEventListener(&quot;click&quot;, () =&gt; { console.log(&quot;clicked&quot;); ws.send(&quot;当前时间&quot; + Date.now());}); WebSocket 连接过程 先发起一个 http 请求 成功之后再升级到 WebSocket 协议，再通讯 WebSocket 和 HTTP 区别？ WebSocket 协议名是 ws://,可双端发起请求 WebSocket 没有跨域限制 通过 send 和 onmessage 通讯（HTTP 通过 req 和 res） ws 可升级为 wss（like https） 12345678910import { createServer } from &quot;https&quot;;import { readFileSync } from &quot;fs&quot;;import { WebSocketServer } from &quot;ws&quot;;const server = createServer({ cert: readFileSync(&quot;/path/to/cert.pem&quot;), key: readFileSync(&quot;/path/to/key.pem&quot;),});const wss = new WebSocketServer({ server }); 实际项目推荐 socket.io,API 更简洁 WebSocket 和 HTTP 长轮询的区别？ 区别 HTTP 长轮询：客户端发起请求，服务端阻塞，不会立即返回 WebSocket：客户端可发起请求，服务端也可发起请求 注意 HTTP 长轮询，需处理 timeout，即 timeout 之后重新发请求 描述从输入 url 到页面展示的完整过程 网络请求 DNS 查询（得到 IP），建立 TCP 连接（三次握手） 浏览器发起 HTTP 请求 收到请求响应，得到 HTML 源代码 解析（字符串 -&gt; 结构化数据） HTML 构建 DOM 树 CSS 构建 CSSOM 树（style tree） 两者结合，形成 render tree 渲染（render tree 绘制到页面） 计算各个 DOM 的尺寸、定位，最后绘制到页面 遇到 js 可能会执行（参考 defer、async） 异步 CSS、图片加载，可能会触发重新渲染 重绘 repaint 重排 reflow 有什么区别？ 重绘 repaint 元素外观改变，如颜色、背景色 但元素的尺寸、定位不变，不会影响到其他元素的位置 重排 relfow 重新计算尺寸和布局，可能会影响其他元素的位置 如元素高度增加，可能会使相邻元素位置下移 区别 重排比重绘影响更大，消耗更大 所以，要尽量避免无意义的重排 减少重排的方法 集中修改样式，或直接切换 css、class 修改之前先设置 display: none,脱离文档流 使用 BFC 特性，不影响其他元素位置 频发触发（resize、scroll）使用节流和防抖 使用 createDocumentFragment 批量操作 DOM 优化动画，使用 CSS3 和 requestAnimationFrame 如何实现网页多标签通讯？ 使用 WebSocket 无跨域限制 需要服务端支持，成本高 localStorage（跨域不共享） 同域的 A 和 B 两个页面 A 页面设置 localStorage B 页面可监听到 localStorage 值的修改 SharedWorker(必须同域) SharedWorker 是 WebWorker 的一种 WebWorker 可开启子进程执行 JS，但不能操作 DOM SharedWorker 可单独开启一个进程，用于同域页面通讯 网页和 iframe 如何通讯？ 使用 postMessage 通讯 注意跨域的限制和判断 123456789// 父传子window.iframe1.contentWindow.postMessage(&quot;hello&quot;, &quot;*&quot;);// 子传父window.parent.postMessage(&quot;world&quot;, &quot;*&quot;);// 接收window.addEventListener(&quot;message&quot;, (event) =&gt; { console.log(event.origin); console.log(event.data);}); 请描述 koa2 洋葱圈模型？ koa2 一个简约、流行的 nodejs 框架 通过中间件组织代码 多个中间件以“洋葱圈模型”执行 代码执行过程 洋葱圈模型(类似捕获冒泡) H5 页面如何进行首屏优化？ 路由懒加载 适用于 SPA 路由拆分，优先保证首页加载 服务端渲染 SSR 传统前后端分离（SPA）渲染页面的过程复杂 SSR 渲染页面过程简单，所有性能好 如果是纯 H5 页面，SSR 是性能优化的终极方案 App 预取 如果 H5 在 App WebView 中展示，可使用 App 预取 用户访问列表页面时，App 预加载文章首屏内容 用户进入 H5 页面，直接从 App 中获取内容，瞬间展示首屏 分页 针对列表页 默认只展示第一页内容 上滑加载更多 图片懒加载 lazyload 针对详情页 默认只展示文本内容，然后出发图片懒加载 注意：提前设置图片尺寸，尽量只重绘不重排 Hybrid 提前将 HTML、JS、CSS 下载到 App 内部 在 App webview 中使用 file：// 协议加载页面文件 再用 Ajax 获取内容并展示（也结合 App 预取） 后端一次性返回 10w 条数据，你该如何渲染？ 设计不合理，去砍了后端 自定义中间层 自定义 nodejs 中间层，获取并拆分这 10w 条数据 前端对接 nodejs 中间层，而不是服务端 成本比较高 虚拟列表 只渲染可视区域 React 都有哪些注意点（坑）？ 自定义组件首字母大写 js 关键字的冲突（htmlFor、className） JSX 的数据类型 12&lt;Demo value={1} /&gt; // number&lt;Demo value=&quot;1&quot; /&gt; // string setState 是异步更新的 123456789this.setState( { num: this.state.num + 1, }, () =&gt; { console.log(this.state.num); // 正确 });console.log(this.state.num); // 错误 如何统一监听 Vue 组件报错？ window.onerror 全局监听所有 js 错误 try…catch 中的错误无法被监听到 1234567window.onerror = function (msg, source, line, column, error) { console.log(msg, source, line, column, error);};// orwindow.addEventListener(&quot;error&quot;, (event) =&gt; { console.log(event);}); errorCaptured 生命周期 监听所有下级组件的错误 返回 false 会阻止向上传播 errorHandler 配置 Vue 全局错误监听，所有组件错误都会汇总到这里 但 errorCaptured 返回 false，不会传播到这里 123app.config.errorHandler = (err, vm, info) =&gt; { console.log(error, vm, info);}; 异步错误 异步回调里面的错误，errorHandler 监听不到 需要使用 window.onerror 如何统一监听 React 报错？ ErrorBoundary 组件 监听所有下级组件报错，可降级展示 UI 只监听组件渲染时报错，不监听 DOM 事件、异步错误 不监听 DOM 事件报错，可用 try…catch,window.onerror 只在 production 环境生效，dev 会直接抛出错误 12345678910111213141516171819202122232425262728class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { error: null, }; } static getDerivedStateFromError(error) { // 更新state，显示降级UI console.log(error); return { error }; } componentDidCatch(error, errorInfo) { // 统计上报错误信息 console.log(error, errorInfo); } render() { if (this.state.error) { return &lt;h1&gt;报错了&lt;/h1&gt;; } return this.props.children; }} 如果一个 H5 很慢，你该如何排查性能问题？ 前端性能指标 First Paint（FP） First ContentFul Paint（FCP） DomContentLoaded（DCL） Largest Contentful Paint（LCP） Load（L） Chrome devtools Performance 可查看上述性能指标，并有网页快照 Network 可以查看各个资源的加载时间 lighthouse（第三方性能评测工具） 12// terminallighthouse https://www.imooc.com/ --view --preset=desktop 通过以上工具来判读是加载慢还是渲染慢 加载慢 优化服务端硬件配置，使用 CDN 路由懒加载，大组件异步加载-减少主包的体积 优化 http 缓存策略 渲染慢 优化服务端接口（如 ajax 获取数据慢） 优化全段组件内部逻辑 服务端渲染 SSR 如何理解 HTML 语义化？ 让人更容易读懂（增加代码可读性） 让搜索引擎更容易读懂（SEO） 块状元素 &amp; 内联元素？ 块级元素 display: block/table; div、h1、h2、table、ul、ol、p 等 内联元素 display: inline/inline-block; span、img、input、button 等； 如下代码，请问 div 的 offsetWidth 是多大？12345678910&lt;style&gt; #div { width: 100px; padding: 10px; margin: 10px; border: 1px solid #ccc; }&lt;/style&gt;&lt;div id=&quot;div&quot;&gt;&lt;/div&gt; offsetWidth = (内容宽度 + 内边距 + 边框)，无外边距 答案： 100 + 10 + 1 * 2 = 122px 可以通过：box-sizing: border-box; 使得 offsetWidth=100 margin 纵向重叠问题 如下代码，A 和 B 之间的距离是多少？ 1234567891011121314&lt;style&gt; p { font-size: 16px; line-height: 1; margin-top: 10px; margin-bottom: 15px; }&lt;/style&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;B&lt;/p&gt; 相邻元素的 margin-top 和 margin-bottom 会发生重叠 空白内容 p 标签也会重叠 答案：15px margin 负值问题 margin-top 和 margin-left 负值，元素向上、向左移动 margin-right 负值，右侧元素左移，自身不受影响 margin-bottom 负值，下方元素上移，自身不受影响 BFC 理解与应用 Block format context，块级格式化上下文 一块独立渲染区域，内部元素的渲染不会影响边界以外的元素 形成 BFC 的常见条件 float 不是 none position 是 absolute 或 fixed overflow 不是 visible display 是 flex、inline-block 等 常见应用： 清除浮动 float 布局 实现圣杯布局和双飞翼布局 目的 三栏布局，中间一栏最先加载和渲染 两侧内容固定，中间内容随着宽度自适应 一般用于 PC 网页 实现 使用 float 布局 两侧使用 margin 负值，以便和中间内容横向重叠 防止中间内容被两侧覆盖，一个用 padding，一个用 margin css 定位 absolute 和 relative 定位 relative 依据自身定位 absolute 依据最近一层的定位元素定位 定位元素：absolute、relative、fied、body 居中对齐 水平居中 inline 元素：text-align: center block 元素：margin: auto absolute 元素：left:50% + margin-left 负值 垂直居中 inline 元素：line-height 的值等于 height 的值 absolute 元素：top: 50% + margin-top 负值 absolute 元素：transform(-50%, -50%) absolute 元素：top,left,bottom,right=0 + margin: auto css-图文样式 line-height 如何继承 如下代码，p 标签的行高是多少？ 1234567891011121314&lt;style&gt; body { font-size: 20px; line-height: 200%; /* 40px */ line-height: 1.5; /* 16 * 1.5 = 24 */ line-height: 30px; /* 30px */ } p { font-size: 16px; }&lt;/style&gt;&lt;body&gt; &lt;p&gt;AAA&lt;/p&gt;&lt;/body&gt; 答案： 40px 具体数值，如 30px，则继承该值 写比例，如 2/1.5，则继承当前元素 font-size 的比例 写百分比，如 200%，则继承计算出来的值 css-响应式 常见长度单位 px，绝对长度单位 em，相对长度单位，相对于父元素 rem，相对长度单位，相对于根元素，常用与响应式布局 响应式布局常用方案 media-query，根据不同屏幕宽度设置根元素 font-size rem，基于根元素的相对单位 rem 的弊端：“阶梯”性 1234567891011121314151617181920212223242526272829&lt;style&gt; @media only screen and (max-width: 374px) { html { font-size: 86px; } } @media only scrren and (min-width: 375px) and (max-width: 413px) { html { font-size: 100px; } } @media only scrren and (min-width: 414px) { html { font-size: 110px; } } body { font-size: 0.16rem; } #div { width: 1rem; /* 100px */ }&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt;div&lt;/div&gt;&lt;/body&gt; 网页视口尺寸 window.screen.height // 屏幕高度 window.innerHeight // 网页视口高度 vh 网页视口高度的 1/100 vw 网页视口宽度的 1/100 vmax 取两者最大值；vmin 取两者最小值 document.body.clientHeight // body 高度 typeof 运算符 识别所有值类型 undefined string number boolean Symbol 识别函数、 function 判断是否是引用类型 object 手写 call123456789101112Function.prototype.call = function (context, ...args) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;}; 手写 apply123456789101112Function.prototype.apply = function (context, args = []) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;}; 手写 bind1234567891011Function.prototype.bind = function (context, ...args) { const fn = this; return function newFn(...newFnArgs) { if (this instanceof newFn) { return new fn(...args, ...newFnArgs); } return fn.apply(context, [...args, ...newFnArgs]); };}; 手写 instanceof12345678910/** 1.通过left.__proto__.__proto__这种方式从下往上获取原型对象* 2.通过Object.create(null)的实例是没有原型链* 3.有原型链的实例的尽头都是Object*/function instanceof(left, right) { if (!left.__proto__) return false; if (right === Object || left.__proto__ === right.protorype) return true; return instanceof(left.__proto__, right);} 异步和单线程 js 是单线程语言，同时只能做一件事 浏览器和 nodejs 已支持启动进程，如 web worker js 和 dom 渲染共用同一个线程，因为 js 可以修改 dom 结构，所以遇到等待（网络请求，定时任务）就会卡住 网络请求，如 ajax 图片加载 定时任务，如 setTimeout 所以需要异步（callback） 异步和同步的区别？ 基于 js 是单线程语言 异步不会阻塞代码执行 同步会阻塞代码执行 for…of for…in（以及 forEach、for）都是常规的同步遍历 1234567891011121314151617181920212223function muti(num) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(num * num); }, 1000); });}const nums = [1, 2, 3];// 现象：1s后，同时打印 1，4，9nums.forEach(async (item) =&gt; { const res = await muti(item); console.log(res);});// 现象：异步等待打印!(async function () { for (let i of nums) { const res = await muti(i); console.log(res); }})(); for…of 常用于异步的遍历 从 event loop 解释，为什么微任务执行更早？ 宏任务： setTimeout、setInterval、ajax、DOM 事件 微任务： promise、async/await 微任务的执行时机要比宏任务要早 每次 call stack 清空，即每次轮询结束，即同步任务执行完成 如果 DOM 结构有改变，则会重新进行 DOM 渲染 宏任务：DOM 渲染后触发，如 setTimeout 微任务：DOM 渲染前触发，如 promise 所以：微任务先于宏任务先执行 补充： 微任务都是 ES6 语法规定的 宏任务都是由浏览器规定的 BOM API navigator screen location history ajax xhr.readyState 0 (未初始化)还没有调用 send()方法 1 (载入)已调用 send()方法，正在发送请求 2 (载入完成) send()方法执行完成，已经接收到全部响应内容 3 (交互) 正在解析响应内容 4 (完成) 响应内容解析完成，可以在客户端调用 xhr.status 2xx 表示成功处理请求，如 200 3xx 需要重定向，浏览器直接跳转，如 301、302、304 4xx 客户端请求错误，如 404、403 5xx 服务端错误 常见状态码？ 200 成功 301 永久重定向（配合 location，浏览器自动处理） 302 临时重定向（配合 location，浏览器自动处理） 304 资源未被修改（协商缓存 ） 404 资源未找到 405 没有权限 500 服务器错误 504 网关超时 本身状态码就是一种约定，一种协议和规范，不要尝试违反规范，例如 IE 浏览器 http 常见 methods？ 传统 methods get 获取服务器的数据 post 向服务器提交数据 新的 methods get 获取数据 post 新建数据 patch/put 更新数据 delete 删除数据 Restful API 一种新的 API 设计方法 传统 API 设计：把每个 url 当作一个功能 Restful API 设计：把每个 url 当作一个唯一的资源 原则 不使用 url 参数 传统 API 设计：/api/list?pageIndex=2 Restful API 设计：/api/list/2 用 method 表示操作类型 传统 API 设计 post 请求 /api/create-blog post 请求 /api/update-blog?id=100 get 请求 /api/get-blog?id=100 Restful API 请求 post 请求 /api/blog patch 请求 /api/blog/100 get 请求 /api/blog/100 常见 http headers？ Request Headers Accept 浏览器可接收的数据格式 Accept-Encoding 浏览器可接收的压缩算法，如 gzip Accept-Languange 浏览器可接收的语言，如 zh-CN Connection: keep-alive 一次 TCP 连接重复使用 cookie Host 如：www.baidu.com Cache-Control User-Agent （简称 UA）浏览器信息 Content-type 发送数据的格式，如 application/json Response Headers Content-type 返回数据的格式，如 application/json Content-length 返回数据的大小，多少字节 Content-Encoding 返回数据的压缩算法，如 gzip Set-Cookie Expires Etag date 自定义 header 缓存相关的 headers Cache-Control Expires Last-Modified If-Modified-Since Etag If-None-Match http 缓存？ 强制缓存 强制缓存过期后会去服务端重新请求 协商缓存 服务端缓存策略 服务端判断客户端资源，是否和服务端资源一样 一致则返回 304，否则返回 200 和最新的资源 在 Response Headers 中，有两种： Last-Modified 资源的最后修改时间 Etag 资源的唯一标识 Last-Modified 和 Etag 会优先使用 Etag Last-Modified 只能精确到秒级 如果资源被重复生成，而内容不变，则 Etag 更精确 综述 刷新操作对缓存的影响？ 正常操作：地址输入 url，跳转链接，前进后退等 强制缓存有效，协商缓存有效 手动刷新：F5，点击刷新按钮，右击菜单刷新 强制缓存失效，协商缓存有效 强制刷新：ctrl + F5 强制缓存失效，协商缓存失效 访问浏览器网页过程？ 加载过程 DNS 解析：域名-&gt;IP 地址 浏览器根据 IP 地址 axing 服务器发起 http 请求 服务器处理 http 请求，并返回给浏览器 渲染过程 根据 HTML 代码生成 DOM Tree 根据 CSS 代码生成 CSSOM 树 将 DOM Tree 和 CSSOM 整合成 Render Tree 根据 Render Tree 渲染页面 遇到 script 标签则停止渲染，优先加载并执行 js 代码，完成再继续 直至把 Render Tree 渲染完成 为何要将 css 文件放在 head 标签中呢？ css 放在 body 标签尾部时，DOMTree 构建完成之后便开始构建 RenderTree，并计算布局渲染网页，等加载解析完 css 之后，开始构建 CSSOMTree，并和 DOMTree 重新构建 RenderTree，重新计算布局渲染网页 css 放在 head 中，先加载 css，之后解析 css 构建 CSSOMTree，同时构建 DOMTree，CSSOMTree 和 DOMTree 都构建完成之后开始构建 Render Tree，计算布局网页 两者对比，css 放在 head 中比放在 body 标签尾部少了一次构建 RenderTree，一次计算布局和一次渲染网页，因此性能会更好，并且 css 放在 body 标签尾部会在网页中短暂出现裸奔的 html，不利于用户体验 为什么建议把 script 标签放在 body 最后？ js 的下载和执行会阻塞 DOMTree 的构建，即会中断 DOMTree 的更新，所以如果把 script 标签放在首屏范围内的 HTML 代码中会截断首屏的内容。 普通 script 标签放在 body 底部，做与不做 async 或者 defer 处理都不会影响首屏时间，但是会影响 DomContentLoad 和 load 的时间，进而影响依赖他们的代码的执行的开始时间 123456window.addEventListener(&quot;load&quot;, function () { // 页面的全部资源加载完成后才会执行，包括图片、视频等});document.addEventListener(&quot;DOMContentLoaded&quot;, function () { // DOM 渲染完成后即可执行，此时图片、视频可能还没有加载完}); 性能优化 性能优化原则 多使用内存、缓存 减少 CUP 计算，减少网络加载耗时 适用于所有变成的性能优化-空间换时间 从何入手 让加载更快 减少资源体积：压缩代码 减少访问次数：合并代码，SSR 服务器渲染，缓存，精灵图 缓存（webpack contenthash） 静态资源加 hash 后缀，根据文件内容计算 hash 文件内容不变，则 hash 不变则 url 不变 url 和文件不变，则会自动触发 http 的缓存机制，返回 304 SSR 服务器端渲染：将网页和数据一起加载，一起渲染 非 SSR（前后端分离）：先加载网页，后加载数据，再渲染数据 使用更快的网络：CDN 让渲染更快 css 放在 head，js 放在 body 最下面 尽早开始执行 js，用 DOMContentLoaded 触发 懒加载（图片懒加载，下滑更多等）12345&lt;img id=&quot;img&quot; src=&quot;preview.png&quot; data-realsrc=&quot;abc.png&quot; /&gt;&lt;script&gt; let img = document.getElementById(&quot;img&quot;); img.src=img.getAttribute('data-realsrc')&lt;/script&gt; 对 DOM 查询进行缓存 合并频繁的 DOM 操作,document.createDocumentFragment() 节流 throttle、防抖 debounce 安全 XSS 跨站请求攻击 攻击方式 一个博客网站，我发表一篇博客，其中嵌入 script 脚本 脚本内容：获取 cookie，发送到我的服务器 发布这篇博客，有人查看，就可以回去到访问者的 cookie 预防方式 替换特殊字符 XSRF 跨站请求伪造 预防 增加验证，例如密码、短信验证、指纹等 ES6 新增的声明方式 let、const 不属于顶层对象 window 不允许重复声明 不存在变量提升 暂时性死区（不能在变量声明之前去使用） 块级作用域 定制化输出特定数组 随机生成一个长度为 10 的整数类型的数据 例如 [2, 10, 3, 35, 5, 11, 10, 11, 20] 将其排列成一个新数组，要求新数组形式如下： [[2, 3, 5], [10, 11],[20],[35]] 12345678910111213141516171819202122232425262728// 1. 获取随机数 0-99function getRandomNumber(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1) + min);}let arr = Array.from({ length: 10 }, () =&gt; getRandomNumber(0, 99));// 2. 去重(没必要)arr = [...new Set(arr)];// 3. 排序arr.sort((a, b) =&gt; a - b);// 4. 存储 0-9 10-19 20-29const map = {};arr.forEach((item) =&gt; { const key = Math.floor(item / 10); if (!map[key]) { map[key] = []; } map[key].push(item);});const result = [];for (const key in map) { result.push(map[key]);}console.log(result); 将树状结构转换为属性平铺的结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 题目const entry = { a: { b: { c: { dd: &quot;abcdd&quot;, }, }, d: { ee: &quot;adee&quot;, }, f: &quot;af&quot;, },};const output = { &quot;a.b.c.dd&quot;: &quot;abcdd&quot;, &quot;a.d.ee&quot;: &quot;adee&quot;, &quot;a.f&quot;: &quot;af&quot;,};// 解答// 方法1: 递归function flatObj(obj, preKey = &quot;&quot;, result = {}) { for (const key in obj) { if (obj.hasOwnProperty(key)) { const newKey = `${preKey}${key}`; if (typeof obj[key] === &quot;object&quot;) { flatObj(obj[key], `${newKey}.`, result); } else { result[newKey] = obj[key]; } } } return result;}// 方法2: while循环-队列function flatObj2(obj) { const queue = Object.entries(obj); const result = {}; while (queue.length) { const [key, value] = queue.pop(); for (const [k, v] of Object.entries(value)) { if (typeof v === &quot;object&quot;) { queue.push([`${key}.${k}`, v]); } else { result[`${key}.${k}`] = v; } } } return result;}// 测试用例flatObj(entry);flatObj2(entry); 将平铺属性的数据结构转换为树状数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 题目const entry = { &quot;a.b.c.dd&quot;: &quot;abcdd&quot;, &quot;a.d.ee&quot;: &quot;adee&quot;, &quot;a.f&quot;: &quot;af&quot;,};const output = { a: { b: { c: { dd: &quot;abcdd&quot;, }, }, d: { ee: &quot;adee&quot;, }, f: &quot;af&quot;, },};// 答案// 方法1: 双重循环function map(entry) { const result = {}; for (const key in entry) { const value = entry[key]; const keyMap = key.split(&quot;.&quot;); if (!result[keyMap[0]]) { result[keyMap[0]] = {}; } let tmp = result[keyMap[0]]; let length = keyMap.length; for (let i = 1; i &lt; length; i++) { if (!tmp[keyMap[i]]) { if (i === length - 1) { tmp[keyMap[i]] = value; } else { tmp[keyMap[i]] = {}; } } tmp = tmp[keyMap[i]]; } } return result;}// 方法2: 递归// {&quot;a.b.c.dd&quot;: &quot;abcdd&quot;}// =&gt; {&quot;a.b.c&quot;: {&quot;dd&quot;:&quot;abcdd&quot;}}// =&gt;...// =&gt; {&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: {&quot;dd&quot;: &quot;abcdd&quot;}}}}function map2(entry) { function getNest(key) { const lastIndex = key.lastIndexOf(&quot;.&quot;); const value = entry[key]; if (lastIndex !== -1) { delete entry[key]; const preKey = key.substring(0, lastIndex); const restKey = key.substring(lastIndex + 1); if (!entry[preKey]) { entry[preKey] = { [restKey]: value }; } else { entry[preKey][restKey] = value; } if (/./.test(preKey)) { getNest(preKey); } } } for (const key in entry) { getNest(key); } return entry;}map(entry);map2(entry); react 自定义封装不会反复创建的定时器（setInterval）123456789101112131415161718192021222324import { useRef, useState } from &quot;react&quot;;const useTimer = (step = 1) =&gt; { const timer = useRef(null); const [num, setNum] = useState(0); const start = () =&gt; { const timeout = setInterval(() =&gt; { setNum((num) =&gt; num + 1); }, step * 1000); timer.current = timeout; }; const clear = () =&gt; { setNum(0); clearInterval(timer.current); }; return { num, start, clear, };}; 修改下面代码，顺序输出 0-9912345678910111213141516171819202122232425262728293031323334353637383940// 要求：// 1. 只能修改 setTimeout// 2. 不能修改Math.floor(Math.random() * 1000)// 3. 不能使用全局变量function print(n) { setTimeout(() =&gt; { console.log(n); }, Math.floor(Math.random() * 1000));}for (var i = 0; i &lt; 100; i++) { print(i);}// 答案// 方法1: 立即执行函数function print(n) { setTimeout( (() =&gt; { console.log(n); return () =&gt; {}; })(), Math.floor(Math.random() * 1000) );}for (var i = 0; i &lt; 100; i++) { print(i);}// 方法1: setTimeout第三个参数function print(n) { setTimeout( () =&gt; { console.log(n); }, 10, Math.floor(Math.random() * 1000) );}for (var i = 0; i &lt; 100; i++) { print(i);} for 循环和 splice 的坑12345678910111213141516171819202122232425262728// for循环和splice的坑// 具体描述：在对一个数组执行for循环时，// 删除数组元素，会存在什么问题// 方法1: i--const arr = [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];for (let i = 0; i &lt; arr.length; i++) { if (arr[i] === &quot;a&quot;) { arr.splice(i, 1); i--; // 需要处理下 i-- }}// 方法2: 倒序const arr = [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];for (let i = arr.length - 1; i &gt;= 0; i--) { if (arr[i] === &quot;a&quot;) { arr.splice(i, 1); }}// for...inconst arr = [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];for (let index in arr) { if (arr[index] === &quot;a&quot;) { arr.splice(index, 1); index--; // 仍然会有问题 }}console.log(arr); 持续更新中…","link":"/2022/03/11/100%E9%81%93%E5%89%8D%E7%AB%AF%E4%BC%98%E8%B4%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"ES6之字符串","text":"ES6 之字符串 ES5 的字符串拼接 123let name = 'foolishmax'let blog = '你好，我是'+name+',是你的新朋友。'console.log(blog) // 你好，我是foolishmax,是你的新朋友。 ES6 采用${name}的形式,同时里面支持 HTML 标签 123let name = 'foolishmax'let blog = `&lt;h3&gt;你好，我是${name},是你的新朋友。&lt;/h3&gt;`document.write(blog) // 你好，我是foolishmax,是你的新朋友。 对运算也支持 1234let a = 1let b = 2let result = `${a + b}`console.log(result) // 3 查找是否存在 1234//includeslet name = 'foolishmax'let str = 'hello world, foolishmax'console.log(str.includes(name)) //true 判断开头是否存在 1str.startsWith(name) 判断结尾是否存在 1str.endsWith(name) 复制字符串 1console.log('hello '.repeat(3))","link":"/2019/08/12/ES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"数组常见的API","text":"数组常见的 API forEach遍历所有数组元素,会自动省略为空的数组元素 123456var array1 = ['a', 'b', 'c'];array1.forEach(function(element) { console.log(element);});// a b c every判断所有元素是否都符合条件 12345678var arr = [1, 2, 3]var result = arr.every(function(item, index){ if (item &lt; 4) { return true }})console.log(result) some判断是否有至少一个元素符合条件 123456789var array = [1, 2, 3, 4, 5];var even = function(element) { // checks whether an element is even return element % 2 === 0;};console.log(array.some(even));// expected output: true sort排序 12345678var arr = [1, 4, 3, 2, 5]var arr2 = arr.sort(function(a, b){ //从小到达 return a - b //从大到小 //return b- a})console.log(arr2) filter过滤符合条件的元素 123456789101112//filter回调函数会返回一个boolean值//true：当返回true时，函数内部会自动将这次回调的item加入到新的数组中arr2//false：当返回false时，函数内部会过滤掉这次的itemvar arr = [1, 2, 3]var arr2 = arr.filter(function(item, index){ if (item &gt;= 2) { return true }})console.log(arr2) map对元素重新组装，生成新数组(该数组中的每个元素都调用一个提供的函数后返回的 结果。) 1234567var array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32] reducereduce作用是对数组中所有内容进行汇总 1234567891011121314151617181920[1,2,3].reduce(function(prev, curr){ return prev + curr}, 0) //6=================//计算小于100，并二倍之后的和const nums = [10, 20, 111, 222, 444, 40, 50]let total = nums.filter(function(n){ return n &lt; 100}).map(function(n){ return n * 2}).reduce(function(pre, curr){ return pre + curr}, 0)let total = nums.filter(n =&gt; n &lt; 100).map(n =&gt; n * 2).reduce((pre, curr) =&gt; pre + curr)console.log(total) //240 join()间隔数组元素 let arr = ['hello', 'world', 'foolish'] console.log(arr.join('|')) // hello|world|foolish toString()let arr = ['hello', 'world', 'foolish'] console.log(arr.toString()) // hello,world,foolish includes() //ES7includes() 函数用来判断一个数组是否包含一个指定的值，如果包含则返回true，否则返回false 类似indexOf() 1234567891011121314//使用indexOf()验证数组中是否存在某个元素，根据返回值是否为-1来判断let arr = ['react', 'angular', 'vue']if (arr.indexOf('react') !== -1) { console.log('react存在')}//使用ES7的includes()方法let arr = ['react', 'angular', 'vue']if (arr.includes('react')) { console.log('react存在')} 指数操作符在ES7中引入了指数操作符 ** ,** 具有和Math.pow(a, b)等效的计算结果 Array.from()JSON数组格式（多个length属性）转换为数组 12345678let json = { '0': 'hello', '1': 'world', '2': 'foolishmax', length: 3}let arr = Array.from(json)console.log(arr) Array.of()负责把一堆文本或者变量转换成数组 1234567// 数字let arr = Array.of(1, 2, 3, 4)console.log(arr) //[1, 2, 3, 4]// 字符串let arr = Array.of('hello', 'world')console.log(arr) //[&quot;hello&quot;, &quot;world&quot;] find()实例方法所谓的实例方法并不是以Array对象开始的，而是必须有一个已经存在的数组， 实例数组调用的方法，就是实例方法. find接受一个方法作为参数，方法内部返回一个条件 find会遍历所有元素，执行给定的函数 符合该条件的元素会作为find方法的返回值 如果遍历结束没有符合条件的元素，则返回undefined 123456789//value: 表示当前查找的值//index: 表示当前查找的数组索引//arr: 表示当前数组let arr = [2,3,4,5,6,7,8]let result = arr.find(function(value, index, arr){ return value &gt; 5})console.log(result) //6 fill()实例方法fill()作用是把数组进行填充，接受三个参数，一个参数填充的变量，第二个 是填充的位置，第三个是填充到的位置 123let arr = [1,2,3,4,5,6,7,8,9]arr.fill('hello', 1, 3)console.log(arr) // [1, &quot;hello&quot;, &quot;hello&quot;, 4, 5, 6, 7, 8, 9] for…of 循环12345678910111213141516171819202122let arr = ['hello', 'world', 'foolishmax']for(let item of arr){ console.log(item)}// hello world foolishmaxlet arr = ['hello', 'world', 'foolishmax']for(let index of arr.keys()) { console.log(index)}// 0 1 2let arr = ['hello', 'world', 'foolishmax']for (let [index, val] of arr.entries()){ console.log(index+':'+val)}//0:hello//1:world//2:foolishmax entries()实例方法entries() 实例方法生成的是Iterator形式的数组，好处就是可以让我们在需要的时候 用next()手动跳转到下一个值 12345let arr = ['hello', 'world', 'foolishmax']let list = arr.entries();console.log(list.next().value);console.log(list.next().value);console.log(list.next().value);","link":"/2019/07/18/ES6%E4%B9%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"title":"CSS-清除浮动","text":"CSS-清除浮动 原文链接 什么是 CSS 清除浮动?1234在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。 清除浮动的方法 方法一：使用带 clear 属性的空元素 12345在浮动元素后使用一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt;来进行清理。优点：简单，代码少，浏览器兼容好。缺点：需要添加大量的无语义的html元素，代码不够优雅，后期不容易维护。 方法二：使用 CSS 的 overflow 属性 1给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动。 方法三：给浮动的元素的容器添加浮动（不太推荐） 12给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 方法四：使用邻接元素处理 1什么都不做，给浮动元素后面的元素添加clear:both属性。 方法五：使用 CSS 的：after 伪元素 12345678910给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。.clearfix::after{ content: &quot;020&quot;; display: block; height: 0; clear: both; visibility: hidden; }","link":"/2019/07/07/CSS-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"},{"title":"ES6之箭头函数","text":"ES6 之箭头函数 默认值在 ES6 中给我们增加了默认值的操作 12345function add(a, b = 1) { return a + b}console.log(arr(1))//2 主动抛出错误 throw new Error(‘This is error’) 函数中的严格模式 123456789function add(a,b=1){ 'use strict' if(a == 0){ throw new Error('This is error'); } return a+b;}console.log(add(1)); 上面代码运行会出现报错，原因就是如果使用了默认值，再使用严格模式的话，就会 有冲突，需要取消默认值的操作。 获得需要传递的参数个数 123456789function add(a,b){ 'use strict' if(a == 0){ throw new Error('This is error'); } return a+b;}console.log(add.length); //2 add.length 可以查看 必须 传递值的参数个数 如果去掉严格模式，再第二个参数加上默认值的话，add.length的值就变成了1","link":"/2019/08/12/ES6%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"title":"ES6实用技巧","text":"ES6 实用技巧 命名规范123456789101112131415//js变量命名：小驼峰，前缀应当是名词，例如 maxCount、tableTitle//js常量：全大写，单词以_分割//js函数命名：小驼峰，前缀应当是动词，例如 setCount、getTitle//常见动词：can has is get set load//类 &amp; 构造函数：大驼峰，首字母大写// class Person {}//类的成员//公共属性和方法：跟变量和函数的命名一样//私有属性和方法，前缀为_(下划线)，同上//private _name: string; let &amp; const123ES6新增了let和const两个命令，let用来定义变量，const用于定义常量，let和const都是块级作用域。const对于对象类型使用的是指针式引用，常量只是指向了对象的指针，对象本身的内容却依然可以被修改。在使用中，建议使用let和const完全代替var命令 字符串模板1const foo = `this is a ${example}`; 数值扩展12345转换Number.parseInt —— 将字符串或数字转换为整数Number.parseFloat —— 将字符串或数字转换为浮点数上述两个方法与parseInt和parseFloat功能一致，在ES6中推荐使用Number.的方法调用，目的是为了减少全局性方法，使语言逐步模块化。 数组扩展12345678910111213141516171819202122232425262728293031323334353637383940//合并数组let a = [1,2]let b = [3]let c = [...a, ...b]//Array.from() 将伪数组对象或可遍历对象转换为真数组//典型的伪数组有：函数的arguments对象，以及大多数DOM元素，还有字符串//快速转换为数组Array.of(3, 4, 5)//判断对象是否为数组if(Array.isArray(obj)){...}//检索数据中是否有5[1, 2, 3].includes(5) //false//找出第一个匹配表达式的结果，只要匹配到一项，函数就返回let a =[1, 3, 4, -89].find((value, index, arr) =&gt; { return value &lt; 0;})console.log(a); //-89//找出第一个匹配表达式的结果的下标let a = [1, 2, 3, -2].findIndex((value, index, arr) =&gt; { return value &lt; 0;})console.log(a); //3//内容过滤let a = [1, 2, 3, -4].filter((item) =&gt; { return item &gt; 0;})console.log(a); //[1, 2, 3]//内容实例.keys() —— 获得数组中所有元素的键名(索引下标).values() —— 获得数组中所有元素的数据.entries() —— 获得数组中所有数据的键名和数据类似Object中的同名函数 对象扩展123456789101112131415161718192021// 对象内容合并let a = {a:1,b:2}, //{a: 1, b: 4} b = {b:3}, c = {b:4,c:5}let d = Object.assign(a, b, c) //{a: 1, b: 4, c: 5}// 合并的同时更新a对象的内容// a自身没有的属性不会被添加，只会更新// 只会影响a第一个，不会影响后面的b、c// 推荐使用下面这种let d = Object.assign({}, a, b, c)//对象内容Object.keys() —— 获取所有键名，以数组形式返回Object.values() —— 获取所有值内容，以数组形式返回Object.entries() —— 获取所有键名和值内容，以数组形式返回，成员内容也是数组形式 例如：[['a', 1],['b', 2]]//判断对象是否为数组对象if(Object.isArray(obj)){}//判断对象是否为空对象if(obj &amp;&amp; Object.keys(obj).length) Destructuring 解构赋值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061let [a, b, c] = [1, 2, 3] //如果个数不匹配，没有对应上的为undefinedlet [a, b, c = 'default'] = [12, 23] //指定默认值let [a, ...b] = [1, 2, 3] //b的值为[2, 3]let [a, b, c] = 'yes' //a的值为y，b的值为e，c的值为s//如果名称是字符串的自带属性，则会获得属性的值let { length } = 'yes' //length 为3//解构赋值使用实例，作为函数传参，使用默认值let obj = {a: 1, b: 2}function test({a = 10, b}) { ...}test(obj)// 对象结构解构赋值let obj = {a: 1, b: 2};let { a, b } = obj; //a = 1,b = 2,需要严格匹配名称，数组的模式是严格匹配下标。let obj = {a: 1, b: 2};let { a = 0, b = 3 } = obj; //赋值并给定默认值let obj = { a: 1, b: 2};let {a: A, b} = obj; //获得内容后，将变量会从新命名let a = 0;({a, b} = obj);//对已存在的a进行修改值，并生成新的变量b//解构的同时使用重命名和设置默认值的语法const person = {name: &quot;zhangsan&quot;,sex: &quot;male&quot;};const {name: middleName = &quot;zhangxiaosan&quot;} = person;console.log(middleName); //&quot;zhangsan&quot;// 首先声明middleName这个变量，查询person的middle属性，如果存在则赋值给middleNmae，如果不存在使用默认值&quot;zhangxiaosan&quot;//多层解构赋值let obj = { arr: ['aaa', {a: 1}]}let {arr: [b, {a}]} = obj; //b为'aaa',a为1，注意结构要对应。//数组转化为对象const points = [ [1,2], [3,4]];let newPoints = points.map(item =&gt; { const [x,y] = item; return {x, y};})orlet newPoints = points.map(([x, y]) =&gt; { return {x, y}})console.log(newPoints);//[// {x:1,y:2},// {x:3,y:4}//] 箭头函数1234567//如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错//报错，会报SyntaxErrorlet count = num =&gt; {base: 50};//正确返回方式let count = num =&gt; ({base: 50});//特点：更简洁的函数和封闭上下文的this指向。 Symbol1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//基本用法let name = Symbol(&quot;name&quot;);console.log(name); //Symbol(name)console.log(typeof name); //&quot;symbol&quot;// Symbol 函数不能用new命令，因为Symbol是原始数据类型，不是对象// Symbol表示独一无二的值，因此带有相同参数的两个Symbol值也不相等let name1 = Symbol();let name2 = Symbol();name1 === name2;// falselet name1 = Symbol(&quot;name&quot;);let name2 = Symbol(&quot;name&quot;);name1 === name2; // false//Symbol不能进行隐式类型转换let name = Symbol('foo');console.log(&quot;nihao&quot; + name);//浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a string.//Symbol值可以显示转换为字符串let name = Symbol('foo');String(name); //&quot;Symbol(foo)&quot;name.toString(); //&quot;Symbol(foo)&quot;//Symbol值不能转换为数字let name = Symbol('foo');Number(name);//浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a number.//Symbol值可以转换为布尔值let name = Symbol('foo');Boolean(name); //true!name //false//Symbol变量不能作为webStorage的键使用let name = Symbol();localStorage.setItem(name,&quot;aaaa&quot;);//浏览器报错：Uncaught TypeError:Cannot convert a Symbol value to a string.//使用场景//作为对象属性名//不能用.只能用[]let name = Symbol();let obj = {};obj[name] = &quot;zhangsan&quot;;console.log(obj); //{Symbol():&quot;zhangsan&quot;}//Symbol作为属性名时，该属性时公有属性不是私有属性，可以在类的外部访问，但是不会出现在for...in,for...of的循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。//可以通过Object.getOwnPropertySymbols()和Reflect.ownKeys()取到。//定义常量，保证唯一性const COLOR_RED = Symbol(&quot;red&quot;);const MY_RED = Symbol(&quot;red&quot;);//Symbol.for()//作用：用于将描述相同的Symbol变量指向同一个Symbol值//Symbol()定义的值每次都是新建的，即使描述相同值也不同//Symbol.for() 会先检查给定的描述是否存在，不存在才会新建一个值，并将这个值登记在全局环境中供搜索。let a1 = Symbol.for('a');let a2 = Symbol.for('a');a1 === a2 //truetypeof a1 //&quot;symbol&quot;typeof a2 //&quot;symbol&quot;//Symbol.keyFor()//检测Symbol值是否被登记过，返回一个已登记的Symbol类型值的keylet a1 = Symbol.for('a');Symbol.keyFor(a1); //&quot;a&quot;let a2 = Symbol('a');Symbol.keyFor(a2); //undefined//Symbol的属性//Symbol.peorotype.description 用于返回Symbol数据的描述let a = Symbol(&quot;accc&quot;);a.description //&quot;accc&quot; 排除 Object 中不需要的键值123const obj = {a:1,b:2,c:3};const {a,...rest} = obj; //获取除了a之外的所有属性 reduce1234567891011121314151617181920//使用reduce对象数组的某一个属性求和const obj = [ {name: &quot;lilei&quot;,score: 98}, {name: &quot;hanmeimei&quot;,score: 90}]const scoreTotal = objs.reduce((total, obj) =&gt; { return total + obj.score;})//使用reduce同时做到map和filter的作用const number = [10,20,30,40];const doubledOver50 = number.reduce((finalList, num) =&gt; { num = num * 2; if(num &gt; 50) { finalList.push(num); } return finalList;},[]);doubledOver50; //[60, 80] import() 动态加载123456//把import作为一个函数可以实现动态加载模块if(true) { import('./module.js).then(res =&gt; { console.log(res); })}","link":"/2020/10/07/ES6%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"HTML语义化","text":"什么是 HTML 语义化？ 1根据内容的结构化，选择合适的标签，便于开发者阅读和写出更优雅的代码的同时利于SEO的优化。 为什么要语义化？ 1234567- 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；- 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；- 有利于SEO ：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息： 爬虫依赖于标签来确定上下文和各个关键字的权重；- 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；- 便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。","link":"/2019/09/30/HTML%E8%AF%AD%E4%B9%89%E5%8C%96/"},{"title":"JS创建对象的几种方式","text":"JS 有哪几种创建对象的方式？ 对象字面量 1var obj = {} Object 构造函数 1var obj = new Object() 工厂模式 1234567891011function Person(name, age) { var o = new Object() o.age = age o.name = name o.say = function() { console.log(name) } return o} // 缺点：每次通过Person创建对象的say方法都一样，却存储了多次，浪费资源 构造函数模式 1234567891011function Person (name, age) { this.name = name this.age = age this.say = function() { console.log(name) }}var person = new Person('foolish', 18)// 构造函数在最后都会隐式返回return this，所以如果缺少new的时候，会将属性和方法添加给全局window对象，必须new，可以通过call和apply指定this。 原型模式 123456789function Person() {}Person.prototype.name = 'foolish'Person.prototype.say = function() { console.log(this.name)}var person = new Person()//实现了方法与属性的共享，可以动态添加对象的属性和方法。但是没有办法创建实例自己的属性和方法，也没有办法传递参数 构造函数和原型组合 12345678function Person (name, age) { this.name = name this.age = age}Person.prototype.say = function() { console.log(this.name)}var person = new Person('hello')","link":"/2019/08/13/JS%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"JS垃圾回收机制","text":"谈谈 JS 垃圾回收机制？ 垃圾回收Javascript中的内存管理是自动执行的，而且是不可见的。在我们创建基本类型、对象、函数 时，这些都需要内存，当不需要某样东西时，JavaScript引擎会利用垃圾回收机制清除它。 在局部作用域中，当函数执行完毕，局部变量也就没必要存在了，因此垃圾收集器很容易 做出判断回收。但是全局变量什么时候需要自动释放内存空间很难判断，因此在开发中， 需要尽量避免使用全局变量。 可达性JavaScript 中内存管理的主要概念是可达性。 当一些值以某种方式可访问或可用，它们会被存储在内存中，叫做可达值。 一些固有可达值，由于显而易见的原因无法删除。例如： 本地函数的局部变量或参数 当前嵌套调用链上的其他函数的变量和参数 全局变量等 这些值 称为 根 如果引用或引用链 可以从根访问任何其他值，则认为该值是可访问的。 一个对象引用另一个对象的属性，则该对象是为可达性。 JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除哪些不可访问的对象。 内部算法v8 的垃圾回收策略基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同的算法。 新生代采用 Scavenge 算法(赋值算法) Scavenge 为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分为 from 和 to 两个空间。每次 gc,会将 from 空间的存活对象复制到 to 空间。然后两个空间角色对换(又称反转)。 该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。 老生代采用 Mark-Sweep(标记清除)和 Mark-Compact(标记整理) 标记-清除算法，定期执行一下“垃圾回收”步骤： 垃圾回收器获取根并“标记”它们 然后访问并标记所有来自它们的引用 然后访问标记的对象 并 标记它们的引用 以此类推，知道有为访问的引用为止 除了标记的对象外，所有对象都被删除。 Mark-Compact 算法(标记整理) 标记清除存在一个问题，清除死亡对象后会造成内存空间不连续，这时候 v8 会使用Mark-Compact 算法(标记整理)，它会在标记完成之后将活着的对象往一端移动，移动完成后直接清理掉边界外的内存。 Reference Counting(引用计数算法) 引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为 0 则直接回收内存。 很明显，引用计数最大的优势是暂停时间短 优化 增量回收：如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分，然后各个部分分别执行，这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。 空闲时间收集：垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。 v8 的内存限制 64 位系统最大约为 1.4G 32 位系统最大约为 0.7G","link":"/2019/10/19/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"title":"JS每日一题","text":"设计 LazyMan 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 题目LazyMan(&quot;Tony&quot;) .eat(&quot;lunch&quot;) .eat(&quot;dinner&quot;) .sleepFirst(5) .sleep(10) .eat(&quot;junk food&quot;);// 输出：// Hi I am Tony// 等待了5秒...// I am eating lunch// I am eating dinner// 等待了10秒...// I am eating junk food// 实现：class LazyManClass { constructor(name) { console.log(`Hi I am ${name}`); this.taskList = []; setTimeout(() =&gt; { this.next(); }, 0); } eat(food) { const that = this; const fn = ((f) =&gt; { return function () { console.log(`I am eating ${f}`); that.next(); }; })(food); this.taskList.push(fn); return this; } sleep(time) { const that = this; const fn = ((t) =&gt; { return function () { setTimeout(() =&gt; { console.log(`等待了${t}秒...`); that.next(); }, t * 1000); }; })(time); this.taskList.push(fn); return this; } sleepFirst(time) { const that = this; const fn = ((t) =&gt; { return function () { setTimeout(() =&gt; { console.log(`等待了${t}秒...`); that.next(); }, t * 1000); }; })(time); this.taskList.unshift(fn); return this; } // 负责执行任务队列 next() { const fn = this.taskList.shift(); fn &amp;&amp; fn(); }}function LazyMan(name) { return new LazyManClass(name);} 按照规则解析字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 输入一串数字字符串，经过解析// 如果连续数字的话，就取连续的第一个数和最后一个数，中间用 ～ 隔开// 如果不连续就用 ， 隔开// 输入 '1， 2， 3， 5， 7， 8， 10'，输出'1~3, 5, 7~8, 10'function getValue(str) { const arr = str.split(&quot;,&quot;).map((i) =&gt; +i); const result = []; let tmp = arr[0]; arr.forEach((item, index, self) =&gt; { if (item + 1 !== self[index + 1]) { if (tmp !== item) { result.push(`${tmp}~${item}`); } else { result.push(item); } tmp = self[index + 1]; } }); return result.join();}const str = &quot;1,2,3,5,7,8,9&quot;;getValue(str);// 正则function getValue2(str) { const arr = str.split(&quot;,&quot;).map((i) =&gt; +i); const target = arr.reduce((pre, cur, index, self) =&gt; { if (index &gt; 0) { if (cur - 1 === self[index - 1]) { return `${pre}~${cur}`; } else { return `${pre},${cur}`; } } else { return cur; } }, &quot;&quot;); return target .split(&quot;,&quot;) .map((item) =&gt; { // 1~2~3~4~5 =&gt; 1~5 const reg = /(\\d{1,})(~\\d{1,})*(~\\d{1,})/; return item.replace(reg, &quot;$1$3&quot;); }) .join();}const str = &quot;1,2,3,5,7,8,9&quot;;getValue2(str); this 全面考察12345678910111213141516171819202122232425262728293031var name = &quot;window&quot;;var person1 = { name: &quot;person1&quot;, show1: function () { console.log(this.name); }, show2: () =&gt; console.log(this.name), show3: function () { return function () { console.log(this); }; }, show4: function () { return () =&gt; console.log(this.name); },};var person2 = { name: &quot;person2&quot; };person1.show1(); // person1person1.show1.call(person2); // person2person1.show2(); // windowperson1.show2.call(person2); // windowperson1.show3()(); // window {}person1.show3().call(person2); // person2 {}person1.show3.call(person2)(); // window {}person1.show4()(); // 'person1'person1.show4().call(person2); // 'person1'person1.show4.call(person2)(); // 'person2' 大数相加123456789101112131415161718192021222324252627282930// 6453234253452432 + 7326362323251323function bigNumberSum(str1, str2) { const arr1 = str1.split(&quot;&quot;).reverse(); const arr2 = str2.split(&quot;&quot;).reverse(); const length = Math.max(arr1.length, arr2.length); let result = []; let flag = 0; for (let i = 0; i &lt; length; i++) { const num1 = Number(arr1[i]) || 0; const num2 = Number(arr2[i]) || 0; let sum = num1 + num2 + flag; if (sum &gt;= 10) { sum = sum % 10; flag = 1; } else { flag = 0; } result.push(sum); } if (flag) { result.push(flag); } return result.reverse().join(&quot;&quot;);}bigNumberSum(&quot;6453234253452432&quot;, &quot;7326362323251323&quot;); 多个异步函数如何同步执行？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 异步函数之间有关联关系// 前一个异步函数的输出作为后一个异步函数的输入// 同步方法的处理const pipeFunctions = (...fns) =&gt; { return fns.reduce((preFn, curFn) =&gt; { return (...args) =&gt; { const res = preFn(...args); return curFn(res); }; });};const add = (x) =&gt; x + 5;const multiply = (x) =&gt; x * 5;const subtraction = (x) =&gt; x - 5;const division = (x) =&gt; x / 5;const targetFn = pipeFunctions( add, // 10 multiply, // 50 subtraction, // 45 division // 9);targetFn(5); // 9// ---------// 异步方法的处理const pipeFunctions2 = (...fns) =&gt; { return fns.reduce((preFn, curFn) =&gt; { return async (...args) =&gt; { const res = await preFn(...args); return curFn(res); }; });};const asyncFn = (v) =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(v); }, Math.random() * 1000); });};const add = async (x) =&gt; await asyncFn(x + 5);const multiply = async (x) =&gt; await asyncFn(x * 5);const subtraction = async (x) =&gt; await asyncFn(x - 5);const division = async (x) =&gt; await asyncFn(x / 5);const targetFn2 = pipeFunctions2( add, // 10 multiply, // 50 subtraction, // 45 division // 9);await targetFn2(5); // 9 找出数组中唯一落单的数（只出现一次的数）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// [1, 4, 3, 3, 2, 4, 1] =&gt; 2/** * 方法1: * 利用object的key-value特性存储数据， * 找出value值为1对应的key值 */function getUnique(arr) { let obj = {}; for (let item of arr) { if (!obj[item]) { obj[item] = 1; } else { obj[item]++; } } for (let key in obj) { if (obj[key] === 1) { return +key; } }}const arr = [1, 4, 3, 3, 2, 4, 1];getUnique(arr);/** * 方法2: * 如果第一个值第一次出现的位置和最后一次出现的位置相同 * 那么这个值就只出现了一次 */function getUnique2(arr) { return arr.filter((item) =&gt; arr.indexOf(item) === arr.lastIndexOf(item))[0];}const arr = [1, 4, 3, 3, 2, 4, 1];getUnique2(arr);/** * 方法3:数字的异或运算 * 两个相同的数字进行异或运算得到 0 * 0 与任何 a 异或运算都将得到 a 本身 */function getUnique3(arr) { let result = 0; for (let i = 0; i &lt; arr.length; i++) { result ^= arr[i]; } return result;}const arr = [1, 4, 3, 3, 2, 4, 1];getUnique3(arr); a==1 &amp;&amp; a==2 &amp;&amp; a==312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 1.with 语句let i = 1;with ({ get a() { return i++; },}) { if (a == 1 &amp;&amp; (a == 2) &amp; (a == 3)) { console.log(&quot;Are you kidding me?&quot;); }}// 2.隐式转换// 核心：对象类型转换为原始类型，处理逻辑：// 1. 调用[Symbol.toPrimitive]，转换成功则结束，否则执行2// 2. 调用valueOf，转换成功则结束，否则执行3// 3. 调用toString，转换成功则结束，否则执行4// 4. 如果都没有转换成原始类型，则抛出异常let a = { value: 1, [Symbol.toPrimitive]() { return this.value++; }, valueOf() { return this.value++; }, toString() { return this.value++; },};if (a == 1 &amp;&amp; (a == 2) &amp; (a == 3)) { console.log(&quot;Are you kidding me?&quot;);}// 3.数组类型的隐式转换// 数组类型转换为基本类型时，会调用toString方法// toString会调用join方法let a = [1, 2, 3];a.join = a.shift;if (a == 1 &amp;&amp; (a == 2) &amp; (a == 3)) { console.log(&quot;Are you kidding me?&quot;);}// 4.Object.defineProperty进行数据劫持let i = 1;Object.defineProperty(window, &quot;a&quot;, { get() { return i++; },});if (a == 1 &amp;&amp; (a == 2) &amp; (a == 3)) { console.log(&quot;Are you kidding me?&quot;);}// 5.方法劫持-Proxyconst a = new Proxy( { x: 1 }, { get(target) { return () =&gt; target.x++; }, });if (a == 1 &amp;&amp; (a == 2) &amp; (a == 3)) { console.log(&quot;Are you kidding me?&quot;);}// 隐藏字符 半形朝鲜文填充符 (U+FFA0)const ifﾠ = () =&gt; !0;let a = 0;ifﾠ(a == 1 &amp;&amp; (a == 2) &amp; (a == 3));{ console.log(&quot;Are you kidding me?&quot;);} 合并多个对象1234567891011121314const obj1 = { a: 1, b: 2 };const obj2 = { b: 3, c: 4 };// 1. Object.assign()// 同名属性会覆盖// 第一个参数如果不为对象，需要转换为对象，转换失败会报错// 非第一个参数，剩余参数不为对象也要转换为对象，转换失败直接忽略const result1 = Object.assign(obj1, obj2);console.log(result1);// 2. 扩展运算符// 同名属性覆盖// 如果第一个参数不为对象，直接忽略const result2 = { ...obj1, ...obj2 };console.log(result2); Object.fromEntries123456789101112131415161718192021222324// 对象互转const obj = { a: &quot;1&quot;, b: &quot;2&quot;,};const entries = Object.entries(obj);console.log(entries); //[[&quot;a&quot;,&quot;1&quot;],[&quot;b&quot;,&quot;2&quot;]]Object.fromEntries(entries); //{a: '1', b: '2'}// map -&gt; 对象const map = new Map();map.set(&quot;a&quot;, 1);map.set(&quot;b&quot;, 2);console.log(map); //{'a' =&gt; 1, 'b' =&gt; 2}Object.fromEntries(map); //{a: 1, b: 2}// 过滤对象const course = { math: 79, english: 85, chinese: 90,};const result = Object.entries(course).filter(([key, value]) =&gt; value &gt; 80);Object.fromEntries(result); // {english: 85, chinese: 90} 去掉空格123456789101112const str = &quot; foo &quot;;// 正则str.replace(/^\\s+/g, &quot;&quot;); // 去掉前面空格str.replace(/\\s+$/g, &quot;&quot;); //去掉后面空格// 去掉前面空格str.trimStart();str.trimLeft();// 去掉后面空格str.trimEnd();str.trimRight();// 去掉前后空格str.trim();","link":"/2022/04/15/JS%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"title":"jQuery学习","text":"jQuery 学习 入口函数 jQuery 入口函数 1234567$(document).ready(function(){ //执行代码})或者（简写）$(function(){ //执行代码}) javascript 入口函数 123window.onload = function(){ //执行代码} jQuery 的入口函数是在 html 的所有标签 DOM 都加载之后，就会执行包裹的代码，可以执行多次，并且不会覆盖上次。 javascript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完成后，才会执行，只能执行一次，如果第二次会把第一次的执行覆盖。 jQuery 选择器 元素选择器 1$(&quot;p&quot;) id 选择器 1$(&quot;#test&quot;) class 选择器 1$(&quot;.test&quot;) 属性选择器 1$(&quot;[href]&quot;) :empty 选择器 123$(&quot;:empty&quot;)//选择空的元素，既不不含子元素也不包含文本的元素$(&quot;div:empty&quot;) //选择div中为空的div元素 :parent 选择器 12$(&quot;td:parent&quot;)//选取所有带有子元素或文本的&lt;td&gt;标签元素 :contains 选择器 12$(&quot;div:contains('hello')&quot;)//找到div中包含文本hello的指定元素 :has 选择器 12$(&quot;div:has(p)&quot;)//找到包含p标签元素的div 补充 1$(&quot;:button&quot;) //获取所有type为button的&lt;input&gt;元素和&lt;button&gt;元素，去掉冒号，只能获取&lt;button&gt;元素。 常用 jQuery 事件方法 click() 点击事件 123$(&quot;p&quot;).click(function(){ $(this).hide();}) dblclick() 双击事件 123$(&quot;p&quot;).dblclick(function(){ $(this).hide();}) mouseenter() 鼠标指针穿过元素时 123$(&quot;p&quot;).mouseenter(function(){ alert(&quot;您的鼠标移到了p标签元素上！&quot;)}) mouseleave() 鼠标指针离开元素时 123$(&quot;p&quot;).mouseleave(function(){ alert(&quot;您的鼠标离开了该p标签元素！&quot;)}) mouseup() 当在元素上松开鼠标时 123$(&quot;p&quot;).mouseup(()=&gt;{ alert(&quot;鼠标在p标签上松开！&quot;)}) hover() 模拟光标悬停事件 12345678$(&quot;p&quot;).hover( function(){ alert(&quot;你进入了p标签！&quot;); }, function(){ alert(&quot;你离开了p标签！&quot;); }) focus() 当元素获得焦点时 123$(&quot;input&quot;).focus(function(){ $(this).css(&quot;background-color&quot;,&quot;#ccc&quot;);}) blur() 当元素失去焦点时 123$(&quot;input&quot;).blur(function(){ $(this).css(&quot;background-color&quot;,&quot;#fff&quot;);}) keypress,keydown,keyup 123456789101112131415161718//获取按键代码或ASCII码$(window).keydown(function(event){ //通过event.which可以拿到按键代码，如果是keypress事件中则拿到ASCII码。 console.log(event);})//获取事件对象$(window).keypress(function(event){ //获取事件对象，里面包含各种有用的信息。 console.log(event); //console.log(event.which);});//keypress事件获取键入的字符$(window).keypress(function(event){ //event.which是获取ASCII码，前面的函数是将ASCII码转换成字符，空格键和Enter键输出均为空白。 console.log(String.fromCharCode(event.which)); //从event对象中key属性获取字符，但是Enter键的key值为&quot;Enter&quot;，空白键还是空白&quot; &quot;。 console.log(event.key);}); off() 事件移除 12345$(&quot;button&quot;).off() //移除所有button元素身上绑定的事件$(&quot;button&quot;).off(&quot;click&quot;) //移除所有的click事件，移除指定类型$(&quot;button&quot;).off(&quot;click&quot;, test) //移除click事件中的test回调方法，移除指定类型的事件 阻止事件冒泡 123456789$(&quot;.son&quot;).click(function(event){ alert(&quot;son&quot;) //return false; event.stopPropagation(); //阻止事件冒泡})$(&quot;.father&quot;).click(function(){ alert(&quot;father&quot;)}) 阻止默认行为 12345//a标签跳转、submit提交按钮等$(&quot;a&quot;).click(function(event){ alert(&quot;弹出注册框！&quot;); event.preventDefault();}) trigger()、triggerHandler() 自动触发事件 12345678910111213//触发绑定到被选元素的所有事件$(&quot;.father&quot;).click(function(){ alert(&quot;father&quot;);})$(&quot;.father&quot;).trigger(&quot;click&quot;); //方法一:会触发事件冒泡$(&quot;.father&quot;).triggerHandler(&quot;click&quot;); //方法二:只触发事件，不会触发事件冒泡-------------------------------$(&quot;input[type='submit']&quot;).click(function(){ alert(&quot;submit&quot;);})$(&quot;input[type='submit']&quot;).trigger(&quot;click&quot;); //方法一：触发事件的同时，还会触发默认行为。$(&quot;input[type='submit']&quot;).triggerHandler(&quot;click&quot;) //方法二：只触发事件，不触发默认行为。//注意：这里&lt;a&gt;标签有点特殊，这两个方法都不会触发默认行为，如果想使用trigger()触发&lt;a&gt;标签的事件和默认行为的话，可以在&lt;a&gt;标签中添加一个&lt;span&gt;,例如&lt;a href =&quot;#&quot;&gt;&lt;span&gt;百度&lt;/span&gt;&lt;/a&gt; 这种写法。 自定义事件 1234567891011121314/** 想要自定义事件，必须满足两个条件* 1.事件必须是通过on绑定的* 2.事件必须通过trigger来触发*/$(&quot;.son&quot;).on(&quot;myClick&quot;,function(){ alert(&quot;son&quot;);})$(&quot;.son&quot;).trigger(&quot;myClick&quot;);or$(&quot;.son&quot;).triggerHandler(&quot;myClick&quot;); 事件命名空间 12345678910111213141516/** 想要事件的命名空间有效，必须满足两个条件* 1.事件通过on来绑定(自定义事件)* 2.通过trigger()或者triggerHandler()来触发*/$(&quot;.son&quot;).on(&quot;eventName.zs&quot;,function(){ alert(&quot;click zhangsan&quot;);})$(&quot;.son&quot;).on(&quot;eventName.ls&quot;,function(){ alert(&quot;click lisi&quot;);})$(&quot;.son&quot;).trigger(&quot;click.zs&quot;);or$(&quot;.son&quot;).triggerHandler(&quot;click.zs&quot;); 隐藏和显示 hide() 隐藏 html 元素 123$(&quot;#hide&quot;).click(function(){ $(&quot;p&quot;).hide();}) show() 显示 html 元素 123$(&quot;#show&quot;).click(function(){ $(&quot;p&quot;).show();}) 语法 12345678910111213141516$(selector).hide(speed,callback);$(selector).show(speed,callback);//可选的speed参数表示规定显示/隐藏的速度(slow、fast、毫秒)//可选的callback参数是隐藏或显示完成后所执行的函数名称$(&quot;.hidebtn&quot;).click(function(){ $(&quot;div&quot;).hide(1000,&quot;linear&quot;,function(){ alert(&quot;Hide() 方法已完成!&quot;); });});//第二个参数是一个字符串，表示过渡使用哪种缓动函数，jQuery自身提供(linear、swing)//补充：callback函数名后面加上括号，会立刻执行函数体，而不是等到显示/隐藏之后才执行,如add()作为callback参数会立即执行，而add作为参数则不会，callback函数可以是匿名函数，$(selector)选中的元素个数为n个，则callback函数会执行n次。 toggle() 切换 hide()和 show()方法 123$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).toggle();}) 淡入淡出 fadeIn() 用于淡入以隐藏的元素 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeIn(3000);})//语法： $(selector).fadeIn(speed, callback)// 可选的speed参数规定效果的时长(slow、fast、毫秒)// 可选的callback参数是fading完成后所执行的函数名称 fadeOut() 用于淡出可见元素 12345678$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeOut(&quot;slow&quot;);})//语法： $(selector).fadeOut(speed, callback)// 可选的speed参数规定效果的时长(slow、fast、毫秒)// 可选的callback参数是fading完成后所执行的函数名称 fadeToggle() 用于在 fadeIn()与 fadeOut()方法之间进行切换 12345678$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeToggle();})//语法： $(selector).fadeToggle(speed, callback)// 可选的speed参数规定效果的时长(slow、fast、毫秒)// 可选的callback参数是fading完成后所执行的函数名称 fadeTo() 允许渐变为给定的不透明度 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.3);})//语法：$(selector).fadeTo(speed, opacity, callback)//必须的speed参数规定效果时长(slow、fast、毫秒)//必须的opacity规定不透明度(介于0-1之间) 滑动方法 slideDown() 用于元素向下滑动 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).slideDown();})//语法：$(selector).slideDown(speed,callback)//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。//可选的 callback 参数是滑动完成后所执行的函数名称。 slideUp() 用于元素向上滑动 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).slideUp();})//语法：$(selector).slideUp(speed,callback)//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。//可选的 callback 参数是滑动完成后所执行的函数名称。 slideToggle() 在 slideDown()与 slideUp()方法之间进行切换 1234567$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).slideToggle();})//语法：$(selector).slideToggle(speed,callback)//可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。//可选的 callback 参数是滑动完成后所执行的函数名称。 动画 animate()方法 123456789101112131415//默认情况下，所有html元素都有一个静态位置，且无法移动。//先将p标签元素设置为position:relative/absolute/fixed$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).animate({ left:'250px', opacity:'0.5', height:'400px', width: '400px', paddingLeft:'10px' });});//语法： $(selector).animate({params},speed,callback)// params参数可以操作几乎所有的css属性，但名字要采用camel标记法 stop() 停止动画 1234567891011 $(&quot;#flip&quot;).click(function(){ $(&quot;#panel&quot;).slideDown(5000); });$(&quot;#stop&quot;).click(function(){ $(&quot;#panel&quot;).stop();});语法: $(selector).stop(stopAll,goToEnd)//可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停/止活动的动画，允许任何排入队列的动画向后执行。//可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 jQuery 方法链接 123$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;) .slideUp(2000) .slideDown(2000); jQuery 获取内容和属性 获取内容 text()、html()、val() text() 设置或返回所选元素的文本内容 html() 设置或返回所选元素的内容(包括 html 标记) val() 设置或返回表单字段的值 1234567891011$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).text());})//-----------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).html())})//------------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;input&quot;).val());}); 获取属性 attr() 12345//项目QC刚用过$(&quot;button&quot;).click(function(){ console.log($(&quot;p&quot;).attr(&quot;data-text&quot;));}) 补充： 12345prop()函数返回相应属性或空字符串。attr()函数返回相应属性或undefined1.对于HTML元素本身就带有的固有属性，在处理时使用prop方法2.对HTML元素我们自己定义的DOM属性，在处理时使用attr方法3.具有true和false两个属性的属性，如checked、selected或者disabled使用prop() 设置内容和属性 设置内容 text()、html()、val() 1234567891011$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).text(&quot;hello&quot;));})//-----------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;p&quot;).html(&quot;hello&quot;))})//------------------------------$(&quot;button&quot;).click(function(){ alert($(&quot;input&quot;).val(&quot;hello&quot;));}); text()、html() 以及 val() 的回调函数 123456789$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).text(function(i,orignText){ //i 为被选元素列表中当前元素的下标 //orignText 为原来的值 //return 为返回的新值 return &quot;hello&quot; })}) 设置属性 attr() 12345678910$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).attr(&quot;data-text&quot;,&quot;hello world&quot;);})// 允许同时设置多个属性$(&quot;button&quot;).click(function(){ $(&quot;p&quot;).attr({ &quot;data-text&quot;,&quot;hello world&quot;, &quot;title&quot;,&quot;jQuery学习！&quot; });}) attr() 也存在回调函数(同上) 12345$(&quot;button&quot;).click(function(){ $(&quot;#runoob&quot;).attr(&quot;href&quot;, function(i,origValue){ return origValue + &quot;/jquery&quot;; });}); 删除属性 removeAttr() 12$(&quot;span&quot;).removeAttr(&quot;class name&quot;);//表示同时删除span标签的class和name属性 removeProp() 12$(&quot;span&quot;).removeProp(&quot;class&quot;);//表示删除所有span标签的class属性 jQuery 添加元素 append/prepend 是在选择元素内容嵌入(文本或标签) after/before 实在元素外部追加(文本或标签) 参数可以是多个，可以是一个 list jQuery 删除元素 remove() 方法 123$(&quot;p&quot;).remove()//remove() 方法删除被选元素及其子元素 empty() 方法 123$(&quot;p&quot;).empty()//empty() 方法删除被选元素的子元素而不删除自身 过滤被删除的元素 1234$(&quot;p&quot;).remove(&quot;.italic&quot;)//表示删除所有&lt;p&gt;标签元素中class = &quot;italic&quot;的元素//过滤时，只能作用于同级元素之间 jQuery 获取并设置 CSS 类 addClass() 向不用的元素添加 class 属性，在添加类时可以选取多个元素,也可以设置多个类。 123$(&quot;button&quot;).click(function(){ $(&quot;h1, h3, p&quot;).addClass(&quot;fontColor fontSize&quot;);}) removeClass() 在不同元素中删除指定的 class 属性 123$(&quot;button&quot;).click(function(){ $(&quot;h1, h3, p&quot;).removeClass(&quot;fontSize&quot;);}) toggleClass() 对被选元素进行添加/删除类的切换操作 123$(&quot;.btn2&quot;).click(function(){ $(&quot;h1, h3, p&quot;).toggleClass(&quot;fontColor2&quot;);}) css() 方法 返回 css 属性 1$(&quot;p&quot;).css(&quot;background-color&quot;); 设置 css 属性,可以同时设置多个 1$(&quot;p&quot;).css({&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;}); 尺寸 width()、height() width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距） height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 12$(&quot;p&quot;).width() //获取$(&quot;p&quot;).width(20) //设置 innerWidth()、innerHeight() innerWidth() 方法返回元素的宽度（包括内边距）。 innerHeight() 方法返回元素的高度（包括内边距）。 outerWidth()、outerHeight() outerWidth() 方法返回元素的宽度（包括内边距和边框）。 outerHeight() 方法返回元素的高度（包括内边距和边框）。 offset() 12345$(&quot;.son&quot;).offset().left //元素距离窗口的偏移距离$(&quot;.son&quot;).offset({ left: 20,}) //设置元素距离窗口的偏移距离 position() 123$(&quot;.son&quot;).position().left //获取元素距离定位元素的偏移距离// 注意点：position() 方法只能获取不能设置 scrollTop() 123456789$(&quot;scroller&quot;).scrollTop() //获取元素相对滚动条顶部的偏移$(&quot;scroller&quot;).scrollTop(300) //设置元素相对滚动条顶部的偏移//获取网页滚动的偏移(考虑兼容)$(&quot;body&quot;).scrollTop() + $(&quot;html&quot;).scrollTop() //ie-&gt;body,chrome...-&gt;html//设置网页滚动的偏移(考虑兼容)$(&quot;html,body&quot;).scrollTop(300) 补充：设置了 box-sizing 后，width()=width - padding - border jQuery 遍历祖先 parent() 返回元素的直接父元素 123$(document).ready(function(){ $(&quot;span&quot;).parents();}) parents() 返回被选元素的所有祖先元素，直到文档根元素 1234567$(document).ready(function(){ $(&quot;span&quot;).parents();})//过滤所有祖先，并且是&lt;ul&gt;元素$(document).ready(function(){ $(&quot;span&quot;).parents(&quot;ul&quot;);}) parentsUntil() 返回给定的两个元素之间的所有祖先元素 1234//返回&lt;span&gt;与&lt;div&gt;元素之间的所有祖先元素$(document).ready(function(){ $(&quot;span&quot;).parentsUntil(&quot;div&quot;);}) 后代 children() 返回被选元素的所有直接子元素 1234$(&quot;div&quot;).children();//可以使用可选参数来过滤子元素的搜索$(&quot;div&quot;).children(&quot;p.aaa&quot;); //返回类名为aaa的&lt;p&gt;元素，且是div的直接子元素。 find() 返回被选元素的后代元素，一路向下直到最后一个后代 1$(&quot;div&quot;).find(&quot;span&quot;); 同胞 siblings() 返回被选元素的所有同胞元素，可以使用可选参数过滤搜索。 next() 返回被选元素的下一个同胞元素，只返回一个元素 nextAll() 返回被选元素的所有跟随的同胞元素 nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素 pre()、prevAll()、prevUntil() 同上，方向相反 过滤：缩小搜索元素的范围 first() 返回被选元素的首个元素 1$(&quot;p&quot;).first(); last() 返回被选元素的最后一个元素 1$(&quot;p&quot;).last(); eq() 返回被选元素中带有指定索引号的元素 123$(&quot;p&quot;).eq(1);//索引号从0开始，eq(1)选择的是第二个&lt;p&gt;元素 filter() 允许规定一个标准，返回匹配的元素 123$(&quot;p&quot;).filter(&quot;.className&quot;);//返回带有类名className的所有&lt;p&gt;元素 not() 返回所有不匹配的元素，与 filter()相反 123$(&quot;p&quot;).not(&quot;.className&quot;);//返回所有不带有类名className的&lt;p&gt;元素","link":"/2020/09/05/Jquery%E5%AD%A6%E4%B9%A0/"},{"title":"JavaScript中判断数据类型","text":"JavaScript 中判断数据类型的几种方法 一、typeof 直接返回数据类型，但是无法判断数组、null、对象 1234567891011121314151617181920212223typeof 1&quot;number&quot;typeof NaN&quot;number&quot;typeof &quot;1&quot;&quot;string&quot;typeof true&quot;boolean&quot;typeof undefined&quot;undefined&quot;typeof null&quot;object&quot;typeof []&quot;object&quot;typeof {}&quot;object&quot; 其中，null、[]、{}都返回“object”。null可是原始数据类型的啊，怎么就是'object' 了呢？？原来这个已经是历史问题了，在 JS 的最初版本中使用的是 32 位系统，为了性能 考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零， 所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 二、instanceof检测的是 原型，只能用来判断两个对象是否属于实例关系，而不能判断 一个对象实例具体属于哪种类型 MDN: instanceof 运算符用于测试构造函数的prototype属性是否出现在对象的原型链中。 f instanceof Foo 的判断逻辑为： f 的 __proto__ 一层一层往上，是否能找到对应的Foo.prototype 之后再判断f instanceof Object 如何判断一个数组？ 方法1：instanceof arr instanceof Array 方法2：Array.isArray() Array.isArray([]) 三、constructor当一个函数被定义时，JS引擎会为其添加prototype原型，然后再再prototype上添加一个 constructor属性，并让其指向该函数的引用，在实例对象的__proto__属性上面。 null 和 undefined 是无效的对象，因此是不会有constructor存在的，这两种类型需要其他方式 1234567function F(){}var f = new Ff.constructor == F //trueF.prototype = {a:1}var f = new Ff.constructor == F //false 函数的constructor是不稳定的，主要体现在自定义对象上，当开发者重写prototype时， 原有的constructor引用会丢失，constructor会默认为Object 因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证 对象实例的类型不被篡改 四、使用 Object.prototype.toString.call()判断call()方法可以改变this的指向，把Object.prototype.toString.call()方法指向 不同的数据上面，返回不同的结果。 1234567891011121314151617181920212223242526Object.prototype.toString.call(1)&quot;[object Number]&quot;Object.prototype.toString.call(NaN);&quot;[object Number]&quot;Object.prototype.toString.call(&quot;1&quot;);&quot;[object String]&quot;Object.prototype.toString.call(true)&quot;[object Boolean]&quot;Object.prototype.toString.call(null)&quot;[object Null]&quot;Object.prototype.toString.call(undefined)&quot;[object Undefined]&quot;Object.prototype.toString.call(function a() {});&quot;[object Function]&quot;Object.prototype.toString.call([]);&quot;[object Array]&quot;Object.prototype.toString.call({});&quot;[object Object]&quot; 最后我们可以定义一个完美的判断数据类型的方法_typeof() 1234567891011121314151617181920212223242526272829303132333435function _typeof(obj){ var s = Object.prototype.toString.call(obj); return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();};_typeof([12,3,343]);&quot;array&quot;_typeof({name: 'zxc', age: 18});&quot;object&quot;_typeof(1);&quot;number&quot;_typeof(&quot;1&quot;);&quot;string&quot; _typeof(null);&quot;null&quot;_typeof(undefined);&quot;undefined&quot;_typeof(NaN);&quot;number&quot;_typeof(Date);&quot;function&quot;_typeof(new Date());&quot;date&quot;_typeof(new RegExp());&quot;regexp&quot;","link":"/2019/07/16/JavaScript%E4%B8%AD%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"JavaScript什么时候必须加分号？","text":"JavaScript 什么时候必须加分号？ 当一行代码以 ( 开头的时候，在前面补一个分号避免一些语法错误 123456789function say() { console.log('hello world')}say();(function () { console.log('hello')})() 当一行代码以 [ 开头的时候 123;['hello', 'world'].forEach(function (item) { console.log(item)}) 当一行代码以 ` 开头的时候 1;`hello`.toString()","link":"/2019/08/07/JavaScript%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BF%85%E9%A1%BB%E5%8A%A0%E5%88%86%E5%8F%B7%EF%BC%9F/"},{"title":"Node.js之http","text":"创建一个简单的 http 服务 123456789101112131415//加载http核心模块var http = require('http')var server = http.createServer()//服务器要做的处理事情server.on('request', function() { console.log('收到客户端的请求了')})//绑定端口号，启动服务器server.listen(3000, function(){ console.log('server start.....')}) 请求处理123456789101112131415161718192021222324252627var http = require('http')var server = http.createServer()//request 请求处理函数，需要接受两个参数server.on('request', function(request, response) {// request 请求对象// 请求对象可以获取客户端的一些请求信息，如请求路径 console.log('收到客户端的请求了,路径是：'+ request.url)// response 响应对象// 响应数据只能是二进制数据或者字符串// 响应对象可以用开给客户端发送响应消息// response对象中：write给客户端发送响应数据，最后使用end结束 response.write('hello') response.write(' nodejs ') response.end(request.url)// 或者直接end的同时发送响应数据：// response.end('hello nodejs')})server.listen(3000, function(){ console.log('server start.....')}) Content-Type 设置编码123456789101112var http = require('http')var server = http.createServer()server.on('request',function (req,res) { //设置服务器响应内容的编码 res.setHeader('Content-Type','text/plain;charset=utf-8') res.end('hello 世界')})server.listen(3000, function () { console.log('server is running...')})","link":"/2019/09/06/Node-js%E4%B9%8Bhttp/"},{"title":"Node.js之mongoDB","text":"开启 MongoDB 服务器 1mongod 连接 MongoDB 服务器1mongo 退出 MongoDB 服务器1exit 基本命令 show dbs 查看显示所有数据库 db 产看当前操作的数据库 use 数据库名称 切换到指定的数据库（没有会新建） show collections 显示集合 db.cats.find() 查看并显示内容 node 中使用 mongodb 使用第三方 mongoose 来操作 MongoDB 数据库 mongoose 安装npm install mongoose 123456789101112131415//引入包const mongoose = require('mongoose');//连接数据库（数据库不需要存在，在插入第一条语句，就会自动创建）mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});//设计数据库集合结构//创建一个Cat表const Cat = mongoose.model('Cat', { name: String });//实例化一个Cat，实例对象为kittyconst kitty = new Cat({ name: 'Zildjian' });//持久化保存kitty实例kitty.save().then(() =&gt; console.log('meow')); mongoose 的基本使用 生成模型构造函数 1234567891011121314151617181920212223242526272829303132333435var mongoose = require('mongoose');var Schema = mongoose.Schema;//设计集合结构（表结构）schema---&gt;提要，纲要//字段名称就是表结构中的属性名称//值类型//约束的目的：为了保证数的完整性var blogSchema = new Schema({ title: String, author: String, body: String, username: { type: String, required: true }, password: { typte: String, required: true } comments: [{ body: String, date: Date }], date: { type: Date, default: Date.now }, hidden: Boolean, meta: { votes: Number, favs: Number }});//将文档结构发布为模型// 参数一：大写单数表示数据库名称// mongoose会自动将大写单数改为小写复数// 参数二： 架构 Schema// 返回值： 模型构造函数var User = mongoose.model('User', blogSchema)// module.exports = mongoose.model('Student', blogSchema) 基于模型构造函数 生成添加一条数据 123456789101112var admin = new User({ username: 'admin', password: '1245435', ....})admin.save(function(err, ret){ if(err){ console.log('保存失败') } else { console.log('保存成功') }}) 基于模型构造函数 查询数据 12345678910111213141516171819202122232425262728293031323334353637//查询所有数据User.find(function(err, ret){ if(err){ console.log('查询失败') } else { console.log(ret) }})//promise 查询所有User.find() .then(function(data){ console.log(data) })//按条件查询 User.find({ username: 'xx' }, function(err, ret){ if(err){ console.log('查询失败') } else { console.log(ret) }})//查找符合条件的第一个（可以写多个条件）,没有条件的话，为第一条数据 User.findOne({ username: 'xx' }, function(err, ret){ if(err){ console.log('查询失败') } else { console.log(ret) }}) 基于模型构造函数 按条件更新数据 1234567891011//Model.update(conditions, doc, [options], [callback])//Model.findOneAndUpdate([conditions], [update], [options], [callback])User.findByIdAndUpdate('5a7d8f2sd78ag6g',{ username: 'zs'}, function(err, ret){ if(err){ console.log('更新失败') else { console.log('更新成功') }}) 基于模型构造函数 删除数据 123456789User.remove({ username: 'zs'}, function(err, ret){ if(err){ console.log('查询失败') else { console.log(ret) }}) 补充（node 使用 mysql）123456789101112131415161718192021222324252627//引包var mysql = require('mysql');//创建连接var connection = mysql.createConnection({ host : 'localhost', user : 'me', password : 'secret', database : 'my_db'}); //连接数据库connection.connect(); //执行数据操作,可以直接使用 SQL 语句 //查找connection.query('SELECT * FROM `users`', function (error, results, fields) { if (error) throw error; console.log('The solution is: ', results[0].solution);});//添加 connection.query('INSERT INTO users VALUES(NULL, &quot;admin&quot;:&quot;123&quot;)', function (error, results, fields) { if (error) throw error; console.log('The solution is: ', results[0].solution); }); //关闭数据库connection.end();","link":"/2019/09/09/Node-js%E4%B9%8BmongoDB/"},{"title":"Node.js之实现读写文件操作","text":"用 nodejs 实现读取文件操作 const fs = require(&quot;fs&quot;) //fs 核心模块提供了一个fs.readFile方法，用来读取指定目录下的文件 //fs.readFile有三个参数 // 1. 读取文件的路径 // 2. 读取文件的编码格式 // 3. 当文件读取完成，调用这个callback回调函数来读取文件的结果 fs.readFile('./data/hello.txt','utf-8',function(err,data){ if(err){ console.log(err) //第一个参数是err对象 return } else { console.log(data) //第二个参数才是data数据 } }) 用 nodejs 实现写入文件操作const fs = require('fs') let msg = 'hello world' //fs.writeFile有三个参数 // 1. 第一个参数为写入的文件路径 // 2. 第二个参数为写入的内容 // 3. 第三个参数为可选参数，表示写文件的编码格式 // 4. 第四个参数为回调函数，回调函数只有一个参数err，判断是否写入成功。 fs.writeFile('./data/hello.txt',msg,'utf-8',function(err){ if(err){ console.log('写入错误' + err) } else { console.log('ok') } })","link":"/2019/08/29/Node.js%E4%B9%8B%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"title":"Node.js之特性","text":"Node.js 是什么? Node.js 是一个 JavaScript 运行时环境，可以解析和执行 js 代码。 构建于 Chrome 的 V8 引擎之上 没有 BOM、DOM，有 EcmaScript 语法。 node 中有很多具名的核心模块 fs 文件操作模块 http 服务器构建模块 path 路径模块 os 操作系统信息模块 在核心模块中提供了一些服务器级别的操作 API - 文件读写 - 网络服务的构建 - 网络通信 - http 服务器 node 都有哪些特性？ 单线程 不会为每个用户连接创建一个新的线程，仅仅使用一个线程，减少了操作系统的线程创建和销毁的时间开销。缺点就是一个用户造成线程的崩溃会导致整个服务的崩溃。 减少内存的开销 事件驱动 event-driven node 中一个时刻只能执行一个事件回调函数，但是执行过程中，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。 非阻塞 I/O I/O 数据传输操作会阻塞代码的执行，极大降低了程序的执行效率,因为一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。非阻塞 I/O 机制，可以将异步操作的处理代码放在回调函数中，从而提高了程序的执行效率。 浏览器的进程和线程 一个程序可以有多个进程 一个进程可以有多个线程 进程在执行 u 欧城中拥有独立的内存单元，而多个线程共享内存。 多个线程之间可以相互通信 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口 线程不能独立执行，必须依存在应用程序中 Node.js 适合开发什么？ 善于 I/O,不善于计算，因为 Node.js 最擅长的就是任务调度，不适合于利用 CPU 进行过多的运算的程序。 当应用程序需要处理大量并发的 I/O,而在向客户端发出响应之前，应用程序内部不需要进行非常复杂处理的时候，Node.js 非常合适。 Node.js 也非常适合与 web socket 配合，开发长连接的实时交互应用程序。 用户表单 考试系统 聊天室 图文直播 nodejs 能做什么？ Node.js 可以生成动态页面内容 Node.js 可以创建，打开，读取，写入，删除和关闭服务器上的文件 Node.js 可以收集表单数据 Node.js 可以添加，删除，修改数据库中的数据 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务器渲染可以被爬虫抓取 例如：京东商品列表是服务端渲染，用户评论是客户端渲染（提高用户体验） 小补充：使用 cnpm 方法一 安装 cnpm npm install --global cnpm 方法二 改变 registry npm install jquery --registry=https://registry.npm.taobao.org 方法三 加入配置选项 npm config set registry https://registry.npm.taobao.org npm config list","link":"/2019/08/29/Node.js%E4%B9%8B%E7%89%B9%E6%80%A7/"},{"title":"Promise","text":"Promise promise: 用来解决两个问题： 1. 回调地狱，代码难以维护，不易阅读。 2. promise可以支持多个并发的请求，获取并发请求中的数据。 Promise对象有三个状态：pending(进行中)、fulfilled(已成功)、rejected(已失败) Promise状态一旦改变，结果就定死了，就不会再变了。 all方法： 所有异步操作都执行成功，才会执行成功的回调，有一个失败就会执行失败的回调。 race方法： 谁先执行完就返回谁的状态和回调。 finally() 允许指定最终的逻辑 （ES9新特性） 一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。而在某些情况下 想要在无论成功还是失败运行相同的代码，例如：清除，删除对话，关闭数据库连接等。 这时，.finally()可以允许你指定最终的逻辑 function doSomething() { doSomething1() .then(doSomething2) .then(doSomething3) .catch(err =&gt; { console.log(arr) }) .finally(() =&gt; { // 最终执行逻辑 }) } ========================= //实例演示(node 中读取文件)：var fs = require(‘fs’)var p1 = new Promise(function(resolve, reject){fs.readFile(‘./data/a.txt’, ‘utf8’, function(err, data){if(err){reject(err)} else {resolve(data)}})}) var p2 = new Promise(function(resolve, reject){fs.readFile(‘./data/b.txt’, ‘utf8’, function(err, data){if(err){reject(err)} else {resolve(data)}})}) // 返回 promise 对象时，可以进行链式调用p1.then(function(data){console.log(data)return p2}, function(err){console.log(‘读取文件失败’, err)}).then(function(data){console.log(data)//return p3},function(err){console.log(err)) =====================//用 promise 封装 node 中 readFile APIvar fs = require(‘fs’) function ReadFile(filePath){return new Promise(function(resolve, reject){fs.readFile(filePath, ‘utf8’, function(err, data){if(err){reject(err)} else {resolve(data)}})})} ReadFile(‘./data/a.txt’).then(function(data){console.log(data)}) ======================== //promise 封装 ajax 中 get 请求function pGet(url, callback){return new Promise(function(resolve, reject){var xhr = new XMLHttpRequest()xhr.onload = function(){callback &amp;&amp; callback(JSON.parse(xhr.responseText))resolve(JSON.parse(xhr.responseText))}xhr.onerror = function(err){reject(err)}xhr.open(“get”, url, true) //为 true 则是异步执行xhr.send()})} 手写 promise 1234567891011121314151617181920212223242526272829303132333435363738394041function myPromise(constructor){ let self=this; self.status=&quot;pending&quot; //定义状态改变前的初始状态 self.value=undefined;//定义状态为resolved的时候的状态 self.reason=undefined;//定义状态为rejected的时候的状态 function resolve(value){ //两个===&quot;pending&quot;，保证了状态的改变是不可逆的 if(self.status===&quot;pending&quot;){ self.value=value; self.status=&quot;resolved&quot;; } } function reject(reason){ //两个===&quot;pending&quot;，保证了状态的改变是不可逆的 if(self.status===&quot;pending&quot;){ self.reason=reason; self.status=&quot;rejected&quot;; } } //捕获构造异常 try{ constructor(resolve,reject); }catch(e){ reject(e); }}//同时再myPromise的原型上定义链式调用的then方法：myPromise.prototype.then=function(onFullfilled,onRejected){ let self=this; switch(self.status){ case &quot;resolved&quot;: onFullfilled(self.value); break; case &quot;rejected&quot;: onRejected(self.reason); break; default: }}","link":"/2019/08/12/Promise/"},{"title":"RBAC是什么？","text":"RBAC 是什么? RBAC是基于角色的访问控制(Role-Based Access Control)在RBAC中，权限与角色相关联，用户通过适当角色的成员而得到这些角色的权限，权限赋予给角色，而角色又赋予给用户，这样权限设计的很清楚，管理起来也很方便。","link":"/2022/02/22/RBAC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"},{"title":"React","text":"React 的基本认识 Fecebook 开源的一个 js 库 一个用来动态构建用户界面的 js 库 React 的特点： 声明式编程 组件化编程 高效 单向数据流 支持客户端与服务端渲染 React 高效的原因 虚拟 DOM，不直接操作 DOM(批量更新，减少更新的次数) 高效的 DOM Diff 算法，最小化页面重绘(减小页面更新的区域) React 中的生命周期函数生命周期函数是指组件在某一时刻自动执行的函数 初始化过程（Initialization） 在 constructor()里面初始化 Props 和 State 属性。 getDefaultProps()可以设置组件的默认属性值。 挂载过程（Mounting） componentWillMount(): 在组件即将被挂载到页面的时刻自动执行。 render(): 将组件挂载到页面。 componentDidMount(): 组件被挂载到页面之后立即执行。 更新过程（Updation） componentWillReceiveProps()（在 16.4 版本中废弃，不推荐使用）：一个组件从父组件接受参数，如果这个组件第一次存在父组件中不会执行，已经存在才会执行，如果没有 Props 属性则直接跳过。 shouldComponentUpdate():组件更新前检查是否需要更新组件，返回布尔类型。此生命周期函数可以强制关闭不需要更新的子组件来提高渲染性能。 componentWillUpdate():组件更新之前自动执行。前提是 shouldComponentUpdate()执行并返回 true-render():将组件更新到页面-componentDidUpdate():组件更新完成之后立即执行。 移除过程（Unmounting） componentWillUnmount():当组件即将从页面中移除时执行。 注意事项 React 中的 render() 也是生命周期函数，而 constructor()并不是生命周期函数。 所有的组件都有生命周期函数。 除了 render()函数，其他函数都可以不写，因为除了 render()函数其他函数都是继承自React 中内置的。 AJAX 请求一般都是放在 componentDidMount()里面。 React 状态提升 所谓状态提升，就是将 各个子组件的公共 state 提升到它们的父组件进行统一存储、处理(单一数据源)，然后将父组件处理后的数据或者函数 props 到各个子组件中。 如果子组件要修改父组件中 state 该怎么办？ 做法就是将父组件中负责 setState 的函数，以 props 的形式传给子组件，然后子组件需要改变 state 时调用即可。 React Router React Router 包装了 BrowserRouter 和 HashRouter 两个组件。 BrowserRouter 使用 HTML5 的 history API(pushState、replaceState 等)实现UI 和 URL 的同步 HashRouter 使用 URL 的 hash 实现应用的 UI 和 URL 同步 React Hooks useState 123456789101112131415161718192021222324252627282930313233343536//用法：//useState唯一的参数就是初始state//返回一个数组，第一项state，第二项更新state的函数const [number, setNumber] = useState(0);//函数式更新//如果新的state需要通过使用以前的state计算得出，可以将函数传递给setState。//例如：setCount((count) =&gt; { return count + 1})//惰性初始化state，对复杂初始数据，initialState可以是一个函数//函数或initialState参数只会在组件的初始渲染中起作用function Counter() { const [{name, number},setValue] = useState(() =&gt; { return {name:'计数器',number:0}; }) return ( &lt;div&gt; &lt;p&gt;{name}:{number}&lt;/p&gt; &lt;button onClick={() =&gt; setValue({number: number + 1})}&gt;+&lt;/button&gt; &lt;/div&gt; )}--------------//官网例子const [state, setState] = useState(() =&gt; { const initialState = someExpensiveComputation(props); return initialState;})//useState的初始值，只在第一次有效//按照有序的方式使用useState不得在循环判断等条件语句中使用//useState不会自动合并更新对象，需使用扩展符{...obj,name:'lisi'} useEffect 123456789101112131415161718192021//基本使用//useEffect有两个参数：function(执行项)，array(依赖项)useEffect(() =&gt; {},[name]);//如果依赖项为空数组，只会在第一次挂载后执行，类似componentDidMountuseEffect(() =&gt; {},[]);//清除副作用，模拟componentUnMount//通过返回一个函数来指定如何清除副作用，防止内存泄漏，函数会在组件卸载前执行useEffect(() =&gt; { let timer = setInterVal(() =&gt; { console.log(&quot;定时器&quot;); },1000) return () =&gt; { clearInterval(timer) }},[name])//注意：可以在组件中多次使用useEffect//Hook 允许我们按照代码的用途分离他们，react将按照effect声明的顺序依次调用组件中的每一个effect useContext 1234567891011121314//父组件创建上下文const Context = createContext();//并将数据传递给子组件const [num, setNum] = useState(0);&lt;Context.Provider value={{num, setNum}}&gt; &lt;Children /&gt;&lt;/Context.Provider&gt;//子组件接收const {num, setNum} = useContext(Context);useEffect(() =&gt; { setNum(num + 1);},[])&lt;p&gt;{num}&lt;/p&gt; useReducer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//基础使用const initialState = { count: 0 };function reducer(state, action){ switch(action.type) { case 'increment': return {count:state.count + 1}; case 'decrement': return {count:state.count - 1}; default: throw new Error(); }}function MyUseReducer() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; count: {state.count} &lt;button onClick={() =&gt; dispatch({type:'decrement'})}&gt;+&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type:'increment'})}&gt;+&lt;/button&gt; &lt;/&gt; )}//惰性初始化//稍加改造const initialCount = 0;function init(initialCount) { return {count: initialCount};}function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1}; case 'decrement': return {count: state.count - 1}; case 'reset': return init(action.payload); default: throw new Error(); }}function MyUseReducer() { const [state, dispatch] = useReducer(reducer, initialCount , init); return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({type: 'reset', payload: initialCount})}&gt; Reset &lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt; &lt;/&gt;》》 );}","link":"/2019/07/01/React/"},{"title":"Node.js之express","text":"Node.js 之 express 123456789101112131415161718192021222324//引包var express = require(&quot;express&quot;);//相当于原来的http.createServervar app = express();//公开指定目录app.use(&quot;/puclic/&quot;, express.static(&quot;./public/&quot;));//当省略第一个参数的时候，可以通过省略/public的方式访问//app.use(express.static('./public/'))//当服务器收到get请求 / 的时候，执行回调函数app.get(&quot;/&quot;, function (req, res) { res.send(&quot;hello exporess&quot;);});app.get(&quot;/about&quot;, function (req, res) { res.send(&quot;hello world&quot;);});//相当于server.listenapp.listen(3000, function () { console.log(&quot;app is running at port 3000&quot;);}); Express 使用 art-template Express&amp;art-template 官网 Install 12npm install --save art-templatesnpm install --save express-art-template Example 1234567891011121314151617181920var express = require('express');var app = express();// view engine setupapp.engine('art', require('express-art-template'));app.set('view', { debug: process.env.NODE_ENV !== 'production'});app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'art');// routesapp.get('/', function (req, res) { res.render('index.art', { user: { name: 'aui', tags: ['art', 'template', 'nodejs'] } });}); body-parser 在 Express 中没有内置获取表单 POST 请求体的 API，需要引入一个第三方包：body-parser Install 1npm install --save body-parser config 1234567var express = require('express')var bodyParser = require('body-parser')var app = express()//配置 body-parser,req对象上就会多出来一个 body 属性app.use(bodyParser.urlencoded({extended: false}))app.use(bodyParser.json()) use 12345app.use(function(req, res){ res.setHeader('Content-Type', 'text/plain') res.write('hello') res.end()})","link":"/2019/09/08/Node-js%E4%B9%8Bexpress/"},{"title":"React深入浅出知识链路","text":"React 框架的关键设计思想：“组件”、“虚拟 DOM” 组件化: 工程化思想在框架中的落地12“封闭”：在组件自身的渲染工作流中，每个组件都只处理它的内部的渲染逻辑。“开放”：针对组件间通信来说，React基于“单向数据流”的原则完成组件间的通信。 虚拟 DOM：核心算法的基石：123组件初始化-&gt;render方法-&gt;生成虚拟DOM-&gt;ReactDOM.render方法-&gt;生成真实DOM组件更新-&gt;render方法-&gt;生成新的虚拟DOM-&gt;diff算法-&gt;定位两次虚拟DOM的差异-&gt;批量更新 componentWillReceiveProps(nextProps)1如果父组件导致子组件重新渲染，即使props没有更改，也会调用此方法，如果只想处理更改，请确保当前值和变更值的比较。---React官方 shouldComponentUpdate1React组件会根据shouldComponentUpdate的返回值来决定是否执行后面的生命周期进而决定是否对组件进行re-render(重渲染) getDerivedStateFromProps(新增)不是 componentWillMount(废弃)的替代品12345678910111213getDerivedStateFromProps有且仅有一个用途：使用props来派生/更新statestatic getDerivedStateFromProps(props, state)1.静态方法，访问不到this2.参数 props(父组件)和state(自身)3.对象格式的返回值，用来更新自身state（更新并非覆盖式，而是替换式更新）4.挂载和更新都会触发此钩子其他：getDerivedStateFromProps是作为一个试图代替componentWillReceiveProps的API出现的。getDerivedStateFromProps不能完全和componentWillReceiveProps画等号原因：getDerivedStateFromProps仅可以代替componentWillReceiveProps来实现基于props派生state，原则来说能且只能做这一件事。 getSnapshotBeforeUpdate(新增)与 componentWillUpdate(废弃)123getSnapshotBeforeUpdate(prevProps, prevState){}1. 执行时机在render方法之后，真实DOM更新之前2.返回值会作为第三个参数传递给componentDidUpdate Fiber 架构（核心：可中断、可恢复、优先级）123456789101112131415161.Fiber是React16对React核心算法的一次重写2.Fiber会使原本同步的渲染过程变成异步的3.Fiber会将一个大的更新任务拆解为许多个小任务(工作单元)，这些工作单元有着不同的优先级，react可以根据优先级的高低去实现工作单元的打断和恢复Fiber架构的重要特征就是可以被打断的异步渲染模式，根据能否被打断这一标准，React16的生命周期被划分为render和commit两个阶段render阶段在执行过程中允许被打断（因为此阶段用户不可见，打断也无影响）commit阶段总是同步执行（涉及到同步渲染，会影响用户直观体验）render阶段是允许暂停、终止和重启的，这就导致render阶段的生命周期都是有可能被重复执行，所以要废弃处于render阶段的一些生命周期：componentWillMount、componenntUpdate、componentWillReceiveProps、shouldComponentUpdate(一般不会在这个生命周期中进行副作用操作，所以相对风险不大，没有被废弃)每个更新任务都会被赋予一个优先级若B任务的优先级高于当前任务A，那么当前处于Reconciler层的A任务就会被中断，当B任务完成后，A任务就会被重新推入Reconciler层，继续它的渲染，这便是所谓的“可恢复”Fiber架构对生命周期的影响react15: render开始-&gt;停不下来的递归计算(同步)-&gt;commit提交渲染react16: render开始-&gt;工作单元｜工作单元｜工作单元...(异步)-&gt;commit提交渲染 组件间通信12UI = render(data) 或 UI = f(data)React的视图会随着数据的变化而变化 React-Hooks 的使用原则12345671.只在React函数中调用Hook2.不要在循环、条件和嵌套函数中调用Hook(要确保hooks在每次渲染时都保持同样的执行顺序)从源码调用流程看原理：Hooks的正常运作，在底层依赖于顺序链表。mountState首次渲染构建链表并渲染，updateState依次遍历链表并渲染hooks的渲染就是通过依次遍历来定位每个hooks的内容，如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然就是不可控的 虚拟 DOM1虚拟DOM本质上是JS和DOM之间的一个映射缓存，在形态上表现为一个能够描述DOM结构及其属性信息的JS对象。 Diff 逻辑的拆分与解读1231.Diff算法性能突破的关键点在于 分层对比2.类型一致的节点才有继续Diff的必要性3.key属性的设置，可以帮我们尽可能重用同一层级内的节点 setState 异步1234567setState-&gt;shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate批量更新：每来一个setState，就把它塞进一个队列里面存起来，等时机成熟，再把存起来的state结果做合并，最后只针对最后一次最新的state值走一次更新流程setState的表现会因为调用的场景不同而不同：1.在React钩子函数及合成事件中，表现为异步2.在setTimeout、setInterval等函数中，包括DOM原生事件中，表现为同步。 ReactDOM.render 调用栈的逻辑分层1待补充 React 事件系统123当事件在具体的DOM节点上被触发后，最终都会冒泡到document上，document上所绑定的统一事件处理程序会将事件分发到具体的组件实例react合成事件：在底层抹平了不同浏览器的差异，在上层面向开发者暴漏统一的、稳定的、与DOM原生事件相同的事件接口（原生DOM事件可以通过e.nativeEvent查看）","link":"/2021/10/05/React%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF/"},{"title":"call、apply、bind三者比较及实现","text":"apply、call、bind 三者比较 1. apply、call、bind三者都是用来改变函数的this对象的指向的 2. apply、call、bind三者第一个参数都是this要指向的对象，也就是指向指定的上下文 3. apply、call、bind三者都可以利用后续参数进行传参 4. bind返回对应函数，可以稍后调用执行；apply、call则是立即调用 5.apply、call的接受参数不同，call将参数按顺序传递进去，apply则采用参数数组的形式 实现 call1234567891011121314151617181920Function.prototype.call2 = function () { //改变this指向，将目标函数作为这个对象的属性 var context = arguments[0] || window; context.fn = this; //利用arguments类数组对象实现参数不定长 var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']'); } //将不定长的参数传递给函数 var result = eval('context.fn(' + args.join(',') +')'); // context.fn(...args) //不能增加对象的属性，所以结尾要删除delete delete context.fn return result;} 实现 apply12345678910111213141516171819Function.prototype.apply2 = function (context, arr) { var context = Object(context) || window; context.fn = this; var result; if (!arr) { result = context.fn(); } else { var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) { args.push('arr[' + i + ']'); } result = eval('context.fn(' + args + ')') } delete context.fn return result;} 实现 bind1234567891011121314Function.prototype.bind2 = function (context) { if (typeof this !== &quot;function&quot;) { throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); } var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fbound = function () { self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments))); } fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); return fbound;} 简单的： 12345function bind(fn, obj) { return function() { return fn.apply(obj, arguments) }}","link":"/2019/08/14/call%E3%80%81apply%E3%80%81bind%E4%B8%89%E8%80%85%E6%AF%94%E8%BE%83%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"title":"TypeScript","text":"什么是 TypeScript？ TypeScript 是 JavaScript 的超集，任何合法的 js 程序都是合法的 TypeScript 程序 TypeScript 通过向 JavaScript 增加可选的静态类型声明把 JavaScript 变成强类型程序语言 提供静态类型声明可约束函数、变量、属性等程序实体 为什么要使用 TypeScript？ 提供了静态类型系统，大大增强了代码的可读性以及可维护性 提供最新和不断发展的 javascript 特性，能让我们建立 更健壮的组件 TS 具有防患于未然的静态检查，以及干净利落的只能提示 TypeScript 中的数据类型 typescript 中为了使编写的代码更规范，更利于维护，增加了类型校验，在 typescript 中主要提供了以下数据类型： 布尔类型 bolean 数字类型 number 字符串类型 string 数组类型 array 元组类型 tuple 枚举类型 enum 任意类型 any null 和 undefined void 类型 never 类型 typescript 中为了使编写的代码更规范，更有利于维护，增加了类型校验，写 ts 代码必须指定类型 未声明类型的变量: 如果变量在声明的时候，未指定其类型，那么他会被识别为任意类123456let something;something = &quot;seven&quot;;something = 7;//不会报错 如果没有明确的指定类型，那么 typescript 会依照类型推论的规则推导出一个规则1234567let num = &quot;seven&quot;;num = 7;//会报错//上面代码等价于：let num: string = &quot;seven&quot;;num = 7;//typescript自动推测出num属于string类型 联合类型：表示取值可以为多种类型中的一种12345678910111213141516171819202122232425let flag:string | numberflag = 'seven'flag = 7//联合类型使用 | 分隔每个类型，表示允许flag为string类型或者number类型---------------------------------------//访问联合类型的属性或者方法//当typescript不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问联合类型的所有类型中共有的属性和方法function getLength(something:string|number):number{ return something.length}//上面代码会报错，因为length不是string和number共有的属性//可以访问共有属性toString()function getString(something:string|number):string { return something.toString()}---------------------------------------//联合属性在赋值的时候，会根据类型推论的规则推断出一个类型let a:string|numbera = 'seven'console.log(a.length) //5，a被推断为string，有length属性a = 7console.log(a.length) //编译时报错，被推断为number，无length属性 数组类型123456789101112131415161718//数组类型定义(不允许出现其他类型，数组方法参数也有限制，如push('7')会报错，不能为字符串)let arr:number[] = [1,2,3]let arr:(number | string)[] = [1,'1',2]---------------------------------//数组泛型let arr:Array&lt;number&gt; = [1,2,3]----------------------------------//用接口表示数组interface NumberArray { [index:number]:number}let arr:NumberArray = [1,2,3]//NumberArray表示，只要index的类型时number，那么值的类型也必须时number-----------------------------------//any在数组中的应用let arr:any[] = ['hello', 24, {a:1}] 函数类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//函数声明（不允许输入多余或者少于要求的参数）function sum(x:number, y: number):number { return x + y}sum(1,2) //rightsum(1,2,3) //falsesum(1) //false----------------------------------------------//函数表达式let sum:(x:number, y: number) =&gt; number = function(x:number, y:number):number { return x + y}-----------------------------------------------//可选参数（使用 ? 表示可选的参数，只能放在参数的最后，后面不允许出现必须参数）function buildName(firstName:string, lastName?:string):string { if (lastName) { return firstName + ' ' + lastName } else { return firstName }}let tomcat = buildName('tom', 'cat')let tom = buildName('tom')--------------------------------------------------//参数默认值（typescript会将添加了默认值的参数识别为可选参数） function buildName(firstName:string, lastName:string = 'cat'):string { if (lastName) { return firstName + ' ' + lastName } else { return firstName } } let tomcat = buildName('tom', 'cat') let tom = buildName('tom')----------------------------------------------------//剩余参数，可以使用...rest的方式获取函数中的剩余参数function push(array: any[], ...items:any[]) { items.forEach(function(item) { array.push(item) })}let a = []push(a, 1,2,3,4)-------------------------------------------------------//重载：允许一个函数接受不同数量或者类型的参数时，做出不同的处理//例如，数字或者字符串的反转输出function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); }} 泛型（注意点）12345type A1 = &quot;x&quot; extends &quot;x&quot; ? string : number; // stringtype A2 = &quot;x&quot; | &quot;y&quot; extends &quot;x&quot; ? string : number; // numbertype P&lt;T&gt; = T extends &quot;x&quot; ? string : number;type A3 = P&lt;&quot;x&quot; | &quot;y&quot;&gt;; // ? 这里的extends是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集。P 是带参数 T 的泛型类型，A1 和 A2 的形式一样，结果也很好理解，A3 是泛型类型 P 传入参数**’x’ | ‘y’**得到的类型，如果将 ‘x’ | ‘Y’ 代入泛型类的表达式，那应该会得到和 A2 类型的形式完全一样的结果，这里直接给结论了 12type P&lt;T&gt; = T extends 'x' ? string : number;type A3 = P&lt;'x' | 'y'&gt; // A3的类型是 string ｜ number 结果是不是出人意料？原因就是分配条件类型,在 TS 中对于 extends 关键字的条件类型（即上面的三元表达式类型），如果extends前面的参数是一个(裸类型)泛型类型，当传入该参数的是联合类型，则使用分配律计算最终结果。 分配律是指，将联合型类的联合项拆分成单项，分别代入条件类型，然后将每个单项代入，再将得到的结果联合起来，得到最终的结果。 特殊的 never 那么，我们在看一个例子： 12345type A1 = never extends &quot;x&quot; ? string : number;type P&lt;T&gt; = T extends &quot;x&quot; ? string : number;type A2 = P&lt;never&gt;; // never 上面的例子中，A2 和 A1 的结果竟然不一样，看起来never并不是一个联合类型啊，所以直接代入条件类型获取的结果应该和 A1 相同才对啊？ 实际上，never 被认为是空的联合类型，never 是一个没有联合项的联合类型，所以还是满足上面的分配律，又因为没有联合项可以分配，所以*P*的表达式根本就没有执行，所以 A2 的定义就类似于永远没有返回的函数一样，是 never 类型。 如何防止条件判断中的分配 12345type P&lt;T&gt; = [T] extends [&quot;x&quot;] ? string : number;type A1 = P&lt;&quot;x&quot; | &quot;y&quot;&gt;; // numbertype A2 = P&lt;never&gt;; // string 在条件判断类型的定义中，将泛型参数使用 [] 括起来，即可阻断条件判断类型的分配，此时，传入的 T 的类型就会被当作一个整体，不再分配。","link":"/2019/08/23/TypeScript/"},{"title":"TS进阶题目","text":"在线 TS 地址 typescript 第一题 以下代码为什么会提示错误，应该如何解决上述问题？ 1234567891011type User = { id: number; kind: string;}function createCustomer&lt;T extends User&gt;(u: T): T { return { id: u.id, kind: 'customer' }} 第一种解决方案 1234567891011type User = { id: number; kind: string;}function createCustomer&lt;T extends User&gt;(u: T): User { return { id: u.id, kind: 'customer', }} 第二种解决方案 123456789101112type User = { id: number; kind: string;}function createCustomer&lt;t extends User&gt;(u: T): T { return { ...u, id: u.id, kind: 'customer' }} 第二题 以下函数我们希望参数a和b的类型都是一致的，即a和b同时为number或string类型，当它们的类型不一致时，ts 类型检查器能自动提示对应的错误信息。 123456789101112function f(a: string | number,b: string | number) { if (typeof a === 'string') { return a + ':' + b; } else { return a + b; }}f(1, 2); // OKf('a', 'b'); // OKf('a', 2); // Errorf(1, 'b'); //Error 第一种解决方案 函数重载 1234567891011121314function f(a: string, b: string): string;function f(a: number, b: number): number;function f(a: string | number, b: string | number): string | number { if (typeof a === 'string') { return a + ':' + b; } else { return (a as number) + (b as number); }}f(1, 2); // OKf('a', 'b'); // OKf(1, 'b'); // Errorf('a', 2); // Error 第二种解决方案 自定义路由守卫 1234567891011121314const isStringArray = (params: string[] | number[]): params is string[] =&gt; typeof params[0] === 'string';function f(...args: string[] | number[]) { if (isStringArray(args)) { return args[0] + ':' + args[1]; } else { return args[0] + args[1]; }}f(1, 2); // OKf('a', 'b'); // OKf(1, 'b'); // Errorf('a', 2); // Error 第三种解决方案 范型 123456789101112function f&lt;T extends string | number&gt;(a: T, b: T) { if (typeof a === 'string') { return a + ':' + b; } else { return (a as number) + (b as number); }}f(1, 2); // OKf('a', 'b'); // OKf(1, 'b'); // Errorf('a', 2); // Error 第三题 实现 SetOptional 工具类型，支持把给定的 keys 对应的属性变为可选，参考Partial 实现 SetRequired 工具类型，支持把给定的 keys 对应的属性变成必填，参考 Require 1234567891011121314151617181920212223242526272829// SetOptional 测试用例type Foo = { a: number; b?: string; c: boolean;}type SomeOptional = SetOptional&lt;Foo, 'a' | 'b'&gt;type SomeOptional = { a?: number; //该属性变为可选的 b?: string; //保持不变 c: boolean;}// SetRequired 测试用例type Foo = { a: number; b?: string; c: boolean;}type SomeRequired = SetRequired&lt;Foo, 'a' | 'b'&gt;type SomeRequired = { a: number; //保持不变 b: string; //该属性变为必选的 c: boolean;} 解决方案 1 SetOptional 1234567891011121314type Foo = { a: number; b?: string; c: boolean;}// 对交叉类型进行扁平化处理type Simplify&lt;T&gt; = { [P in keyof T]: T[P]}type SetOptional&lt;T, K extends keyof T&gt; = Simplify&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;&gt;type SomeOptional = SetOptional&lt;Foo, 'a' | 'b'&gt; SetRequired 12345678910111213type Foo = { a: number; b?: string; c: boolean;}type Simplify&lt;T&gt; = { [P in keyof T]: T[P]}type SetRequired&lt;T, K extends keyof T&gt; = Simplify&lt;Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt; &amp; Required&lt;Pick&lt;T, K&gt;&gt;&gt;type SomeRequired = SetRequired&lt;Foo, 'b' | 'c'&gt; 解决方案 2 1234567891011121314151617type Foo = { a: number; b?: string; c: boolean;}type Simplely&lt;T&gt; = { [P in keyof T]: T[P]}type SetOptional&lt;T, K extends keyof T&gt; = Simplely&lt;{ [X in keyof Omit&lt;T, K&gt;]: T[X]; } &amp; { [P in K]?: T[P] }&gt;;type SetRequired&lt;T, K extends keyof T&gt; = Simplely&lt;{ [X in keyof Omit&lt;T, K&gt;]: T[X]; } &amp; { [P in K]-?: T[P] }&gt;;// 测试用例type SomeOptional = SetOptional&lt;Foo, 'a' | 'b'&gt;;type SomeRequired = SetRequired&lt;Foo, 'b' | 'c'&gt;; 解决方案 3 1234567type Simplify&lt;T&gt; = { [P in keyof T]: T[P]}type SetOptional&lt;T, K extends keyof T&gt; = Simplify&lt;Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt;;type SetRequired&lt;T, K extends keyof T&gt; = Simplify&lt;Required&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;&gt; 第四题 Pick&lt;T, K extends keyof T&gt; 的作用是将某个类型中的字属性挑出来，得到包含这个类型部分属性的字类型。 123456789101112interface Todo { title: string; description: string; completed: boolean;}type TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;const todo: TodoPreview = { title: &quot;clean room&quot;, completed: false} 问题：如何定义一个ConditionalPick工具类型，支持根据指定的Condition条件来生成新的类型，对应的使用示例如下： 12345678910interface Example { a: string; b: string | number; c: () =&gt; void; d: {}}// 测试用例type StringKeyOnly = ConditionalPick&lt;Example, string&gt;;// =&gt; {a: string} 解决方案 神奇的 as 1234567891011121314interface Example { a: string; b: string | number; c: () =&gt; void; d: {};}type ConditionalPick&lt;T, K&gt; = { [P in keyof T as (T[P] extends K ? P : never)]: T[P]}// 测试用例type StringKeysOnly = ConditionalPick&lt;Example, string&gt;;// =&gt; {a: string} 第五题 定义一个工具类型AppendArgument,为已有函数累心增加指定类型的参数，新增的参数名是x，将作为新函数类型的第一个参数，示例如下： 123456type Fn = (a: number, b: string) =&gt; number;type AppendArgument&lt;F, A&gt; = // 你的实现代码// 测试用例type FinalFn = AppendArgument&lt;Fn, boolean&gt;// (x: boolean, a: number, b: string) =&gt; number; 解决方案 1 延伸阅读 掌握 TS 这些工具类型，让你开发事半功倍 123456type AppendArgument&lt;F extends (...args: any) =&gt; any, A&gt; = (x: A, ...args: Parameters&lt;F&gt;) =&gt; ReturnType&lt;F&gt;type Fn = (a: number, b: string) =&gt; number;type FinalFn = AppendArgument&lt;Fn, boolean&gt;;// (x: boolean, a: number, b: string) =&gt; number; 解决方案 2 延伸阅读 用上这几招，轻松实现 TS 类型提取 123456type AppendArgument&lt;F, T&gt; = F extends (...args: infer Args) =&gt; infer Return ? (x: T, ...args: Args) =&gt; Return : never;type Fn = (a: number, b: string) =&gt; number;type FinalFn = AppendArgument&lt;Fn, boolean&gt;;// (x: boolean, a: number, b: string) =&gt; number 第六题 定义一个 NativeFlat 工具类型，支持把数组类型拍平(扁平化),示例如下： 12345type NativeFlat&lt;T extends any[]&gt; = // 实现代码//测试用例type NativeResult = NativeFlat&lt;[['a'],['b','c'],['d']]&gt;;// =&gt; &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; 在完成NativeFlat工具类型之后，继续实现DeepFlat工具类型，以支持多维数组类型： 123456type DeepFlat&lt;T extends any[]&gt; = unknown // 你的实现代码// 测试用例type Deep = [['a'], ['b', 'c'], [['d']], [[[['e']]]]];type DeepTestResult = DeepFlat&lt;Deep&gt;// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; 解决方案 NativeFlat 123456type NaiveFlat&lt;T extends any[]&gt; = { [P in keyof T]: T[P] extends any[] ? T[P][number] : T[P]}[number]type NaiveResult = NaiveFlat&lt;[['a'], ['b', 'c'], ['d']]&gt;// NaiveResult的结果： &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; DeepFlat 12345678type Deep = [['a'], ['b', 'c'], [['d']], [[[['e']]]]];type DeepFlat&lt;T extends any[]&gt; = { [K in keyof T]: T[K] extends any[] ? DeepFlat&lt;T[K]&gt; : T[K]}[number]type DeepTestResult = DeepFlat&lt;Deep&gt;// DeepTestResult: &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; 第七题 使用类型别名定义一个EmptyObject类型，是的该类型只允许空对象赋值： 1234567type EmptyObject = {}// 测试用例const shouldPass: EmptyObject = {}; // OKconst shouldFail: EmptyObject = { // Error prop: &quot;TS&quot;} 更改以下takeSomeTypeOnly函数类型定义，让参数只允许严格 SomeType 类型的值，示例如下： 123456789101112type SomeType = { prop: string;}function takeSomeTypeOnly(x: SomeType) {return x};// 测试用例const x = {prop: 'a'};takeSomeTypeOnly(x); // OKconst y = {prop: 'a', additionalProp: 'x'};takeSomeTypeOnly(y); // Error 解决方案 EmptyObject 1234567891011// type PropertyKey = string | number | symbol;type EmptyObject = { [K in PropertyKey]: never;}// 测试用例const shouldPass: EmptyObject = {}; // OKconst shouldFail: EmptyObject = { // Error prop: &quot;TS&quot;} takeSomeTypeOnly 12345678910111213141516type SomeType = { prop: string;}type Exclusive&lt;T1, T2 extends T1&gt; = { [K in keyof T2]: K extends keyof T1 ? T2[K] : never;}function takeSomeTypeOnly&lt;T extends SomeType&gt;(x: Exclusive&lt;SomeType, T&gt;) {return x};// 测试用例const x = {prop: 'a'};takeSomeTypeOnly(x); // OKconst y = {prop: 'a', additionalProp: 'x'};takeSomeTypeOnly(y); // Error 第八题 定义一个NonEmptyArray工具类型，用于确保数据为非空数组 1234type NonEmptyArray&lt;T&gt; = // 代码实现const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 解决方案 1 1234type NonEmptyArray&lt;T&gt; = [T, ...T[]];const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 解决方案 2 12345type NonEmptyArray&lt;T&gt; = T[] &amp; {0: T};const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 解决方案 3 12345678type NonEmptyArray&lt;T&gt; = { [P in number]: T;} &amp; { 0: T};const err: NonEmptyArray&lt;string&gt; = []; // Errorconst succ: NonEmptyArray&lt;string&gt; = ['Hello Ts']; //Ok 第九题 定义一个JoinStrArray工具类型，用于根据指定的Separator分隔符，对字符串数据类型进行拼接，示例如下： 1234567type JoinStrArray&lt;Arr extends string[], Separator extends string, Result extends string = &quot;&quot;&gt; = // 你的实现代码// 测试用例type Names = [&quot;Sem&quot;, &quot;Lolo&quot;, &quot;Kaquko&quot;]type NamesComma = JoinStrArray&lt;Names, &quot;,&quot;&gt; // &quot;Sem,Lolo,Kaquko&quot;type NamesSpace = JoinStrArray&lt;Names, &quot; &quot;&gt; // &quot;Sem Lolo Kaquko&quot;type NamesStars = JoinStrArray&lt;Names, &quot;⭐️&quot;&gt; // &quot;Sem⭐️Lolo⭐️Kaquko&quot; 解决方案 12345678910111213141516171819type JoinStrArray&lt; Arr extends string[], Separator extends string, Result extends string = &quot;&quot;&gt; =Arr extends [infer El,...infer Rest]? Rest extends string[]? El extends string? Result extends &quot;&quot;? JoinStrArray&lt;Rest, Separator,`${El}`&gt;: JoinStrArray&lt;Rest, Separator,`${Result}${Separator}${El}`&gt;: `${Result}`: `${Result}`: `${Result}`type Names = [&quot;Sem&quot;, &quot;Lolo&quot;, &quot;Kaquko&quot;]type NamesComma = JoinStrArray&lt;Names, &quot;,&quot;&gt; // &quot;Sem,Lolo,Kaquko&quot;type NamesSpace = JoinStrArray&lt;Names, &quot; &quot;&gt; // &quot;Sem Lolo Kaquko&quot;type NamesStars = JoinStrArray&lt;Names, &quot;⭐️&quot;&gt; // &quot;Sem⭐️Lolo⭐️Kaquko&quot; 第十题 实现一个Trim工具类型，用于对字符串字面量类型进行去空格处理，示例如下： 123type Trim&lt;V extends string&gt; = // 代码实现type Result = Trim&lt;' foolishmax '&gt; 解决方案 123456type TrimLeft&lt;V extends string&gt; = V extends ` ${infer R}` ? TrimLeft&lt;R&gt; : V;type TrimRight&lt;V extends string&gt; = V extends `${infer R} `? TrimRight&lt;R&gt; : V;type Trim&lt;V extends string&gt; = TrimLeft&lt;TrimRight&lt;V&gt;&gt;;type Result = Trim&lt;' foolishmax '&gt; 第十一题 实现一个*IsEqual&lt;A, B&gt;*工具类型，用于比较两个类型是否相等，示例如下： 123456type IsEqual&lt;A, B&gt; = // 代码实现// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1, {a: 1}}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false 解决方案（原始方案） 1 123456789101112type IsEqual&lt;A, B&gt; = A extends B ? (B extends A ? true : false) : false;// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1}, {a: 1}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false// errortype E3 = IsEqual&lt;true, boolean&gt; // booleantype E4 = IsEqual&lt;1 | 2, 1&gt; // boolean这是因为泛型和*extends*两者结合所产生的*distributive conditionial types*效应导致的 解决方案（稍微优化）2 12345678910111213141516type IsEqual&lt;A, B&gt; = [A] extends [B] ? [B] extends [A] ? true : false : false或type IsEqual&lt;A, B&gt; = [A, B] extends [B, A] ? true : false// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1}, {a: 1}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false// errortype E3 = IsEqual&lt;any, string&gt; // truetype E4 = IsEqual&lt; { name: string }, { readonly name: string }&gt; // true这是因为Ts中any可以赋值为任何类型，任何类型也可以赋值给any，这就意味着any和任意类型之间都是assignable的，对于extends而言就是都可以相互extends的，所以E3是true。readonly不会改变assignable。 解决方案 4 12345678type IsEqual&lt;A, B&gt; =(&lt;G&gt;() =&gt; G extends A ? 1 : 2) extends(&lt;G&gt;() =&gt; G extends B ? 1 : 2) ? true : false;// 测试用例type E0 = IsEqual&lt;1, 2&gt;; // falsetype E1 = IsEqual&lt;{a : 1}, {a: 1}&gt;; // truetype E2 = IsEqual&lt;[1], []&gt;; // false 第十二题 实现一个Head工具类型，用于获取数组类型的第一个类型，示例如下： 123456type Head&lt;T extends Array&lt;any&gt;&gt; = // 代码实现// 测试用例type H0 = Head&lt;[]&gt; // nevertype H1 = Head&lt;[1]&gt; // 1type H2 = Head&lt;[2,3,4]&gt; // 2 解决方案 1 123456type Head&lt;T extends Array&lt;any&gt;&gt; = T extends [] ? never : T[0];// 测试用例type H0 = Head&lt;[]&gt; // nevertype H1 = Head&lt;[1]&gt; // 1type H2 = Head&lt;[2,3,4]&gt; // 2 解决方案 2 123456type Head&lt;T extends Array&lt;any&gt;&gt; = T extends [head: infer H, ...rest: any[]] ? H : never;// 测试用例type H0 = Head&lt;[]&gt; // nevertype H1 = Head&lt;[1]&gt; // 1type H2 = Head&lt;[2,3,4]&gt; // 2 第十三题 实现一个Tail工具类型，用于获取数组类型除了第一个类型外，剩余的类型，示例如下： 123456type Tail&lt;T extends Array&lt;any&gt;&gt; = // 代码实现// 测试用例type T0 = Tail&lt;[]&gt; //[]type T1 = Tail&lt;[1, 2]&gt; // [2]type T2 = Tail&lt;[1, 2, 3, 4, 5]&gt; //[2, 3, 4, 5] 解决方案 123456type Tail&lt;T extends Array&lt;any&gt;&gt; = T extends [infer A, ...infer B] ? B : [];// 测试用例type T0 = Tail&lt;[]&gt; //[]type T1 = Tail&lt;[1, 2]&gt; // [2]type T2 = Tail&lt;[1, 2, 3, 4, 5]&gt; //[2, 3, 4, 5] 第十四题 实现一个Unshift工具类型，用于把指定类型 E 作为第一个元素添加到T数组类型中，示例如下： 12345type Unshift&lt;T extends any[], E&gt; = // 代码实现// 测试用例type U0 = Unshift&lt;[], 1&gt;; // [1]type U1 = Unshift&lt;[1, 2, 3], 0&gt;; //[0, 1, 2, 3] 解决方案 12345type Unshift&lt;T extends any[], E&gt; = [E, ...T];// 测试用例type U0 = Unshift&lt;[], 1&gt;; // [1]type U1 = Unshift&lt;[1, 2, 3], 0&gt;; //[0, 1, 2, 3] 第十五题 实现一个Shift工具类型，用于移除T数组类型中的第一个类型，示例如下： 12345type Shift&lt;T extends any[]&gt; = // 代码实现// 测试用例type S0 = Shift&lt;[1, 2, 3]&gt;type S1 = Shift&lt;[string, number, boolean]&gt; 解决方案 1234567type Shift&lt;T extends any[]&gt; = T extends [infer A, ...infer B] ? B : [];// 测试用例type S0 = Shift&lt;[1, 2, 3]&gt;; // [2, 3]type S1 = Shift&lt;[string, number, boolean]&gt;; // [number, boolean]type S2 = Shift&lt;[]&gt;; // []type S3 = Shift&lt;[string]&gt;; // [] 第十六题 实现一个Push工具类型，用于把指定类型E作为最后一个元素添加到T数组类型中，示例如下： 12345type Push&lt;T extends any[], E&gt; = // 代码实现// 测试用例type P0 = Push&lt;[], 1&gt;; // [1]type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4] 解决方案 1 12345type Push&lt;T extends any[], E&gt; = T extends [...infer U] ? [...U, E] : never;// 测试用例type P0 = Push&lt;[], 1&gt;; // [1]type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4] 解决方案 2 123456type Push&lt;T extends any[], E&gt; = [...T, E];// 测试用例type P0 = Push&lt;[], 1&gt;; // [1]type P1 = Push&lt;[1, 2, 3], 4&gt;; // [1, 2, 3, 4] 第十七题 实现一个Includes工具类型，用于判断指定的类型E，是否包含在T数组类型中，示例如下： 12345type Includes&lt;T extends any[], E&gt; = // 代码实现// 测试用例type I0 = Includes&lt;[], 1&gt;; // falsetype I1 = Includes&lt;[2, 3], 2&gt;; // true 解决方案 1 12345type Includes&lt;T extends any[], E&gt; = E extends T[number] ? true : false;// 测试用例type I0 = Includes&lt;[], 1&gt;; // falsetype I1 = Includes&lt;[2, 3], 2&gt;; // true 解决方案 2 123456type Includes&lt;T extends any[], E&gt; = T extends [infer A, ...infer R] ? E extends A ? true : Includes&lt;R, E&gt; : false;// 测试用例type I0 = Includes&lt;[], 1&gt;; // falsetype I1 = Includes&lt;[2, 3], 2&gt;; // true 第十八题 实现一个UnionToIntersection工具类型，用于把联合类型转换为交叉类型，示例如下： 12345type UnionToIntersection&lt;U&gt; = // 代码实现// 测试用例type U0 = UnionToIntersection&lt;string | number&gt;; // nevertype U1 = UnionToIntersection&lt;{name: string} | {age: number}&gt;; // {name: string} &amp; {age: number} 解决方案 逆变协变 注释 12345678910type Fun&lt;X&gt; = (...args: X[]) =&gt; void;let f: Fun&lt;string&gt;let g: Fun&lt;string | number&gt;g = f // this cannot be assigned当f赋值给g时，新的g不能使用number类型的参数，我们丢失了g的一部分类型，这就属于 逆变(contra-variance),这个和交集的工作机制类似。当我们把逆变位置放在条件类型时：Typescript会创建一个交集，我们从函数参数中infer了一个类型，TypeScript知道我们必须符合逆变的条件，然后TypeScript会自动创建并集中所有的成分的交集。 123456type UnionToIntersection&lt;U&gt; = (U extends any ? (k: U) =&gt; void : never) extends (k: infer I) =&gt; void ? I : never// 测试用例type U0 = UnionToIntersection&lt;string | number&gt; // nevertype U1 = UnionToIntersection&lt;{ name: string } | { age: number }&gt; // { name: string; } &amp; { age: number; } 第十九题 实现一个 OptionalKeys 工具类型，用来获取对象类型中声明的可选属性，示例如下: 12345678910type Person = { id: string; name: string; age: number; from?: string; speak?: string;}type OptionalKeys&lt;T&gt; = // 代码实现type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot; 解决方案 1 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;}type OptionalKeys&lt;T&gt; = NonNullable&lt;{ [P in keyof T]: undefined extends T[P] ? P : never}[keyof T]&gt;type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot; 解决方案 2 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;}type OptionalKeys&lt;T&gt; = keyof { [P in keyof T as undefined extends T[P] ? P : never]: T[P]}type PersonOptionsKeys = OptionalKeys&lt;Person&gt; // &quot;from&quot; | &quot;speak&quot; 解决方案 3 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;};type OptionalKeys&lt;T&gt; = Exclude&lt;{ [P in keyof T]: T extends T[P] ? never : T[P]}[keyof T], undefined&gt;type PersonOptionalKeys = OptionalKeys&lt;Person&gt;; // &quot;from&quot; | &quot;speak 解决方案 4 12345678910111213type Person = { id: string; name: string; age: number; from?: string; speak?: string;};type OptionalKeys&lt;T&gt; = { [P in keyof T]: (undefined extends T[P] ? P : never)}[keyof T] &amp; keyof Ttype PersonOptionalKeys = OptionalKeys&lt;Person&gt;; // &quot;from&quot; | &quot;speak 第二十题 实现一个Curry工具类型，用来实现函数类型的柯里化处理，示例如下： 123456789type Curry&lt; F extends (...args: any[]) =&gt; any, P extends any[] = Parameters&lt;F&gt;, R = ReturnType&lt;F&gt;&gt; = // 代码实现type C0 = Curry&lt;() =&gt; Date&gt;; // () =&gt; Datetype C1 = Curry&lt;(a:number) =&gt; Date&gt;; // (arg: number) =&gt; Datetype C2 = Curry&lt;(a: number, b: string) =&gt; Date&gt;; // (arg: number)=&gt;(arg: string) =&gt; Date 解决方案 12345678910111213type Curry&lt; F extends (...args: any[]) =&gt; any, P extends any[] = Parameters&lt;F&gt;, R = ReturnType&lt;F&gt;,&gt; = P extends [infer A, ...infer B] ? B extends [] ? (arg: A) =&gt; R : (arg: A) =&gt; Curry&lt;(...arg: B) =&gt; R&gt; : F;type C0 = Curry&lt;() =&gt; Date&gt;; // () =&gt; Datetype C1 = Curry&lt;(a:number) =&gt; Date&gt;; // (arg: number) =&gt; Datetype C2 = Curry&lt;(a: number, b: string) =&gt; Date&gt;; // (arg: number)=&gt;(arg: string) =&gt; Date 第二十一题 实现一个Merge工具类型，用于把两个类型合成一个新的类型，第二类型（SecondType）的Keys将会覆盖第一种类型（FirstType）的Keys，示例如下： 123456789101112type Foo = { a: number; b: string;}type Bar = { b: number;}type Merge&lt;FirstType, SecondType&gt; = // 代码实现type M = Merge&lt;Foo, Bar&gt;; // {a: number, b: number} 解决方案 1 将 FirstType 和 SecondType 做交叉类型，并遍历每一个属性； 如果当前属性名在 SecondType 类型中，则使用 SecondType 类型中的当前属性值； 如果当前属性名在 FirstType 类型中，则使用 FirstType 类型中的当前属性值； 否则为 never； 123456789101112131415161718type Foo = { a: number; b: string;}type Bar = { b: number;}type Merge&lt;FirstType, SecondType&gt; ={ [K in keyof (FirstType &amp; SecondType)] : K extends keyof SecondType ? SecondType[K] : K extends keyof FirstType ? FirstType[K] : never}type M = Merge&lt;Foo, Bar&gt;; // {a: number, b: number} 解决方案 2 先将 FirstType 类型中已经有的，和 SecondType 类型中相同的属性删除； 将前面结果和 SecondType 做交叉类型，获得合并后结果。 123456789101112type Foo = { a: number; b: string;}type Bar = { b: number;}type Merge&lt;F, S&gt; = Omit&lt;F, keyof S&gt; &amp; S;type M = Merge&lt;Foo, Bar&gt;; // {a: number, b: number} 第二十二题 实现一个RequireAtLeastOne工具类型，它将创建一个至少含有一个给定keys的类型，其余keys类型保持原样，示例如下： 123456789101112131415type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;}type RequireAtLeastOne&lt; ObjectType, KeysType extends keyof ObjectType = keyof ObjectType,&gt; = 代码实现const responder: RequireAtLeastOne&lt;Responder, 'text'|'json'&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true} 解决方案 1 1234567891011121314151617181920212223type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;}type RequireAtLeastOne&lt; ObjectType, KeysType extends keyof ObjectType = keyof ObjectType,&gt; = KeysType extends unknown ? ObjectType &amp; { [K in KeysType]-?: ObjectType[K]} : never;// 表示当前类型至少包含 'text' 或 'json' 键const responder: RequireAtLeastOne&lt;Responder, 'text' | 'json'&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true};// @ts-expect-error 因为没有'text'和'json'中的任何一个，报错const responder2: RequireAtLeastOne&lt;Responder, 'text' | 'json'&gt; = { secure: true}; 解决方案 2 12345678910111213141516type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;};type RequireAtLeastOne&lt;ObjectType, KeysType extends keyof ObjectType = keyof ObjectType&gt; = { [K in keyof ObjectType]: K extends KeysType ? ObjectType &amp; Required&lt;Pick&lt;ObjectType, K&gt;&gt; : never;}[keyof ObjectType]// 表示当前类型至少包含 'text' 或 'json' 键const responder: RequireAtLeastOne&lt;Responder, &quot;text&quot; | &quot;json&quot;&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true,}; 解决方案 3 12345678910111213141516type Responder = { text?: () =&gt; string; json?: () =&gt; string; secure?: boolean;};type RequireAtLeastOne&lt;ObjectType, KeysType extends keyof ObjectType = KeysType extends unknown? Omit&lt;ObjectType, KeysType&gt; &amp; Require&lt;Pick&lt;ObjectType, KeysType&gt;&gt;: never// 表示当前类型至少包含 'text' 或 'json' 键const responder: RequireAtLeastOne&lt;Responder, &quot;text&quot; | &quot;json&quot;&gt; = { json: () =&gt; '{&quot;message&quot;: &quot;ok&quot;}', secure: true,}; 第二十三题 实现一个RemoveIndexSignature工具类型，用于移除已有类型中的索引签名，示例如下： 12345678910interface Foo { [key: string]: any; [key: number]: any; [key: symbol]: any; bar(): void;}type RemoveIndexSignature&lt;T&gt; = // 代码实现type R = RemoveIndexSignature&lt;Foo&gt;; // {bar: ()=&gt;void;} 解决方案 123456789101112interface Foo { [key: string]: any; [key: number]: any; [key: symbol]: any; bar(): void;}type RemoveIndexSignature&lt;T&gt; = { [K in keyof T as string extends K ? never : number extends K ? never : symbol extends K ? never : K]: T[K]}type R = RemoveIndexSignature&lt;Foo&gt;; // {bar: () =&gt; void;} 第二十四题 实现一个 Mutable 工具类型，用于移除对象类型上所有属性或者部分属性的 readonly 修饰符，示例如下： 123456789101112type Foo = { readonly a: number; readonly b: string; readonly c: boolean;}type Mutable&lt;T, Keys extends keyof T = keyof T&gt; = // 代码实现const mutableFoo: Mutable&lt;Foo, 'a'&gt; = { a: 1, b: '2', c: true };mutableFoo.a = 3; // okmutableFoo.b = '6'; // Cannot assign to 'b' because it is a read-only property. 解决方案 1 12345678910111213type Foo = { readonly a: number; readonly b: string; readonly c: boolean;}type Mutable&lt;T, Keys extends keyof T = keyof T&gt; ={-readonly [K in Keys]: T[K] } &amp; Pick&lt;T, Exclude&lt;keyof T, Keys&gt;&gt;;const mutableFoo: Mutable&lt;Foo, 'a'&gt; = { a: 1, b: '2', c: true };mutableFoo.a = 3; // okmutableFoo.b = '6'; // Cannot assign to 'b' because it is a read-only property. 解决方案 2 12345678910111213type Foo = { readonly a: number; readonly b: string; readonly c: boolean;}type Mutable&lt;T, Keys extends keyof T = keyof T&gt; ={-readonly [K in Keys]: T[K] : T[K]} &amp; Omit&lt;T, Keys&gt;;const mutableFoo: Mutable&lt;Foo, 'a'&gt; = { a: 1, b: '2', c: true };mutableFoo.a = 3; // okmutableFoo.b = '6'; // Cannot assign to 'b' because it is a read-only property. 第二十五题 实现一个 IsUnion 工具类型，判断指定的类型是否为联合类型，示例如下： 12345type IsUnion&lt;T, U = T&gt; = // 代码实现type I0 = IsUnion&lt;string|number&gt; // truetype I1 = IsUnion&lt;string|never&gt; // falsetype I2 = IsUnion&lt;string|unknown&gt; //false 解决方案 12345type IsUnion&lt;T, U = T&gt; = T extends any ? [U] extends [T] ? false : true : never;type I0 = IsUnion&lt;string|number&gt; // truetype I1 = IsUnion&lt;string|never&gt; // falsetype I2 = IsUnion&lt;string|unknown&gt; //false 知识点： 1.联合类型作为泛型的时候 extends 会触发分发执行 2.联合类型 T 写成[T]就变成了普通类型，extends 的时候不会分发执行 这里第一步T extends any肯定为真，一个其实就是利用其分发的特性，后面的[T]就是一个联合类型拆开后的某一个，因此如果是联合类型的话[U] extends [T]一定为否 第二十六题 实现一个IsNever工具类型，判断指定的类型是否为never类型，示例如下： 12345type IsNever&lt;T&gt; = // 代码实现type I0 = IsNever&lt;never&gt; // truetype I1 = IsNever&lt;never | string&gt; // falsetype I2 = IsNever&lt;null&gt; // false 解决方案 用[]包裹 T，否则泛型参数会被当作一个裸类型处理，走条件式分布类型的判断逻辑，当泛型参数是 any 这种特殊值时，会得到分布后的类型。 12345type IsNever&lt;T&gt; = [T] extends [never] ? true : false;type I0 = IsNever&lt;never&gt; // truetype I1 = IsNever&lt;never | string&gt; // falsetype I2 = IsNever&lt;null&gt; // false 第二十七题 实现一个Reverse工具类型，用于对元祖类型中元素的位置颠倒，并返回该数组，元祖的第一个元素就会变成最后一个，最后一个元素变成第一个。 1234567type Reverse&lt; T extends any[], R extends any[] = []&gt; = // 代码实现type R0 = Reverse&lt;[]&gt; // []type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1] 解决方案 1 1234567type Reverse&lt; T extends any[], R extends any[] = []&gt; = T extends [infer A, ...infer B] ? Reverse&lt;B, [A, ...R]&gt; : R;type R0 = Reverse&lt;[]&gt; // []type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1] 解决方案 2 123456type Reverse&lt; T extends any[]&gt; = T extends [infer A, ...infer B] ? [...Reverse&lt;B&gt;, A] : [];type R0 = Reverse&lt;[]&gt; // []type R1 = Reverse&lt;[1, 2, 3]&gt; // [3, 2, 1] 第二十八题 实现一个Split工具类型，根据给定的分割符(Delimiter)对包含分割符的字符串进行切割，可用于定义String.prototype.split方法的返回值类型，示例如下： 12345678type Item = `zs, ls, ww`;type Split&lt; S extends string, Delimiter extends string&gt; = // 代码实现type ElementType = Split&lt;Item, ','&gt;; // [&quot;zs&quot;, &quot;ls&quot;,&quot;ww&quot;] 解决方案 1234567891011121314type Item = `zs, ls, ww`;type Split&lt; S extends string, Delimiter extends string,&gt; = S extends `${infer Key}${Delimiter}${infer Rest}`? [Key, ...Split&lt;Rest, Delimiter&gt;]: S extends '' /* 处理空字符串 */? []: [S]type ElementType = Split&lt;Item, ','&gt;; // [&quot;zs&quot;, &quot;ls&quot;,&quot;ww&quot;]type ElementType2 = Split&lt;'a|b|c||d', '|'&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;d&quot;]type ElementType3 = Split&lt;'abcdef', ''&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 第二十九题 实现一个ToPath工具类型，用于把属性访问(.或[])路径转换为元祖的形式，示例如下： 1234type ToPath&lt;S extends string&gt; = // 代码实现ToPath&lt;'foo.bar.baz'&gt; // ['foo', 'bar', 'baz']ToPath&lt;'foo[0].bar.baz'&gt; // ['foo', '0', 'bar', 'baz'] 解决方案 12345678910type ToPath&lt;S extends string&gt; = S extends `${infer F}${`[${infer D}]`}${infer R}`? [...ToPath&lt;F&gt;, ...([D] extends [never] ? [] : [D]), ...ToPath&lt;R&gt;]: S extends `${infer F}.${infer R}`? [...ToPath&lt;F&gt;, ...ToPath&lt;R&gt;]: S extends ''? []: [S]type T0 = ToPath&lt;'foo.bar.baz'&gt; // ['foo', 'bar', 'baz']type T1 = ToPath&lt;'foo[0].bar.baz'&gt; // ['foo', '0', 'bar', 'baz'] 第三十题 完善Chainable类型的定义，是的 TS 能成功推断出result变量的类型，调用option方法之后会不断扩展当前对象的类型，使得调用get方法后能获取正确的类型。 12345678910111213141516171819202122declare const config: Chainabletype Chainable = { option(key: string, value: any): any get(): any}const result = config .option('age', 7) .option('name', 'lolo') .option('address', { value: 'XiaMen' }) .get()type ResultType = typeof result// 期望 ResultType 的类型是：// {// age: number// name: string// address: {// value: string// }// } 解决方案 12345678910declare const config: Chainable;type Chainable&lt;T = {}&gt; = { option&lt;K extends string, V extends any&gt;(key: K, value: V): Chainable&lt;{ [P in K]: V } &amp; T&gt;; get(): T;};const result = config.option(&quot;age&quot;, 7).option(&quot;name&quot;, &quot;lolo&quot;).option(&quot;address&quot;, { value: &quot;XiaMen&quot; }).get();type ResultType = typeof result; 第三十一题 实现一个Repeat工具类型，用于根据类型变量C的值，重复T类型并以元祖的形式返回新的类型，示例如下： 12345type Repeat&lt;T, C extends number&gt; = // 代码实现type R0 = Repeat&lt;0, 0&gt;; // []type R1 = Repeat&lt;1, 3&gt;; // [1, 1, 1]type R2 = Repeat&lt;number, 2&gt;; // [number, number] 解决方案 12345type Repeat&lt;T, C extends number, A extends any[]&gt; = A[&quot;length&quot;] extends C ? A : Repeat&lt;T, C, [...A, T]&gt;;type R0 = Repeat&lt;0, 0&gt;; // []type R1 = Repeat&lt;1, 3&gt;; // [1, 1, 1]type R2 = Repeat&lt;number, 2&gt;; // [number, number] 第三十二题 实现一个RepeatString工具类型，用于根据类型变量C的值，重复 T 类型并以字符串的形式返回新的类型，示例如下： 1234567type RepeatString&lt; T extends string, C extends number,&gt; = // 代码实现type S0 = RepeatString&lt;&quot;a&quot;, 0&gt;; // ''type S1 = RepeatString&lt;&quot;ab&quot;, 2&gt;; // 'abab' 解决方案 1234567891011type RepeatString&lt; T extends string, C extends number, S extends string = '', A extends any[] = []&gt; = A[&quot;length&quot;] extends C? S: RepeatString&lt;T, C, `${S}${T}`, [...A, T]&gt;type S0 = RepeatString&lt;&quot;a&quot;, 0&gt;; // ''type S1 = RepeatString&lt;&quot;ab&quot;, 2&gt;; // 'abab' 第三十三题 实现一个ToNumber工具类型，用于实现把数值字符串转换为数值类型，示例如下： 12345type ToNumber&lt;T extends string&gt; = // 代码实现type T0 = ToNumber&lt;&quot;0&quot;&gt;; // 0type T1 = ToNumber&lt;&quot;10&quot;&gt;; // 10type T2 = ToNumber&lt;&quot;20&quot;&gt;; // 20 解决方案 123456type ToNumber&lt;T extends string, S extends any[] = [], L extends number = S[&quot;length&quot;]&gt; =`${L}` extends T ? L : ToNumber&lt;T, [...S, 1]&gt;type T0 = ToNumber&lt;&quot;0&quot;&gt;; // 0type T1 = ToNumber&lt;&quot;10&quot;&gt;; // 10type T2 = ToNumber&lt;&quot;20&quot;&gt;; // 20 第三十四题 实现一个SmallerThan工具类型，用于比较数值类型的大小，示例如下： 12345678type SmallerThan&lt; N extends number, M extends number,&gt; = //代码实现type S0 = SmallerThan&lt;0, 1&gt;; // truetype S1 = SmallerThan&lt;2, 0&gt;; // falsetype S2 = SmallerThan&lt;8, 10&gt;; // true 解决方案 123456789101112type SmallerThan&lt; N extends number, M extends number, S extends any[] = [], L extends number = S[&quot;length&quot;]&gt; = L extends N? L extends M ? false : true: L extends M ? false : SmallerThan&lt;N, M, [...S, 1]&gt;type S0 = SmallerThan&lt;0, 1&gt;; // truetype S1 = SmallerThan&lt;2, 0&gt;; // falsetype S2 = SmallerThan&lt;8, 10&gt;; // true 第三十五题 实现一个Add工具类型，用于实现对数组对应的数值进行加法运算，示例如下： 12345type Add&lt;T, R&gt; = // 代码实现type A0 = Add&lt;5, 5&gt;; // 10type A1 = Add&lt;8, 20&gt;; // 28type A2 = Add&lt;10, 20&gt;; // 30 解决方案 123456789101112type Push&lt;T extends number[], V&gt; = [...T, V];type CreateTuple&lt; T extends number, A extends number[] = []&gt; = A[&quot;length&quot;] extends T ? A : CreateTuple&lt;T, Push&lt;A, 1&gt;&gt;;type Add&lt;T extends number, R extends number&gt; = [...CreateTuple&lt;T&gt;, ...CreateTuple&lt;R&gt;][&quot;length&quot;];type A0 = Add&lt;5, 5&gt;; // 10type A1 = Add&lt;8, 20&gt;; // 28type A2 = Add&lt;10, 20&gt;; // 30 第三十六题 实现一个Filter工具类型，用于根据类型变量F的值进行类型过滤，示例如下： 12345type Filter&lt;T extends any[], F&gt; = // 代码实现type F0 = Filter&lt;[6, &quot;lolo&quot;, 7, &quot;semlinker&quot;, false], number&gt;; // [6, 7]type F1 = Filter&lt;[&quot;kakuqo&quot;, 2, [&quot;ts&quot;], &quot;lolo&quot;], string&gt;; // [&quot;kakuqo&quot;, &quot;lolo&quot;]type F2 = Filter&lt;[0, true, any, &quot;abao&quot;], string&gt;; // [any, &quot;abao&quot;] 解决方案 1234// 本题关键点就是对`any`类型的处理：type A0 = any &amp; 1; // anytype A1 = any &amp; boolean; // anytype A2 = any &amp; never; // never 1234567891011type IsAny&lt;T&gt; = 0 extends (1 &amp; T) ? true : false;type Filter&lt;T extends any[], F&gt; = T extends [infer R1, ...infer R2]? IsAny&lt;R1&gt; extends true? [R1, ...Filter&lt;R2, F&gt;]: [...R1 extends F ? [R1] : [], ...Filter&lt;R2, F&gt;]:[]type F0 = Filter&lt;[6, &quot;lolo&quot;, 7, &quot;semlinker&quot;, false], number&gt;; // [6, 7]type F1 = Filter&lt;[&quot;kakuqo&quot;, 2, [&quot;ts&quot;], &quot;lolo&quot;], string&gt;; // [&quot;kakuqo&quot;, &quot;lolo&quot;]type F2 = Filter&lt;[0, true, any, &quot;abao&quot;], string&gt;; // [any, &quot;abao&quot;] 第三十七题 实现一个Flat工具类型，支持把数组类型拍平（扁平化）,示例如下： 12345type Flat&lt;T extends any[]&gt; = // 代码实现type F0 = Flat&lt;[]&gt;; // []type F1 = Flat&lt;['a', 'b', 'c']&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]type F2 = Flat&lt;['a', ['b', 'c'], ['d', ['e', ['f']]]]&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 解决方案 1 123456789type Flat&lt;T extends any[]&gt; = T extends [infer First, ...infer Rest]? First extends any[]? [...Flat&lt;First&gt;, ...Flat&lt;Rest&gt;]: [First, ...Flat&lt;Rest&gt;]: [];type F0 = Flat&lt;[]&gt;; // []type F1 = Flat&lt;['a', 'b', 'c']&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]type F2 = Flat&lt;['a', ['b', 'c'], ['d', ['e', ['f']]]]&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 解决方案 2 123456789type Flat&lt;T extends any[], S extends any[] = []&gt; = T extends [infer R, ...infer Rest]? R extends any[]? Flat&lt;Rest, Flat&lt;R, S&gt;&gt;: Flat&lt;Rest, [...S, R]&gt;: Stype F0 = Flat&lt;[]&gt;; // []type F1 = Flat&lt;['a', 'b', 'c']&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]type F2 = Flat&lt;['a', ['b', 'c'], ['d', ['e', ['f']]]]&gt;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 第三十八题 实现StartsWith工具类型，判断字符串字面量类型T是否以给定的字符串字面量类型U开头，并根据判断结果返回布尔值，示例如下： 12345type StartsWith&lt;T extends string, U extends string&gt; = // 代码实现type S0 = StartsWith&lt;'123', '12'&gt;; // truetype S1 = StartsWith&lt;'123', '13'&gt;; // falsetype S2 = StartsWith&lt;'123', '1234'&gt;; // false 之后，继续实现EndsWith工具类型，判断字符串字面量类型T是否以给定的字符串字面量类型U结尾，并根据判断结果返回布尔值，示例如下： 12345type EndsWith&lt;T extends string, U extends string&gt; = // 代码实现type E0 = EndsWith&lt;'123', '23'&gt;; // truetype E1 = EndsWith&lt;'123', '13'&gt;; //falsetype E2 = EndsWith&lt;'123', '123'&gt;; //true 解决方案 12345678910111213// StartWithtype StartsWith&lt;T extends string, U extends string&gt; = T extends `${U}${infer R}` ? true : false;type S0 = StartsWith&lt;'123', '12'&gt;; // truetype S1 = StartsWith&lt;'123', '13'&gt;; // falsetype S2 = StartsWith&lt;'123', '1234'&gt;; // false// EndsWithtype EndsWith&lt;T extends string, U extends string&gt; = T extends `${infer Head}${U}` ? true : false;type E0 = EndsWith&lt;'123', '23'&gt;; // truetype E1 = EndsWith&lt;'123', '13'&gt;; //falsetype E2 = EndsWith&lt;'123', '123'&gt;; //true 第三十九题 实现IsAny工具类型，用于判断类型T是否为any类型，示例如下： 12345type IsAny&lt;T&gt; = // 代码实现type I0 = IsAny&lt;never&gt;; // falsetype I1 = IsAny&lt;unknown&gt;; // falsetype I2 = IsAny&lt;any&gt;; // tue 解决方案 1 123456// 思路： 利用任何类型和any交叉都等于any来实现type IsAny&lt;T&gt; = 0 extends 1 &amp; T ? true : false;type I0 = IsAny&lt;never&gt;; // falsetype I1 = IsAny&lt;unknown&gt;; // falsetype I2 = IsAny&lt;any&gt;; // tue 解决方案 2 123456// unknown 只能赋给 unknown 或者 anytype IsAny&lt;T&gt; = [unknown] extends [T] ? ([T] extends [string] ? true : false) : false;type I0 = IsAny&lt;never&gt;; // falsetype I1 = IsAny&lt;unknown&gt;; // falsetype I2 = IsAny&lt;any&gt;; // tue 第四十题 实现AnyOf工具类型，只要数组中任意元素的类型非Falsy类型、{}类型或[]类型，则返回true，否则返回false,如果数组为空的话，则返回false，示例如下： 12345type AnyOf&lt;T extends any[]&gt; = // 代码实现type A0 = AnyOf&lt;[]&gt;; //falsetype A1 = AnyOf&lt;[0,'',false,[],{}]&gt;; //falsetype A2 = AnyOf&lt;[1, &quot;&quot;,false,[],{}]&gt;; true 解决方案 1234567type Falsy = { [p in PropertyKey]: never} | [] | '' | &quot;&quot; | false | 0 | undefined | nulltype AnyOf&lt;T extends any[]&gt; = T extends [infer A, ...infer Rest]? (A extends Falsy ? AnyOf&lt;Rest&gt; : true): false 第四十一题 实现Replace工具类型，用于实现字符串类型的替换操作，具体的使用示例如下： 123456789type Replace&lt; S extends string, From extends string, To extends string&gt; = // 代码实现type R0 = Replace&lt;'', '', ''&gt;; // ''type R1 = Replace&lt;'foobar', 'bar', 'foo'&gt;; // 'foofoo'type R2 = Replace&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoobar' 此外，继续实现ReplaceAll工具类型，用于实现替换所有满足条件的字串，示例如下： 12345678910type ReplaceAll&lt; S extends string, From extends string, To extends string&gt; = // 代码实现type R0 = ReplaceAll&lt;'', '', ''&gt;; // ''type R1 = ReplaceAll&lt;'barfoo', 'bar', 'foo'&gt;; // 'foofoo'type R2 = ReplaceAll&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoofoo'type R3 = ReplaceAll&lt;'foobarfoobar', 'ob', 'b'&gt;; // 'fobarfobar' 解决方案 1234567891011type Replace&lt; S extends string, From extends string, To extends string,&gt; = S extends `${infer H}${From}${infer R}`? `${H}${To}${R}`: S;type R0 = Replace&lt;'', '', ''&gt;; // ''type R1 = Replace&lt;'foobar', 'bar', 'foo'&gt;; // 'foofoo'type R2 = Replace&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoobar' 123456789101112type ReplaceAll&lt; S extends string, From extends string, To extends string,&gt; = S extends `${infer H}${From}${infer R}`? `${H}${To}${ReplaceAll&lt;R, From, To&gt;}`: S;type R0 = ReplaceAll&lt;'', '', ''&gt;; // ''type R1 = ReplaceAll&lt;'barfoo', 'bar', 'foo'&gt;; // 'foofoo'type R2 = ReplaceAll&lt;'foobarbar', 'bar', 'foo'&gt;; // 'foofoofoo'type R3 = ReplaceAll&lt;'foobarfoobar', 'ob', 'b'&gt;; // 'fobarfobar' 第四十二题 实现IndexOf工具类型，用于获取数组类型中指定项的索引值，若不存在的话，则返回-1字面量类型，示例如下： 123456type IndexOf&lt;A extends any[], Item&gt; = // 代码实现type Arr = [1, 2, 3, 4, 5];type I0 = IndexOf&lt;Arr, 0&gt;; // -1type I1 = IndexOf&lt;Arr, 1&gt;; // 0type I2 = IndexOf&lt;Arr, 3&gt;; // 2 解决方案 12345678910type IndexOf&lt;A extends any[], Item, R extends any[] = []&gt; = A extends [infer H, ...infer Rest]? Item extends H? R[&quot;length&quot;]: IndexOf&lt;Rest, Item, [...R, H]&gt;: -1type Arr = [1, 2, 3, 4, 5];type I0 = IndexOf&lt;Arr, 0&gt;; // -1type I1 = IndexOf&lt;Arr, 1&gt;; // 0type I2 = IndexOf&lt;Arr, 3&gt;; // 2 第四十三题 实现一个Permutation工具类型，当输入一个联合类型时，返回一个包含该联合类型的全排列类型数组。示例如下： 1234type Permutation&lt;T, K = T&gt; = // 代码实现type P0 = Permutation&lt;'a' | 'b'&gt;; // ['a', 'b'] | ['b' , 'a']type P1 = Permutation&lt;'a' | 'b' | 'c'&gt;; //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] | [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;] | [&quot;b&quot;, &quot;a&quot;, &quot;c&quot;] | [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] | [&quot;c&quot;, &quot;a&quot;, &quot;b&quot;] | [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;] 解决方案 12345678type Permutation&lt;T, K = T&gt; = [T] extends [never]? []: K extends K? [K, ...Permutation&lt;Exclude&lt;T, K&gt;&gt;]: nevertype P0 = Permutation&lt;'a' | 'b'&gt;; // ['a', 'b'] | ['b' , 'a']type P1 = Permutation&lt;'a' | 'b' | 'c'&gt;; //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] | [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;] | [&quot;b&quot;, &quot;a&quot;, &quot;c&quot;] | [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] | [&quot;c&quot;, &quot;a&quot;, &quot;b&quot;] | [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;] 第四十四题 实现Unpacked工具类型，用于对类型执行“拆箱”操作，示例如下： 12345678910type Unpacked&lt;T&gt; = // 代码实现// 测试用例type T00 = Unpacked&lt;string&gt;; // stringtype T01 = Unpacked&lt;string[]&gt;; // stringtype T02 = Unpacked&lt;() =&gt; string&gt;; // stringtype T03 = Unpacked&lt;Promise&lt;string&gt;&gt;; // stringtype T04 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;; // stringtype T05 = Unpacked&lt;any&gt;; // anytype T06 = Unpacked&lt;never&gt;; // never 解决方案 12345678910111213141516type Unpacked&lt;T&gt; = T extends (...args: any) =&gt; infer A? A: T extends Promise&lt;infer B&gt;? B: T extends (infer A)[]? A: T// 测试用例type T00 = Unpacked&lt;string&gt;; // stringtype T01 = Unpacked&lt;string[]&gt;; // stringtype T02 = Unpacked&lt;() =&gt; string&gt;; // stringtype T03 = Unpacked&lt;Promise&lt;string&gt;&gt;; // stringtype T04 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;; // stringtype T05 = Unpacked&lt;any&gt;; // anytype T06 = Unpacked&lt;never&gt;; // never 第四十五题 实现JsonifiedObject工具类型，用于对Object对象类型进行序列话操作，示例如下： 123456789101112131415161718192021declare class MyClass { toJSON(): &quot;MyClass&quot;;}type Jsonified&lt;T extends object&gt; = // 代码实现type MyObject = { str: &quot;literalstring&quot;; fn: () =&gt; void; date: Date; customClass: MyClass; obj: { prop: &quot;property&quot;; clz: MyClass; nested: { attr: Date }; };};type JsonifiedMyObject = Jsonified&lt;MyObject&gt;;declare let ex: JsonifiedMyObject;const z1: &quot;MyClass&quot; = ex.customClass;const z2: string = ex.obj.nested.attr; 解决方案 1234567891011121314151617181920212223242526272829declare class MyClass { toJSON(): &quot;MyClass&quot;;}type Jsonified&lt;T extends object&gt; = { [K in keyof T]: T[K] extends { toJSON(): infer Return } ? ReturnType&lt;T[K][&quot;toJSON&quot;]&gt; : T[K] extends (...arg: any[]) =&gt; any ? never : T[K] extends object ? Jsonified&lt;T[K]&gt; : T[K];};type MyObject = { str: &quot;literalstring&quot;; fn: () =&gt; void; date: Date; customClass: MyClass; obj: { prop: &quot;property&quot;; clz: MyClass; nested: { attr: Date }; };};type JsonifiedMyObject = Jsonified&lt;MyObject&gt;;declare let ex: JsonifiedMyObject;const z1: &quot;MyClass&quot; = ex.customClass;const z2: string = ex.obj.nested.attr; 第四十六题 实现RequireAllOrNone工具类型，用于满足以下功能，当设置age属性时，gender属性也会变成必填，示例如下： 1234567891011121314151617interface Person { name: string; age?: number; gender?: number;}type RequireAllOrNone&lt;T, K extends keyof T&gt; = // 你的实现代码const p1: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;};const p2: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1}; 解决方案 123456789101112131415161718192021222324interface Person { name: string; age?: number; gender?: number;}type RequireAllOrNone&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; &amp; ( {[P in K]-?: T[P]} | {[P in K]?: never})const p1: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;};const p2: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1};const p3: RequireAllOrNone&lt;Person, 'age' | 'gender'&gt; = { // error name: &quot;lolo&quot;, age: 7,}; 第四十七题 实现RequireExactlyOne工具类型，用于满足以下功能，即只能包含age或gender属性，不能包含着两个属性，示例如下： 12345678910111213141516171819202122232425interface Person { name: string; age?: number; gender?: number;}// 只能包含Keys中唯一的一个Keytype RequireExactlyOne&lt;T, Keys extends keyof T&gt; = // 你的实现代码const p1: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7,};const p2: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, gender: 1};// Errorconst p3: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1}; 解决方案 12345678910111213141516171819202122232425262728interface Person { name: string; age?: number; gender?: number;}// 只能包含Keys中唯一的一个Keytype RequireExactlyOne&lt;T, Keys extends keyof T, K extends keyof T = Keys&gt; =Keys extends any? Omit&lt;T, K&gt; &amp; Required&lt;Pick&lt;T, Keys&gt;&gt; &amp; Partial&lt;Record&lt;Exclude&lt;K, Keys&gt;, never&gt;&gt;: never;const p1: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7,};const p2: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, gender: 1};// Errorconst p3: RequireExactlyOne&lt;Person, 'age' | 'gender'&gt; = { name: &quot;lolo&quot;, age: 7, gender: 1}; 第四十八题 实现ConsistsOnlyOf工具类型，用于判断LongString字符串类型是否由 0 个或多个Substring字符串类型组成，示例如下： 123456type ConsistsOnlyOf&lt;LongString extends string, SubString extends string&gt; = // 代码实现type C0 = ConsistsOnlyOf&lt;'aaa', 'a'&gt;; // truetype C1 = ConsistsOnlyOf&lt;'ababab', 'ab'&gt;; // truetype C2 = ConsistsOnlyOf&lt;'aBa', 'a'&gt;; // falsetype C3 = ConsistsOnlyOf&lt;'', 'a'&gt;; // true 解决方案 1234567891011type ConsistsOnlyOf&lt;LongString extends string, SubString extends string&gt; =LongString extends ''? true: LongString extends `${SubString}${infer R}`? ConsistsOnlyOf&lt;R, SubString&gt;: falsetype C0 = ConsistsOnlyOf&lt;'aaa', 'a'&gt;; // truetype C1 = ConsistsOnlyOf&lt;'ababab', 'ab'&gt;; // truetype C2 = ConsistsOnlyOf&lt;'aBa', 'a'&gt;; // falsetype C3 = ConsistsOnlyOf&lt;'', 'a'&gt;; // false","link":"/2022/01/17/TS%E8%BF%9B%E9%98%B6%E9%A2%98%E7%9B%AE/"},{"title":"WEB前端性能优化","text":"WEB 前端性能优化常见方法前端性能优化针对不用资源有不同的性能优化方式 内容优化 + (1)减少HTTP请求数：因为一个完整的请求要经过 DNS寻址，与服务器建立连接，发送数据， 等待服务器响应，接受数据等消耗时间成本和资源成本的复杂过程。 - 常见解决方法： + 资源和并和压缩：合并多个 CSS 文件和 js 文件并使用相应的工具对 js、css、图片等进行压缩处理 + 雪碧图（精灵图）：减少请求数 + 合理设置 http 缓存：原则就是能缓存的越多越好，越久越好，通过 http header 中设置 Expires 过期时间，或者 Last-Modifed 进行请求验证 + 减少 http 请求头、配置多个域名和 CDN 加速、使用缓存（HTTP 缓存、浏览器缓存、应用缓存）、优化 cookie + （2）避免重定向：减少不必要的 http 跳转 + （3）延迟加载组件，预加载组件，图片懒加载 + （4）减少 DOM 元素数量：页面中存在大量 DOM 元素，会导致 JavaScript 遍历 DOM 的效率变慢。 服务器优化 （1）使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度 （2）Gzip 压缩 （3）设置 ETag：ETags（Entity tags，实体标签）是 web 服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。 （4）提前刷新缓冲区 （5）避免空的图像 src Cookie 优化 （1）减少 Cookie 的大小 （2）针对 Web 组件使用域名无关的 Cookie CSS 优化 将 CSS 代码放在 HTML 页面的顶部 避免使用 CSS 表达式 使用来代替@import 避免使用 Filters JavaScript 优化 (1) 将 JavaScript 脚本放在页面的底部。 (2) 将 JavaScript 和 CSS 作为外部文件来引用：在实际应用中使用外部文件可以提高页面速度，因为 JavaScript 和 CSS 文件都能在浏览器中产生缓存。 (3) 最小化 DOM 的访问：使用 JavaScript 访问 DOM 元素比较慢。 (4) document.getElement…将获取到的元素长度提取出来 (5) 尽量减少会产生 reflow 和 repaint 的操作，因为它们都是需要消耗资源的 (6) 慎用 with，with 他会修改编译时的词法作用域，修改了执行环境，访问非局部属性的时候，会从指定 obj 作用域上开始查找，相当于增长了作用域长度，而过长的作用域链会造成查找性能下降。 (7) 慎用 eval 和 Function,需要 js 引擎将源代码转换成可执行代码，这是很消耗资源的操作，同时，也不利于压缩工具进行压缩。 (8) 减少作用域链的查找，访问非本作用域下的变量，在循环遍历的时候使用局部变量缓存该变量，遍历结束后再重写那个变量，尤其是全局变量处于作用域的最顶端，访问时查找次数最多 图像优化 (1)优化图片大小 （2）通过 CSS Sprites 优化图片 （3）不要在 HTML 中使用压缩图片 （4）favicon.ico 要小而且可缓存 robots.txt搜索引擎蜘蛛访问网站时会第一个访问 robots.txt 文件，robots.txt 用于指导搜索引擎蜘蛛禁止抓取网站的某些内容和只允许抓取哪些内容，放在站点根目录。 dns-prefetch &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.bootcss.com&quot;&gt; 使用 dns-prefetch 对项目中使用的域名进行 DNS 预解析，减少 DNS 查询。 URL 优化越短越好避免太多参数目录层次尽量少文件及目录名具有描述性字母全部小写连词符使用-而不是_URL 中包括关键字 TDK 优化TDK 为 title，description，keywords 三个的统称。title：分隔符一般有 ， - ,其中对百度比较友好，-对谷歌比较友好，title 长度 pc 端一般30 个中文，移动端 20 个，超过会截断为省略号。 其他标签语义化img 设置 alt 属性不需要跟踪爬行的链接，设置 rel = “nofollow” [参考]：（https://segmentfault.com/a/1190000008829958）","link":"/2019/07/17/WEB%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"Vuex &amp; Redux工作流程","text":"Vue 核心原理 Store : 统一的状态管理容器对象 Vue Components : Vue 组件 dispatch : 操作行为触发方法，是唯一能执行 action 的方法 actions : 操作行为处理模块。 负责处理 Vue Components 接收的所有交互行为， commit : 状态改变提交操作方法，对 mutation 进行提交，是唯一能执行 mutation的方法 mutation : 状态改变操作方法，Vuex 中修改 state 的唯一推荐方法，该方法只能进行同步操作 getter : state 对象读取方法，类似 computed 计算属性。 过程：Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。 Redux 核心原理 只使用 redux，流程是这样的： component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component 使用 react-redux 之后，流程是这样的： component –&gt; actionCreator(data) –&gt; reducer –&gt; component store 的三大功能：dispatch,subscribe,getState 都不需要手动来写了，react-redux 帮我们做了这些，同时提供了 Provider 和 connect 注意点: store 是唯一的 只有 store 能够改变自己的内容 reducer 必须是一个纯函数（给定固定的输入，一定会有固定的输出，不会产生副作用） 核心 API createStore(reducer) 创建 store，并将 reducer 传递给 store store.dispatch(action) 创建 action 之后，负责将 action 传给 store action 是一个对象形式，会包含 Type(告诉 store 要做的事情)、Value(参数结果) store.getState() 获取 store 内容 store.subscribe() 订阅 store 改变，只要 store 发生改变，其中的回调函数就会被执行 Vuex 和 Redux 的区别？ 都是状态管理系统，除了具备床柜的状态管理的功能之外，也针对自身框架进行一些优化特性。 状态注入组件： React-Redux: 通过&lt;Provider/&gt;组件拿到 store 之后，还需要显示指定容器组件，即用 connect 包装一下该组件。 Vue 通过 Vue.use(Vuex)将 vuex 应用为全局的插件，将 store 传入跟实例，就可以使得 store 对象运行在任何 vue 组件中。 vuex 借鉴 redux，通过弱化概念（action、reducer），弱化了 dispatch 的存在感，任何东西都没做实质性消减，但同时使得整套框架更加易于理解了","link":"/2019/09/18/Vuex-Redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"title":"docker实践指南","text":"启动 docker 1open /Applications/Docker.app docker runeg1: 1docker run ubuntu:15.10 /bin/echo 'hello world' 各个参数解析： docker：Docker 的二进制执行文件 run：与 docker 组合来运行一个容器 ubuntu:15.10 指定要运行的景象，docker 先从本地主机查找景象是否存在，如不存在，docker 就会从 Docker hub镜像仓库下载公共镜像 /bin/echo ‘hello world’：在启动的容器中执行的命令 注意： 不存在时会出现错误信息： Unable to find image ‘ubuntu:15.10’ locally 之后便会从镜像仓库下载公共镜像 打印 hello world M1-Mac 可能会出现如下警告：WARNING: The requested image’s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested 解决方法：docker run –platform linux/amd64 ubuntu:15.10 /bin/echo ‘hello world’ eg2: 123456// 启动容器 docker run -p xxx:xxx -v=hostPath:containerPath -d --name &lt;container-name&gt; &lt;image-name&gt;// -p 端口映射// -v 数据卷，文件映射// -d 后台运行// --name 定义容器名称docker run -p 81:80 -d --name nginx1 nginx DockerfileDockerfile 是一个用来构建镜像的文本文件，文件内容包含一条条构建镜像所需的指令和说明 12345678910111213#DockerfileFROM node:latestWORKDIR /appCOPY . /appRUN npm set registry https://registry.npm.taobao.orgRUN npm installRUN npm install pm2 -gCMD echo $SERVER_NAME &amp;&amp; echo $AUTHOR_NAME &amp;&amp; npm run start &amp;&amp; npx npm2 logENV SERVER_NAME = 'react-demo'ENV AUTHOR_NAME = 'foolishmax' .dockerignore12.gitnode_modules 始构建镜像在 Dockerfile 文件的存放目录下，执行构建动作 1docker bild -t react-demo-image . docker images 查看1234REPOSITORY TAG IMAGE ID CREATED SIZEreact-demo-image latest 35c499bddac6 3 minutes ago 1.22GBnode-test latest 028a51c6e54d 8 months ago 945MBnginx latest f1325989da19 8 months ago 134MB 运行容器1docker run -p 8081:3000 -d --name react-demo-server react-demo-image 查看容器12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf71ef1480035 react-demo-image &quot;docker-entrypoint.s…&quot; 4 seconds ago Up 3 seconds 0.0.0.0:8081-&gt;3000/tcp react-demo-server 查看日志docker logs f71ef1480035 1234567891011121314151617181920212223242526# 这两行对应Dockerfile中的CMD变量打印= react-demo= foolishmax&gt; react-demo@0.1.0 start&gt; react-scripts start(node:27) [DEP_WEBPACK_DEV_SERVER_ON_AFTER_SETUP_MIDDLEWARE] DeprecationWarning: 'onAfterSetupMiddleware' option is deprecated. Please use the 'setupMiddlewares' option.(Use `node --trace-deprecation ...` to show where the warning was created)(node:27) [DEP_WEBPACK_DEV_SERVER_ON_BEFORE_SETUP_MIDDLEWARE] DeprecationWarning: 'onBeforeSetupMiddleware' option is deprecated. Please use the 'setupMiddlewares' option.Starting the development server...Compiled successfully!You can now view react-demo in the browser. Local: http://localhost:3000 On Your Network: http://172.17.0.2:3000Note that the development build is not optimized.To create a production build, use npm run build.webpack compiled successfullyCompiling...Compiled successfully!webpack compiled successfully 停止容器docker stop f71ef1480035 删除容器docker rm f71ef1480035 删除镜像docker rmi 35c499bddac6 12Untagged: react-demo-image:latestDeleted: sha256:35c499bddac6675ff20a7d951fc1c1f6770a10430278fec6f2b8d1c866037624 docker-compose.yml 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344version: &quot;3&quot;services: edditor-server: # service name build: context: . #当前目录 dockerfile: Dockerfile # 基于Dockerfile构建 image: editor-server #依赖当前dockerfile创建出来的镜像 container_name: editor-server ports: - 8081:3000 #宿主机通过8081访问 editor-redis: image: redis #引用官方redis镜像 container_name: editor-redis ports: - 6378:6379 environment: - TZ=Asia/Shanghai # 设置时区 editor-mysql: image: mysql # 引用官网 mysql 镜像 container_name: editor-mysql restart: always # 出错则重启 privileged: true # 高权限，执行下面的 mysql/init command: --default-authentication-plugin=mysql_native_password # 远程访问 ports: - 3305:3306 # 宿主机可以用 127.0.0.1:3305 即可连接容器中的数据库，和 redis 一样 volumes: - .docker-volumes/mysql/log:/var/log/mysql # 记录日志 - .docker-volumes/mysql/data:/var/lib/mysql # 数据持久化 - ./mysql/init:/docker-entrypoint-initdb.d/ # 初始化 sql environment: - MYSQL_DATABASE=imooc_lego_course # 初始化容器时创建数据库 - MYSQL_ROOT_PASSWORD=Mysql_2019 - TZ=Asia/Shanghai # 设置时区 editor-mongo: image: mongo # 引用官网 mongo 镜像 container_name: editor-mongo restart: always volumes: - &quot;.docker-volumes/mongo/data:/data/db&quot; # 数据持久化,映射本地文件 environment: - MONGO_INITDB_DATABASE=imooc_lego_course - TZ=Asia/Shanghai # 设置时区 ports: - &quot;27016:27017&quot; # 宿主机可以用 127.0.0.1:27016 即可连接容器中的数据库 构建容器 docker-compose build 启动所有服务器 docker-compose up -d,后台启动 查看服务 docker-compose ps (相比较 docker ps 等于多了层作用域) 停止所有服务 docker-compose down 注意：经过以上操作之后需修改.gitignore 文件，增加一行 .docker-volumes/","link":"/2022/07/31/docker%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"},{"title":"getcomputedstyle和style的区别","text":"getomputedstyle 和 style 的区别？ getComputedStyle 方法是只读的，只能获取样式，不能设置；而 element.style 能读写。 getComputedStyle 方法获取的是最终应用在元素上的所有 Css 属性样式(即使没有 css 代码)，而 element.style 只能获取元素 style 属性中的 css 样式。 getComputedStyle 可以获取伪元素的样式。 兼容性：getComputedStyle 方法在 IE6~IE8 是不支持的。","link":"/2019/09/26/getcomputedstyle%E5%92%8Cstyle%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"get和post请求的区别？","text":"get 和 post 的请求区别？ 区别一： get 重点是从服务器上获取资源 post 重点是向服务器发送数据 区别二： get 传输数据通过 url 请求，以 field（字段）=value 的形式放在 url 后，用“？”连接，多个请求数据间用“&amp;”连接，过程用户可见。 post 传输数据放在请求体（request body）中发送给服务器，用户不可见。 区别三： get 传输数据大小有限制（根本原因是卢兰其地址栏对输入的 url 有最大长度限制，超过会截断），但效率较高 post 可以传输大量数据，所以上传文件用 post 方式 区别四： get 请求不安全，因为参数直接暴露在 url 上，并且会保存在浏览器的历史记录中，不能用来传递敏感信息。 post 较 get 安全性较高。 区别五： get 方式只能支持 ASCII 字符，向服务传的中文字符可能会乱码。 post 支持标准字符集，可以正确传递中文字符。 区别六： get 在浏览器回退是无害的，而 post 会再次提交请求。 区别七 get 请求会被浏览器主动 cache（缓存），而 post 不会除非手动设置。","link":"/2019/09/07/get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"},{"title":"git commit提示Your branch is up-to-date with &#39;origin&#x2F;master&#39;","text":"git commit 提示 Your branch is up-to-date with ‘origin/master’ 新建一个分支 git branch newbranch 然后检查分支是否创建成功 git branch 切换到新的分支 git checkout newbranch 将改动提交到新的分支上 git add .git commit -m “0.0.1” 然后可以检查是否成功 git status 然后切换到主分支 git checkout master 然后将新分支提交的改动合并到主分支上 git merge newbanch push 到仓库 git push -u origin master 最后还可以删除这个分支 git branch -D newbranch","link":"/2019/09/21/git-commit%E6%8F%90%E7%A4%BAYour-branch-is-up-to-date-with-origin-master/"},{"title":"cookie封装以及元素拖拽记录位置","text":"cookie封装以及元素拖拽记录位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo{ position: absolute; left: 100px; top: 100px; width: 100px; height:100px; background: orange; color: #fff; font-size: 30px; text-align: center; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt;demo&lt;/div&gt; &lt;script&gt; var oDemo = document.getElementById('demo'); var manageCookie = { setCookie: function (key, value, date) {//增，改 var oDate = new Date(); oDate.setDate(oDate.getDate() + date); document.cookie = key + '=' + value + ';expires=' + oDate; return this; }, removeCookie: function (key) {//删 this.setCookie(key, '', -1 ); return this; }, getCookie: function (key, callback) {//查 var allCookie = document.cookie; var cookieArr = allCookie.split('; '); cookieArr.forEach(function (ele) { var item = ele.split('='); if(item[0] == key) { callback?callback(item[1]):''; } }) return this; } } var dragFun = { init: function () { //入口函数 this.dom = oDemo; manageCookie.getCookie('position', function (data) { if(data) { var dataArr = data.split('&amp;'); oDemo.style.left = dataArr[0] + 'px'; oDemo.style.top = dataArr[1] + 'px'; } }) dragFun.bindEvent(); }, bindEvent: function() { //绑定事件 this.dom.onmousedown = this.oDemoDown.bind(this); }, oDemoDown: function () { //鼠标按下触发的函数 this.disX = event.clientX - this.dom.offsetLeft; this.disY = event.clientY - this.dom.offsetTop; document.onmousemove = this.oDemoMove.bind(this); document.onmouseup = this.oDemoUp.bind(this); }, oDemoMove: function () { //鼠标移动 this.newLeft = event.clientX - this.disX; this.newTop = event.clientY - this.disY; this.dom.style.left = this.newLeft + 'px'; this.dom.style.top = this.newTop + 'px'; }, oDemoUp: function () { //鼠标抬起 document.onmousemove = null; document.onmouseup = null; var positionStr = this.newLeft + '&amp;' + this.newTop; manageCookie.setCookie('position', positionStr, 3); } } dragFun.init(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 简单拖拽封装 12345678910111213141516function drag (elem) { var disX, disY; elem.onmousedown = function(e) { disX = e.pageX - parseInt(div.style.left) disY = e.pageY - parseInt(div.style.top) document.onmousemove = function(e) { var event = e|| window.event div.style.left = e.pageX - disX + &quot;px&quot; div.style.top = e.pageY - disY + &quot;px&quot; } document.onmouseup = function() { div.onmousemove = null } } }","link":"/2019/08/08/cookie%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%83%E7%B4%A0%E6%8B%96%E6%8B%BD%E8%AE%B0%E5%BD%95%E4%BD%8D%E7%BD%AE/"},{"title":"js严格模式","text":"使用严格模式 在脚本 顶层 中添加 ‘use strict’ 为什么使用严格模式？ 消除 js 语法的一些不合理、不严谨之处，减少一些怪异行为 提高编译器效率，增加运行速度 为未来新版的 JavaScript 做好铺垫 严格模式和正常模式比较： 严格模式下，不允许给为声明的变量赋值。 严格模式下不允许使用 with 12345678!function () { 'use strict'; with({ x: 1 }) { console.log(x); //SyntaxError }}()// !function(){}() 表示：解释器在解释语句时，如果以function开头，就会理解为函数声明，//而前面加一个&quot;!&quot;可以让解释器理解为函数表达式，这样就可以立即调用了。 严格模式下，eval 变成了独立作用域 一般函数调用，this 默认指向全局对象，在严格模式下，this 指向 undefined 严格模式下，对 arguments 对象有很多限制，如不能给 arguments 赋值，不再支持 arguments.callee 和 arguments.caller 严格模式下，删除参数名、函数名会报错。非严格模式下返回 false，静态失败（不报错也没效果） 严格模式下，给不可扩展（Object.preventExtensions(obj)）对象的新属性赋值会报错.非严格模式下，静态失败。 严格模式下，修改不可写（Object.defineProperty(obj, ‘a’, {writable: false})）的属性报错。非严格模式下，静态失败。 严格模式下，删除不可配置（Object.defineProperty(obj, ‘a’, {configurable: false})）的属性报错。非严格模式下，静态失败。 严格模式下，给只读属性赋值会报错。 12345!function(){ 'use strict' var obj = {get x() {return 12;}} obj.x = 5 //TypeError} 严格模式下，禁止写八进制字面量。 严格模式下，对象的属性名重复设置会报错。非严格模式下，后者覆盖前者。 严格模式下，禁止设置五种基本类型的属性。（null.bbb = ‘xxx’ //TypeError） 严格模式下，不能使用一些保留的关键字（如 static、puclic、private、protected、interface）","link":"/2019/08/21/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"},{"title":"javascript常用api合集","text":"一、节点节点属性 12345678910111213141516171819Node.nodeName //返回节点名称，只读Node.nodeType //返回节点类型的常数值，只读Node.nodeValue //返回Text或Comment节点的文本值，只读Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI //返回当前网页的绝对路径Node.ownerDocument //返回当前节点所在的顶层文档对象，即documentNode.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode //返回当前节点的父节点Node.parentElement //返回当前节点的父Element节点Node.childNodes //返回当前节点的所有子节点Node.firstChild //返回当前节点的第一个子节点Node.lastChild //返回当前节点的最后一个子节点Node.children //返回当前节点的所有Element子节点Node.firstElementChild //返回当前节点的第一个Element子节点Node.lastElementChild //返回当前节点的最后一个Element子节点Node.childElementCount //返回当前节点所有Element子节点的数目 操作123456789101112131415Node.appendChild(node) //向节点添加最后的子节点Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true) //默认为false(克隆节点),true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode) //在指定子节点前插入新的子节点Node.removeChild(node) //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild) //替换节点Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(node) //返回布尔值，用于检查两个节点是否想等，所谓的相等节点，指的的两个节点的类型、属性、子节点都相同Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个ChildNode.remove() //用于删除当前节点ChildNode.before() //在ChildNode前插入元素节点或者文本节点ChildNode.after() //在ChildNode后插入元素或文本节点ChildNode.replaceWith() //替换该节点的父节点下的子节点，可以为文本或元素对象 Document 节点Document 节点的属性1234567891011121314151617181920212223242526document.doctype //返回当前文档关联的文档类型定义(DTD)document.documentElement //返回当前文档的根节点(html)document.defaultView //返回document对象所在的window对象document.body //返回当前文档的&lt;body&gt;节点document.head //返回当前文档的&lt;head&gt;节点document.activeElement //返回当前文档中获得焦点的那个元素document.links //返回当前文档的所有a元素document.forms //返回页面中所有表单元素document.images //返回页面中所有图片元素document.embeds //返回网页中所有嵌入对象document.scripts //返回当前文档的所有脚本document.styleSheets //返回当前网页的所有样式表document.documentURI //表示当前文档的网址document.URI //返回当前文档的网址document.domain //返回当前文档的域名document.lastModified //返回当前文档最后修改的时间戳document.location //返回location对象，提供当前文档的URL信息document.referrer //返回当前文档的访问来源document.title //返回当前文档的标题document.characterSet //属性返回渲染当前文档的字符集，比如UTF-8document.readyState //返回当前文档的状态document.designMode //控制当前文档是否可编辑，可读写document.compatMode //返回浏览器处理文档的模式document.cookie //用来操作Cookie Document 节点的方法读写方法1234document.open() //用于新建并打开一个文档document.close() //关闭open方法所新建的文档document.write() //用于向当前文档写入内容document.writeIn() //用于向当前文档写入内容，尾部添加换行符 查找节点1234567document.querySelector(selectors) //接收一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点document.querySelectorAll(selectors) //接收一个CSS选择器作为参数，返回所有匹配该选择器的元素节点document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name) //用于选择拥有name属性的HTML元素(比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;object&gt;等)document.getElementById(id) //返回匹配指定id属性的元素节点document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点 生成节点1234document.createElement(tagName) //用来生成HTML元素节点document.createTextNode(text) //用来生成文本节点document.createAttribute(name) //生成一个新的属性对象节点，并返回document.createDocumentFragment() //生成一个DocumentFragment对象 事件方法1234document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture) //注册事件document.removeEventListener(type,listener,capture) //注销事件document.dispatchEvent(event) //触发事件 其他123document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点document.importNode(externalNode,deep) //从外部文档拷贝指定节点，插入当前文档 Element 节点Element 节点的属性特性属性12345678Element.attributes //返回当前元素节点的所有属性节点Element.id //返回指定元素的id属性，可读写Element.tagName //返回指定元素的大写标签名Element.innerHTML //返回该元素包含的HTML代码，可读写Element.outerHTML //返回该元素节点的所有HTML代码，包括自身和所有子元素，可读写Element.className //返回当前元素的class属性，可读写Element.classList //返回当前元素节点的所有class集合Element.dataset //返回元素节点中所有data-*属性 尺寸属性12345678910111213141516Element.clientHeight //返回元素节点可见部分的高度Element.clientWidth //返回元素节点可见部分的宽度Element.clientLeft //返回元素节点左边框的宽度Element.clientTop //返回元素节点顶部边框的宽度Element.scrollHeight //返回元素节点的总高度Element.scrollWidth //返回元素节点的总宽度Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值，通过设置这个属性可以改变元素滚动的位置Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight //返回元素的垂直高度(包含border，padding)Element.offsetWidth //返回元素的水平宽度(包含border，padding)Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop //返回水平位移Element.style //返回元素节点的行内样式 节点相关属性1234567Element.children //包括当前元素节点的所有子元素Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild //返回当前节点的第一个Element子节点Element.lastElementChild //返回当前节点的最后一个Element子节点Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML元素节点Element.offsetParent //返回当前元素节点的最靠近、并且CSS的position属性不等于static的父元素 Element 节点的方法位置方法12getBoundingClientRect() //获取元素位置getClientRects() //返回当前元素在页面上的矩形区域 属性方法1234Element.getAttribute() //读取指定属性Element.setAttribute() //设置指定属性Element.hasAttribute() //返回一个布尔值，表示当前元素节点是否有指定属性Element.removeAttribute() //移除指定属性 查找方法1234Element.querySelector()Element.querySelectorAll()Element.getElementByTagName()Element.getElementByClassName() 事件方法1234567891011121314151617181920Element.addEventListener() //添加事件的回调函数Element.removeEventListener() //移除事件监听函数Element.dispatchEvent() //触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)//event对象var event = window.event||event//事件的目标节点var target = event.target || event.srcElement//事件代理ul.addEventListener('click',function(event){ if(event.target.tagName.toLowerCase() === 'li'){ console.log(event.target.innerHTML) }}) 123456789101112Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString);Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从DOM中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上 二、CSS 操作类名操作1234567891011121314151617181920//ie8以下Element.className //获取元素节点的类名Element.className += ' ' + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className){ return new RegExp(className,'gi').test(element.className);}//移除classfunction removeClass(element,className){ element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'),'');}//ie10element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class style 操作123456789101112131415161718element.setAttribute('style','')element.style.backgroundColor = 'red'element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName]window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,':after')[attrName] 对象Object 对象生成实例对象var o = new Object() 属性Object.prototype //返回原型对象 方法Object.keys(o) //遍历对象的可枚举属性 Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法valueOf() //返回当前对象对应的值 toString() //返回当前对象对应的字符串形式 toLocaleString() //返回当前对象对应的本地字符串形式 hasOwnProperty() //判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性 isPrototypeof() //判断当前对象是否为另一个对象的原型 propertyIsEnumerable() //判断某个属性是否可枚举 Array 对象生成实例对象var a = new Array() 属性a.length //长度 Array.isArray()Array.isArray(a) //用来判断一个值是否为数组 Array 实例的方法a.valueof() //返回数组本身 a.toString() //返回数组的字符串形式 a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。 pop() //用于删除数组的最后一个元素，并返回该元素 join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。 concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。 shift() //用于删除数组的第一个元素，并返回该元素。 unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。 reverse() //用于颠倒数组中元素的顺序，返回改变后的数组 slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。 splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。 map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。 map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。 forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。 filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。 some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。 every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。 reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员） reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员） indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 Number 对象生成对象var n = new Number() Number 对象的属性Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 Number 对象实例的方法toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。 toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。 toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。 toPrecision() //用于将一个数转为指定位数的有效数字。 String 对象生成实例对象var s = new String() String 对象的属性s.length //返回字符串的长度 方法s.chatAt(index) //返回指定位置的字符 s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。 s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示） s.concat(s2) //用于连接两个字符串 s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。 s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。 s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。 s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。 s.trim() //用于去除字符串两端的空格，返回一个新字符串 s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。 s.toUpperCase() //全部转为大写 s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。 s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 Math 对象属性Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。 数学方法Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。 Math.exp()：返回e的指数，也就是常数e的参数次方。 Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 三角函数方法Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值） JSON 对象方法JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。 //（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。 //还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。 JSON.parse() //用于将JSON字符串转化成对象。 console 对象方法console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。 console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。 console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。 console.warn() //输出信息时，在最前面加一个黄色三角，表示警告； console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈 console.table() //可以将复合类型的数据转为表格显示。 console.count() //用于计数，输出它被调用了多少次。 console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。 console.dirxml() //用于以目录树的形式，显示DOM节点。 console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 //这两个方法用于计时，可以算出一个操作所花费的准确时间。 console.time() console.timeEnd() //time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。 console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。 console.profileEnd() //用来结束正在运行的性能测试器。 console.group() console.groupend() //上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。 console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 console.trace() //显示当前执行的代码在堆栈中的调用路径。 console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。","link":"/2020/07/17/javascript%E5%B8%B8%E7%94%A8api%E5%90%88%E9%9B%86/"},{"title":"异步加载js","text":"js 加载(浏览器加载)时间线理论：它是根据js出生的那一刻开始记录的一系列浏览器按照顺序做的事， 就是加载顺序及一些优化 创建 Document 对象，开始解析 web 页面，这个阶段 document.readyState = ‘loading’ 遇见 link 外部 css，创建线程 加载，并继续解析文档 遇见 script 外部 js，并且没有设置 async、defer，浏览器加载，并阻塞，等待 js 加载完成 并执行该脚本，然后继续解析文档 遇见 script 外部 js，并且设置了 async、defer，浏览器创建线程 加载，并继续解析文档，对于 async 属性的脚本，加载完成后立即执行。（异步加载禁止使用 document.write(),它会清除文档流） 遇见 img 等，先正常解析 dom 结构，然后浏览器异步加载 src，并继续解析文档 文档解析完成，document.readyState = ‘interactive’ 文档解析完成后，所有设置 defer 的脚本会按照顺序执行。（也禁止使用 document.write()） 之后 document 对象触发 DOMContentLoaded 事件，标志程序执行从同步脚本执行阶段，转化为 事件驱动阶段 当所有 async 的脚本加载并执行后、img 等加载完成后，document.readyState = ‘complete’, 这是 window 对象触发 load 事件。 … 异步加载 jsjavascript 异步加载的三种方案: defer 异步加载，但要等到 dom 文档全部解析完成才会被执行，只有 IE 能用，可以将 js 代码写在 script 标签内部。 async 异步加载，加载完就执行，async 只能加载 外部脚本，不能把 js 写在 script 标签中，执行 时也不会阻塞页面。 动态创建 script，插入到 dom 中，加载完毕后 callback。简单实例： 1234567891011var script = document.createElement('script')script.type = 'text/javascript'script.src = demo.jsscript.onload = function() { //兼容性很好，除了IE // ...}document.head.appendChild(script) 动态加载函数封装 1234567891011121314151617181920212223function asyncLoaded(url,callback){ var script = document.createElement(&quot;script&quot;);// script.src = url; 假如说网速非常好，直接执行完成了，后面就监听不到状态的改变了 if(script.readyState){ script.onreadystatechange = function(){ if(script.readyState == &quot;complete&quot; || script.readyState ==&quot;loaded&quot;){// 执行某个函数 callback() } } }else{ script.onload = function(){// 执行某个函数 callback() } } script.src = url; //异步的过程 document.head.appendChild(script)}asyncLoaded('demo.js', function(){ test();})","link":"/2019/08/14/js%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%BA%BF%E5%92%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjs/"},{"title":"js引擎的预编译和执行","text":"var 的变量提升底层原理 JavaScript引擎，不是逐条解释执行javascript代码，而是按照代码块一段段解释执行， 所谓代码块就是script标签分割的代码块。 js引擎的工作方式分为：预编译和执行代码两个阶段。 1）常见的编译型语言编译阶段：词法分析（生成词法单元）——&gt;语法分析（抽象语法树）——&gt;(语义检查，代码优化)——&gt;代码生成 2）对于解释型语言来说，通过词法分析和语法分析得到抽象语法树之后就开始执行了，在JavaScript 解释器在构造语法树的时候，如果无法构造，就会报语法错误，并结束整个代码块的执行。 而在整个编译阶段，会把“一等公民”function和var创建的变量进行提升。（其中函数提升在变量 提成之前） 3）JavaScript语法采用的是词法作用域，也就是javascript的变量和函数作用域是在定义时 决定的，函数调用时决定的是执行期上下文和作用域链，所以js解释器只需要静态分析就能确定每个 变量、函数的作用域，这种作用域也称为静态作用域。 执行上下文 全局执行上下文：默认的上下文，任何不再函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象(浏览器的情况下)，并且设置 this 的值等于这个全局对象。一个程序只会有一个全局执行上下文。 函数执行上下文：每当函数被调用时，都会为该函数创建一个新的上下文。 Eval 函数执行上下文：执行在 eval 函数内部的代码也会有属于它自己的执行上下文。 执行栈：JavaScript 引擎会以栈的方式来处理多个执行期上下文其他语言叫“调用栈”，类似于数据结构的栈 LIFO(后进先出)，用来存储代码运行时创建的所有执行上下文。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当 JavaScript 引擎第一次遇见脚本时，它会创建一个全局的执行上下文并且压入当前执行栈，每当引擎遇到一个函数调用，会为该函数创建一个新的执行上下文并压入栈的顶部。 引擎会执行那些执行上下文位于栈顶的函数，当函数执行结束时，执行上下文从栈顶弹出，控制流程到达当前栈中的下一个上下文。 当函数执行时，会创建一个成为 执行期上下文的内部对象。 执行期上下文就是 js 代码被解析和执行时的运行环境，函数每次执行都会创建一个独一无二的执行上下文，所以多次调用会产生多个执行上下文，当函数执行完毕，所产生的执行上下文被销毁。 执行上下文的生命周期包括三个阶段：创建阶段-&gt;执行阶段-&gt;挥手阶段 创建阶段会创建变量对象(Variable Object)，建立作用域链，确定 this 指向 1. 创建 Scope chain 2. 创建 AO 3. 设置 this 的值创建 AO 主要做了以下事情： 1. 创建 AO 对象 2. 形参和变量声明存储到 AO 对象 //赋值为 undefined 3. 将形参和实参相统一 4. 函数声明的函数名作为 AO 对象的 key，函数体作为 value 执行阶段会完成变量赋值，函数引用，以及执行其他代码。 AO(Active Object) &amp; VO(Variable Object)的区别？ VO：未进入执行上下文执行阶段之前，变量对象中的属性都不能访问。 AO：进入执行阶段之后，变量对象转变为活动对象，里面的属性都能访问了。 它们都是同一个对象，只是处于执行上下文的不同生命周期，而且只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。 如果函数引用了外部变量的值，则 JavaScript 引擎会为改函数创建一个闭包体（closure），闭包体是一个完全封闭和独立的作用域，他不会在函数调用完毕后就被 js 引擎当作垃圾进行回收，闭包体可以长期存在。 执行上下文总结： 单线程 同步执行，只有栈顶的上下文处于执行中，而其他上下文需要等待 全局上下文只有唯一的一个，它在浏览器关闭时出栈，而且其他所有上下文环境都可以直接访问全局上下文的属性 函数的执行上下文的个数没有限制 每次某个函数被调用，就会有新的执行上下文为其创建，即使是调用的自身函数，也是如此。 JS 执行机制同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入Event Table 并注册函数。 当指定的事情完成时（例如定时器执行完毕，获取数据结束等），Event Table会将这个函数移入Event Queue 主线程内的任务执行完毕为空，会去Event Queue（事件队列）读取对应的函数，进入主线程执行。 上述过程不断重复，称为Event Loop（事件轮询）","link":"/2019/08/13/js%E5%BC%95%E6%93%8E%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"title":"js继承的几种实现方式","text":"js 继承的几种实现方式首先，我们需要定义一个父类： 12345678910111213//定义一个动物类function Animal (name) {//属性 this.name = name || 'Animal'; //实例方法 this.sleep = function() { console.log(this.name + 'i'm sleeping') }}//原型方法Animal.prototype.eat = function(food) { console.log(this.name + 'i'm eating' + food)} 原型链继承 12345678910111213141516function Parent2 () { this.name = 'parent2'}function Child2 () { this.sex = 'male'}//第一种写法Child2.prototype = new Parent2()//第二种写法(创建一个新的Child2.prototype对象关联到Parent2.prototype)//但是现在没有了Child2.prototype.constructor了//Child2.prototype = Object.create(Parent2.prototype)//第三种写法（ES6）//Object.setPrototypeOf(Child2.prototype, Parent.prototype)console.log(new Child2())//缺点就是：实例化子类的时候无法给父类传递参数 构造函数继承 12345678910111213// js没有构造函数，但是一个普通函数，使用new调用的时候，它就会构造一个对象//函数不是构造函数，准确来说是 带new的函数调用function Parent1 () { this.name = 'parent1'}Parent1.prototype.say = function(){};function Child1() { Parent1.call(this) this.sex = 'male'}console.log(new Child1())//缺点就是：不能继承原型链上的属性或方法 实例继承 拷贝继承 组合继承 1234567891011121314151617function Cat(name) { Animal.call(this) this.name = name || 'tom'}Cat.prototype = new Animal();//第二种写法：Cat.prototype = Animal.prototype//如果没有Cat.prototype = new Animal()这一行，Cat.prototype.constructo是指向Cat的，加了这一行，Cat.prototype.constructor 指向了Animal，这显然会导致继承链的紊乱，因此必须手动纠正。Cat.prototype.constructor = Cat;//Cat.prototype = Animal.prototype// Text codevar cat = new Cat()console.log(cat.name)console.log(cat.sleep())console.log(cat instanceof Animal) //trueconsole.log(cat instanceof Cat) //true 寄生组合继承 12345678910111213141516171819function Cat(name) { Animal.call(this); this.name = name || 'Tom'}(function(){ // 创建一个没有实例的类 var Super = function() { Super.prototype = Animal.prototype; } //将实例作为子类的原型 Cat.prototype = new Super();})();Cat.prototype.constructor = Cat;// Text Codevar cat = new Cat();console.log(cat.name)console.log(cat.sleep)console.log(cat instanceof Animal) //trueconsole.log(cat instanceof Cat) //true extends 继承 1234567891011class Animal {}//使用extends实现继承，必须添加super关键字定义子类的constructor，这里的super()相当于Animal.prototype.constructor.call(this)class Cat extends Animal { constructor() { super() }}","link":"/2019/08/13/js%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"},{"title":"koa-generator快速搭建koa服务","text":"1.全局安装koa-generator脚手架 123npm install -g koa-generator# oryarn global add koa-generator 创建koa项目1234koa2 project-name// 使用ejs引擎koa2 -e project-name 进入项目安装依赖12cd project-nameyarn install 项目运行1234npm start# ornpm run dev# or... 使用 pm2 启动 koa 项目123456// 全局安装npm install -g pm2// 启动项目pm2 start ./bin/www// pm2自动重启pm2 start ./bin/www/ --watch pm2 相关命令（www 是项目名）12345pm2 list #查看所有已启动项目pm2 start #启动pm2 restart www #重启pm2 stop www #停止pm2 delete www #删除","link":"/2022/03/08/koa-generator%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAkoa%E6%9C%8D%E5%8A%A1/"},{"title":"lerna开发","text":"创建 npm 私服 verdaccio 是一个简单、零配置的本地私有化 npm 仓库 123456cnpm install verdaccio -gverdacciohttp://localhost:4873npm adduser --registry http://localhost:4873/npm publish --registry http://localhost: 4873/ lerna 常用命令项目初始化| 命令 | 说明 || — | — || lerna init –independent | 初始化项目 | 创建包| 命令 | 说明 || — | — || lerna create module-1 | 创建 package || lerna add | 安装依赖 || lerna link | 链接依赖 | 开发和测试| 命令 | 说明 || — | — || lerna exec | 执行 shell 脚本 || lerna run | 执行 npm 命令 || lerna clean | 清空依赖|| lerna bootstrap | 重新安装依赖 | package 依赖 1234567891011121.给指定package安装依赖$ lerna add lodash packages/module-1$ lerna add lodash --scope=module-1$ lerna add lodash **/module-1$yarn workspace module-1 add lodash2.给所有package安装依赖$ lerna add lodash3.workspace之间的依赖$ lerna add module-2 packages/module-1$ lerna add module-2 --scope module-1 发布 1$ lerna publish lerna.json version: 当前仓库的版本，independent mode 请设置为 independent. lerna 对于包的管理有两种模式：固定模式 fixed、独立模式 independent。 固定模式所有包是统一的版本号，每次升级所有包统一更新，无论这个包内容是否改变。 *具体体现在 lerna 的配置文件中 lerna.json 中永远会存在一个确定版本号：{“version”: “0.0.1”} 独立模式，每个包都是单独的版本号，每次 lerna 触发发布命令，每个包的版本都会单独变化，具体体现在 lerna 的配置文件 lerna.json 中没有一个确定的版本号，而是{“version”:”independent”} npmClient: 指定运行的客户端程序 默认为 npm ignoreChanges: 一个不包含在lerna changed/publish的 glob 数组，使用这个阻止发布不必要的更新，比如修复README.md 123456789101112131415161718192021222324{ &quot;useWorkspaces&quot;: true, // 使用 workspaces 配置。此项为 true 的话，将使用 package.json 的 &quot;workspaces&quot;，下面的 &quot;packages&quot; 字段将不生效 &quot;version&quot;: &quot;0.1.0&quot;, // 所有包版本号，独立模式-&quot;independent&quot; &quot;npmClient&quot;: &quot;cnpm&quot;, // npm client，可设置为 cnpm、yarn 等 &quot;packages&quot;: [ // 包所在目录，可指定多个 &quot;packages/*&quot; ], &quot;command&quot;: { // lerna 命令相关配置 &quot;publish&quot;: { // 发布相关 &quot;ignoreChanges&quot;: [ // 指定文件或目录的变更，不触发 publish &quot;.gitignore&quot;, &quot;*.log&quot;, &quot;*.md&quot; ] }, &quot;bootstrap&quot;: { // bootstrap 相关 &quot;ignore&quot;: &quot;npm-*&quot;, // 不受 bootstrap 影响的包 &quot;npmClientArgs&quot;: [ // bootstr 执行参数 &quot;--no-package-lock&quot; ] } }} CRA + lerna + react + typescript 项目搭建12345678910111213141.create-react-app demo --template typescript2.cd demo3.npm run eject4.lerna init5.lerna create builder-script6.自定义builder-scripts脚本命令7.自定义 eslintrc、tsconfig、webpack等配置项","link":"/2021/11/01/lerna%E5%BC%80%E5%8F%91/"},{"title":"var、let、const区别","text":"JavaScript 中 var、let 和 const 的区别？ 1. JavaScript有两种作用域：全局作用域和方法作用域，没有块级作用域。 2. var在全局声明为全局变量，在函数内声明就是局部变量。 3. let是ES6新增的一个命令，用来声明局部变量。 4. var存在变量提升，可以在变量声明之前使用，返回undefined。let存在暂时性死区，在变量声明之前 使用，会提示ReferenceError。 5. 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不 可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 6. let不允许在同一个作用域内重复声明同一个变量。 7. const 和 let 相同，声明也只在当前的块级作用域生效。同样也不会声明提升， 也存在暂时死区，只能在声明之后使用，且和 let 一样不得重复声明，不能重新赋值。 8. const 所不能改变的并不是值，而是变量指向的那个内存地址所保存的值不能变动， 对于简单类型（数值、字符串、布尔值），值就保存在变量所指向的内存地址中， 因此等同于常量。而对于复合类型（数组、对象），变量指向的内存地址，保 存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的 （即总指向一个固定的地址）。","link":"/2019/07/29/var%E3%80%81let%E3%80%81const%E5%8C%BA%E5%88%AB/"},{"title":"null和undefined的区别","text":"null 和 undefined 的区别？ null表示空对象，即此处为一个空值典型用法： 作为函数的参数 作为对象原型链的终点 undefined 表示缺少值，即此处应该有一个值，但是还没有赋值 典型用法： 变量被声明，但还未赋值，为 undefined 调用函数时，应该提供的参数没有提供，为 undefined 对象没有赋值的属性，该属性的值为 undefined 函数没有返回值时，默认返回 undefined undefined 和 null转换为Boolean都会自动转换为false Number(null) ——&gt; 0 null + 5 = 5 Number(undefined) ——&gt; NaN undefined + 5 = NaN","link":"/2019/08/13/null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"new 的过程都干了什么","text":"new 的过程 - 新生成一个对象 - 链接到原型（继承该函数的原型） - 绑定this（将原型中的属性和方法加入到this引用的对象中） - 返回新对象 自己实现一个 new： 123456789101112function create() { // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 设置新对象的__proto__属性指向构造函数的prototype属性 obj.__proto__ = Con.prototype // 绑定 this，函数中this指向新实例对象。 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj} // 简洁版的 new 实现过程 12345678910function newFunc(constructor){ //第一步：创建一个空对象obj var obj = {}; //第二步：将构造函数 constructor的原型对象赋给obj的原型 obj.__proto__ = constructor.prototype; //第三步：将构造函数 constructor中的this指向obj,并立即执行构造函数内部的操作 constructor.apply(obj); //第四步：返回这个对象 return obj;}","link":"/2019/08/13/new-%E7%9A%84%E8%BF%87%E7%A8%8B%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/"},{"title":"什么是DOCTYPE及其作用？","text":"什么是 DOCTYPE 及其作用？ DOCTYPE 是 document type（文档类型）的缩写。 写法：(声明了浏览器就会进入标准模式，按照 W3C 标准渲染页面) DOCTYPE 的作用： DOCTYPE 是用来声明文档类型和 DTD 规范的，校验文件和代码的合法性。 告诉浏览器通过哪种规范（文档类型，DTD）来解析文档。 DTD（document type definition）文档类型定义是一系列的语法规则，用来定义 XML或 HTML 的文件类型。浏览器会根据它来判断文档类型，决定使用哪种协议来解析，以及切换浏览器的模式。 浏览器模式 为了能够很好的显示满足标准的页面，又能最大程度兼容不合法的 HTML，浏览器厂商会提供两种浏览器模式。 标准模式：根据 W3C 标准来渲染页面。 混杂模式（兼容模式、怪异模式）：浏览器采用更加宽松、向后兼容的方式来渲染页面。","link":"/2019/07/06/%E4%BB%80%E4%B9%88%E6%98%AFDOCTYPE%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9F/"},{"title":"什么是FOUC？如何避免？","text":"什么是 FOUC？如何避免？ 一、为什么会有白屏和 FOUC 呢？ 浏览器再渲染的时候没有请求到或请求时间过长造成的，那么浏览器怎么应对的呢？ 白屏：CSS 全部载入解析完成后渲染展示页面，如果没有加载完，就会出现白屏。 FOUC(Flash of Unstyled Content)无样式内容闪烁：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式表加载渲染之后，再重新显示文档，造成页面闪烁。 解决方法 使用 link 标签将样式表放在顶部标签中，防止白屏问题出现。 将 JS 放在标签底部，原因如下： 脚本会阻塞后面内容的呈现 脚本会阻塞其后组件的下载","link":"/2019/07/17/%E4%BB%80%E4%B9%88%E6%98%AFFOUC%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F/"},{"title":"webpack配置工程师","text":"构建 webpack 知识体系分为下面三个层级： 1.基础–会配置 2.进阶–能优化 3.深入–懂原理 一、基础篇 1.简单配置该部分需掌握：1.Webpack 常规配置项有哪些？ 2.常用 loader 有哪些？如何配置？ 3.常用插件 plugin 有哪些？如何配置？4.Babel 如何配置？Babel 插件如何使用？ 1.1 安装依赖需要现在本地安装webpack及webpack-cli 1$ npm install webpack webpack-cli -D 1.2 开始工作webpack 在 4 以后就支持 0 配置打包，我们可以测试一下 1.新建 webpack-work 项目，新建 ./src/index.js文件，写一段简单的代码 123const a = 'hello foolishmax';console.log(a);module.exports = a; 2.直接运行npx webpack，启动打包) 打包完成，会有一个提示：The 'mode' option has not been set,... 意思就是我们没有配置 mode（告知 webpack 使用相应模式的内置优化，默认为production，另外还有development、none） 选项 描述 development 开发模式，打包更加快速，省了代码优化步骤 production 生产模式，打包比较慢，开启 tree-shaking 和压缩代码 none 不使用任何默认优化选项 webpack.config.js 中配置： 123module.exports = { mode: 'development',} 1.3 配置文件虽然可以零配置打包，但是实际工作中，还是需要使用配置文件的方式来满足不同项目的需求。 1.跟路径下创建配置文件webpack.config.js 2.新增基本配置信息 1234567891011const path = require('path');module.exports = { mode: 'development', // 模式 entry: './src/index.js', // 打包入口地址 output: { filename: 'bundle.js', // 输出文件名 path: path.join(__dirname, 'dist') // 输出文件目录 }} 1.4 loader这里我们把入口文件改成 css 文件，看下打包结果如何 1.新增./src/main.css 1234567body { margin: 0 auto; padding: 0 20px; max-width: 800px; background: #f4f8fb;} 2.修改 entry 配置 1234567891011const path = require('path');module.exports = { mode: 'development', entry: './src/main.css', output: { filename: 'bundle.js', path: path.join(__dirname, 'dist') }} 3.运行打包命令： npx webpack这里的报错信息是因为：webpack 默认支持处理 js 文件，其他类型都处理不了，需要借助 loader 来对不同类型的文件进行处理。 4.安装css-loader来处理 CSS 1npm install css-loader -D 5.配置资源加载模块 12345678910111213141516171819const path = require('path');module.exports = { mode: 'development', entry: './src/main.css', output: { filename: 'bundle.css', path: path.join(__dirname, 'dist') }, module: { rules: [ // 转换规则 { test: /.css$/, // 匹配所有css文件 use: 'css-loader', //对应的loader名称 } ] }} 6.重新运行打包命令npx webpack,就可以打包成功了 总结：loader 就是将 webpack 不认识的内容转化为认识的内容 插件（plugin）插件可以贯穿 webpack 打包的生命周期，执行不同的任务 1.新建./src/index.html文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 如果想要打包后的资源文件，例如 js 或者 css 文件可以自动引入到 html 中，就需要使用插件html-webpack-plugin来做这件事情。 2.本地安装 html-webpack-plugin 1npm install html-webpack-plugin -D 3.配置插件 12345678910111213141516171819202122232425const HtmlWebpackPlugin = require('html-webpack-plugin');const path = require('path');module.exports = { mode: 'development', entry: './src/main.js', output: { filename: 'bundle.js', path: path.join(__dirname, 'dist') }, module: { rules: [ // 转换规则 { test: /.css$/, // 匹配所有css文件 use: 'css-loader', //对应的loader名称 } ] }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', }) ]} 运行一下打包，打开 dist 目录下的 index.html 文件 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 可以看到它自动引入打包好的 bundle.js 1.6 自动清空打包目录每次打包的时候，打包目录都会遗留上次打包的文件，为了保持打包目录的纯净，打包前需将上次打包目录清空。 1.安装 clean-webpack-plugin 1$ npm install clean-webpack-plugin -D 2.配置 123456789101112const HtmlWebpackPlugin = require('html-webpack-plugin');const {CleanWebpackPlugin} = require('clean-webpack-plugin');const path = require('path');module.exports = { plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', }), new CleanWebpackPlugin() ]} 1.7 区分环境本底环境 需要更快的构建速度 需要打印 debug 信息 需要 live reload 或者 hot reload 功能 需要 sourcemap 方便定位问题 … 生产环境： 需要更小的包体积，代码压缩+tree-shaking 需要进行代码分割 需要压缩图片体积 … 掘金","link":"/2021/10/27/webpack%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E5%B8%88/"},{"title":"什么是事件代理，它的原理是什么？","text":"什么是事件代理，它的原理是什么？ 事件代理：通俗来说就是将元素的事件委托给它的父级或者更外层元素处理 原理：利用事件冒泡机制实现 优点： 只需将同类元素的事件委托给父级或者更外层的元素，不需要给所有元素都绑定事件 减少内容空间占用，提升性能 动态新增的元素无需重新绑定事件","link":"/2019/08/13/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%83%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"},{"title":"vue3源码调试","text":"vue3 源码调试步骤 clone 项目1git clone https://github.com/vuejs/vue-next.git 安装依赖1yarn --ignore-scripts 修改配置修改package.json中的 scripts 下 dev 的配置，后面添加 –sourcemap 123&quot;dev&quot;: &quot;node scripts/dev.js&quot;// ⬇&quot;dev&quot;: &quot;node scripts/dev.js --sourcemap&quot; 编译1yarn run dev 当终端出现waiting for changes…表示编译成功，可以ctrl+c结束进程查看源码了 打包完成之后，examples 下面的文件会引用 dist 文件下的文件（dist 文件是我们刚才编译后生成的文件） debugger我们直接在package/vue/examples目录下添加demo/test.html文件，并引用**../../dist/vue.global.js**文件就可以使用 vue3 了，代码如下： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../../dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;template id=&quot;foo&quot;&gt; &lt;h2&gt;{{name}}&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; const App = { template: '#foo', data: function () { return { name: 'foolishmax' } } } Vue.createApp(App).mount('#app') &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 接下来在浏览器中打开就可以进行 vue3 的代码调试了。","link":"/2022/01/02/vue3%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/"},{"title":"你真的了解ES6吗？","text":"你真的了解 ES6 吗？ 下面的代码输出什么？1234567891011121314151617181920212223let promise = new Promise((resolve, reject) =&gt; { console.log(1) setTimeout(() =&gt; { resolve(2) console.log(3) }, 2000); reject('error')})promise.then(res =&gt; { console.log(5)}).catch(err =&gt; { console.log(err)})// 1 error 3//要点分析：// + promise 创建之后会立即执行// + 状态一旦改变就不会在变，也就是reject与resolve只会执行其中一个// + 异步队列的执行顺序 下面的代码输出什么？123456789101112131415161718192021222324252627const first = () =&gt; (new Promise((resolve, reject) =&gt; { console.log(1); let p = new Promise((resolve, reject) =&gt; { console.log(2); setTimeout(() =&gt; { console.log(3); resolve(4); }, 0) resolve(5); }); resolve(6); p.then((arg) =&gt; { console.log(arg); });}));first().then((arg) =&gt; { console.log(arg);});console.log(7);// 1 2 7 5 6 3//要点解析：// + promise创建立即执行，依次输出1 2// + 执行同步任务，输出 7// + 在执行上一步的时候已经将p.then 以及 first.then 加入到微任务执行队列，所以依次输出 5 6// + 最后执行宏任务 setTimeout，输出 3 下面的代码输出什么？12345678Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log)// 答案： 1// + 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。// + then方法接收的参数是函数！！！，而如果传递的并非是一个函数就会导致前一个Promise的结果穿透到下面。 const 和 Object.freeze 有什么区别？123//const 声明一个常量，一旦声明，常量的值就不能改变，对于复杂的数据类型，比如对象是可以修改其属性的。const实际保证的不是变量的值，而是变量指向的内存地址所指向的数据不能改变//Object.freeze适用于对象值，使得对象不可变，即不能改变对象属性，但是如果对象的属性值仍是复杂数据类型，那么是可以修改成功的。 for…in 和 for…of12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//对于纯对象的遍历，for...in更合适const obj = { a: 1, b: [], c: function(){}}for( let key in obj) { console.log(key);// a b c console.log(obj[key]); //1 [] function(){}}//对于数组遍历，如果不需要知道索引，for...of迭代更合适，还可以中断const arr = [3, 5, 7];for(let i of arr){ console.log(i);//3 5 7}//数组遍历如果需要知道索引forEach()更合适arr.forEach((value, index) =&gt; { console.log(value);//3 5 7 console.log(index);//0 1 2})//for...in对于数组遍历，会遍历得到索引值，可以通过数组索引取得对应得值，但是，for...in不仅可以枚举数组自身，还会枚举数组的原型(可通过arr.hasOwnProperty(i)去除)以及数组对象本身属性值。//for...of可以迭代字符串let str = 'foo'for(let value of str) { console.log(value); // &quot;f&quot; &quot;o&quot; &quot;o&quot;}//for...of可以直接迭代arguments类数组对象(function(){ for(let arg of arguments) { console.log(arg);//1 2 3 }})(1, 2, 3);//for...of 还可以迭代NodeList这类DOM集合let elements = document.querySelectorAll('body');for(let element of elements) { console.log(element.tagName); //&quot;BODY&quot;}//for...of迭代Maplet mapData = new Map([['a',1],['b',2]]);for(let [key, value] of mapData) { console.log(value); //1 2 3}//for...of迭代Setlet setData = new Set([1, 2, 3, 2, 1]);for(let value of setData) { console.log(value);//1 2 3}","link":"/2020/10/07/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3ES6%E5%90%97%EF%BC%9F/"},{"title":"从浏览器输入网站最终页面渲染完成的全过程解析","text":"从浏览器输入网站最终页面渲染完成，发生了什么？ 在浏览器输入 URL（Uniform Resource Locator,统一资源定位符），也就是网址。 网址分为三部分：举例 https://www.zhihu.com/people/oliver-8-10/activities 协议部分 https 网络地址部分 www.zhihu.com(每个域名背后都有一个对应的 IP 地址，分为三种局域网 IP、公网 IP、本机 IP) 资源路径部分 /people/oliver-8-10/activities DNS（Domain Name System 域名系统）解析: 将域名地址解析为 ip 地址 查找浏览器本地缓存（格式化检查以及确认是哪种协议，默认为 http 协议） 查找系统缓存（本地 host 文件查找对应 ip） 查找本地路由器缓存解析 查找网络服务商 DNS 缓存（也是先检查缓存，若没有或过期则到根域名服务商上查找对应 ip） 至于为什么一定要拿到 ip，因为我们的 tcp/ip 协议只能识别 ip 根据 IP 地址与服务器建立联系（TCP 连接，TCP 三次握手） (客户端拿到 ip 地址之后，想要进行通信就要先和服务器取得联系，看对方在不在，通常是由三次握手来实现) 第一次握手：建立连接时，客户端发送一个 syn 包（syn=1）到服务器，并进入 SYN_SEND状态，等待服务器确认。 第二次握手：服务器收到 syn 包之后，回复给客户端一个 SYN+ACK 报文段，然后服务器端进入 SYN_RECV 状态。 第三次握手：客户端收到服务器的 SYN+ACK 报文段之后，向服务器发送 ACK 报文段，发送之后客户端和服务器都进入 ESTABLISHED（已建立）状态，完成 TCP 三次握手。（第三次握手，是为了防止已经失效的连接请求报文段突然传到服务端而产生错误。没有第三次的 client 的确认，server 端会一直等待，浪费资源） 发送请求 请求报文： HTTP 协议的通信内容 请求头 请求行 :请求方法、请求 URL、请求 HTTP 协议及版本 请求主体 接受响应 响应报文 响应头 响应行 响应主体 数据传输完毕之后，要断开 TCP 连接，TCP 四次挥手 第一次分手：客户端向服务端发送一个 FIN 报文段，告诉服务端表示没有数据要发送了，客户端进入 FIN_WAIT_1 状态。 第二次分手：服务端接受到客户端的 FIN 报文段，返回一个 ACK 报文段表示已经知道客户端没有数据要发送了，服务端进入 FIN_WAIT_2 状态。 第三次分手：服务端向客户端发送一个 FIN 报文段，请求关闭连接，同时服务端进入 CLOSE_WAIT状态 第四次分手：客户端接受到服务端的 FIN 报文段，向服务端发送一个 ACK 报文段，然后客户端进入 TIME_WAIT 状态，服务端接受 ACK 报文段后，关闭连接；过了一段时间后，客户端没有收到回复，证明服务端已正常关闭，然后客户端也关闭连接。 页面渲染 浏览器根据服务端返回的 HTML 通过深度遍历解析成一个 DOM 树。 将 CSS 解析成一个 CSS 规则树。 根据 DOM 树和 CSS 规则树构建出一个 Rendering 树。 最后就是通过 Rendering 树，浏览器就知道每个节点和各个节点 css 的关系，再算出每个节点再屏幕的具体位置，将内容从上而下的渲染出来。 浏览器渲染流程 浏览器的主线程：Browser 进程 负责下载资源 创建销毁 renderer 进程 负责将 renderer 进程生成的位图渲染到页面上 与用户交互 浏览器内核：renderer 进程 js 引擎线程 由一个主线程和多个 web worker 线程组成，web worker 线程不能操作 dom GUI 线程 用于解析 html 生成 DOM 树，解析 CSS 生成 CSSOM，布局 layout、绘制 paint，回流和重绘依赖该线程。 事件线程 当事件触发时，该线程将事件的回调函数放入 callback queue(任务队列)中，等待 js 引擎处理 定时触发线程 setTimeout 和 setInterval 由该线程来计时，计时结束，将回调函数放入任务队列。 http 请求线程 每有一个 http 请求就开一个该线程，每当检测到状态编程就会产生一个状态变更事件，如果这个事件都由对应的回调函数，将这个函数放入到任务队列。 任务队列轮询线程 用于轮询监听任务队列 事件 DOMContentLoaded 当初始的 HTML 文档被完全加载和解析完成(script 脚本执行完，所属的 script脚本之前的样式表加载解析完成)之后，DOMContentLoaded 事件被触发。 onLoad 所有资源加载完成触发 window 的 onLoad 事件","link":"/2019/06/29/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E7%AB%99%E6%9C%80%E7%BB%88%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/"},{"title":"元数据&lt;meta&gt;","text":"有哪些常见的 meta 标签？ 指定文档编码 &lt;meta charset = &quot;UTF-8&quot;&gt; name 属性 1.&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;：在移动设备浏览器上，禁用缩放（zooming） 功能，用户只能滚动屏幕。 2.&lt;meta name=”description” content=””&gt;：告诉搜索引擎，当前页面的主要内容是xxx。 3.&lt;meta name=”keywords” content=””&gt;：告诉搜索引擎，当前页面的关键字。 4.&lt;meta name=”author” content=””&gt;：告诉搜索引擎，标注网站作者是谁。 5.&lt;meta name=”copyright” content=””&gt;：标注网站的版权信息。 http-equiv 属性 1.&lt;meta http-equiv=”Set-Cookie” content=”cookievalue=xxx; expires=Friday,12-Jan-2001 18:18:18 GMT; path=/”&gt;:如果网页过期， 那么存盘的cookie将被删除。必须使用GMT的时间格式。 2.&lt;meta http-equiv='expires' content='时间' &gt;：用于设定网页的到期时间。 一旦网页过期，必须到服务器上重新传输。 3.&lt;meta http-equiv=”Refresh” content=”5;URL”&gt;：告诉浏览器在 【数字】秒后跳转到【一个网址】 4.&lt;meta http-equiv=”content-Type” content=”text/html; charset=utf-8″&gt;： 设定页面使用的字符集。 -5.&lt;meta http-equiv=”Pragma” content=”no-cache”&gt;：禁止浏览器从本地 计算机的缓存中访问页面内容。访问者将无法脱机浏览。 6.&lt;meta http-equiv=”Window-target” content=”_top”&gt;：用来防止 别人在iframe(框架)里调用自己的页面，这也算是一个非常实用的属性。 7.&lt;meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'&gt; :强制浏览器按照特定的版本标准进行渲染。但不支持IE7及以下版本。如果是 ie浏览器就用最新的ie渲染，如果是双核浏览器就用chrome内核。","link":"/2019/09/07/%E5%85%83%E6%95%B0%E6%8D%AE-meta/"},{"title":"关于substring、substr和slice、splice的用法和区别","text":"substring 和 substr substring 和 substr都是针对字符串的，都是返回一个副本，而不是再原来字符串上直接操作的。 关于 substring（） substring（start, stop）表示从 start 开始到 stop 之间的新字符串，含头不含尾。 123var str = 'follish'console.log(str.substring(1, 5)) //&quot;olli&quot;console.log(str.substring(1, 5), str) //&quot;olli follish&quot; 其中 start 是必填项，stop 不填，表示从 start 处截取到字符串结尾，上代码： 12var str = &quot;0123456789&quot;console.log(str.substring(1)) //&quot;123456789&quot; 如果 start 比 stop 大，再方法执行前会先交换这两个参数，例如： 12var str = &quot;0123456789&quot;;console.log(str.substring(8,4))//&quot;4567&quot; 如果 start 和 stop 相等，会返回一个空的字符串，例如： 12var str = &quot;0123456789&quot;;console.log(str.substring(6,6))//&quot;&quot; 如果 start 和 stop 为负数，则在方法执行之前会先将负数变为 0，例如： 1234var str = &quot;0123456789&quot;;console.log(str.substring(-2,6))//&quot;012345&quot;console.log(str.substring(2,-6))//&quot;01&quot;console.log(str.substring(-2,-6))//&quot;&quot; 关于 substr（） substr(start, length)表示返回从 start 开始包含 length 长度的新字符串，包含 start 且不修改原字符串，如： 123var str = &quot;0123456789&quot;;console.log(str.substr(1,5))//&quot;12345&quot; length为5console.log(str.substr(2,6),str)//&quot;234567&quot; &quot;0123456789&quot; 其中 start 是必填项，如果 length 不填，表示从 start 截取到字符串结尾，例如 12var str = &quot;0123456789&quot;;console.log(str.substr(1))//&quot;123456789&quot; 如果 start 为负数，那么 start = str.length + start ,例如： 123var str = &quot;0123456789&quot;;console.log(str.substr(-1))//&quot;9&quot;console.log(str.substr(-6,3))//&quot;456&quot; 如果 length 的值为 0 或负数，则返回空字符串，例如： 1234var str = &quot;0123456789&quot;;console.log(str.substr(1,0))//&quot;&quot;console.log(str.substr(-1,-1))//&quot;&quot;console.log(str.substr(-1,0))//&quot;&quot; 关于 slice() 重点声明一下，substring、substr 只能操作字符串，splice 只能操作数组，而最 🐮🍺 的就是slice既可操作数组又可以操作字符串。 slice(start, stop)表示截取从下标 start 到 stop 之间的元素，并返回新数组不改变原数组（字符串），类似与 substring，例如： 1234var str = &quot;0123456789&quot;; arr = [0,1,2,3,4,5,6,7,8,9];console.log(str.slice(1,6))//&quot;12345&quot;console.log(arr.slice(1,6))//[1,2,3,4,5] start 是必填项，如果 stop 不填，表示从 start 处截取到结尾，例如： 1234var str = &quot;0123456789&quot;; arr = [0,1,2,3,4,5,6,7,8,9];console.log(str.slice(1))//&quot;123456789&quot;console.log(arr.slice(1))//[1,2,3,4,5,6,7,8,9] 如果 start 比 stop 大，或者两者相等，则截取的内容为空，例如： 123456var str = &quot;0123456789&quot;; arr = [0,1,2,3,4,5,6,7,8,9];console.log(str.slice(3,3))//&quot;&quot;console.log(arr.slice(3,3))//[]console.log(str.slice(6,5))//&quot;&quot;console.log(arr.slice(6,5))//[] 注意：如果 start 或者 stop 为负数，那么负数的选项从数组尾部开始算起，最后一个数字为-1，倒数第二个数字为-2，依次类推，例如： 1234var str = &quot;0123456789&quot;;console.log(str.slice(6,-1))//&quot;678&quot;console.log(str.slice(-6,-1))//&quot;45678&quot;console.log(str.slice(-6,8))//&quot;4567&quot; 关于 splice() splice 只能操作数组，splice(start, length, items)表示从下标 start 出截取 length 长度的元素后，在 start 处为原数组添加 items，并返回截取的数组，splice 会直接修改原数组： 123var arr = [0,1,2,3,4,5,6,7,8,9];console.log(arr.splice(1,3,2,3,4))//[1,2,3]console.log(arr);//[0,2,3,4,4,5,6,7,8,9] 原数组被截取走了1,2,3，并加入了2,3,4 其中 start 和 length 都是必填项，items 为选填项，如果 length 为 0 或负数，则返回空数组，例如： 123var arr = [0,1,2,3,4,5,6,7,8,9];console.log(arr.splice(1,0,2,3,4))//[]console.log(arr);//[0,2,3,4,1,2,3,4,5,6,7,8,9] 直接在原数组下标0处并加入了2,3,4 123var arr = [0,1,2,3,4,5,6,7,8,9];console.log(arr.splice(1,-9,2,3,4))//[]console.log(arr);//[0,2,3,4,1,2,3,4,5,6,7,8,9] 直接在原数组下标0处并加入了2,3,4 如果 start 为负数，也是从右往左截取，最后一位为-1，倒数第二位为-2，以此类推，例如： 123var arr = [0,1,2,3,4,5,6,7,8,9];console.log(arr.splice(-1,1,2,3,4))//[9]console.log(arr);//[0,1,2,3,4,5,6,7,8,2,3,4] 从右往左截取1位，也就是9，并加入2,3,4 【参考链接】：https://www.cnblogs.com/echolun/p/7646025.html","link":"/2019/06/06/%E5%85%B3%E4%BA%8Esubstring%E3%80%81substr%E5%92%8Cslice%E3%80%81splice%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"title":"内存泄漏","text":"造成内存泄漏的原因？ 意外的全局变量 无法被回收 定时器 未被正确关闭，导致所引用的外部变量无法被释放 事件监听 没有正确销毁 闭包 会导致父级中的变量无法被释放 DOM 引用 DOM 被删除时，内存中的引用未被正确清空 如何查看内存变化情况？ 使用 Chrome 的 Performance 面板进行内存标记，可视化查看内存变化情况，找出异常点。","link":"/2019/10/11/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"title":"凡事预则立，不预则废","text":"凡事预则立，不预则废凡事预则立，不预则废","link":"/2021/03/28/%E5%87%A1%E4%BA%8B%E9%A2%84%E5%88%99%E7%AB%8B%EF%BC%8C%E4%B8%8D%E9%A2%84%E5%88%99%E5%BA%9F/"},{"title":"前端安全","text":"前端安全 sql 注入 就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令 预防：比如使用基于 nodejs 的 sequelize 框架，不要裸写 sql 语句，使用常见的数据库工具即可解决 XSS xss：跨站脚本攻击(Cross Site Scripting),攻击者通过注入非法的 html 标签或者 JavaScript 代码，从而当用户浏览该网页时，控制用户浏览器。 xss 主要分为三类： DOM xss DOM 即文本对象模型，DOM 通常代表在 html、xhtml 和 xml 中的对象，使用 DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发 XSS 靠的是浏览器端的 DOM 解析，可以认为完全是客户端的事情。 反射型 xss 反射型 XSS 也被称为非持久性 XSS，是现在最容易出现的一种 XSS 漏洞。发出请求时，XSS 代码出现在 URL 中 ，最后输入提交到服务器，服务器解析后在响应内容中出现这段 XSS 代码，最后浏览器解析执行。 存储型 xss 存储型 XSS 又被称为持久性 XSS，它是最危险的一种跨站脚本，相比反射型 XSS和 DOM 型 XSS 具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。允许用户存储数据的 web 程序都可能存在存储型 XSS 漏洞，当攻击者提交一段 XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被 XSS，其中最典型的例子就是留言板。 主要影响： 利用虚假输入表单骗取用户个人信息 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。 显示伪造的文章或者图片 防御措施： 设置 httpOnly：在 cookie 中设置 HttpOnly 属性后，js 脚本将无法读取到 cookie 的信息。 输入检查，对于用户输入进行格式检查。 移除用户上传的 DOM 属性，如 onerror 事件等。 移除用户上传的 style 节点、script 节点、iframe 节点。 vue 中输出原生 html 需要使用 v-html react 中可以使用 dangerouslySetInnerHTML CSRF csrf：跨站请求伪造(Cross-Site Request Forgeries)，冒充用户发起请求，完成一些违背用户意愿的事情。 防御措施 提交数据使用 post 请求 Token 验证： 第一步：后端随机产生一个 token，把这个 token 保存在 session 状态中，同时后端把 token 交给前端页面； 第二步：前端页面提交请求时，把 token 加入到请求数据或者头信息中，一起传给后端； 后端验证前端传来的 token 与 session 是否一致，一致则合法，否则非法请求。 Referer check：请求来源验证，但是不能保证 100%有效，因为服务器并不是什么时候都能取到 Referer，而且低版本浏览器存在伪造 Referer 的风险。 验证码：强制用户必须和应用进行交互，完成最终请求，但用户体验比较差。 clickjacking clickjacking: 点击劫持，利用透明的按钮或连接做成陷阱，覆盖在 web 页面之上，然后诱使用户在不知的情况下，点击那个链接访问内容的一种攻击手段。又称为界面伪装。 大概有两种方式： 攻击者使用一个透明 iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用将在不知情的情况下点击透明的 iframe 页面。 攻击者使用一张图片覆盖在网页，遮挡网页原有的位置含义。 防御措施： X-FRAME-OPTIONS 响应头是用来给浏览器指示允许一个页面可否在&lt;frame&gt;,&lt;iframe&gt; 或者 &lt;object&gt; 中展现的标记。网站可以使用此功能，来确保自己网站内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。 控制台注入代码附：优化请求头（使用 helmet 协议规范）","link":"/2019/10/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"title":"单页面应用前端路由原理","text":"什么是单页面应用？ 单页面应用是指第一次进入页面的时候会请求一个 html 文件，切换到其他组件的时候，虽然路径会发生相应的变化，但是没有新的 html 文件请求，原理是 js 会感知到 url 的变化，js 会动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这时候的路由不是后端做的而是由前端来做，来判断页面到底显示哪个组件，这个过程就是单页面的应用。 单页面应用的优缺点优点：页面切换快，因为页面每次切换的时候，并不需要做 html 文件的请求，这样就减少的很多 http 发送的时延。 缺点：单页面应用的首屏加载时间比较慢，首屏加载需要一次 html 请求和一次 js 请求，时间相对较慢，而且 SEO 效果差，因为搜索引擎只认识 html 中的内容，但是单页面应用中内容很多需要靠 js 渲染出来，搜索引擎不识别这部分内容，就会导致 SEO 效果不好。 什么是多页面应用？多页面应用是指每一次页面跳转的时候，服务器都会返回一个新的 html 文档，这种类型的应用叫做多页应用。 多页面应用的优缺点优点：首屏加载快，SEO 效果好，因为客户端向服务端发起请求的时候，服务器之返回了一个 html 页面，所以加载比较快。 缺钱：页面切换比较慢 单页面应用和多页面应用的区别1.应用构成不同多页面应用是由多个不同的页面构成，单页面应用是一个外壳页面和多个页面片段构成。 2.页面跳转方式不同多页面应用的页面跳转是从一个页面跳转到另一个页面，而单页面则是把一个页面判断删除或隐藏，加载另一个页面片段。 3.跳转后公共资源是否重新加载跳转后多页面应用需要重新进行加载，但是单页面不需要重新加载 4.用户体验不同多页面应用首屏加载快但是切换慢，单页面应用首屏加载慢但是切换快 5.页面传递数据方式不同多页面应用依靠 url、cookie、localstorage 来传递数据，单页面应用则是靠组件进行通信，相对更加简单。 前端路由的原理前端路由的原理本质上就是通过不刷新浏览器的请求下修改 url、检测 url 的变化，截获 url 的地址，通过解析、匹配路由规则从而实现 UI 的更新，路由的实现通常有两种实现：hash 模式、history 模式 hash 路由的原理在 hash 模式下，在 url 中#后面的部分表示的是一个客户端状态，当这部分发生变化的时候，浏览器本身就不会刷新，这样就满足了第一个条件，即在不刷新浏览器的情况下修改浏览器链接，同事通过监听 hashChange 事件来监听 url 中 hash 值的变化，触发相关函数，改变相关组件。 history 路由的原理history 模式利用 html5 中 history API，history.pushState 和 history.replaceState 这两个方法可以在不刷新页面的情况下，操作浏览器的历史记录，然后通过 popState 事件来监听 url 的变化，从而触发相关函数，改变相关组件。","link":"/2022/03/14/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/"},{"title":"同步和异步的区别，怎么异步加载javascript","text":"同步和异步的区别，怎么异步加载 javascript? 同步模式同步模式，又称阻塞模式，javascript 在默认情况下是会阻塞加载的，当前面的 javascript 请求没有处理和执行完时，会阻止浏览器的后续处理 异步模式异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理 异步加载 JavaScript 动态添加 script 标签 defer async defer 属性和 async 都是属于 script 标签上面的属性，两者都能实现 JavaScript 的 异步加载。不同之处在于：async 在异步加载完成的时候就马上开始执行了，defer 会等到 html 加载完毕之后再执行。","link":"/2019/08/13/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjavascript/"},{"title":"字符串去重","text":"字符串去重 for 遍历 function removeRepeatStr(str){ var newStr = ''; var flag; var len = str.length; for(var i=0; i&lt;len; i++){ flag = 1; var newLen = newStr.length; for(var j=0; j&lt;newLen; j++){ if(str[i] == newStr[j]){ flag = 0; break; } } if(flag){ newStr = newStr + str[i]; } } return newStr; } indexOf 方法function removeRepeatStr(str){ var newStr = ''; var len = str.length; for(var i=0; i&lt;len; i++){ if(newStr.indexOf(str[i])==-1){ newStr = newStr + str[i]; } } return newStr; } search 方法function removeRepeatStr(str){ var newStr = ''; var len = str.length; for(var i=0; i&lt;len; i++){ if(newStr.search(str[i])==-1){ newStr = newStr + str[i]; } } return newStr; } 对象属性法function removeRepeatStr(str){ var obj = {}; var newStr = ''; var len = str.length; for(var i=0; i&lt;len; i++){ if(!obj[str[i]]){ newStr = newStr + str[i]; obj[str[i]] = 1;//注意，这里的1是给对象属性赋值，这个值可以任意取。意思是把每个遍历的字符作为对象属性并赋值保存，保证该属性的唯一性 } } return newStr; }","link":"/2019/08/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D/"},{"title":"常见设计模式","text":"常见的设计模式 单例模式 构造函数模式 建造者模式 工厂模式 代理模式 命令模式 观察者模式 适配器模式 职责链模式","link":"/2019/09/27/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"手写JS代码","text":"手写防抖（Debouncing）和节流（Throttling） 防抖（Debouncing）实现 典型例子：限制鼠标连击触发、监听用户输入。 解释：当一次事件发生后，事件处理器要等一定阀值的时间，如果这段时间过去后，再也没有事件发生，就处理最后一次发生的事件。如果还差0.01秒到达指定事件，这是又有一次事件触发，那么之前的等待作废，需要重新再次等待指定时间。 123456789101112131415161718192021//防抖动函数function debounce(fn, wait = 50, immediate) { let timer; return function() { if (immediate) { fn.apply(this, arguments) } if (timer) clearTimeout(timer) timer = setTimeout() =&gt; { fn.apply(this, arguments) },wait) }} 节流（Throttling）实现 解释：可以理解为事件再一个管道中传输，加上这个节流阀之后，事件的流速就会减慢，节流可以将一个函数的调用频率限制再一定阀值内，例如 1s ，那么 1s 内这个函数一定不会被调用两次。 123456789101112//简单的节流函数function throttle(fn, wait) { let prev = new Date(); return function() { const args = arguments; const now = new Date(); if (now - prev &gt; wait) { fn.apply(this, args); prev = new Date(); } }} 手写一个 JS 深拷贝 著名乞丐版 var newObj = JSON.parse ( JSON.stringify ( someObj ) ); 面试够用版 12345678910111213function deepCopy(obj) { if (typeof obj == &quot;object&quot;) { //复杂数据类型 var result = obj.constructor == Array ? [] : {}; for (let i in obj) { result[i] = typeof obj[i] == &quot;object&quot; ? deepCopy(obj[i] : obj[i]) } } else { //简单数据类型 var result = obj } return result} 手写一个 Promise 三种状态 pending | fulfilled(resolved) | rejected 当处于 pending 状态的时候，可以转移到 fulfilled(resolved)或者rejected状态 当处于fulfilled(resolved)状态或者rejected状态时候，就不可变。 必须有一个then的异步执行方法，then接受两个参数onFulfilled、onRejected 基础版 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041function myPromise(constructor){ let self=this; self.status=&quot;pending&quot; //定义状态改变前的初始状态 self.value=undefined;//定义状态为resolved的时候的状态 self.reason=undefined;//定义状态为rejected的时候的状态 function resolve(value){ //两个===&quot;pending&quot;，保证了状态的改变是不可逆的 if(self.status===&quot;pending&quot;){ self.value=value; self.status=&quot;resolved&quot;; } } function reject(reason){ //两个===&quot;pending&quot;，保证了状态的改变是不可逆的 if(self.status===&quot;pending&quot;){ self.reason=reason; self.status=&quot;rejected&quot;; } } //捕获构造异常 try{ constructor(resolve,reject); }catch(e){ reject(e); }}//同时再myPromise的原型上定义链式调用的then方法：myPromise.prototype.then=function(onFullfilled,onRejected){ let self=this; switch(self.status){ case &quot;resolved&quot;: onFullfilled(self.value); break; case &quot;rejected&quot;: onRejected(self.reason); break; default: }} 实现 instanceof123456789function instanceof (left, right) { let proto = left.__proto__; let prototype = right.prototype while (true) { if (proto === null) return false if (proto === prototype) return true proto = proto.__proto__; }} js 函数柯里化1234567891011121314151617181920212223//求和let add = function (a, b, c) { return a + b +c}function curry(fn) { //闭包 //缓存除函数fn之外的所有参数 let args = Array.prototype.slice.call(arguments, 1) return function() { //连接已经缓存的老的参数和新传入的参数（就是把每次传入的参数都先保存下来，但是并不执行） let newArgs = args.concat(Array.from(arguments)) if (newArgs.length &lt; fn.length) { return curry.call(this, fn, ...newArgs) } else { //调用 return fn.apply(this, newArgs) } }}let f = curry(add)console.log('柯里化',f(1)(2)(3))console.log('柯里化',f(1, 2)(3))console.log('柯里化',f(1, 2, 3)) 原生 js 封装 ajax123456789101112131415161718192021222324252627282930313233343536373839404142434445function ajax(options) { var xhr = null; var params = formsParams(options, data); //创建对象 if (window.XMLHttpRequest()) { xhr = new XMLHttpRequest() } else { xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } //连接 if (options.type === &quot;GET&quot;) { xhr.open(options.type, options.url + &quot;?&quot; +params, options.async); xhr.send(null) } else if (options.type === &quot;POST&quot;) { xhr.open(options.type, options.url, options.async); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(params); } //判断状态 xhr.onreadystateChange = function() { if (xhr.readyState === 4 &amp;&amp; xhr.status ===200) { options.success(xhr.responseText); } function formParams(data) { var arr = []; for (var prop in data) { arr.push(prop + &quot;=&quot; + data[prop]); } return arr.join(&quot;&amp;&quot;); } }}//调用ajax({ url: &quot;time.php&quot;, type: &quot;POST&quot;, async: true, data: { name: &quot;Tom&quot;, age: 18 }, success: function(data) { console.log(data); }}) 简化版： 123456789101112131415161718/** 1. 创建连接 **/var xhr = null;xhr = new XMLHttpRequest()/** 2. 连接服务器 **/xhr.open('get', url, true)/** 3. 发送请求 **/xhr.send(null);/** 4. 接受请求 **/xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status == 200){ success(xhr.responseText); } else { /** false **/ fail &amp;&amp; fail(xhr.status); } }} 简化版封装： 123456789101112function get(url, callback) { var oReq = new XMLHttpRequest() oReq.onload = function() { callback(oReq.responseText) } oReq.open(&quot;get&quot;, url, true) oReq.send()}get('data.json', function(data) { console.log(data)}) 手写 jsonp跨域通信的几种方式：jsonp、hash、postMessage、webSocket、CORS 123456789101112131415161718192021222324252627282930313233343536373839(function (window,document) { &quot;use strict&quot;; var jsonp = function (url,data,callback) { // 1.将传入的data数据转化为url字符串形式 // {id:1,name:'zhangsan'} =&gt; id=1&amp;name=zhangsan var dataString = url.indexof('?') == -1? '?': '&amp;'; for(var key in data){ dataString += key + '=' + data[key] + '&amp;'; }; // 2 处理url中的回调函数 // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉） var cbFuncName = 'my_json_cb_' + Math.random().toString().replace('.',''); dataString += 'callback=' + cbFuncName; // 3.创建一个script标签并插入到页面中 var scriptEle = document.createElement('script'); scriptEle.src = url + dataString; // 4.挂载回调函数 window[cbFuncName] = function (data) { callback(data); // 处理完回调函数的数据之后，删除jsonp的script标签 document.body.removeChild(scriptEle); } // 5.append到页面中 document.body.appendChild(scriptEle); } // 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用 window.$jsonp = jsonp;})(window,document) 简化版 JSONP 1234567891011var script = document.createElement('script') script.type = 'text/javascript' //传参一个回调函数名给后端，方便后端返回时执行这个前端定义的回调函数 script.src = 'http://www.xxx.com:8080/login?user=admin&amp;callback=handleCallback' document.body.appendChild(script) //回调执行函数 function handleCallbak(res) { alert(JSOn.stringify(res)) } 实现一个 new 操作符1234567891011121314151617181920212223242526272829function New(func) { var res = {}; if (func.prototype !== null) { res.__proto__ = func.prototype; } var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === &quot;object&quot; || typeof ret === &quot;function&quot;) &amp;&amp; ret !== null) { return ret; } return res;}var obj = New(A, 1, 2);// equals tovar obj1 = new A(1, 2);// 简洁版的new实现过程function newFunc(constructor){ //第一步：创建一个空对象obj var obj = {}; //第二步：将构造函数 constructor的原型对象赋给obj的原型 obj.__proto__ = constructor.prototype; //第三步：将构造函数 constructor中的this指向obj,并立即执行构造函数内部的操作 constructor.apply(obj); //第四步：返回这个对象 return obj;} 实现 call1234567891011121314151617181920Function.prototype.call2 = function (context) { //改变this指向，将目标函数作为这个对象的属性 var context = context || window; context.fn = this; //利用arguments类数组对象实现参数不定长 var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']'); } //将不定长的参数传递给函数 var result = eval('context.fn(' + args +')'); // obj.fn(...args) //不能增加对象的属性，所以结尾要删除delete delete context.fn return result;} 实现 apply12345678910111213141516171819Function.prototype.apply2 = function (context, arr) { var context = Object(context) || window; context.fn = this; var result; if (!arr) { result = context.fn(); } else { var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) { args.push('arr[' + i + ']'); } result = eval('context.fn(' + args + ')') } delete context.fn return result;} 实现 bind1234567891011121314Function.prototype.bind2 = function (context) { if (typeof this !== &quot;function&quot;) { throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); } var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fbound = function () { self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments))); } fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); return fbound;}","link":"/2019/07/17/%E6%89%8B%E5%86%99JS%E4%BB%A3%E7%A0%81/"},{"title":"微信小程序","text":"微信小程序 文件主要目录及文件作用 component 组件文件夹 navBar 底部组件 navBar.js 底部组件的 js 代码 navBar.json 底部组件的配置文件 navBar.wxml 底部组件的 html 代码 navBar.wxss 底部组件的 css 代码 pages 页面文件夹 index 首页 index.js 首页的 js 代码 index.json 首页的配置文件 index.wxml 首页的 html 代码 index.wxss 首页的 css 代码 public 图片文件夹 utils 工具文件夹 api.js 控制 api 的文件 md5.js 工具：MD5 加密文件 timestamp.js 工具：事件戳文件 app.json 设置全局的基础数据等 app.wxss 公共样式，可通过 import 导入更多 project.config.json 项目配置文件 微信小程序生命周期 onLoad(): 页面加载时触发，一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow(): 页面显示/切入前台时触发，每次打开页面都会调用一次。 onReady(): 页面初次渲染完成时触发，一个页面只会调用一次。 onHide(): 页面隐藏/切入后台时触发，当 navigateTo 或底部 tab 切换时调用。 onUnload(): 页面卸载时触发。 app.json 是对当前小程序的全局配置，讲述三个配置各个项的含义? pages 字段：用于描述当前小程序所有页面路径，为了让微信客户端知道当前小程序页面定义在那个目录。 window 字段：小程序所有页面的顶部背景颜色，文字颜色定义等。 tab 字段：小程序全局顶部 tab 或底部 tab。 小程序的 wxss 和 css 有哪些不一样的地方？ 新像素单位 rpx 样式可直接使用 import 导入 小程序 wxml 和标准的 html 的异同？都是用来描述页面的结构，都是由标签、属性等构成。 标签名字不一样，且小程序标签更少，单一标签更多。 多了一些 wx:if 这样的属性和双大括号这样的表达式。 wxml 只能在微信小程序开发者工具中预览，html 可以在浏览器内预览。 组件封装不同，wxml 对组件进行了重新封装。 小程序运行在 JS Core 内，没有 DOM 树和 window 对象，小程序无法使用 window 对象和 document对象。 小程序 wxss 和 css 的异同？都是用来描述页面的样子 wxss 具有 css 大部分的特性，也做了一些扩充和修改。 wxss 新增了尺寸单位，wxss 在底层支持新的尺寸单位 rpx。 wxss 仅支持部分 css 选择器。 wxss 提供全局样式和局部样式。 小程序页面间有哪些传递数据的方法？ 使用全局变量实现数据传递 页面跳转或重定向时，使用 url 带参数传递数据 使用组件模板 template 传递参数 使用数据库传递数据","link":"/2019/10/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"title":"数据结构与算法之哈希表","text":"具体代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174// 创建HashTable构造函数function HashTable() { // 定义属性 this.storage = [] this.count = 0 this.limit = 8 // 定义相关方法 // 判断是否是质数 HashTable.prototype.isPrime = function (num) { var temp = parseInt(Math.sqrt(num)) // 2.循环判断 for (var i = 2; i &lt;= temp; i++) { if (num % i == 0) { return false } } return true } // 获取质数 HashTable.prototype.getPrime = function (num) { while (!isPrime(num)) { num++ } return num } // 哈希函数 HashTable.prototype.hashFunc = function(str, max) { // 1.初始化hashCode的值 var hashCode = 0 // 2.霍纳算法, 来计算hashCode的数值 for (var i = 0; i &lt; str.length; i++) { hashCode = 37 * hashCode + str.charCodeAt(i) } // 3.取模运算 hashCode = hashCode % max return hashCode } // 插入数据方法 HashTable.prototype.put = function (key, value) { // 1.获取key对应的index var index = this.hashFunc(key, this.limit) // 2.取出数组(也可以使用链表) // 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ] [ [k,v] ] ] var bucket = this.storage[index] // 3.判断这个数组是否存在 if (bucket === undefined) { // 3.1创建桶 bucket = [] this.storage[index] = bucket } // 4.判断是新增还是修改原来的值. var override = false for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] if (tuple[0] === key) { tuple[1] = value override = true } } // 5.如果是新增, 前一步没有覆盖 if (!override) { bucket.push([key, value]) this.count++ if (this.count &gt; this.limit * 0.75) { var primeNum = this.getPrime(this.limit * 2) this.resize(primeNum) } } } // 获取存放的数据 HashTable.prototype.get = function (key) { // 1.获取key对应的index var index = this.hashFunc(key, this.limit) // 2.获取对应的bucket var bucket = this.storage[index] // 3.如果bucket为null, 那么说明这个位置没有数据 if (bucket == null) { return null } // 4.有bucket, 判断是否有对应的key for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] if (tuple[0] === key) { return tuple[1] } } // 5.没有找到, return null return null } // 删除数据 HashTable.prototype.remove = function (key) { // 1.获取key对应的index var index = this.hashFunc(key, this.limit) // 2.获取对应的bucket var bucket = this.storage[index] // 3.判断同是否为null, 为null则说明没有对应的数据 if (bucket == null) { return null } // 4.遍历bucket, 寻找对应的数据 for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] if (tuple[0] === key) { bucket.splice(i, 1) this.count-- // 缩小数组的容量 if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) { var primeNum = this.getPrime(Math.floor(this.limit / 2)) this.resize(primeNum) } } return tuple[1] } // 5.来到该位置, 说明没有对应的数据, 那么返回null return null } // isEmpty方法 HashTable.prototype.isEmpty = function () { return this.count == 0 } // size方法 HashTable.prototype.size = function () { return this.count } // 哈希表扩容 HashTable.prototype.resize = function (newLimit) { // 1.保存旧的数组内容 var oldStorage = this.storage // 2.重置属性 this.limit = newLimit this.count = 0 this.storage = [] // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中 oldStorage.forEach(function (bucket) { // 1.bucket为null, 说明这里面没有数据 if (bucket == null) { return } // 2.bucket中有数据, 那么将里面的数据重新哈希化插入 for (var i = 0; i &lt; bucket.length; i++) { var tuple = bucket[i] this.put(tuple[0], tuple[1]) } }).bind(this) }}","link":"/2019/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"title":"掘金面经笔记","text":"如何监听未处理的异常 try…catch 无法捕捉到语法错误，只能捕捉运行时错误 可以拿到出错的信息(出错的文件，行号，列号) window.onerror 由于 try…catch 只能捕获块里面的错误，全局的一些错误可以用 window.onerror 来捕获 http 和 https 的区别 http 是一种一种广泛使用的网络协议，是一个客户端和服务器请求和应答的标准。 http 工作在 TCP 协议的 80 端口，https 工作在 TCP 协议的 443 端口 http 协议运行在 TCP 协议之上，所有的传输内容都是明文，https 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有的传输内容都是经过加密的。 https 是以安全为目标的 http 通道，是 http 的安全版。是 http 加上 SSL 层对传输的信息和 url 做了一些加密处理，更加安全 为什么 https 不会被截取信息 完成 TCP 三次同步握手 客户端验证服务器数字证书，通过，进入步骤 3 DH 算法协商对称加密算法的密钥、hash 算法的密钥 SSL 安全加密隧道协商完成 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的 hash 算法进行数据完整性保护，保证数据不被篡改 浏览器如何缓存 html meta 标签控制缓存 &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cahce&quot;&gt; //告诉浏览器当前页面不被缓存 http 头信息控制缓存 Expires ——&gt; 过期时间 Cache-Control 响应头信息(no-cache、no-store、max-age、public) TCP 协议如何保证传输的可靠性 校验和 确认应答 + 序列号 超时重传 流浪控制 拥塞控制 TCP 的连接管理 滑动窗口 UDP &amp; TCP 的区别 相同点： UDP 协议 和 TCP 协议 都是运输层协议 不同点： UDP 特点： 无连接 —— 知道对端的 IP 和端口号就直接进行传输，不需要建立连接 不可靠 —— 没有确认机制，没有重传机制，即使因为网络故障无法发送到对方，UDP 协议也不会给应用层返回任何错误信息 面向数据报 传输速 度块 TCP 特点： 面向连接，在客户端和服务器进行交换数据前，必须先在双方之间建立一个TCP 连接 可靠传输，具有确认应答机制、超时重传机制、拥塞控制、流量控制、滑动窗口机制、延迟应答等。 面向字节流 UDP 的响应速度优于 TCP，安全性和数据可靠性不如 TCP UDP 一般用在网络负担非常重，但对响应速度要求高，数据类型都是短消息的情况下 样式导入方式及优先级？ 引入方式 行内样式 内联式 外链式 导入式: @import url(reset.css) 各种方式的优先级 行内样式 &gt; 外链式 &gt; 内联式 &gt; @import 导入式 BFCBFC(block formatting context)翻译为“块级格式化上下文”，它会生成独立的渲染区域(不影响外面的元素，同时也不受外部元素的影响)，它有一下规则： 内部的 box 会在垂直方向上一个接一个的放置。 内部 box 在垂直方向上的距离由 margin 决定，同属一个 BFC 内的相邻 box 会发生 margin 重叠。 BFC 的区域不会与 float box 发生重叠。 计算 BFC 的高度时，浮动元素也参与计算(清除浮动) 触发 BFC 的条件： float 属性不为 none position 为 absolute 或者 fixed display 为 inline-block、table-cell、table-caption、flex、inline-flex overflow 不为 visible","link":"/2019/09/13/%E6%8E%98%E9%87%91%E9%9D%A2%E7%BB%8F%E7%AC%94%E8%AE%B0/"},{"title":"js数据结构与算法","text":"什么是数据结构与算法？ 数据结构就是在计算机中，存储和组织数据的方式。 + 常见的数据结构： &lt;img src=&quot;http://vamknight.com/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png&quot;&gt; &lt;!--more--&gt; 算法（Algorithm）的定义： 算法就是解决问题的方法/步骤，数据结构的实现离不开算法。 一个有限指令集，每条指令的描述不依赖于语言 接受一些输入（有些情况不需要输入） 产生输出 一定在有限步骤之后终止","link":"/2019/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"},{"title":"队列（Queue）","text":"队列（Queue） 队列是一种受限的线性表，先进先出（FIFO First In First Out）。 它只允许在表的前端（front）进行删除操作 在表的后端（rear）进行插入操作 常见应用场景： + 队列主要用在和时间有关的地方，特别是操作系统中，队列是实现多任务的重要机制。 + 消息机制可以通过队列来实现，进程调度也是使用队列来实现。 队列有哪些常见的操作呢？ enqueue(element): 向队列尾部添加一个（或多个）新的项。 dequeue(): 移除队列的第一项，并返回被移除的元素。 front(): 返回队列中第一个元素，队列不做任何改动。 isEmpty(): 如果队列中不包含任何元素，返回 true，否则返回 false。 size(): 返回队列包含的元素个数，与数组 length 类似。 toString(): 将队列中的内容，转成字符串形式。 队列常见操作的封装： 1234567891011121314151617181920212223242526272829303132333435363738//封装队列function Queue() { //属性 this.items = [] //将元素加入到队列中 Queue.prototype.enqueue = function(element) { this.items.push(element) } //从队列中删除前端元素 Queue.prototype.dequeue = function() { return this.items.shift() } //查看前端的元素 Queue.prototype.front = function() { return this.items[0] } //查看队列是否为空 Queue.prototype.isEmpty = function() { return this.items.length == 0 } //查看队列中元素的个数 Queue.prototype.size = function() { return this.items.length } //toString方法 Queue.prototype.toString = function() { var resultString = '' for (var i = 0; i&lt; this.items.length; i++) { resultString += this.items[i] + ' ' } return resultString }}//调用队列函数var queue = new Queue()queue.enqueue(20)alert(queue) 面试题： 击鼓传花 12345678910111213141516171819//面试题: 击鼓传花function passGame(nameList, num) { //创建一个队列结构 var queue = new Queue() //将所有人加入到队列中 for(var i = 0; i &lt; nameList.length; i++) { queue.enqueue(nameList[i]) } //开始数数字 while (queue.size() &gt; 1) { //不是num重新加入队列末尾 //是num从队列中删除 for (var i = 0; i&lt; num - 1; i++) { queue.enqueue(queue.dequeue()) } queue.dequeue() } return queque.front()} 封装优先队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//封装优先级队列function PriorityQueue() { //内部创建一个构造类 function QueueElement(element, priority) { this.element = element this.priority = priority } //属性 this.items = [] //实现队列元素的插入 PriorityQueue.prototype.enqueue = function(element, priority) { //创建QueueElement对象 var queueElement = new QueueElement(element, priority) //判断为队列是否为空 if (this.items.length == 0) { this.items.push(queueElement) } else { var added = false for (var i = 0; i &lt; this.items.length; i++) { if (queueElement.priority &lt; this.items[i].priority) { this.items.splice(i, 0, queueElement) added = true break } } if (!added) { this.items.push(queueElement) } } } //从队列中删除前端元素 PriorityQueue.prototype.dequeue = function() { return this.items.shift() } //查看前端的元素 PriorityQueue.prototype.front = function() { return this.items[0] } //查看队列是否为空 PriorityQueue.prototype.isEmpty = function() { return this.items.length == 0 } //查看队列中元素的个数 PriorityQueue.prototype.size = function() { return this.items.length } //toString方法 PriorityQueue.prototype.toString = function() { var resultString = '' for (var i = 0; i&lt; this.items.length; i++) { resultString += this.items[i].element + '-' + this.items[i].priority + ' ' } return resultString }}//测试代码var pq = new PriorityQueue()pq.enqueue('a',10)pq.enqueue('b',100)pq.enqueue('c',50)alert(pq)","link":"/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89/"},{"title":"数据结构与算法之排序","text":"数据结构与算法 五大算法 贪心算法 分治算法 动态规划 回溯法 分支限界法 冒泡排序1234567891011function bubleSort(arr) { var len = arr.length; for (let outer = len ; outer &gt;= 2; outer--) { for(let inner = 0; inner &lt;=outer - 1; inner++) { if(arr[inner] &gt; arr[inner + 1]) { [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]] } } } return arr;} 选择排序1234567891011function selectSort(arr) { var len = arr.length; for(let i = 0 ;i &lt; len - 1; i++) { for(let j = i ; j&lt;len; j++) { if(arr[j] &lt; arr[i]) { [arr[i],arr[j]] = [arr[j],arr[i]]; } } } return arr} 插入排序123456789101112function insertSort(arr) { for(let i = 1; i &lt; arr.length; i++) { //外循环从1开始，默认arr[0]是有序段 for(let j = i; j &gt; 0; j--) { //j = i,将arr[j]依次插入有序段中 if(arr[j] &lt; arr[j-1]) { [arr[j],arr[j-1]] = [arr[j-1],arr[j]]; } else { break; } } } return arr;} 快速排序12345678910111213141516function quickSort(arr) { if(arr.length &lt;= 1) { return arr; //递归出口 } var left = [], right = [], current = arr.splice(0,1); for(let i = 0; i &lt; arr.length; i++) { if(arr[i] &lt; current) { left.push(arr[i]) //放在左边 } else { right.push(arr[i]) //放在右边 } } return quickSort(left).concat(current,quickSort(right));} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173//创建列表类function ArrayList() { this.array = [] //方法 //插入方法 ArrayList.prototype.insert = function(item){ this.array.push(item) } //toString 方便测试 ArrayList.prototype.toString = function(){ return this.array.join('-') }}&lt;!--var arr = new ArrayList()--&gt;&lt;!--arr.insert(1)--&gt;&lt;!--arr.insert(2)--&gt;&lt;!--arr.insert(3)--&gt;//实现排序算法//冒泡排序ArrayList.prototype.bubbleSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.反向循环, 因此次数越来越少 for (var i = length - 1; i &gt;= 0; i--) { // 3.根据i的次数, 比较循环到i位置 for (var j = 0; j &lt; i; j++) { // 4.如果j位置比j+1位置的数据大, 那么就交换 if (this.array[j] &gt; this.array[j+1]) { // 交换 this.swap(j, j+1) } } }}ArrayList.prototype.swap = function (m, n) { var temp = this.array[m] this.array[m] = this.array[n] this.array[n] = temp}//选择排序ArrayList.prototype.selectionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 从0位置开始取出数据, 直到length-2位置 for (var i = 0; i &lt; length - 1; i++) { // 3.内层循环: 从i+1位置开始, 和后面的内容比较 var min = i for (var j = min + 1; j &lt; length; j++) { // 4.如果i位置的数据大于j位置的数据, 那么记录最小的位置 if (this.array[min] &gt; this.array[j]) { min = j } } // 5.交换min和i位置的数据 this.swap(min, i) }}//插入排序ArrayList.prototype.insertionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后 for (var i = 1; i &lt; length; i++) { // 3.记录选出的元素, 放在变量temp中 var j = i var temp = this.array[i] // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环 while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) { this.array[j] = this.array[j-1] j-- } // 5.将选出的j位置, 放入temp元素 this.array[j] = temp }}//希尔排序ArrayList.prototype.shellSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.根据长度计算增量 var gap = Math.floor(length / 2) // 3.增量不断变量小, 大于0就继续排序 while (gap &gt; 0) { // 4.实现插入排序 for (var i = gap; i &lt; length; i++) { // 4.1.保存临时变量 var j = i var temp = this.array[i] // 4.2.插入排序的内层循环 while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) { this.array[j] = this.array[j - gap] j -= gap } // 4.3.将选出的j位置设置为temp this.array[j] = temp } // 5.重新计算新的间隔 gap = Math.floor(gap / 2) }}//快速排序 // 选择枢纽 ArrayList.prototype.median = function (left, right) { // 1.求出中间的位置 var center = Math.floor((left + right) / 2) // 2.判断并且进行交换 if (this.array[left] &gt; this.array[center]) { this.swap(left, center) } if (this.array[center] &gt; this.array[right]) { this.swap(center, right) } if (this.array[left] &gt; this.array[right]) { this.swap(left, right) } // 3.巧妙的操作: 将center移动到right - 1的位置. this.swap(center, right - 1) // 4.返回pivot return this.array[right - 1] } // 快速排序实现 ArrayList.prototype.quickSort = function () { this.quickSortRec(0, this.array.length - 1) } ArrayList.prototype.quickSortRec = function (left, right) { // 0.递归结束条件 if (left &gt;= right) return // 1.获取枢纽 var pivot = this.median(left, right) // 2.开始进行交换 // 2.1.记录左边开始位置和右边开始位置 var i = left var j = right - 1 // 2.2.循环查找位置 while (true) { while (this.array[++i] &lt; pivot) { } while (this.array[--j] &gt; pivot) { } if (i &lt; j) { // 2.3.交换两个数值 this.swap(i, j) } else { // 2.4.当i&lt;j的时候(一定不会=, 看下面解释中的序号3), 停止循环因为两边已经找到了相同的位置 break } } // 3.将枢纽放在正确的位置 this.swap(i, right - 1) // 4.递归调用左边 this.quickSortRec(left, i - 1) this.quickSortRec(i + 1, right) } 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// 封装ArrayList function ArrayList() { this.array = [] ArrayList.prototype.insert = function (item) { this.array.push(item) } ArrayList.prototype.toString = function () { return this.array.join() } ArrayList.prototype.bubbleSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.反向循环, 因此次数越来越少 for (var i = length - 1; i &gt;= 0; i--) { // 3.根据i的次数, 比较循环到i位置 for (var j = 0; j &lt; i; j++) { // 4.如果j位置比j+1位置的数据大, 那么就交换 if (this.array[j] &gt; this.array[j+1]) { // 交换 this.swap(j, j+1) } } } } ArrayList.prototype.selectionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 从0位置开始取出数据, 直到length-2位置 for (var i = 0; i &lt; length - 1; i++) { // 3.内层循环: 从i+1位置开始, 和后面的内容比较 var min = i for (var j = min + 1; j &lt; length; j++) { // 4.如果i位置的数据大于j位置的数据, 记录最小的位置 if (this.array[min] &gt; this.array[j]) { min = j } } this.swap(min, i) } } ArrayList.prototype.insertionSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后 for (var i = 1; i &lt; length; i++) { // 3.记录选出的元素, 放在变量temp中 var j = i var temp = this.array[i] // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环 while (j &gt; 0 &amp;&amp; this.array[j-1] &gt; temp) { this.array[j] = this.array[j-1] j-- } // 5.将选出的j位置, 放入temp元素 this.array[j] = temp } } ArrayList.prototype.shellSort = function () { // 1.获取数组的长度 var length = this.array.length // 2.根据长度计算增量 var gap = Math.floor(length / 2) // 3.增量不断变量小, 大于0就继续排序 while (gap &gt; 0) { // 4.实现插入排序 for (var i = gap; i &lt; length; i++) { // 4.1.保存临时变量 var j = i var temp = this.array[i] // 4.2.插入排序的内存循环 while (j &gt; gap - 1 &amp;&amp; this.array[j - gap] &gt; temp) { this.array[j] = this.array[j - gap] j -= gap } // 4.3.将选出的j位置设置为temp this.array[j] = temp } // 5.重新计算新的间隔 gap = Math.floor(gap / 2) } } ArrayList.prototype.swap = function (m, n) { var temp = this.array[m] this.array[m] = this.array[n] this.array[n] = temp } // 选择枢纽 ArrayList.prototype.median = function (left, right) { // 1.求出中间的位置 var center = Math.floor((left + right) / 2) // 2.判断并且进行交换 if (this.array[left] &gt; this.array[center]) { this.swap(left, center) } if (this.array[center] &gt; this.array[right]) { this.swap(center, right) } if (this.array[left] &gt; this.array[right]) { this.swap(left, right) } // 3.巧妙的操作: 将center移动到right - 1的位置. this.swap(center, right - 1) // 4.返回pivot return this.array[right - 1] } // 快速排序实现 ArrayList.prototype.quickSort = function () { this.quickSortRec(0, this.array.length - 1) } ArrayList.prototype.quickSortRec = function (left, right) { // 0.递归结束条件 if (left &gt;= right) return // 1.获取枢纽 var pivot = this.median(left, right) // 2.开始进行交换 var i = left var j = right - 1 while (true) { while (this.array[++i] &lt; pivot) { } while (this.array[--j] &gt; pivot) { } if (i &lt; j) { this.swap(i, j) } else { break } } // 3.将枢纽放在正确的位置 this.swap(i, right - 1) // 4.递归调用左边 this.quickSortRec(left, i - 1) this.quickSortRec(i + 1, right) } }","link":"/2019/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/"},{"title":"链表","text":"链表 什么是链表？ + 链表的元素在内存中不必是连续的空间，链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。 相对于数组，链表都有哪些优势？ 内存空间不是比是连续的. 可以充分利用计算机的内存. 实现灵活的内存动态管理。 链表不必在创建时就确定大小, 并且大小可以无限的延伸下去。 链表在插入和删除数据时, 时间复杂度可以达到 O(1). 相对数组效率高很多。 相对于数组，链表都有哪些缺点？ + 链表访问任何一个位置的元素时, 都需要从头开始访问.(无法跳过第一个元素访问任何一个元素)。 + 无法通过下标直接访问元素, 需要从头一个个访问, 直到找到对应的问题。 链表的数据结构： 链表有哪些常见操作？ + append(element)：向列表尾部添加一个新的项 + insert(position, element)：向列表的特定位置插入一个新的项。 + update(position, element): 修改某一个位置上的元素。 + remove(element)：从列表中移除一项。 + indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。 // 链表中的属性 this.length = 0 this.head = null // 链表尾部追加元素方法 LinkedList.prototype.append = function (element) { // 1.根据新元素创建节点 var newNode = new Node(element) // 2.判断原来链表是否为空 if (this.head === null) { / + removeAt(position)：从列表的特定位置移除一项。 this.next = null}/ 链表尾空this.head = newNode} else { // 链表不为空// 2.1.定义变量, 保存当前找到的节点var current = this.headwhile (current.next) {current = current.next} // 2.2.找到最后一项, 将其next赋值为node current.next = newNode } // 3.链表长度增加1 this.length++ } // 链表的toString方法 LinkedList.prototype.toString = function () { // 1.定义两个变量 var current = this.head var listString = &quot;&quot; // 2.循环获取链表中所有的元素 while (current) { listString += &quot;,&quot; + current.element current = current.next } // 3.返回最终结果 return listString.slice(1) } // 根据下标删除元素 LinkedList.prototype.insert = function (position, element) { // 1.检测越界问题: 越界插入失败 if (position &lt; 0 || position &gt; this.length) return false // 2.定义变量, 保存信息 var newNode = new Node(element) var current = this.head var previous = null index = 0 // 3.判断是否列表是否在第一个位置插入 if (position == 0) { newNode.next = current this.head = newNode } else { while (index++ &lt; position) { previous = current current = current.next } newNode.next = current previous.next = newNode } // 4.length+1 this.length++ return true } //update方法 LinkedList.prototype.update = function (position, newData) { if (position &lt; 0 || position &gt;= this.length) return null var current = this.head var index = 0 while (index++ &lt; position) { current = current.next } current.data = newData return true } // 根据位置移除节点 LinkedList.prototype.removeAt = function (position) { // 1.检测越界问题: 越界移除失败, 返回null if (position &lt; 0 || position &gt;= this.length) return null // 2.定义变量, 保存信息 var current = this.head var previous = null var index = 0 // 3.判断是否是移除第一项 if (position === 0) { this.head = current.next } else { while (index++ &lt; position) { previous = current current = current.next } previous.next = current.next } // 4.length-1 this.length-- // 5.返回移除的数据 return current.element } // 根据元素获取链表中的位置 LinkedList.prototype.indexOf = function (element) { // 1.定义变量, 保存信息 var current = this.head index = 0 // 2.找到元素所在的位置 while (current) { if (current.element === element) { return index } index++ current = current.next } // 3.来到这个位置, 说明没有找到, 则返回-1 return -1 } // 根据元素删除信息 LinkedList.prototype.remove = function (element) { var index = this.indexOf(element) return this.removeAt(index) } // 判断链表是否为空 LinkedList.prototype.isEmpty = function () { return this.length == 0 } // 获取链表的长度 LinkedList.prototype.size = function () { return this.length } // 获取第一个节点 LinkedList.prototype.getFirst = function () { return this.head.element } } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- 以上操作的都是单向链表，下面来认识一下双向链表。- 单向链表的缺点： + 只能从头遍历到尾，也就是链表的相连的过程是单向的，实现的原理是上一个链表中有一个指向下一个的引用。 + 我们可以轻松的到达下一个节点，但是回到上一个节点是很难的，只能从头遍历。 + 但是，实际开发中，经常会遇到回到上一个节点的情况。- 双向链表： + 既可以从头遍历到尾，又可以从尾遍历到头。 + 也就是链表相连的过程是双向的。 + 实现的原理就是既有先前连接的引用，也有一个向后连接的引用。 + 双向链表可以有效的解决单向链表的问题。- 双向链表的一些缺点： + 每次在插入或删除某一个节点时，需要处理四个引用，实现起来比较复杂。 + 相对于单向链表占用的内存更大一些。- 双向链表的结构图：&lt;img src=&quot;http://vamknight.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png&quot;&gt;- 双向链表的特点： + 可以使用一个head和一个tail分别指向头部和尾部的节点。 + 每个节点都是由三部分组成：前一个节点的指针（prev）、保存的元素（item）、后一个节点的指针（next）。 + 双向链表的第一个节点的prev是null。 + 双向链表的最后一个节点的next是null。- 双向链表都有哪些常见操作？ + append(element)：向列表尾部添加一个新的项 + insert(position, element)：向列表的特定位置插入一个新的项。 + update(position, element): 修改某一个位置上的元素。 + get(position): 获取对应位置的元素。 + remove(element)：从列表中移除一项。 + indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。 + removeAt(position)：从列表的特定位置移除一项。 + isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。 + size()：返回链表包含的元素个数。与数组的length属性类似。 + toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。 + forwardString(): 返回正向遍历的节点字符串形式。 + backwardString(): 返回反向遍历的节点字符串形式。- 双向链表常见方法的封装： // 创建双向链表的构造函数function DoublyLinkedList() {// 创建节点构造函数function Node(element) {this.element = elementthis.next = nullthis.prev = null // 新添加的} // 定义属性 this.length = 0 this.head = null this.tail = null // 新添加的 // 定义相关操作方法 // 在尾部追加数据 DoublyLinkedList.prototype.append = function (element) { // 1.根据元素创建节点 var newNode = new Node(element) // 2.判断列表是否为空列表 if (this.head == null) { this.head = newNode this.tail = newNode } else { this.tail.next = newNode newNode.prev = this.tail this.tail = newNode } // 3.length+1 this.length++ } // 在任意位置插入数据 DoublyLinkedList.prototype.insert = function (position, element) { // 1.判断越界的问题 if (position &lt; 0 || position &gt; this.length) return false // 2.创建新的节点 var newNode = new Node(element) // 3.判断插入的位置 if (position === 0) { // 在第一个位置插入数据 // 判断链表是否为空 if (this.head == null) { this.head = newNode this.tail = newNode } else { this.head.prev = newNode newNode.next = this.head this.head = newNode } } else if (position === this.length) { // 插入到最后的情况 // 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么? this.tail.next = newNode newNode.prev = this.tail this.tail = newNode } else { // 在中间位置插入数据 // 定义属性 var index = 0 var current = this.head var previous = null // 查找正确的位置 while (index++ &lt; position) { previous = current current = current.next } // 交换节点的指向顺序 newNode.next = current newNode.prev = previous current.prev = newNode previous.next = newNode } // 4.length+1 this.length++ return true } // 根据位置删除对应的元素 DoublyLinkedList.prototype.removeAt = function (position) { // 1.判断越界的问题 if (position &lt; 0 || position &gt;= this.length) return null // 2.判断移除的位置 var current = this.head if (position === 0) { if (this.length == 1) { this.head = null this.tail = null } else { this.head = this.head.next this.head.prev = null } } else if (position === this.length -1) { current = this.tail this.tail = this.tail.prev this.tail.next = null } else { var index = 0 var previous = null while (index++ &lt; position) { previous = current current = current.next } previous.next = current.next current.next.prev = previous } // 3.length-1 this.length-- return current.element } // 根据元素获取在链表中的位置 DoublyLinkedList.prototype.indexOf = function (element) { // 1.定义变量保存信息 var current = this.head var index = 0 // 2.查找正确的信息 while (current) { if (current.element === element) { return index } index++ current = current.next } // 3.来到这个位置, 说明没有找到, 则返回-1 return -1 } // 根据元素删除 DoublyLinkedList.prototype.remove = function (element) { var index = this.indexOf(element) return this.removeAt(index) } // 判断是否为空 DoublyLinkedList.prototype.isEmpty = function () { return this.length === 0 } // 获取链表长度 DoublyLinkedList.prototype.size = function () { return this.length } // 获取第一个元素 DoublyLinkedList.prototype.getHead = function () { return this.head.element } // 获取最后一个元素 DoublyLinkedList.prototype.getTail = function () { return this.tail.element } // 遍历方法的实现 // 正向遍历的方法 DoublyLinkedList.prototype.forwardString = function () { var current = this.head var forwardStr = &quot;&quot; while (current) { forwardStr += &quot;,&quot; + current.element current = current.next } return forwardStr.slice(1) } // 反向遍历的方法 DoublyLinkedList.prototype.reverseString = function () { var current = this.tail var reverseStr = &quot;&quot; while (current) { reverseStr += &quot;,&quot; + current.element current = current.prev } return reverseStr.slice(1) } // 实现toString方法 DoublyLinkedList.prototype.toString = function () { return this.forwardString() } } 1","link":"/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/"},{"title":"本地存储","text":"客户端的本地存储： localStorage - 生命周期永久生效，除非手动删除，否则关闭页面也会存在 - 可以在同一浏览器多窗口共享 - 以键值对的形式存储使用 - 方法： + 存储数据：localStorage.setItem(key, value) + 获取数据：localStorage.getItem(key) + 删除数据：localStorage.removeItem(key) + 删除所有数据：localStorage.clear() sessionStorage 声明周期为关闭浏览器窗口 在同一个窗口中数据可以共享 以键值对的形式存储 方法： 存储数据：sessionStorage.setItem(key, value) 获取数据：sessionStorage.getItem(key) 删除数据：sessionStorage.removeItem(key) 删除所有数据：sessionStorage.clear() localStorage 和 sessionStorage cookie 和 session IndexDB 离线存储，当网络断开，可以从浏览器中读取数据，用来做一些离线应用 Cookie 包含字段 name: cookie 名称 value: 值 domain: cookie 生效的域名 path: cookie 生效的路径 expires/max-age: cookie 过期时间 size: 大小 HttpOnly: 用户端不可更改 存储用户信息，通过在客户端记录信息确定用户身份，最大为 4kb 会话 Cookie，若不设置过期时间，表示这个 cookie 的生命周期为浏览器会话期间，浏览器关闭，cookie 就消失，会话 cookie 会保存在内存中而不是硬盘上。 持久 Cookie，若设置了过期时间，浏览器会把 cookie 保存在硬盘上，关闭浏览器仍然有效直到超过设定的过期时间。 cookie 数据始终在同源的 http 请求中携带(即使不需要)，即会在浏览器和服务器之间来回传递。 Cookie 具有不可跨域名性，例如浏览器访问百度不会带上谷歌的 cookie 服务端的存储： Session Session 服务器端一种记录客户端状态的机制 cookie 数据存放在客户的浏览器上，session 将数据存放在服务器端 Session 相对 Cookie 来说比较安全，别人可以分析本地存放的 cookie 进行 cookie 欺骗 Session 会在一定时间内保存在服务器上，访问量较多的时候会比较占用服务器的性能，考虑到减轻服务器性能方面的时候，应当使用 cookie 可以将登陆等重要信息保存在 session，其他信息放在 cookie 中","link":"/2019/09/30/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"},{"title":"数组去重的6种方法","text":"终于，石墨烯的 PPT 完成了一小部分，感觉自己高中的化学都白学了，什么 sp² 杂化轨道全忘完了，回来继续学习我的前端学习之旅。今天来总结一下，前端高频面试题，数组去重！！！ 1.直接遍历法 利用 JavaScript 的indexOf方法，新建一个数组 newArr，用这个数组去判断旧数组中的每一个数是否等于-1,如果是，说明该数在新数组中不存在，则将其添加进新数组，遍历完后就能将数组去重并保存至新建的数组中。 1234567891011121314151617181920212223242526272829function unique(arr) { var newArr = [] for (var i = 0;i &lt; arr.length;i++) { if (newArr.indexOf(arr[i]) === -1) { newArr.push(arr[i]) } } return newArr}var arr = [1, 2, 3, 3, 2, undefined, undefined]console.log(unique(arr))----------------------------------------------------原型链：Array.prototype.unique = function() { var arr = [] for(var i = 0; i &lt; this.length; i++) { if (arr.indexOf(this[i]) == -1) { arr.push(this[i]) } } return arr}var arr = [1, 2, 3, 3, 2, undefined, undefined]console.log(arr.unique()) 2.reduce 函数 使用数组的reduce方法结合indexOf两个方法实现数组去重，来自 MDN 的解释：reduce() 方法对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。mozilla 官方对 reduce 的解释是 arr.reduce(callback[, initialValue])方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。简单点讲就是对数组中的每一个数作用一个函数，这个回调函数就是第一个参数 callback ,第二个参数是传入的初始值，不传则使用数组中的第一个元素，注意在没有初始值的空数组上调用 reduce 将报错。 12345678910function unique2(arr) { return arr.reduce (function(prev, next) { if(prev.indexOf(next) === -1) { prev.push(next) } return prev }, []);}var arr = [1, 2, 3, 3, 2, undefined, undefined]console.log(unique2(arr)) 3.相邻比较 利用数组的 sort() 函数，这个函数原本是对数组进行排序的，但在这里我们不用它进行排序，而只是让它将重复的元素聚拢起来，接着我们比较相邻的两个数，如果相等，则跳过；如果不相等，我们就将其添加进新数组里，这样得到的数组就是去重后的数组。 12345678910111213function unique3(arr){ var newArr = [arr[0]]; arr.sort(); for(var i=1;i&lt;arr.length;i++){ if(arr[i] !== arr[i-1]){ newArr.push(arr[i]); } } return newArr;}var arr = [1, 2, 3, 3, 2, undefined, undefined]console.log(unique3(arr)) 4.下标指针遍历（不太理解） 利用数组的下标指针，来确定是否是相同的元素，如果是的话，就让其指针递增跳过，然后不断把不重复的数组保存至新数组中。代码嵌套了两层循环，分别有 i 和 j 两指针，其中 j 总是比 i 大 1，通过判断数组中这个数与它后面的数是否相等，如果相等，则说明这个数重复了，我们便将指针 i 和 j 继续往后运行，然后用 j = ++i 保持 j 比 i 大 1。最后一直把不重复的指针 i 对应的元素添加进数组。 123456789101112131415function unique4(){ var newArr = []; for(var i=0;i&lt;arr.length;i++){ for(var j=i+1;j&lt;arr.length;j++){ if(arr[i] === arr[j]){ j = ++i; } } newArr.push(arr[i]); } return newArr;}var arr = [1, 2, 3, 3, 2, undefined, undefined]console.log(unique4(arr)) 5.临时对象存储 借用一个临时对象来存储数组元素，判断数组中的元素是否在对象中，如果不存在，就将该数添加进数组，并在临时对象中做标记。 1234567891011121314function unique5(arr){ var newArr = []; var temp = {}; for(var i=0;i&lt;arr.length;i++){ if(!temp[arr[i]]){ newArr.push(arr[i]); temp[arr[i]] = true; } } return newArr;}var arr = [1, 2, 3, 3, 2, undefined, undefined]console.log(unique5(arr)) 6.简单粗暴法 利用 ES6 中的 Set 集合里元素唯一的特性，先将数组转换为集合，这样里面的元素就是唯一的了，再用 Array.from 方法将集合转回数组返回。 12345678function unique6(arr){ //return Array.from(new Set(arr)); return [...new Set(arr)]}var arr = [1, 2, 3, 3, 2, undefined, undefined]console.log(unique6(arr))","link":"/2019/06/18/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"日期","text":"日期 Date.now() //获取当前时间毫秒数 var dt = new Date() //构造一个实例对象 dt.getTime() //获取毫秒数 dt.getFullYear() //年 dt.getMonth() //月（0-11） dt.getDate() //日 （0-31） dt.getHours() //小时（0-23） dt.getMinutes() //分钟（0-59） dt.getSeconds() //秒（0-59） dt.getDay() //星期几（0-6）","link":"/2019/07/18/%E6%97%A5%E6%9C%9F/"},{"title":"栈","text":"栈 我们知道数组是一种线性结构，可以在数组的任意位置插入或删除数据。但有些时候，我们为了实现某种功能，必须对这种 任意性 加以限制，而我们的栈和队列就是比较常见的 受限的线性结构。 栈是一种先进后出或**后进先出(LIFO Last In First Out)**的数据结构，栈内的元素只能通过列表的一端访问，这一端称为栈顶，因为数据只能在栈顶添加或删除，所以只要数据的保存满足“先进后出或后进先出”的原理，都优先考虑使用栈。 栈的结构示意图： 栈常见有哪些操作？ push（element）：添加一个新元素到栈顶位置。 pop（）：移除栈顶的元素，同时返回被移除的元素。 peek（）：返回栈顶的元素，不对栈做任何修改。 isEmpty（）：如果栈里没有任何元素返回 true，否则返回 false。 size（）：返回栈里的元素个数，类似数组中的 length。 toString（）：将栈结构的内容以字符形式返回。 栈常见操作的封装： 1234567891011121314151617181920212223242526272829303132333435function Stack() { this.items = [] //将元素压入栈 Stack.prototype.push = function(element) { this.items.push(element) } //从栈中移除元素 Stack.prototype.pop = function() { return this.items.pop() } //查看栈顶元素 Stack.prototype.peek = function() { return this.items[this.items.length - 1] } //判断栈是否为空 Stack.prototype.isEmpty = function() { return this.items.length == 0 } //判断栈中元素个数 Stack.prototype.size = function() { return this.items.length } //toString方法 Stack.prototype.toString = function() { var resultString = '' for (var i = 0; i&lt; this.items.length; i++) { resultString += this.items[i] + ' ' } return resultString }}//栈的使用var s = new Stack()s.push(23)alert(s) 12345678910111213141516171819//函数十进制转为二进制function dec2bin(decNumber) { //定义栈对象 var stack = new Stack() while (decNumber &gt; 0) { //获取余数放入栈中 stack.push(decNumber % 2) //获取除后的结果,作为下次操作的对象 decNumber = Math.floor(decNumber / 2) } //从栈中取出0和1 var binaryString = '' while (!stack.isEmpty()) { binaryString += stack.pop() } return binaryString}//调用函数alert(dec2bin(100))","link":"/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%EF%BC%88Stack%EF%BC%89/"},{"title":"比较Vue和React？","text":"比较 Vue 和 React 的相同点和不同点？ 相同点 + 都有组件化开发和 Virtual DOM + 都支持 props 进行父子组件间的数据通信 + 都支持数据驱动视图，不直接操作真实 DOM，状态数据更新页面则自动更新 + 都支持服务端渲染 + 都支持原生应用的开发方案，React 有 React Native，Vue 有 Weex 不同点 数据绑定： Vue 实现了数据的双向绑定，React 数据流动是单向的 React 推荐的组件写法为 JSX，也就是把 HTML 和 CSS 全部写进 Javascript 中，即“all in js”Vue 推荐的组件写法是 webpack+vue-loader 的单文件组件格式，即 html、css、js 写在同一个文件 state 对象在 react 应用中不可变，需要使用 setState 方法更新状态；在 vue 中 state 对象不是必须的，数据由 data 属性在 vue 对象中管理 virtual DOM 不一样，vue 会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树，而对于 React 而言，每当应用的状态被改变时，全部组件都会重新渲染，所以 react 会需要shouldComponentUpdate 这个生命周期函数方法进行控制。 React 严格上只针对 MVC 的 view 层，Vue 则是 MVVM 模式。 前端框架使用 Vue 还是 React？清晰比较两者差异诞生 vue vue 由尤雨溪开发，独立团队维护，大部分子项目交给团队成员打理，Vue 核心库依然主要由尤雨溪亲自维护。 react React 起源于 Facebook 的内部项目，在建设 instagram(图片分享)的时候，为了处理数据流且考虑性能方面的问题，因该公司对市场上所有框架都不满意，就决定自己写一套，用来架构 Instagram 的网站。并在 2013 年 5 月开源。 设计思想 vue vue 是一款渐进式框架，采用自底向上增量开发的设计。在声明式渲染(视图模板引擎)的基础上，通过添加组件系统(component)、客户端路由(vue-router)、状态管理(vuex)来构建一个完整的框架。 react react 主张函数式编程，所以推崇纯组件，数据不可变，单向数据流， 编写语法 vue vue 推荐的做法是 webpack + vue-loader 的单文件格式，vue 保留了 html、css、js分离的写法，数据绑定使用 mustache 风格，样式直接使用 css，在&lt;style&gt;标签提供了一个可选的 scoped 属性，用开控制 css 仅对当前组件生效还是全局生效。 react react 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript中，即“all in js”，react 没有模板，直接就是一个渲染函数，返回一个虚拟 DOM 树，在 render()编写的 JSX 语法最终会被编译成原生 JavaScript。 构建工具 vue vue 提供了 CLI 脚手架，可以帮助我们非常容易地构建项目，全局安装后用 vue create命令创建新项目，可以让用户自定义选择需要安装的模板。 react react 提供了 create-react-app，但只提供一个构建单页面应用的默认选项。 数据绑定 vue vue 实现双向数据绑定，view 的变化能实时让 model 改变，而 model 的变化也能实时更新到 view vue 采用数据劫持 + 发布-订阅模式，通过 Object.defineProperty 对数据进行操作，为数据动态添加 getter 和 setter 方法，当获取数据的时候会触发对应的 getter 方法，当设置数据的时候会触发对应的 setter 方法，从而进一步触发 vm 的 watcher 方法，然后对数据进行更改，vm 则进一步触发视图更新操作。 react react 是单向数据流，react 中属性是不允许更改的，状态是允许更改的。react 中组件不允许通过 this.state 这种方法直接更改组件的状态。自身设置的状态，可以通过 setState进行更改。 setState 是异步的，导致获取 dom 可能拿到的还是之前的内容，所以需要在 setState第二个参数(回调函数)中获取更新后的内容。 性能优化 vue vue 中每个组件内部自动实现了 shouldComponentUpdate 的优化，在 vue 中里面由于依赖追踪系统的存在，当任意数据变动的时候，Vue 的每一个组件都能精确的知道自己是否需要重绘。而在 react 中需要我们手动去优化其性能，但 s 是当数据特别多的时候 vue 中的 watcher 也会特别多，从而造成页面卡顿，所以一般大西瓜项目会倾向于 react。 react 当 props 或 state 发生改变的时候会触发 shouldComponentUpdate 生命周期函数，它是用来控制组件是否被重新渲染的，如果它返回 true，则执行 render 函数，更新组件；如果它返回 false，则不会触发重新渲染的过程。 如果希望更新之前和之前的状态进行一个对比，这个时候需要重写 shouldCompnentUpdate来避免不必要的 dom 操作，对比当前的 props 或 state 和更新后的 nextProps 或 nextState，返回 true 时，组件更新；返回 false，不更新，节省性能。","link":"/2019/06/30/%E6%AF%94%E8%BE%83Vue%E5%92%8CReact%EF%BC%9F/"},{"title":"每日积累","text":"npm 1234567891011121314151617181920212223242526272829303132333435363738// 举个例子：&quot;dependencies&quot;: { &quot;jquery&quot;: &quot;^13.4.6&quot;, // 只锁定主版本号 major &quot;jquery&quot;: &quot;~13.4.6&quot;, // 锁定主版本号和次版本号 major + minor &quot;jquery&quot;: &quot;13.4.6&quot;, // 锁定版本 &quot;jquery&quot;: &quot;*&quot;, // 最新版本}// major: 13, minor: 4, patch: 6$ npm info jquery // 查看 jquery 信息$ npm view jquery versions // 查看 jquery 所有版本$ npm list | grep gulp // 过滤 gulp$ npm outdated // 查看过期版本$ npm update //更新版本$ npm cache clean --force // 清楚缓存$ npm ls // 查看项目引用了哪些包$ npm unpublish --force // 从npm卸载包// 执行顺序$ npm run script1 &amp; npm run script2 //并行执行$ npm run script1 &amp;&amp; npm run script2 // 继发执行// cross-env: 运行跨平台设置和使用环境变量的脚本// cross-env可以设置NODE_ENV环境变量，process.env.NODE_ENV === 'production'$ npm install --save-dev cross-env// {// &quot;scripts&quot;: {// &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;// }// }$ npm config get registry // 查看当前源$ npm config set registry https://registry.npm.taobao.org //切换镜像源// npx// --no-install: 让npx强制使用本地模块，不下载远程模块，如果本地不存在，就会报错$ npx --no-install http-server// --ignore-existing: 忽略本地的同名模块，强制安装远程模块$ npx --ignore-existing http-server","link":"/2022/05/14/%E6%AF%8F%E6%97%A5%E7%A7%AF%E7%B4%AF/"},{"title":"浏览器是怎么对HTML5的离线存储资源进行管理和加载的？","text":"浏览器是怎么对 HTML5 的离线存储资源进行管理和加载的？ 在线的情况下：浏览器发现 html 头部有 manifest 属性，会请求 manifest 文件，如果是第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并进行离线缓存。如果已经离线存储了，浏览器会使用离线的资源加载页面，然后浏览器会比对新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不要做任何操作，如果文件改变，就会重新下载文件中的资源并进行离线存储。 离线的情况下：浏览器就直接使用离线存储的资源。","link":"/2019/10/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%B9HTML5%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E5%92%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%EF%BC%9F/"},{"title":"浏览器的reflow和repaint","text":"浏览器的 reflow 和 repaint reflow（回流||重排）：当浏览器上某一个位置的布局发生了改变，浏览器会重新从根部开始计算该节点的 布局。比如：向页面中添加、删除某一元素等，dom 节点的宽高位置改变，只要这些操作影响了 页面的元素位置或大小的变化，都会引起 reflow。 repaint（重绘）：如果只改变页面元素的颜色、字体等不影响布局的属性时，浏览器会进行 repaint。 总结123由上可见，相比repaint操作，reflow的耗时要更多。只要是动态的对页面进行修改，浏览器的reflow和repaint的操作就不可避免，我们要做的就是尽可能的减少浏览器的reflow和repaint的次数。","link":"/2019/07/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84reflow%E5%92%8Crepaint/"},{"title":"深度封装typeof判断","text":"深度封装 typeof 判断 function myTypeof(val) { var type = typeof(val) var res = { '[object Object]' : 'object', '[object Array]' : 'array', '[object Number]' : 'object number', '[object String]' : 'object string', '[object Boolean]' : 'object boolean' } if (val === null) { return 'null' } else if (type == 'object') { var str = Object.prototype.toString.call(val) return res[str] } else { return type } }","link":"/2019/08/04/%E6%B7%B1%E5%BA%A6%E5%B0%81%E8%A3%85typeof%E5%88%A4%E6%96%AD/"},{"title":"深拷贝、浅拷贝","text":"深拷贝、浅拷贝 浅拷贝：只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 深拷贝：会创造一个一模一样的对象，新旧对象不共享内存，修改新对象不会影响原对象。 浅拷贝实现： 1.自定义函数 function shallowCopy (initialObj) { var obj = {} for (var prop in initialObj) { if (initialObj.hasOwnProperty(prop)) { obj[prop] = initialObj[prop] } } return obj } 2.ES6 的Object.assign() //目标对象只有一层的时候，就是深拷贝 let newObj = Object.assign({}, obj) 3.ES6 的对象扩展（当数组或对象只有一层的时候，扩展运算符就相当于深拷贝） let newObj = {...obj} 深拷贝实现 1.JSON.stringify 和 JSON.parse let newObj = JSON.parse(JSON.stringify(obj)) 2.lodash函数库的_.cloneDeep方法 var _ = require('lodash') var newObj = _.cloneDeep(obj) 3.slice方法实现数组深拷贝 let arr1 = [1,2,3,4] let arr2 = arr1.slice(0) arr1[0] = 5 console.log(arr1) //[5,2,3,4] console.log(arr2) //[1,2,3,4] 4.concat实现数据深拷贝 let arr1 = [1,2,3,4] let arr2 = arr1.concat() arr1[0] = 5 console.log(arr1) //[5,1,2,3] console.log(arr2) //[1,2,3,4] 5.自己封装 function deepClone(obj) { let objClone = Array.isArray(obj) ? [] : {}; if (obj &amp;&amp; typeof obj === &quot;object&quot;) { // for...in 会把继承的属性一起遍历 for (let key in obj) { // 判断是不是自有属性，而不是继承属性 if (obj.hasOwnProperty(key)) { //判断ojb子元素是否为对象或数组，如果是，递归复制 if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) { objClone[key] = this.deepClone(obj[key]); } else { //如果不是，简单复制 objClone[key] = obj[key]; } } } } return objClone; }","link":"/2019/07/29/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"title":"浏览器关闭清除token","text":"知识点 浏览器关闭会出发 beforeunload ，unload 这两个事件。 浏览器刷新也会触发，还会触发load事件 如何清除 token 方案一 123window.onbeforeunload = function () { localStorage.removeItem(&quot;token&quot;)} 缺点： 刷新也会清空 token 方案二 123456789101112131415window.onunload = function() { localStorage.setItem(&quot;lastTime&quot;,new Date().getTime())}window.onload = function() { let lastTime = localStorage.getItem(&quot;lastTime&quot;); const interval = 3 * 1000; // 如果时间间隔大于3s，则清除token if (!lastTime || new Date().getTime() - lastTime &gt; interval) { localStorage.remove(&quot;token&quot;); console.log(&quot;remove token&quot;); } else { console.log(&quot;time is less than not remove token&quot;); }} 补充可以使用 sessionStorage 代替 localStorage 来存储 token，当关闭浏览器时会自动清除 token，sessionStorage 不是持久化的本地存储，而是会话级别的存储，而 localStorage 是持久化的本地存储，除非主动删除数据，否则数据是不会过期的。","link":"/2021/05/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%97%AD%E6%B8%85%E9%99%A4token/"},{"title":"集合","text":"集合 集合通常是由一组无序的，不能重复的元素构成。可以看成是一种特殊的数组，特殊之处在于里面的元素没有顺序就意味着不能通过下标值进行访问，不能重复意味着相同的对象在同一个集合中只能存在一份。 集合都有哪些常见的操作方法呢？ add(value)：向集合添加一个新的项。 remove(value)：从集合移除一个值。 has(value)：如果值在集合中，返回 true，否则返回 false。 clear()：移除集合中的所有项。 size()：返回集合所包含元素的数量。与数组的 length 属性类似。 values()：返回一个包含集合中所有值的数组。 集合之间都有哪些操作呢？ 并集：对于两个给定的集合，返回一个包含两个集合中所有元素的新集合。 交集：对于两个给定的集合，返回一个包含两个集合中公有元素的新集合。 差集：对于两个给定的集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的新集合。 子集：验证一个给定集合是否是另一个集合的子集。 集合封装的完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// 封装集合的构造函数function Set() { // 使用一个对象来保存集合的元素 this.items = {} // 集合的操作方法 // 判断集合中是否有某个元素 Set.prototype.has = function (value) { return this.items.hasOwnProperty(value) } // 向集合中添加元素 Set.prototype.add = function (value) { // 1.判断集合中是否已经包含了该元素 if (this.has(value)) return false // 2.将元素添加到集合中 this.items[value] = value return true } // 从集合中删除某个元素 Set.prototype.remove = function (value) { // 1.判断集合中是否包含该元素 if (!this.has(value)) return false // 2.包含该元素, 那么将元素删除 delete this.items[value] return true } // 清空集合中所有的元素 Set.prototype.clear = function () { this.items = {} } // 获取集合的大小 Set.prototype.size = function () { return Object.keys(this.items).length /* 考虑兼容性问题, 使用下面的代码 var count = 0 for (var value in this.items) { if (this.items.hasOwnProperty(value)) { count++ } } return count */ } // 获取集合中所有的值 Set.prototype.values = function () { return Object.keys(this.items) /* 考虑兼容性问题, 使用下面的代码 var keys = [] for (var value in this.items) { keys.push(value) } return keys */ } //集合之间的操作 //并集 Set.prototype.union = function (otherSet) { //this:集合对象A //otherSet:集合对象B //1.创建新的集合 var unionSet = new Set() //2.将A集合中所有的元素添加到新集合中 var values = this.values() for(var i = 0; i &lt; values.length; i++) { unionSet.add(values[i]) } //3.取出B集合中的元素，判断是否需要添加到新集合 values = otherSet.values() for(var i = 0; i &lt; values.length; i++) { unionSet.add(values[i]) } return unionSet } //交集 Set.prototype.intersection = function (otherSet) { var intersectionSet = new Set() var values = this.values() //取出A集合一个个元素，判断是否同时存在于B中，存在B中，则添加到新集合中 for (var i = 0; i &lt; values.length; i++) { var item = values[i] if (otherSet.has(item)) { intersectionSet.add(item) } } return intersectionSet } //差集 Set.prototype.difference = function (otherSet) { var differenceSet = new Set() var values = this.values() //取出A集合一个个元素，判断是否同时存在于B中，不存在B中，则添加到新集合中 for (var i = 0; i &lt; values.length; i++) { var item = values[i] if (!otherSet.has(item)) { differenceSet.add(item) } } return differenceSet } // 子集 Set.prototype.subset = function (otherSet) { var values = this.values() for (var i = 0; i &lt; values.length; i++) { var item = values[i] if (!otherSet.has(item)) { return false } } return true }}","link":"/2019/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%9B%86%E5%90%88/"},{"title":"简书面经笔记（一）","text":"前端面经笔记(一) 如何判断一个对象是否为数组1. Array.prototype.isPrototypeOf(obj)方法，判断Array.prototype是不是在obj的原型链中， 如果在，则返回true，否则返回false。 2. obj instanceof Array 3. Object.prototype.toString.call(obj); //(===&quot;[object Array]&quot;) 4.Array.isArray(obj) 宏任务和微任务1.macro-task(宏任务)：包括整体代码script、setTimeout、setInterval 2.micro-task(微任务)：Promise.then、process.nextTick Http 的持久连接和管线化1. 什么是持久连接？ HTTP1.1规定了默认保持持久连接，数据传输完成也保持TCP连接不断开，等待同域名下 继续使用这个通道传输数据,在一个TCP连接上传输多个HTTP请求和响应。 持久连接避免了重新建立连接，大大减少了建立和关闭连接的消耗和延迟，HTTP的连接是建立 在TCP协议之上的，建立一条TCP连接需要三次握手，TCP连接关闭需要四次挥手，这些都需要时间。 2. 什么是管线化？ 持久连接： 请求1 ——&gt; 响应1 ——&gt; 请求2 ——&gt; 响应2 管线化： 请求1 ——&gt; 请求2 ——&gt; 响应1 ——&gt; 响应2 管线化机制需要通过持久化连接完成。 持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后， 才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。 实现并行发送请求。 只有GET和HEAD请求可以进行管线化，而POST有所限制。 初次建立连接不应启动管线机制，因为对方服务器不一定支持HTTP1.1版本的协议。 为什么利用多个域名来存储网站资源会更有效？1.CDN 是构建在网络之上的内容分发网络，可以使用户就近获取资源，减低网络拥塞，提高用户 访问的响应效率以及命中率。 2.突破浏览器的并发限制，同一时间针对同一域名下的请求有一定的数量限制，超过限定数目 的请求会被阻塞。 3.节约cookie带宽 4.减少主域名的连接数，优化页面响应速度 5.防止不必要的安全问题 CSS 权重（156 进制）1. ！import 权值：infinite 无穷大 2. 内联样式， 权值1000 3. ID选择器， 权值： 100 4. 类、伪类、属性选择器， 权值： 10 5.标签、伪元素选择器， 权值： 1 6.通配符选择器 *，子选择器 &gt;,相邻选择器 +，权值： 0 权值相等，后来居上 html5 的新特性1. 添加了video、radio标签 2. 添加了canvas画布和svg渲染矢量图片 3. 添加了一些语义化的标签 header、footer、main、section... 4. input的type值新添加了很多属性（email，search，color，number...） 5. 添加了地理位置定位功能 Geolocation API 6. 添加了web Storage存储功能，localStorage和sessionStorage 7. 使用html5，通过创建cache manifest文件，可以轻松地创建web应用的离线版本 8. web worker创造多线程环境，是运行在后台的javaScript。 9。 服务端推送（EventSource用于接受服务端发送事件通知） CSS3 新添加的特性？1. 媒体查询 2. transform，transition，translate，scale，rotate等相关动画效果 3. box-shadow，text-shadow等特效 4. CSS3 @font-face规则，可以引入任意字体 5. CSS3 @keyframes规则，创建动画(配合animation使用) 6. 2D、3D转化 7. 添加了border-radius、border-image、column-count、resize、box-sizing 、outline-offset等属性 基本数据类型基本数据类型：Null、Undefined、String、Boolean、Number ES6：Symbol ES10：Bigint（可以突破安全整数限制，安全的存储和操作最大整数之外的整数，不会损失精度）","link":"/2019/07/28/%E7%AE%80%E4%B9%A6%E9%9D%A2%E7%BB%8F%E7%AC%94%E8%AE%B0/"},{"title":"说一下浏览器的缓存机制","text":"前言 缓存可以简单高效的提高性能优化，对于一个数据请求来说，分为网络请求、后端处理、浏览器 响应三个步骤，浏览器缓存可以优化网络请求和响应部分。比如：直接换用缓存而不发起请求， 或者发起请求但后端存储的数据和前端一致，就没有必要将数据回传，这样就减少的响应数据， 使得缓存文件可以重复利用，减少带宽，减低网络负荷。 缓存位置网络请求会先从缓存位置上面查找缓存，如果都没有命中，才会去请求网络资源，从缓存位置 分为四种，并且各自有优先级： - Service Worker - Memory Cache - Disk Cache - Push Cache Service Worker&nbsp;&nbsp;&nbsp;&nbsp;Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 &nbsp;&nbsp;&nbsp;&nbsp;Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 &nbsp;&nbsp;&nbsp;&nbsp;当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 Memory Cache&nbsp;&nbsp;&nbsp;&nbsp;Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 Disk Cache&nbsp;&nbsp;&nbsp;&nbsp;Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之Memory Cache 胜在容量和存储时效性上。 &nbsp;&nbsp;&nbsp;&nbsp;在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。 Push Cache&nbsp;&nbsp;&nbsp;&nbsp;Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。 如果以上四种缓存都没有命中的话，只能发起网络请求来获取资源了。 为了性能上的考虑，大部分接口都应该选择好缓存策略， 浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置HTTP Header来实现的。 强缓存强缓存：不会向服务器发送请求，直接从缓存中读取资源，可以通过HTTP Header实现：Expires 和Cache-Control。 + Expires：缓存过期时间，用来指定资源到期的时间，是服务端的具体的时间点，结合Last-modified 使用，Expires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 + Cache-Control：和多个指令配合使用，实现资源缓存。 + Expires和Cache-Control同时存在，Cache-Control优先级高于Expires。 协商缓存协商缓存就是强缓存失效后，浏览器携带缓存表示向服务器发起请求，由服务器根据缓存表示决定 是否使用缓存的过程，主要有以下两种情况： + 协商缓存生效，返回304和Not Modified + 协商缓存失效，返回200和请求结果。 + 协商缓存可以通过设置两种HTTP Header实现：Last-Modified和ETag。 + ETag是服务器响应请求时，返回当前资源文件的一个唯一标识（有服务器生成），只要资源有变化 ，ETag就会重新生成。 缓存机制强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用 缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效， 那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中； 生效则返回304，继续使用缓存","link":"/2019/07/10/%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"说说你对闭包的理解？","text":"说说你对闭包的理解？ 闭包 函数可以记住并访问所在的词法作用域，就产生了闭包。或简单理解为：定义在一个函数内部的函数，内部函数持有外部函数内变量或参数的引用。 内部函数被保存在全局，内部函数依赖外部函数，外部函数参数和变量不会被垃圾回收机制回收，这些变量会始终存在于内存中。 作用域 JavaScript 代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码编译成可执行代码，这个阶段作用域规则会确定。执行阶段由 js引擎完成，主要任务是执行可执行代码，执行期上下文在这个阶段创建。 编译器 语法分析 词法分析 可执行代码生成 作用域规则确定 … js 引擎 执行上下文 代码执行 垃圾回收 … 1234567891011121314151617181920212223242526272829303132333435363738function foo() { var a = 2 function bar() { console.log(2) } return bar}var baz = foo()baz() //2//也可以是作为参数传递给外部函数function foo() { var a = 2 function bar() { console.log(a) } baz(bar)}function baz(fn) { fn()}foo()//也可以间接的分配给全局变量var fnfunction foo() { var a = 2 function bar() { console.log(a) } fn = bar}function baz() { fn()}foo()baz() 好处 可以读取函数内部的变量 柯里化 封装对象的私有属性和私有方法（收敛权限）,例如模块实例 模块的两个特征： 为了创建一个内部作用域而调用了一个包装函数 包装函数必须至少一个对内部函数的引用，这样就会创建涵盖整个函数内部作用域的闭包 1234567891011121314151617181920var foo = (function CoolModule(){ var something = &quot;cool&quot; var another = [1, 2, 3] function doSomething() { console.log(something) } function doAnother() { console.log(another.join('!')) } return { doSomething: doSomething, doAnother: doAnother }})()foo.doSomething() //coolfoo.doAnother() //1!2!3 避免污染全局变量 坏处 会增大内存使用量，容易造成内存泄漏。 解决方案 在退出函数前，将不使用的局部变量全部删除。","link":"/2019/07/17/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/"},{"title":"牛客学习知识总结-1","text":"牛客学习知识总结 超链接 a 标签的 href 的属性值是 url，里面必须包含协议，没有协议就会解析成相对路径。 HTTP 状态码分类： 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接受并处理。 200 服务端成功处理了请求并返回内容 3** 重定向，需要进一步的操作以完成请求 301 永久重定向 302 临时重定向 304 资源未被修改，返回一个 304 状态吗然后从本地缓存中加载请求的资源 4** 客户端错误，请求包含语法错误或无法完成请求。 404 （页面丢失）未找到资源 403 服务器拒绝请求 408 （请求超时） 服务器等候请求时发生超时 5** 服务器错误，服务器在处理请求的过程中发生错误 + 503 服务器暂时不可用 + 504 服务器内部错误 HTTP 协议的特征： C/S(客户端/服务器)模式：只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过 HTTP 来发送，客户端和服务器指定合适的 MIME-type 内容类型。 简单快速 灵活 无连接：限制每次连接只处理一个请求，收到客户的应答后即断开连接，可以节省传输时间。 无状态：对于事物处理没有记忆能力，意味着如果后续处理需要前面的信息，则必须重传，这样就会导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就会很快。 get 和 post 的请求区别？ 区别一： get 重点是从服务器上获取资源 post 重点是向服务器发送数据 区别二： get 传输数据通过 url 请求，以 field（字段）=value 的形式放在 url 后，用“？”连接，多个请求数据间用“&amp;”连接，过程用户可见。 post 传输数据放在请求体（request body）中发送给服务器，用户不可见。 区别三： get 传输数据大小有限制，但效率较高 post 可以传输大量数据，所以上传文件用 post 方式 区别四： get 请求不安全，因为参数直接暴露在 url 上，不能用来传递敏感信息。 post 较 get 安全性较高。 区别五： get 方式只能支持 ASCII 字符，向服务传的中文字符可能会乱码。 post 支持标准字符集，可以正确传递中文字符。 区别六： get 在浏览器回退是无害的，而 post 会再次提交请求。 区别七 get 请求会被浏览器主动 cache（缓存），而 post 不会除非手动设置。 iframe 有哪些缺点？ iframe 会阻塞主页面的 onload 事件 通过 oIframe.contentWindow 寻找子 window 对象 通过 window.parent 寻找父级窗体 通过 window.top 寻找顶级窗体 window.location.hash 解决父页面向子页面传值 window.name 解决子页面向父页面传值 不利于 SEO，搜索引擎的检索程序无法解读这种页面（百度 spider 不收录，浏览器对 iframe 框架的兼容问题） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 如果需要使用 iframe，最好通过 javascript 动态给 iframe 添加 src 属性值。 xhtml 和 html 有什么区别？ 性能方面 XHTML 兼容性好，兼容各大浏览器、手机以及 PDA，使浏览器可以快速正确编译网页 书写习惯方面 HTML 标签不区分大小写，XHTML 所有标签必须小写 XHTML 必须成双成对 HTML 对标签顺序要求不严格，XHTML 标签顺序必须正确 等等 html 和 xml 的区别？ xml 被设计用来传输和存储数据，其焦点是数据的内容 html 被设计用来显示数据，其焦点是数据的外观 html 旨在显示信息，而 xml 旨在传输信息 xml 在定义标记时区分大小写，而 html 不区分大小写 link 和@import 的区别：两者都是外部引用 CSS 的方式，但有一定的区别 + link是XHTML标签，除了加载CSS外，还可以加载其他文件；@import只能加载CSS。 + 解析到link时，页面会同步加载Css；@import在页面加载完后加载Css。 + link是XHTML标签，无兼容问题；@import是在**CSS2.1**之后提出的，只有再IE5以上才能识别。 + link可以js动态引入，@import不行 + @import的最佳写法： @import url(style.css),其他写法：@import 'style.css'、 @import &quot;style.css&quot;、@import url('style.css')、@import url(&quot;style.css&quot;) viewport 123456789&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt; // width 设置viewport宽度，为一个正整数，或字符串‘device-width’ // device-width 设备宽度 // height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置 // initial-scale 默认缩放比例（初始缩放比例），为一个数字，可以带小数 // minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数 // maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数 // user-scalable 是否允许手动缩放 单行文本溢出省略号 overflow: hidden; text-overflow:ellipsis; white-space: nowrap; 多行文本溢出省略号 display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; 换行标签 word-wrap: break-word","link":"/2019/07/06/%E7%89%9B%E5%AE%A2%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-1/"},{"title":"简单说一下原型链","text":"简单说下原型链 原型链是由原型对象组成的，每个对象都有proto属性，指向了创建该对象的构造函数的原型，proto将对象连接起来组成了原型链。 原型链：用来实现继承和共享属性的有限对象链。 每个对象都有proto（隐式原型）属性，指向创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 proto 来访问。 对象的隐式原型等于对象的构造函数的显式原型：obj.proto === Object.prototype 访问属性的时候，js 引擎会调用内部的默认。。。。。。[[Get]]操作，[[Get]]操作首先会检查对象本身是否包含这个属性如果对象没有这个属性，则对象可以通过proto来寻找不属于该对象的属性，proto将对象和原型连接起来形成原型链 Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎创建。","link":"/2019/07/16/%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"防抖节流实现","text":"手写防抖（Debouncing）和节流（Throttling） 防抖（Debouncing）实现 典型例子：限制鼠标连击触发、监听用户输入。 解释：当一次事件发生后，事件处理器要等一定阀值的时间，如果这段时间过去后，再也没有事件发生，就处理最后一次发生的事件。如果还差0.01秒到达指定事件，这是又有一次事件触发，那么之前的等待作废，需要重新再次等待指定时间。 123456789101112131415161718192021//防抖动函数function debounce(fn, wait = 50, immediate) { let timer; return function() { if (immediate) { fn.apply(this, arguments) } if (timer) clearTimeout(timer) timer = setTimeout(() =&gt; { fn.apply(this, arguments) },wait) }} 节流（Throttling）实现 解释：可以理解为事件再一个管道中传输，加上这个节流阀之后，事件的流速就会减慢，节流可以将一个函数的调用频率限制再一定阀值内，例如 1s ，那么 1s 内这个函数一定不会被调用两次。 123456789101112//简单的节流函数function throttle(fn, wait) { let prev = new Date(); return function() { const args = arguments; const now = new Date(); if (now - prev &gt; wait) { fn.apply(this, args); prev = new Date(); } }}","link":"/2019/06/11/%E9%98%B2%E6%8A%96%EF%BC%88Debouncing%EF%BC%89%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%88Throttling%EF%BC%89%E5%AE%9E%E7%8E%B0/"},{"title":"跨域","text":"什么是跨域？解决跨域的方法有哪些? 同源策略 是一种浏览器的安全策略 协议、域名、端口号必须完全一致 不同源的客户端脚本在没有明确的授权的情况下，不能读取对方的资源 跨域 指一个域下的文档或脚本尝试去请求另一个域下的资源。 解决跨域 jsonp postMessage 跨域 WebSocket 协议跨域 CORS（跨域资源共享，服务端设置 Access-Control-Allow-Origin，前端无需设置，若要带 cookie 请求，前后端都要设置） nginx 反向代理接口跨域 document.domain(两个页面通过 js 强制设置 document.domain 为基础主域，针对基础域名相同的情况) window.name + iframe location.hash + iframe … 实现 jsonp 跨域 通常为了减轻 web 服务器的负载，我们把 js、css、img 等静态资源分离到另一台独立域名的服务器上，在 html 页面中再通过响应的标签从不同域名加载静态资源。jsonp 就是利用此原理，动态创建 script，再请求一个带参网址实现跨域通信 12345678910111213&lt;script&gt; var script = document.createElement('script') script.type = 'text/javascript' //传参一个回调函数名给后端，方便后端返回时执行这个前端定义的回调函数 script.src = 'http://www.xxx.com:8080/login?user=admin&amp;callback=handleCallback' document.body.appendChild(script) //回调执行函数 function handleCallbak(res) { alert(JSOn.stringify(res)) }&lt;/script&gt;","link":"/2019/06/29/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%AE%83/"},{"title":"阻止冒泡以及默认事件","text":"如何阻止冒泡? W3C的方法e.stopPropagation(),IE使用e.cancelBubble = true; 封装： //阻止冒泡行为 function stopBubble(e) { //如果提供了事件对象，则这是一个非IE浏览器 if (e &amp;&amp; e.stopPropagation) e.stopPropagation() //IE的方法 else window.event.cancelBubble = true } 如何阻止默认事件？W3C的方法是e.preventDefault(),IE使用e.returnValue = false 封装： //阻止浏览器的默认行为 function stopDefault (e) { if (e &amp;&amp; e.preventDefault) e.preventDefault() //IE中阻止默认事件的方法 else window.event.returnValue = false return false } 补充：事件绑定的封装function addEvent(element,type,handle) { if(element.addEventListener){ element.addEventListener(type,handle,false); }else if(element.attachEvent){ element.attachEvent('on'+type,function () { handle.call(element); }) }else { element['on'+type] = handle; } } JS 如何设置获取盒子模型对应的宽和高？ dom.style.width/height dom.currentStyle.width/height (ie 支持) window.getComputedStyle(dom).width/height dom.getBoundingClientRect().width/height","link":"/2019/07/29/%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E4%BB%A5%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/"},{"title":"面试优质手写题","text":"手写部分 数组去重12345678910111213141516171819202122232425262728293031323334353637383940// indexOffunction unique(arr) { let res = []; for (let i = 0; i &lt; arr.length; i++) { if (res.indexOf(arr[i]) &lt; 0) { res.push(arrp[i]); } } return res;}// includesfunction unique(arr) { let res = []; for (let item of arr) { if (!res.includes(item)) { res.push(item); } } return res;}// 利用filterfunction unique(arr) { const res = arr.filter(function (item, index, array) { return array.indexOf(item) === index; }); return res;}// 利用Es6中的Set数据结构(扩展运算符)const unique = (arr) =&gt; [...new Set(arr)];// Array.form 方法将set结构转换为数组const unique = (arr) =&gt; Array.from(new Set(arr)); 数组扁平化123456789101112131415let arr = [1, [2, [3]]];// let res = arr.flat(Infinity)// let res = JSON.parse(&quot;[&quot;+JSON.stringify(arr).replace(/\\[|\\]/g,&quot;&quot;) + &quot;]&quot;)function flatArr(arr) { let res = arr.reduce((accu, curr) =&gt; { return accu.concat(Array.isArray(curr) ? flatArr(curr) : curr); }, []); return res;}console.log(flatArr(arr)); 浅拷贝12345678910111213141516171819202122// 只考虑对象类型function shallowCopy(obj) { if (typeof obj !== &quot;object&quot;) return; let newObj = obj instanceof Array ? [] : {}; if (obj === null) return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key]; } } return newObj;}// Object.assign()// arr.slice(0)// arr.concat()// 扩展运算符 深拷贝123456789101112131415161718192021// 只考虑普通对象属性，不考虑内置对象和函数function deepCone(obj) { if (typeof obj !== &quot;object&quot;) return; let newObj = obj instanceof Array ? [] : {}; if (obj === null) return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === &quot;object&quot; ? deepClone(obj[key]) : obj[key]; } } return newObj;}// JSON.parse(JSON.stringify())// lodash: _.cloneDeep() 实现一个 compose(组合)函数12345678910111213141516171819202122function compose(...fn) { if(!fn.length) return (v) =&gt; v; if(fn.length === 1) return fn[0]; return fn.reduce((accu, curr) =&gt; (...args) =&gt; accu(curr(...args)) );}例子：function fn1(x) { return x + 1;}function fn2(x) { return x + 2;}function fn3(x) { return x + 3;}function fn4(x) { return x + 4;}const res = compose(fn1, fn2, fn3, fn4);console.log(res(5)); // 5+4+3+2+1=15 assign12345678910111213141516171819Object.assign = function (target, ...source) { if (target === null || target === undefined) { throw new TypeError(&quot;Cannot convert undefined or null to object&quot;); } let result = Object(target); source.forEach(function (obj) { if (obj !== null) { for (let key in obj) { if (obj.hasOwnProperty(key)) { result[key] = obj[key]; } } } }); return result;}; 防抖函数12345678910111213function debounce(func, wait) { let timeout; return function () { clearTimeout(timeout); timeout = setTimeout(() =&gt; { func.apply(this, arguments); }, wait); };}// 搜索联想，用户在不断输入时，用防抖来节约请求资源// window触发resize的时候 节流函数12345678910111213141516function throttle(func, wait) { const previous = 0; return function () { const now = +new Date(); if (now - previous &gt; wait) { func.apply(this, arguments); previous = now; } };}// 鼠标不断点击触发，可以使其单位时间内只触发以此// 监听滚动事件// 防止高频点击提交 函数柯里化123456789101112131415161718192021222324function curry(fn, ...args) { // 需要柯里化的函数fn，也可以支持初始参数的传入 return function () { //参数缓存在args里面,合并上次参数和本次参数 args = [...args, ...arguments]; // 判断参数个数，不够继续递归 if (args.length &lt; fn.length) { return curry(fn, ...args); } else { //参数足够返回函数执行结果 return fn.apply(null, args); } };}function bar(a, b, c) { return a + b + c;}const f = curry(bar);console.log(f(1)(2)(3), f(1, 2)(3), f(1, 2, 3)); 如何把字符串中大小写取反1234567let str = &quot;LiBoShi&quot;;str = str.replace(/[a-zA-Z]/g, (content) =&gt; { return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();}); 从 S 中查找 T 字符串，找到返回索引值，没有则返回-1，类似 indexOf12345678910111213141516171819// 普通方法function myIndexOf(T) { let index = -1; for (let i = 0; i &lt;= this.length - T.length; i++) { if (this.substr(i, T.length) === T) { return (index = i); } } return index;}String.prototype.myIndexOf = myIndexOf;// 正则方法function myIndexOf(T) { let reg = new RegExp(T); let res = reg.exec(this); return res === null ? -1 : res.index;} call12345678910111213141516171819202122232425Function.prototype.myCall = function (context, ...args) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;};// 使用let obj = { desc: function (from, to) { console.log(`${this.name}来自${from}去往${to}`); },};let person = { name: &quot;lbs&quot;,};obj.desc.myCall(person, &quot;北京&quot;, &quot;上海&quot;); apply1234567891011Function.prototype.myApply = function (context, args = []) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;}; bind12345678910111213Function.prototype.myBind = function (content, ...args) { const fn = this; return function newFn(...newFnArgs) { // 检测 New // 如果当前函数的this指向的是构造函数中的this 则判定为new 操作 if (this instanceof newFn) { return new fn(...args, ...newFnArgs); } return fn.myApply(context, [...args, ...newFnArgs]); };}; instanceof123456789101. 通过left.__proto__.__proto__这种方式从下往上的获取原型对象2. 通过Object.create(null)的实例是没有原型链3. 有原型链的实例的尽头都是Objectfunction instanceof(left, right) { if(!left.__proto__) return false; if(right === Object || left.__proto__ === right.prototype) return true; return instanceof(left.__proto__, right);} 手写 Object.is123456789function is(x, y) { if (x === y) { // x,y都为0，但是1 / +0 = +Infinity,1 / -0 = -Infinity 是不一样的 return x !== 0 || y !== 0 || 1 / x === 1 / y; } else { //NaN === NaN = false是不对的，做一个拦截操作 return x !== x &amp;&amp; y !== y; }} ajax12345678910111213141516171819202122232425262728function ajax(method, url, headers, body) { return new Promise((resolve, reject) =&gt; { let req = null; try { req = new XMLHttpRequest(); } catch { req = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } req.open(method, url); for (let key in headers) { req.setRequestHeader(key, headers[key]); } req.onreadystatechange(() =&gt; { if (req.readystate === 4) { if (req.status &gt;= 200 &amp;&amp; req.status &lt;= 300) { resolve(req.responseText); } else { reject(req); } } }); req.send(body); });} async 和 await12345678910111213141516171819202122232425262728293031323334// 执行async函数，返回的都是Promise对象async function test1() { return 1;}async function test2() { return Promise.resolve(2);}console.log(test1(), test2());// Promise.then 成功的情况对应的就是awaitasync function test3() { const p = Promise.resolve(3); p.then((data) =&gt; console.log(data)); const data = await p; console.log(data);}test3();// Promise.catch 异常对应 try...catchasync function test4() { const p = Promise.reject(&quot;异常了&quot;); try { const data = await p; console.log(data); } catch (e) { console.log(e); }}test4(); map123456789101112Array.prototype.map = function (fn, toThis) { const arr = this; const result = []; const _this = toThis || Object.create(null); for (let i = 0; i &lt; arr.length; i++) { const item = fn.call(_this, arr[i], i, arr); result.push(item); } return result;}; 手写 promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161class Promise1 { static PENDING = &quot;pending&quot;; static FULFILLED = &quot;fulfilled&quot;; static REJECTED = &quot;rejected&quot;; constructor(executor) { this.status = Promise.PENDING; //默认状态，进行中 this.value = null; //成功值 this.reason = null; // 失败原因 // 解决异步问题 this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; try { executor(this.resolve.bind(this), this.reject.bind(this)); } catch (e) { this.reject(e); } } resolve(value) { if (this.status === Promise.PENDING) { this.status = Promise.FULFILLED; this.value = value; setTimeout(() =&gt; { this.onFulfilledCallbacks.forEach((cb) =&gt; cb(this.value)); }); } } reject(reason) { if (this.status === Promise.PENDING) { this.status = Promise.REJECTED; this.reason = reason; setTimeout(() =&gt; { this.onRejectedCallbacks.forEach((cb) =&gt; cb(this.reason)); }); } } then(onFulfilled, onRejected) { if (typeof onFulfilled !== &quot;function&quot;) { onFulfilled = () =&gt; this.value; } if (typeof onRejected !== &quot;function&quot;) { onRejected = () =&gt; this.reason; } return new Promise1((resolve, reject) =&gt; { if (this.status === Promise.PENDING) { return new Promise1((resolve, reject) =&gt; { this.onFulfilledCallbacks.push(() =&gt; { this.parse(onFulfilled(this.value), resolve, reject); }); }); return new Promise1((resolve, reject) =&gt; { this.onRejectedCallbacks.push(() =&gt; { this.parse(onRejected(this.value), resolve, reject); }); }); } if (this.status === Promise.FULFILLED) { setTimeout(() =&gt; { return new Promise1((resolve, reject) =&gt; { this.parse(onFulfilled(this.value), resolve, reject); }); }); } if (this.status === Promise.REJECTED) { setTimeout(() =&gt; { return new Promise1((resolve, reject) =&gt; { this.parse(onRejected(this.reason), resolve, reject); }); }); } }); } parse(result, resolve, reject) { try { if (result instanceof Promise1) { result.then(resolve, reject); } else { resolve(result); } } catch (error) { reject(error); } } static resolve(value) { return new Promise1((resolve, reject) =&gt; { if (value instanceof Promise1) { value.then(resolve, reject); } else { resolve(value); } }); } static reject(reason) { return new Promise1((resolve, reject) =&gt; { reject(reason); }); } static all(promises) { const result = []; return new Promise1((resolve, reject) =&gt; { promises.forEach((promise) =&gt; { promise.then( (value) =&gt; { result.push(value); if (result.length === promises.length) { resolve(result); } }, (reason) =&gt; { reject(reason); } ); }); }); } static race(promises) { return new Promise1((resolve, reject) =&gt; { promises.forEach((promise) =&gt; { promise.then( (value) =&gt; { resolve(value); }, (reason) =&gt; { reject(reason); } ); }); }); }}let aaa = new Promise1((resolve, reject) =&gt; { resolve(&quot;lbs&quot;); // reject('error')}).then((value) =&gt; { console.log(value); return &quot;666&quot;;});aaa.then(() =&gt; { console.log(123);});console.log(aaa); 手写 event bus12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class EventEmitter { constructor() { this.events = {}; this.maxListeners = maxListeners || Infinity; } emit(event, ...args) { const cbs = this.events[event]; if (!cbs) { console.log(&quot;没有这个事件函数&quot;); return this; } cbs.forEach((cb) =&gt; cb.apply(this, args)); return this; } on(event, cb) { if (!this.events[event]) { this.events[event] = []; } if ( this.maxListeners !== Infinity &amp;&amp; this.events[event].length &gt;= this.maxListeners ) { console.log(&quot;当事件超过了最大监听数&quot;); return this; } this.events[event].push(cb); return this; } once(event, cb) { const fn = (...args) =&gt; { this.off(event, fn); cb.apply(this, args); }; this.on(event, func); return this; } off(event, cb) { if (!cb) { this.events[event] = null; } else { this.events[event] = this.events[event].filter((item) =&gt; item !== cb); } return this; }} 继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 构造函数继承function Person() { this.name = &quot;lbs&quot;;}function Student() { Person.call(this); this.age = 18;}const s = new Student();// 原型链继承function Person() { this.name = &quot;lbs&quot;;}function Student() { this.age = 18;}Student.prototype = new Person();const s = new Student();//寄生式组合继承function Person(obj) { this.name = obj.name;}function Student(obj) { Person.call(this, obj); this.age = obj.age;}// object.create()// 方法创建一个新对象，使用现有的对象来提供新创建对象的__proto__Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;// 或者：Student.prototype = Object.create(Person.prototype, { constructor: { value: Student, enumerable: false, writable: true, configurable: true, },});const student = new Student({ name: &quot;lbs&quot;, age: 18 });console.log(student); createElement 手写1234567891011121314151617181920212223242526272829303132333435363738394041424344const symbolFor = Symbol.for;const REACT_ELEMENT_TYPE = symbolFor(&quot;react.element&quot;);const RESERVED_PROPS = { key: true, ref: true, __self: true, __source: true,};function createElement(type, config, children) { const props = {}; let key = null; if (config !== null) { key = config.key; } for (let propName in config) { if (!RESERVED_PROPS.hasOwnProperty(propName)) { props[propName] = config[propName]; } } const childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = children; } else if (childrenLength &gt; 1) { const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } props.children = childArray; } const element = { $$typeof: REACT_ELEMENT_TYPE, type, key, props, };} 编写正则，验证一个 6 ～ 16 位的字符串，必须同时包含大小写字母和数字1234567正向预查 ？= 必须反向预查 ？！必须不let reg = /(?!^[a-zA-Z]+$)(?!^[0-9]+$)(?!^[a-z0-9]+$)(?!^[A-Z0-9]+$)^[a-zA-Z0-9]{6,16}$/;补充：数字、字母、下划线组成字符串，必须有_let reg = /(?=_)\\w/;let reg = /(?!^[a-zA-Z0-9]+$)^\\w{1,10}$/; 限制1-10位 获取所有属性为 name，值为 value 的元素集合12345678910111213141516171819202122232425// 正则\\b单词边界function getElements(property, value) { let elements = document.getElementsByTagName(&quot;*&quot;); let arr = []; elements = Array.from(elements); elements.forEach((item) =&gt; { // 当前元素property对应的值 let itemValue = item.getAttribute(propertype); if (property === &quot;class&quot;) { const reg = new RegExp(`\\b${value}\\b`); if (reg.test(itemValue)) { arr.push(item); } } if (itemValue === value) { arr.push(item); } }); return arr;} 英文字母汉字组成的字符串，用正则给英文单词前后加空格12345678let str = &quot;中国hello你好&quot;;let reg = /\\b[a-z]+\\b/gi;str = str .replace(reg, (value) =&gt; { return ` ${value} `; }) .trim(); // 去除首尾空格 js 实现斐波那契数列的几种方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1.递归function fibonacci(n) { if (n === 1 || n === 2) { return 1; } return fibonacci(n - 1) + fibonacci(n - 2);}// 2.尾递归(每次调用都在收集结果，避免了线性递归不收集结果只依次展开消耗内存的坏处)function fibonacci(n, res1 = 1, res2 = 1) { if (n &lt;= 2) return res2; return fibonacci(n - 1, res2, res1 + res2);}// 循环function fibonacci(n) { let num1 = 1; let num2 = 2; let sum = 1; for (let i = 3; i &lt; n; i++) { sum = num1 + num2; num1 = num2; num2 = sum; } return sum;}// 数组function fibonacci(n) { const arr = [0, 1, 1]; if (n &lt; 0) { throw new Error(&quot;输入的数字不能小于0&quot;); } if (n &gt;= 3) { for (let i = 3; i &lt;= n; i++) { arr[i] = arr[i - 1] + arr[i - 2]; } } return arr[n];} 并发加载123456789101112131415161718192021222324252627282930313233343536373839404142function limitLoad(urls, handler, limit) { const sequence = [].concat(urls); let promises = []; promises = sequence.splice(0, limit).map((url, index) =&gt; { return handler(url).then(() =&gt; { return index; }); }); let p = Promise.race(promises); for (let i = 0; i &lt; sequence.length; i++) { p = p.then((res) =&gt; { promises[res] = handler(sequence[i]).then(() =&gt; { return res; }); console.log(promises); return Promise.race(promises); }); }}function loadImg(url) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // console.log(url.info + '---OK!!!') resolve(); }, url.time); });}let urls = [ { info: 1, time: 2000 }, { info: 2, time: 1000 }, { info: 3, time: 3000 }, { info: 4, time: 4000 }, { info: 5, time: 5000 },];limitLoad(urls, loadImg, 3); 前端内存处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781. 内存的生命周期 内存分配：声明变量、函数对象的时候，js会自动分配内存 内存使用 内存回收2. js中的垃圾回收机制 引用计数：缺点循环引用无法清除 标记清除3. 常见内存泄漏 全局变量（记得手动回收） 未被清除的定时器 闭包 dom的引用4. 怎么避免内存泄漏 减少不必要的全局变量 使用完数据，及时解除引用实现sizeOf，传入object，计算其所占字节大小number: 8 字节string: 2 字节boolean; 4 字节const seen = new WeakSet();function sizeOfObject(obj) { if (obj === null) { return 0; } let bytes = 0; const keys = Object.keys(obj); for(let i = 0; i &lt; keys.length; i++) { const key = keys[i]; bytes += calculator(key); if (typeof obj[key] === 'object' &amp;&amp; obj[key] !== null) { if (seen.has(obj[key])) { continue; } seen.add(obj[key]) } bytes += calculator(obj[key]) }}function calculator(obj) { const objType = typeof obj; switch(objType) { case 'string': { return obj.length * 2 } case 'boolean': { return 4 } case 'number': { return 8 } case 'object': { if (Array.isArray(obj)) { return obj.map(calculator).reduce((accu, curr) =&gt; { return accu + curr }, 0) } else { return sizeOfObject(obj) } } default: { return 0 } }} 数据结构就是在计算机中存储和组织数据的方式。 算法（Algorithm）解决问题的逻辑或步骤 栈(封装)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function Stack() { this.items = []; // 1. 将元素压入栈 Stack.prototype.push = function (element) { this.items.push(element); }; // 2.从栈中取出元素 Stack.prototype.pop = function () { return this.items.pop(); }; // 3.查看一下栈顶元素 Stack.prototype.peek = function () { return this.items[this.items.length - 1]; }; // 4.判断栈是否为空 Stack.prototype.isEmpty = function () { return !this.items.length; }; // 5.获取栈中元素个数 Stack.prototype.size = function () { return this.item.length; }; // 6. toString方法 Stack.prototype.toString = function () { let res = &quot;&quot;; for (let i = 0; i &lt; this.items.length; i++) { res += `${this.items[i]} `; } return res; };}const stack = new Stack();// 实例：将十进制转换成二进制function dec2bin(decimalNumber) { let stack = new Stack(); let binary = &quot;&quot;; while (decimalNumber &gt; 0) { stack.push(decimalNumber % 2); decimalNumber = Math.floor(decimalNumber / 2); } while (!stack.isEmpty()) { binary += stack.pop(); } return binary;} 平衡括号问题12345678910111213141516171819202122232425262728293031function check(str) { const stack = new Stack(); const open = &quot;{[(&quot;; const close = &quot;}])&quot;; let index = 0; let balanced = true; while (index &lt; str.length &amp;&amp; balanced) { if (open.includes(str[index])) { stack.push(str[index]); } else { const top = stack.pop(); if (open.indexOf(top) === close.indexOf(str[index])) { balanced = true; } else { balanced = false; } } index++; } if (balanced &amp;&amp; stack.isEmpty()) { return true; } return false;}check(&quot;{([][])}&quot;);check(&quot;{[(])}&quot;); 翻转链表12345678910function reverseList(head) { if (head === null || head.next === null) return head; let result = reverseList(head.next); head.next.nexd = head; head.next = null; return result;} 二分查找1234567891011121314151617function binarySearch(elements, value, _start, _end) { let end = _end || elements.length - 1; let start = _start || 0; let povitIndex = Math.floor((start + end) / 2); if (elements[povitIndex] === value) { return povitIndex; } if (value &lt; elements[povitIndex]) { return binarySearch(elements, value, 0, povitIndex - 1); } else { return binarySearch(elements, value, povitIndex + 1, end); } return false;} 快速排序123456789101112131415161718192021222324function quickSort(elements) { if (elements.length &lt;= 1) { return elements; } let pivotIndex = Math.floor(elements.length / 2); let [pivot] = elements.splice(pivotIndex, 1); let left = []; let right = []; for (let i = 0; i &lt; elements.length; i++) { if (elements[i] &lt; pivot) { left.push(elements[i]); } else { right.push(elements[i]); } } return quickSort(left).concat([pivot], quickSort(right));}let elements = [2, 4, 3, 7, 5];console.log(quickSort(elements)); 冒泡排序123456789101112131415161718192021function bubbleSort(elements) { let elementLength = elements.length; for (let i = 0; i &lt; elementLength - 1; i++) { for (let j = 0; j &lt; elementLength - i - 1; j++) { if (elements[j] &gt; elements[j + 1]) { let temp = elements[j]; elements[j] = elements[j + 1]; elements[j + 1] = temp; } } } console.log(elements);}let elements = [2, 4, 3, 7, 5];bubbleSort(elements);// console.log(elements) 二叉搜索树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//满二叉树：每层节点数都达到最大值，第n层节点数为2^(n - 1),总节点数为2^n -1(2的n次方减一)//完全二叉树：除最后一层外，其他各层节点数都达到最大个数，最后一层所有节点集中在最左边class Node { constructor(value) { this.value = value; this.left = null; this.right = null; }}class BinarySearchTree { constructor() { this.root = null; } // 插入前比较 insertNode(node, newNode) { // 右侧插入 if (newNode.value &gt; node.value) { if (node.right === null) { node.right = newNode; } else { this.insertNode(node.right, newNode); } } else if (newNode.value &lt; node.value) { // 左侧插入 if (node.left === null) { node.left = newNode; } else { this.insertNode(node.left, newNode); } } } // 插入 insert(value) { let newNode = new Node(value); if (this.root === null) { this.root = newNode; } else { this.insertNode(this.root, newNode); } } preOrderTraversalNode(node, callback) { if (node === null) return; callback(node.value); this.preOrderTraversalNode(node.left, callback); this.preOrderTraversalNode(node.right, callback); } // 先序遍历 preOrderTraversal(callback) { this.preOrderTraversalNode(this.root, callback); } inOrderTraversalNode(node, callback) { if (node === null) return; this.inOrderTraversalNode(node.left, callback); callback(node.value); this.inOrderTraversalNode(node.right, callback); } // 中序遍历 inOrderTraversal(callback) { this.inOrderTraversalNode(this.root, callback); } postOrderTraversalNode(node, callback) { if (node === null) return; this.postOrderTraversalNode(node.left, callback); this.postOrderTraversalNode(node.right, callback); callback(node.value); } // 中序遍历 postOrderTraversal(callback) { this.postOrderTraversalNode(this.root, callback); } //最大值 max() { let node = this.root; while (node.right !== null) { node = node.right; } return node.value; } // 最小值 min() { let node = this.root; while (node.left !== null) { node = node.left; } return node.value; } // 寻找指定值是否存在 search(val) { let node = this.root; while (node !== null) { if (val &lt; node.value) { node = node.left; } else if (val &gt; node.value) { node = node.right; } else { return true; } } }}var bst = new BinarySearchTree();bst.insert(3);bst.insert(2);bst.insert(5);// bst.preOrderTraversal((nodeValue) =&gt; {// console.log(nodeValue)// })// bst.inOrderTraversal((nodeValue) =&gt;{// console.log(nodeValue)// })// bst.postOrderTraversal((nodeValue) =&gt;{// console.log(nodeValue)// })// console.log(bst.max())console.log(bst.search(5));console.log(bst); 翻转链表12345678910111213141516171819202122232425262728293031323334// 递归var reverseList = function (head) { if (head === null || head.next === null) return head; let res = reverseList(head.next); head.next.next = head; head.next = null; return res;};// 循环var reverseList = function (head) { let pre = null; let cur = head; if (cur === null || cur.next === null) { return cur; } while (cur) { const t = cur.next; cur.next = pre; pre = cur; cur = t; // cur.next = null // cur.next.next = cur // cur = cur.nexxt } return pre;}; 算法 1: Two Sum1234567891011121314151617181920example:given nums = [2, 7, 11, 15], target = 9because num[0] + num[1] = 2 + 7 = 9,return [0, 1]答：function twoSum(nums, target) { const map = new Map(); for(let i = 0; i &lt; nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) { return [map.get(complement), i] } else { map.set(nums[i], i) } }} 装箱：基本类型到引用类型的一个转换拆箱：将引用类型到基本类型的转换（toPrimitive） 编码和解码：escape(str) unescape(str)encodeURI() decodeURI()encodeURIComponent() decodeURIComponent()btoa() atob() 回流：相当与刷新页面重绘： 不刷新，动态更新内容重绘不一定引起回流，回流一定引起重绘","link":"/2022/03/31/%E9%9D%A2%E8%AF%95%E4%BC%98%E8%B4%A8%E6%89%8B%E5%86%99%E9%A2%98/"},{"title":"面试优质知识点","text":"从浏览器地址栏输入 url 到显示页面的步骤 1. 浏览器查看缓存(浏览器对应的都会有cache文件)。 若请求有缓存且未过期，则取缓存资源提供给客户端，否则发起请求与服务器进行验证。 检验是否过期通常有两个HTTP头：Expires、Cache-control 2.浏览器需要获取域名对应的ip地址，过程如下： 1.本地host文件查找 - 浏览器解析URL获取协议、域名、端口、path路径，然后查看本地硬盘中hosts文件，看是否存在与这个域名对应的规则，如果有就直接使用hosts文件里面的ip地址。 2.路由器缓存 3.ISP DNS(Domain Name System域名系统)(情报局)缓存（互联网提供服务商）-本地DNS服务器以递归方式进行查询缓存记录， 若没有就向跟DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器， 本地DNS服务器把对应关系草存在缓存中（一边下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。 3.客户端发送HTTP请求。 4.TCP传输报文（三次握手四次挥手） 5.向客户端返回资源 6.解析HTML文档，构建DOM树，CSSOM树，下载资源，执行js脚本等。 DNS 负载均衡1当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个域名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 强缓存和协商缓存123强缓存：（expires、Cache-Control）在过期时间内，浏览器再次加载资源时，不会向服务器发起请求，直接从缓存中读取资源协商缓存：向服务器发送请求，服务器会根据请求头（request header）的一些参数（Etag、last-modified）来判断是否命中协商缓存，首先根据Etag的值判断请求的文件有没有被修改，如果Etag一致则没有被修改，命中协商缓存返回304，如果不一致则返回新的资源并带上新的Etag返回200状态码。如果没有Etag值，则对比If-Modified-Since和请求文件的最后修改时间，一致则命中协商缓存返回304，不一致则返回新的last-modified和200状态码 http 协议的特点123456789101112131415161718192021222324251.支持客户/服务器模式2.简单快速：客户向服务器发送请求时，只需传送请求方法和路径。3.灵活：http允许传输任意类型的数据对象（Content-Type内容编码类型）application/x-www-form-urlencoded 常见post提交数据格式（key-value格式）application/json4.无连接：限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。（原因是早期服务器需要同时面对全世界数十万、上百万的客户端的网页访问，但是每次客户端与服务端传输的数据关联性很低，就会导致大部分通过会很空闲，无端占用资源）（解决无连接）Keep-Alive：使客户端到服务端之间的Http连接保持，不会断开，当再次对服务器发送请求时，keep-Alive功能避免了重新建立连接5.无状态：Http是一个无状态协议，就是每个请求都是独立的，数据传输完毕不会记录任何信息。缺点就是如果后续处理需要前面的信息，就必须重传，就会导致每次连接传送的数据量增加，如果服务器不需要前面信息的时候应答就会很快。（解决无状态）怎样保持http连接状态呢Cookie（每次http请求的时候，客户端都需要发送响应的cookie信息到服务端，服务端根据cookie判断来自哪个客户端）服务端生成cookie，客户端保存Session服务端生成一个sessionid，在客户端下次请求的时候在cookie里面记录这个sessionid，然后发送给服务端，服务端再根据cookie中的sessionid来识别客户端返回资源数据。禁用cookie怎么办？url重写，每次http请求的时候，在url后面拼接sid=**参数withCredentials:指定在涉及到跨域请求时，是否携带cookie信息，默认为falseAccess-Control-Allow-Credentials: true cookie 和 session 的区别12341.存取方式不同： cookie只能保存ASCII字符串，session能够存储任意类型的数据2.隐私策略不同3.cookie是存在客户端，session是存在服务器的4.浏览器的支持不同，浏览器可以禁用cookie 权限身份验证12345678910111213一般都是通过sessionid来进行用户身份验证，sessionid一般会存放在redis中。1.用户向服务端发送用户名和密码进行登陆2.服务器验证通过后，服务器为用户创建一个session，并将session信息存储起来3.服务器向用户返回一个sessionid，写入用户的cookie4.当用户保持登陆状态时，每次后续请求都会一起发送给后端5.服务器将存储在cookie中的sessionid和存储在内存或者数据库中的sessin信息进行一个比较，验证用户身份，然后返回响应信息注意：1.依赖session的关键业务一定要确保客户端开启了cookie2.注意session的过期时间一般在http header的Authorization字段中添加token 禁用 cookie 之后 session 还能用吗？12url重写，例如 https://javascript.cn/?session_id=xxx缺点是安全性降低，可以对sessionid进行一次加密后传输 get 和 post 的区别1234561.url可见性：get参数url可见，post参数url不可见2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数3.缓存性：get请求可以缓存，post请求不可以缓存4.get请求网页回退时，不产生影响，post请求网页回退会重新发请求5.传输数据：get一般传输数据大小不超过4k，post可以传输大量数据6.post较get安全性较高，get是不安全的因为url可见，可能会泄漏私密信息 http 常见的请求头字段12345678910111213141516Accept: 浏览器可接受的数据类型Accept-Charset: 浏览器可接受的字符集Accept-Encoding：浏览器能够进行解码的数据编码方式Accept-Language： 浏览器所希望的语言种类Connection：是否需要持久连接，值“Keep-Alive”，HTTP1.1默认进行持久连接Cookie：cookie信息content-typeIf-Modified-Since：内容被修改才会返回User-Agent：浏览器类型响应头：content-Length: 表示内容长度content-type：文档类型Date：当前时间Expires：指定缓存过期时间Last-Modified：文档过期时间 http 和 https 的区别12345678910http是超文本传输协议，信息是明文传输，https是更加安全的ssl加密传输协议http默认是80端口，https默认是443端口https需要申请CA证书https是http + ssl/tls（数字证书）进行组合的更加安全的传输协议https工作原理（非对称加密）1.服务端向客户端传递证书作为公钥2.客户端对证书进行解析，判断证书的办法机构和过期时间等，如果都没有问题，生成一个随机值作为私钥，然后使用证书进行加密发送给服务端3.服务端解密得到客户端私钥4.之后双方利用私钥进行加密解密，完成信息的通信 xss（跨域脚本攻击）csrf（跨站请求伪造）123csrf: 需要用户先登陆网站A，获取cookie，利用的是网站A本身的漏洞，去请求网站A的api，---进行token验证，referer验证，只接收本站的请求xss：向网站A注入js代码，然后执行js代码，篡改网站A的内容，破坏页面正常结构，插入恶意广告。---编码转换 http1.0、http1.1 和 http2.0 的区别123http/1.0 每个请求都要建立一个连接http/1.1 多了长连接keep-alive，若干个请求需要排队串行化单线程处理，会发生网络请求阻塞问题。http/2.0 同一个连接可以有多个请求，各个请求直接互不影响（进行了头部压缩和多路复用的优化） 设计模式123456单例模式 （class组件中new store创建store实例）工厂模式 （mobx store中creatLayoutStore）观察者模式发布订阅模式装饰器模式 （移动、pc配置同步@sync） TCP 与 UDP 区别123456* TCP是面向连接的协议，发送数据前先要建立连接，TCP提供可靠的服务，通过TCP建立连接传输的数据不会丢失，没有重复，并且按照顺序到达。* UDP是无连接的协议，发送数据前不需要建立连接，是不可靠的* TCP只支持点对点通信，而UDP支持一对一，多对多* TCP是面向字节流的，UDP是面向报文的* TCP通信类似打电话，接通后需要确认身份，才可以开始通信* UDP类似广播直接进行通信 TCP/IP 模型1234应用层（应用层就是向用户提供通信服务的活动，提供用户程序接口HTTP、DNS）传输层（传输层为两台主机上的应用程序提供端到端的通信TCP，UDP）网络层（网络层实现数据包的选路和转发）数据链路层（ARP地址解析协议、RARP逆地址解析协议，使用物理地址寻找一台机器） 正向代理和反向代理12正向代理是客户端代理，服务端不知道是哪个客户端发起的请求反向代理是服务端代理，客户端不知道是哪个服务端提供的资源 OSI 模型12345678910应用层表示层会话层传输层网络层数据链路层物理层 三次握手为什么需要三次握手？两次握手第二次结束后，服务端并不能保证客户端已经接收到了第二次的应答信息，如此一来服务器会一直保持通信过程，因为 TCP 通信会占用端口，造成资源浪费。 防止已失效的连接请求报文段突然又传送到服务端，产生错误。如上述情况，如果 client 没有再次向 server 发出确认，server 收不到确认就不会建立连接，可以避免 server 端一直等待浪费资源。 四次挥手 https://blog.csdn.net/rememberyf/article/details/80309148 301 和 302 的区别1234567891011121314151617181920212223301 表示资源被永久移除，浏览器在拿到状态码后跳转到一个新的URL地址，可从相应头的location首部中获取，搜索引擎在抓取新内容的同时也将就地址交换为重定向之后的网址。302 表示地址资源还在，仍可以访问，搜索引擎会抓取新的内容而保存旧的地址，seo 302 优于301.重定向的原因：网站调整（改变网页目录结构）页面被移到一个新地址页面扩展名改变 .php -&gt;.html如果不做重定向会返回404页面，会白白流失用户访问量。1XX 信息性状态码，表示接受的请求正在处理2XX 成功状态码，表示请求被正常处理完毕3XX 重定向状态码，表示需要进行附加操作以完成请求4XX 客户端错误状态码，表示服务器无法处理请求 400 Bad Request请求出现语法错误 401 被请求的页面需要用户名和密码 403 forbidden 请求页面的访问被禁止 404 资源未找到5XX 服务器错误状态码，表示服务器处理请求出错 502 网关错误 503 服务器超负载或者停机维护，无法处理请求 504 网关超时 cookie cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据 cookie 追踪用户在不同页面的访问信息。 cookie 特点 1.大小限制，cookie 大小限制在 4KB 以内 2.宽带限制，cookie 数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。 3.安全风险，cookie 会频繁的在网络中传送，不加密的情况下是有安全风险的。 4.操作复杂123456function setCookie(name: string, value: string) { const exp = new Date(); //过期时间设置为一天 exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000); document.cookie = `${name}=${escape(value);expires=${exp.toString()}}`;} localStorage 会话存储 和 sessionStorage 本地存储 1.存储容量大 2.零宽带，仅存储在本地，不会和服务器发生任何交互行为，不存在网络宽带占用问题。 3.编程接口，提供一套丰富的接口，操作数据更加方便。 4.独立的存储空间，不会造成数据的混乱。 主要区别在于数据存储的 时间范围和页面范围 sessionStorage: 数据只存储到窗口或标签关闭时，只在当前窗口的当前标签内可见,5M 左右，不同浏览器不同大小。 localStorage: 数据会一直存在除非手动清除，数据可被同源(协议、域名、端口号一致)的每个窗口或标签共享,5M 左右，不同浏览器不同大小。 监测是否支持 web Storage 1.通过 window.sessionStorage,window.localStorage 判断浏览器是否支持 2.通过 try{}catch{} 执行一下 storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。 html5 的几种存储形式 1.本地存储 localStorage,sessionStorage 2.离线缓存 application cache indexedDb,webSQL 性能优化1234567891011121.负载均衡、CDN加速、设置缓存、2.业务逻辑优化3.代码程序优化（组件按需加载、图片懒加载，代码压缩）4.避免重绘回流重绘：页面元素的样式改变不会影响它在文档流中的位置时发生重绘回流：DOM尺寸大小结构发生变化时回流一定会导致重绘如何避免：1.避免频繁操作dom，通过创建document.createDocumentFragment()一次性插入需要操作的dom2.具有复杂动画的Dom元素使用绝对定位，使其脱离文档流3.合并对于Dom中style样式的操作4.避免使用css表达式 calc() fetch 和 axios12345678910fetch取消发送1.创建一个AbortController实例2.该实例具有signal属性3.将signal传递给fetch option4.调用AbortController的abort属性来取消所有使用该信号的fetchaxios取消发送1.const cancelToken = axios.CancelToken2.const source = CancelToken.source()3.axios.get('/xxx',{cancelToken: source.token}) flex 常用属性，grid 布局123456789101112131415flex属性：1.flex-direction属性，决定主轴方向2.flex-wrap属性，控制换行3.flex-flow属性，flex-direction和flex-wrap的简写形式，默认值flex-flow: row nowrap;4.justify-content属性，项目主轴上的对齐方式5.align-item属性，项目在交叉轴上的对齐方式6.align-content属性，多个轴线的时候在元素在交叉轴的对齐方式，只有一根轴线时不起作用flex（子元素的属性）：1.order属性,定义项目的排列顺序，数值越小，排列越靠前，默认为0.2.align-self属性，允许单个项目与其他项目不一样的对齐方式，会覆盖align-items属性.3.flex属性，flex-grow、flex-shrink、flex-basis简写，默认为0 1 auto auto(1 1 auto) none(0 0 auto)4.flex-grow属性，定义项目的放大比例，默认为0，即如果存在剩余空间也不放大，1等分，一个项目为2，其他为1，则前者占据空间是其他的两倍。5.flex-shrink属性，定义项目的缩小比例，默认为1，空间不足则缩小，如果所有项目都为1，则等比例缩小，如果有的项目为0，则空间不足时为0的不缩小，负值无效6.flex-basis属性，项目占据的固定空间 padding-bottom 实现子元素高度等于父元素宽度问题1当margin或者padding取值是百分比的时候，无论是left，right或者top，bottom，都是以父元素的width为参考物，进行提前占位 预编译123456在作用域的创建阶段（预编译阶段），会生成js的变量对象（VO对象）供js引擎去访问。1.创建ao对象2.找形参和变量声明，作为ao对象的属性名，值为undefined3.实参和形参相统一4.找函数声明，如果名字和变量相同则覆盖变量声明5.解释执行 箭头函数中的 this121.箭头函数中的this是在定义函数的时候绑定的（继承自父执行上下文中的this），而不是执行函数时绑定。2.箭头函数没有this，所以不能用作构造函数。 Map 和 Set 两种新的数据结构的区别？1231. Map类似Object是一种键值对集合，区别在于Map的键不仅限于字符串，其他各种类型的值都可以作为Map的键2.Set是类似数组的一种数据结构，不点在于Set中没有重复的值 你对闭包了解多少？解释一下作用域链是如何产生的 解释一下js执行山下文的创建、执行过程 解释一下闭包所产生的变量放在哪里 闭包的定义：闭包就是能够读取其他函数内部变量的函数。 闭包的底层实现原理 js 执行上下文： 1234567891011121314151617181920212223242526272829js运行三部曲1.语法分析2.预编译3.解释执行js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。预编译的环境需要个环境，这个环境就是执行上下文。js执行上下文分为三种：1.全局执行上下文：代码开始执行时首先进入的环境2.函数执行上下文：函数调用时，会开始执行函数中的代码3.eval执行上下文：不建议使用执行上下文的周期，分为两个阶段1.创建阶段 创建词法环境 生成变量对象VO，建立作用域链 确认this指向，并绑定this2.执行阶段 进行变量赋值，函数引用以及执行代码预编译发生在函数执行前，预编译四部曲：1.创建AO对象2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined3.将形参和实参相统一4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）5.最后程序输出变量值的时候，就是从AO对象中拿（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包） 原型12345student.__proto__ === Student.prototype1.每个函数function都由一个prototype，即显式原型。是在定义函数的时候自动添加的，默认是一个空的Object对象2.每个引用类型都有一个__proto__,即隐式原型。是创建对象时自动添加的，默认值为构造函数的prototype属性值实例对象的隐式原型 等于 对应构造函数或类的显式原型能直接操作显式原型，不能直接操作隐式原型 js 的 new 操作符都做了些什么？1234567891011121314151617181920211. 创建一个空的js对象{}2. 将空对象的隐式原型__proto__指向构造函数的原型3. 将空对象作为构造函数的上下文（改变this指向）4. 对构造函数返回值做判断实现：function create(fn, ...args) { let obj = Object.create({}); // obj.__proto__ = fn.prototype; Object.setPrototypeOf(obj, fn.prototype); let result = fn.apply(obj, args); return result instanceof Object ? result : obj;}补充：在new的时候，会对构造函数的返回值做一些判断1. 如果返回值是基础类型数据，则忽略返回值2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效 calc, support, media 各自的含义及用法？1234567891011121314151617@support 主要用于检测浏览器是否支持css的某个属性，相当于条件语句，支持的话写一套样式，不支持写另外一套样式，例如 @supports (display: grid) { div { display: grid; } } @supports not (display: grid) { div { float: right; } }calc(): 用于动态计算值，支持 + - * / 运算。@media查询：可以针对不同的媒体类型定义不同的样式。 什么是会话 cookie,什么是持久 cookie?1cookie是服务器返回的，指定了expire（有效期）的是持久cookie,没有指定的是会话cookie img 标签 title 和 alt 属性1234alt: 图片加载失败时，显示在网页上的替代文字title: 鼠标放在图片上的提示文字alt是必须属性，可以为空；title为非必须 es6 新特性12345671.let和const2.模版字符串3.箭头函数4.函数可以设置默认参数值5.扩展运算符6.对象和数组的解构7.class 图片懒加载原理12345671. 浏览器是否发起请求是根据&lt;img /&gt;标签的src属性2. 所以懒加载的关键是：在图片没有进入可视区域时，先不给&lt;img /&gt;的src属性赋值，等到图片进入可是区域再给src赋值。当图片底边距离页面的偏移（图片高度+图片距离顶部偏移高度）小于等于浏览器底边距离页面顶部高度（浏览器一屏高度 + 滚动区域） H5 新增了哪些标签？1article、aside、audio、video、footer、header、nav、section SVG 和 Canvas 的区别？12341.svg:表示以XML格式定义图像的可伸缩矢量图形。2.canvas：通过js来绘制2D图形svg通过标签fill属性可以调整颜色 AMD 和 CMD 的区别1234567共同点：1.两者都是框架在推广过程中对模块定义的规范产出2.都是异步加载模块不同点：1.AMD是RequireJs在推广过程中对模块定义的规范产出，CMD是SeaJs在推广过程中对模块定义的规范化产出2.AMD推崇依赖前置，CMD推崇依赖就近3.AMD的应用体验好，因为模块提前执行了，CMD性能好，因为只有用户需要的时候才执行 如何实现 js 倒计时的纠偏？123451. 第一种通过前端定时向服务端发送请求获取最新的时间差，以此来校准倒计时时间。2. 通过前端根据偏差时间来自动调整下次间隔的时间来实现，首先以setTimeout递归的方式来实现倒计时，通过一个变量记录倒计时的秒数，根据秒数和间隔时间计算出此时无偏差时应该显示的时间，然后拿当前真实时间与这个时间相减，就可以得到时间的偏差大小，因此在设置下一个定时器的时候，间隔时间减去这个偏差大小就可以纠正时间误差。 js 的执行机制12345678910111213141516js是单线程的，处理js任务只能一个一个顺序执行，js中把任务分为了同步任务和异步任务，同步任务进入主线程先执行，异步任务进入Event Table并注册函数，指定事情完成后，Event Table就会将函数移入到事件队列Event Queque中，等待主线程任务执行完毕，就会从事件队列中取出对应事件进入主线程执行。macro-task（宏任务）：包括整体代码script、setTimeout、setIntervalmicro-task（微任务）：Promise.then、process.nextTick微任务先于宏任务先执行（除了script）执行过程不同任务进入不同的event quuejs先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，遇到宏任务放到宏任务事件队列中。然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，以此类推。 React请说一下你对 React 的理解？1234567891011121314151. react是一个网页的UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。2. react的核心设计思路有三个：声明式 命令式：命令程序一步一步的执行操作 声明式：只需告诉程序我们想要的结果，其他的交给程序去做。组件化 将视图拆分和模块复用，做到高内聚低耦合通用性 一次学习，随处编写。RN，react360等，跨平台底层靠虚拟DOM实现3. 缺点1.没有官方系统解决方案，在开发大型应用时需要向社区寻找并整合解决方案。2.过于灵活，需要注意代码规范 React.lazy 懒加载12345678910// React.lazy方法可以异步加载组件const Foo = React.lazy(() =&gt; import('../components/Foo')// React.lazy不能单独使用，需要配合React.suspense,用来包裹异步组件，添加loading效果等。&lt;React.Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt; &lt;Foo /&gt;&lt;/React.Suspense&gt;React.lazy原理React.lazy使用import来懒加载组件，import在webpack中最终会调用requireEnsure方法，动态插入script来请求js文件，类似jsonp的形式。 类组件和函数组件之间的区别？1234567891011121314相同点：接受属性返回React元素不同点： 1.编程思想不同：类组件需要创建实例，基于面向对象的方式编程。函数式组件接受输入返回输出，属于函数式编程的思想。 2.内存占用：类组件需要创建实例，会占用内存，函数组件不需要创建实例，可以节约内存 3.捕获特性：函数组件具有捕获特性 4.可测试性：函数组件更方便编写单元测试 5.状态：类组件有实例可以维护自己的状态，函数组件可以使用useState维护自己的状态 6.声明周期：类组件有生命周期，可以在生命周期内写逻辑，函数组件可以在useEffect中 7.逻辑复用：函数组件通过继承实现逻辑复用，函数组件可以通过自定义hooks实现逻辑复用 8.性能优化：类组件通过shouldComponentUpdate和PureComponent来跳过更新，函数组件通过React.memo 当调用 setState 的时候，发生了什么事？12将传递给setState的参数对象合并到组件的当前的状态，react遍历dom节点，计算差异，更新UI。https://segmentfault.com/a/1190000018250127 为什么 setState 的参数是一个 callback 而不是一个对象123456因为this.props和this.state的更新可能是异步的，不能依赖它们的值去计算下一个state(更新状态不要直接修改this.state，虽然状态可以改变，但不会触发组件的更新)setState何时同步何时异步？异步：由React控制的事件处理程序以及生命周期函数中调用setState为异步同步：React控制之外的原生js绑定的事件、setTimeout/setInterval等。 setState 什么时候同步什么时候异步？12345678910111213react三个模式：1.legacy模式： 通过ReactDOM.render(&lt;App /&gt;, rootNode)创建的，当前react的使用方式2.blocking模式：通过ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;),实验阶段，作为迁移到concurrent模式的第一个步骤3.concurrent模式，通过ReactDOM.createRoot(rootNode).render(&lt;App /&gt;),实验阶段，未来react的默认开发模式setState 只在合成事件（react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件）和钩子函数（生命周期中）是异步的，在原生事件和setTimeout中都是同步的。不同模式执行结果不同，legacy模式命中batchedUpadates（批处理）时异步，为命中时同步concurrent模式都是异步的setState异步并不是说内部由异步代码实现，其本身执行过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了“异步”可以通过第二个参数的callback回调函数中拿到最新的值，在异步中如果对同一个值进行多次setState，那么setState的批量更新策略会将其覆盖，去最后一次的执行，如果同时setState多个值，会在更新时对其进行合并批量更新。 react 渲染机制12345678首先打开页面会渲染出一颗DOM树，更新数据会生成一颗虚拟DOM树，通过diff算法，比较两颗DOM树的差异，找到更新的地方进行批量改动。diff：计算一棵树形结构到另一颗树形结构的最少操作。1.把树形结构按照层级分解，只比较同级元素2.给列表结构的每个单元添加唯一的 key 属性，方便比较3.diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。（官方也不推荐） React.StrictMode 目前有助于：12345识别不安全的生命周期关于使用过时字符串 ref API 的警告关于使用废弃的 findDOMNode 方法的警告检测意外的副作用检测过时的 context API 虚拟 DOM 优点12345678910111213141516171819202122231. 减少不必要的DOM操作 1.1虚拟dom可以将多次操作合并为一次操作，比如添加100个节点，确是一个一个操作的 1.2虚拟dom借助dom diff可以将多余的操作省略掉，比如添加100个节点，其中10个是新增的2. 跨平台渲染 1.因为虚拟dom本质上是一个js对象react虚拟dom结构:const vNode = { key: null, props:{ children: [ {type: 'span', ....}, ], className: 'red', onClick: () =&gt; {} }, ref: null, type: 'div',}创建虚拟dom：React.createElement diff 策略`策略一： tree diff1.React 对树进行分层比较，两颗虚拟 DOM 树只会对同一层级的 DOM 节点进行比较。如果存在跨层级的操作，只会进行创建和删除 2.如果节点是组件就进行 Component diff 3.如果节点是标签就进行 Element diff 策略二：component diff如果为非同类型组件的话标记组件为 dirty component，替换组件下所有子节点，类型相同更新属性，然后深入组件进行 Tree diff（递归遍历对比） 策略三：element diff如果节点是原生标签，则看标签名标签名不同直接替换，相同更新属性，然后进入标签进行 Tree diff（递归遍历对比）` shouldComponentUpdate(nextProps, nextState)是做什么的，（react 性能优化是哪个周期函数？）12shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新绘制dom,由于渲染dom非常消耗性能，合理的调用shouldComponentUpdate方法可以极大的提高性能。 createElement 和 cloneElement 有什么区别？1234567891011121314React.createElement()构建React元素。接受三个参数，第一个参数为标签名，如div、span等，或者react组件，第二个参数为传入的属性，第三个为组件的子组件。React.createElement( type, [props], [...children])React.cloneElement(),第一个参数传入react元素不是标签名，第二个参数传入属性，新添加的属性会并入原有的属性，第三个参数为子组件React.cloneElement( element, [props], [...children]) 虚拟 DOM 的优缺点？123456789优点：1. 处理了浏览器兼容性问题，避免了用户操作真实DOM2.内容经过xss处理，可以防范xss攻击3.跨平台开发4.更新的时候可以实现差异化更新，减少更新DOM的操作缺点：1.虚拟DOM需要消耗额外的内存2.首次渲染不一定会更快 React 中创建组件的方式1React.createClass()、ES6 class组件 无无状态函数式组件 react 中 key 的作用12345key在react中用于追踪哪些列表中元素被修改、添加或者移除的辅助标识。在开发中，需要保证某个元素的key在同级元素中具有唯一性。diff算法会借助元素的key值来判断元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染 react 优势12341. 速度快：不直接操作dom，采用虚拟dom的概念2.跨浏览器兼容，兼容性好3.一切都是component，代码更加模块化，可维护性高4.单向数据流，采用Flux单向数据层架构 react 事件机制1234567react的事件机制利用了事件委托机制，事件并没有真正的绑定在真实的dom节点上，而是把事件绑定在结构的最外层document，使用统一的事件监听器，所有事件都由这个监听器统一分发。组件挂载和更新时，会将绑定的事件分门别类的放进一个叫EvnentPluginHub的事件池中。事件触发时，根据事件产生的Event对象找到触发事件的组件，再通过组件标识和事件类型从事件池中找到对应的事件监听回调，然后执行相关的监听函数。 异步回调中怎么使用 syntheticEvent？123在合成事件机制里，一旦事件监听回调执行，合成事件对象就会被销毁，异步回调执行的时候合成事件对象早就被销毁了。解决方法：执行event.persist(),通知react不需要回收。 React 生命周期123456789101112131415161718192021React 16推出Fiber之后，如果要开启async rendering，那么在render函数之前的所有函数都有可能被执行多次废弃：componentWillMountcomponentWillReceiveProps(nextProps)componentWillUpdate(nextProps, nextState)代替：静态函数：static getDerivedStateFromProps(nextProps, prevState)静态函数：static getDerivedStateFromError(error) // 渲染备用UI此生命周期return的值会自动调用setState，将值和state合并运行事件节点：子组件被渲染发生错误后且在页面更新前getSnapshotBeforeUpdate(prevProps, prevState) 此生命周期的返回值将作为参数传递给componentDidUpdate()componentDidCatch(error, info) // 打印错误信息错误边界无法捕获的错误：1.组件自身的错误2.异步错误，setTimeout3.事件中的错误，比如click事件中发生错误 Redux12345678910111. 构建action，通过创建一个函数，返回一个对象，需要携带type属性2. 构建reducer，用来响应action，然后通过return把数据传回store3. 利用createStore来构建store，把reducer作为参数传入4. 利用store.subscribe()注册监听5. 利用store.dispatch()发送action6. 利用store.getState()拿到值 Typescriptts 中 type 和 interface 的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445相同点：1.都可以描述一个对象和函数interface User { name: string;}interface SetUser { (name: string): void;}type User = { name: string;}type SetUser = (name: string): void;2.扩展与交叉类型interface可以extends进行类型扩展，type可以通过交叉类型实现interface的extend行为。interface可以exteds type，type也可以与interface类型交叉（&amp;符号）不同点：1.type可以声明基本类型别名，联合类型，元祖等类型基本类型别名type Name = string;联合类型interface Dog { wang();}interface Cat { miao();}type Pet = Dog | Cat;元祖类型type PetList = [Dog, Cat];2. interface能够声明合并interface User { name: string;}interface User { age: number;}=/**interface User { name: string; age: number;}*/ ts 中如何实现一个函数的重载12js是动态类型语言，所以是没有overload的，但js可以在运行的时候判断类型ts的重载只是重载函数声明，函数的实现还是只有一个 mobx1234567Observable //被观察者Observer // 观察者Reaction //响应mobx底层对数据的观察是使用Object.defineProperty(mobx4)或Proxy(mobx5)observer这个装饰器，对react组件的render方法进行跟踪，将render方法加入到各个observable的依赖中，当observale发生变化的时候，就会调用forceUpdate更新组件（mobx4将Array用类数组对象来模拟的，通过包装类封装为一个对象） webpack 常用 loader12345678910111213样式：style-loader、css-loader、less-loader、sass-loader文件：file-loader、url-loader编译：babel-loader、ts-loader校验：eslint-loader常用的pluginhtml-webpack-pluginwebpack-bundle-analyzer 打包分析HotModuleReplacementPlugin 热更新自己写webpack插件：主要就是通过访问compliler和compilation拦截webpack的执行 垃圾回收机制12345678910111213垃圾收集器会定期（周期性）的找出那些不再继续使用的变量，释放其内存，因为开销比较大，所以会按照固定的时间间隔周期性的执行最常用的两种方法：标记清除（常用）和引用计数标记清除：变量进入作用域，进行标记，离开作用域进行清除回收引用计数：就是跟踪记录每个值被引用的次数，引用一次加1，删除减1，引用计数为0时，进行回收，（循环引用可能会导致内存泄漏）常见的内存泄漏原因：全局变量过多引起内存泄漏闭包dom事件未清除循环引用 谈谈你对 webpack 的理解？1234567webpack是一个打包模块化js的工具，在webpack里一切文件皆模块，通过loader转换，通过plugin注入钩子，最后输出由多个模块组合成的文件，webpack专注构建模块化。WebPack可以看做是模块的打包机器：它做的事情是，分析你的项目结构，找到js模块及其它的一些浏览器不能直接运行的拓展语言，例如：Scss，TS等，并将其打包为合适的格式以供浏览器使用。 说说 webpack 与 grunt、gulp 的不同？12345678910111213141516171819三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据，整条链式操作构成了一个任务，多个任务就构成了web的构建流程。webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。所以，从构建来说，gulp和grunt需要开发者将整个前端构建过程拆分成多个`Task`，并合理控制所有`Task`的调用关系；webpack需要开发者找到入口，并需要清楚对于不同的资源应该使什么Loader做何种解析和加工对于知识背景来说，gulp更像后端开发者的思路，需要对于整个流程了如指掌webpack更倾向于前端开发者的思路 什么是 bundle,什么是 chunk，什么是 module?123bundle：是由webpack打包出来的文件chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块 什么是 Loader?什么是 Plugin?123451.Loaders是用来告诉webpack如何转化处理某一类型的文件，并且引入到打包出的文中2）Plugin是用来自定义webpack打包过程的方式，一个插件是含有apply方法的一个，通过这个方法可以参与到整个webpack打包的各个流程(生命周期)。 有哪些常见的 Loader？他们是解决什么问题的？12345678910file-loader：把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件url-loader：和file-loader类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中去source-map-loader：加载额外的Source Map文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把ES6转换成ES5css-loader：加载CSS，支持模块化、压缩、文件导入等特性style-loader：把CSS代码注入到JavaScript中，通过DOM操作去加载CSS。eslint-loader：通过ESLint检查JavaScript代码 有哪些常见的 Plugin？他们是解决什么问题的？123define-plugin：定义环境变量commons-chunk-plugin：提取公共代码uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 Loader 和 Plugin 的不同？123456789101112不同的作用Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。不同的用法Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。 webpack 的构建流程是什么?1234567891011121314151617181920212223Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；开始编译：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；确定入口：根据配置中的 entry 找出所有的入口文件；编译模块：从入口文件出发，调用所有配置的 Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；完成模块编译：在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，Webpack会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 描述一下编写 loader 或 plugin 的思路？1234Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 如何利用 webpack 来优化前端性能？123456789101112131415用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件，利用cssnano（css-loader?minimize）来压缩css利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现提取公共代码。 如何提高 webpack 的构建速度？1234567多入口情况下，使用CommonsChunkPlugin来提取公共代码通过externals配置来提取常用库利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。使用Happypack 实现多线程加速编译使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用Tree-shaking和Scope Hoisting来剔除多余代码 怎么配置单页应用？怎么配置多页应用？12单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用webpack的AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。多页应用中要注意的是：每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表,随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置 vue 项目中实现按需加载？123456为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。通过import(*)语句来控制加载时机，webpack内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个chunk。当代码执行到import(*)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill","link":"/2022/03/31/%E9%9D%A2%E8%AF%95%E4%BC%98%E8%B4%A8%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"打乱数组","text":"打乱数组 1. 常见的sort打乱数组的方法 function shuffle(arr) { return arr.sort (function () { return Math.random() - 0.5 }) } var arr = [1,2,3,4,5,6,7] shuffle(arr) 更加简洁的ES6写法 function shuffle(arr) { return arr.sort(() =&gt; Math.random() - 0.5) } 但是这种写法有问题，并不能真正地随机打乱数组，经过大量的实验发现 每个元素仍然有很大的几率出现在它原来的位置附近。 2.洗牌算法 从最后一个数据开始往前，每次随机一个位置，将两者的位置进行交换，直到数组交换完毕。 ES6实现： function shuffle(arr) { let i = arr.length; while(i) { let j = Math.floor(Math.random() * i--); [arr[j], arr[i]] = [arr[i], arr[j]]; } return arr } var arr = [1,2,3,4,5,6,7] shuffle(arr)","link":"/2019/08/07/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"},{"title":"获取唯一id的三种方法","text":"uuid 1234567891011const UUID = (len = 32) =&gt; { return &quot;xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx&quot; .replace(/[xy]/g, function replace(c) { /* eslint-disable no-bitwise */ const r = (Math.random() * 16) | 0; const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8; return v.toString(16); }) .substring(0, len);}; nanoid1234567891011121314151617const nanoid = (t = 21) =&gt; { let e = &quot;&quot;, r = crypto.getRandomValues(new Uint8Array(t)); for (; t--; ) { let n = 63 &amp; r[t]; e += n &lt; 36 ? n.toString(36) : n &lt; 62 ? (n - 26).toString(36).toUpperCase() : n &lt; 63 ? &quot;_&quot; : &quot;-&quot;; } return e;}; 原生方法1const id = URL.createObjectURL(new Blob()).substr(-36)","link":"/2022/01/04/%E8%8E%B7%E5%8F%96%E5%94%AF%E4%B8%80id%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"面试居中问题","text":"如何居中一个元素？ 行级元素水平居中(单行文本水平居中)text-align: center; 块级元素水平居中1.宽度固定，自身设置 margin: 0 auto; 2.宽度不固定： 父元素设置 text-align: center; 自身设置：display: inline-block; 行级元素垂直居中(单行文本垂直居中)line-height: height; 行级元素垂直居中(多行文本垂直居中)1.父元素设置 display: table; //table是块状元素成为一个块级表格 2.子元素设置 display: table-cell; //子元素设置成表格单元格 vertical-align: middle; //使表格内容垂直居中显示 实现元素的水平垂直居中方法一： margin: auto; 父元素：position: relative; width: 300px; height: 300px; border: 1px solid red; 子元素：position: absolute; width: 100px; height: 100px; margin: auto; top: 0; left: 0; right: 0; bottom: 0; 方法二： 负margin法 .box { width: 400px; height: 200px; position: relative; background: red; } .content { width: 200px; height: 100px; position: absolute; top: 50%; left: 50%; &lt;!--margin-left: -100px;//宽高已知--&gt; &lt;!--margin-top: -50px;--&gt; transform: translate(-50%, -50%);//宽高未知 background: green; } 方法三： flex布局 .box { width: 400px; height: 200px; background: red; display: flex; justify-content: center; //控制水平方向的居中 align-items: center; //控制垂直方向的居中 } .content { width: 200px; height: 100px; background: green; }","link":"/2019/07/29/%E9%9D%A2%E8%AF%95%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/"},{"title":"面试题分享——反转数组","text":"JS 基础：反转数组 12345678910var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]for (var i = 0; i &lt; arr.length / 2; i++) { var temp = arr[i] arr[i] = arr[arr.length - 1 - i] arr[arr.length - 1 - i] = temp}console.log(arr)//JS反转函数：reverse()arr.reverse()","link":"/2019/06/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84/"},{"title":"面试题分享——冒泡排序","text":"JS 冒泡排序详解 说明： + 时间复杂度指的是一个算法执行所消耗的时间。—— O（n*n） + 空间复杂度指执行一个程序所需内存的大小。—— O（1） + 稳定性，如果 a = b,a 在 b 的前面，排序后 a 仍然在 b 的前面。——（稳定） + 不稳定性，如果 a = b,a 在 b 的前面，排序后可能会交换位置。 原理： 依次比较相邻的两个值，如果后面的比前面的小，则将小的元素排到前面。依照这个规则进行多次并且递减的迭代，直到顺序正确。 冒泡排序的写法： 123456789101112131415function sortArr (arr) { for (i = 0; i &lt; arr.length - 1; i++) { for (j = 0; j &lt;arr.length - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { var temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp } } } return arr}var arr = [2, 5, 6, 3, 3, 2, 9, 4]console.log(sortArr(arr))","link":"/2019/06/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"title":"值类型和引用类型的传递","text":"值类型和引用类型的传递 123456789101112131415function Person(name, age, salary) { this.name = name; this.age = age; this.salary = salary;}function f1(person) { person.name = &quot;ls&quot;; person = new Person(&quot;aa&quot;, 18, 10);}var p = new Person(&quot;zs&quot;, 18, 1000);console.log(p.name); //zsf1(p);console.log(p.name); //ls","link":"/2019/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92/"},{"title":"面试题目手写部分","text":"[toc] 手写部分数组去重 123456789101112131415161718192021222324252627282930313233343536373839404142// indexOffunction unique(arr) { let res = []; for(let i = 0; i &lt; arr.length; i++) { if(res.indexOf(arr[i]) &lt; 0) { res.push(arrp[i]) } } return res;}// includesfunction unique(arr) { let res = []; for (let item of arr) { if(!res.includes(item)) { res.push(item) } } return res;}// 利用filterfunction unique(arr) { const res = arr.filter(function(item, index, array){ return array.indexOf(item) === index; }) return res;}// 利用Es6中的Set数据结构(扩展运算符)const unique = arr =&gt; [...new Set(arr)];// Array.form 方法将set结构转换为数组const unique = arr =&gt; Array.from(new Set(arr)); 数组扁平化12345678910111213141516let arr = [1,[2,[3]]]// let res = arr.flat(Infinity)// let res = JSON.parse(&quot;[&quot;+JSON.stringify(arr).replace(/\\[|\\]/g,&quot;&quot;) + &quot;]&quot;)function flatArr(arr) { let res = arr.reduce((accu, curr) =&gt; { return accu.concat(Array.isArray(curr) ? flatArr(curr) : curr) }, []) return res}console.log(flatArr(arr)) 浅拷贝12345678910111213141516171819202122// 只考虑对象类型function shallowCopy(obj) { if (typeof obj !== 'object') return; let newObj = obj instanceof Array ? [] : {}; if(obj === null) return obj; if(obj instanceof Date) return new Date(obj); if(obj instanceof RegExp) return new RegExp(obj); for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key]; } } return newObj;}// Object.assign()// arr.slice(0)// arr.concat()// 扩展运算符 深拷贝1234567891011121314151617181920// 只考虑普通对象属性，不考虑内置对象和函数function deepCone(obj) { if (typeof obj !== 'object') return; let newObj = obj instanceof Array ? [] : {}; if(obj === null) return obj; if(obj instanceof Date) return new Date(obj); if(obj instanceof RegExp) return new RegExp(obj); for(let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]; } } return newObj}// JSON.parse(JSON.stringify())// lodash: _.cloneDeep() 实现一个 compose(组合)函数12345678910111213141516171819202122function compose(...fn) { if(!fn.length) return (v) =&gt; v; if(fn.length === 1) return fn[0]; return fn.reduce((accu, curr) =&gt; (...args) =&gt; accu(curr(...args)) );}例子：function fn1(x) { return x + 1;}function fn2(x) { return x + 2;}function fn3(x) { return x + 3;}function fn4(x) { return x + 4;}const res = compose(fn1, fn2, fn3, fn4);console.log(res(5)); // 5+4+3+2+1=15 assign12345678910111213141516171819Object.assign = function(target, ...source) { if (target === null || target === undefined) { throw new TypeError(&quot;Cannot convert undefined or null to object&quot;); } let result = Object(target); source.forEach(function(obj){ if (obj !== null) { for (let key in obj) { if (obj.hasOwnProperty(key)) { result[key] = obj[key] } } } }) return result;} 防抖函数12345678910111213function debounce (func, wait) { let timeout; return function () { clearTimeout(timeout); timeout = setTimeout(() =&gt; { func.apply(this, arguments) }, wait) }}// 搜索联想，用户在不断输入时，用防抖来节约请求资源// window触发resize的时候 节流函数12345678910111213141516function throttle(func, wait) { const previous = 0; return function() { const now = +new Date(); if(now - previous &gt; wait) { func.apply(this, arguments); previous = now; } }}// 鼠标不断点击触发，可以使其单位时间内只触发以此// 监听滚动事件// 防止高频点击提交 函数柯里化1234567891011121314151617181920212223242526function curry(fn, ...args) { // 需要柯里化的函数fn，也可以支持初始参数的传入 return function() { //参数缓存在args里面,合并上次参数和本次参数 args = [...args, ...arguments] // 判断参数个数，不够继续递归 if (args.length &lt; fn.length) { return curry(fn, ...args) } else { //参数足够返回函数执行结果 return fn.apply(null, args) } }}function bar(a, b, c) { return a + b + c;}const f = curry(bar)console.log(f(1)(2)(3),f(1,2)(3),f(1,2,3)) 如何把字符串中大小写取反12345let str = &quot;LiBoShi&quot;;str = str.replace(/[a-zA-Z]/g, content =&gt; { return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();}) 从 S 中查找 T 字符串，找到返回索引值，没有则返回-1，类似 indexOf1234567891011121314151617181920// 普通方法function myIndexOf(T) { let index = -1; for(let i = 0; i &lt;= this.length - T.length; i++) { if (this.substr(i, T.length) === T) { return index = i; } } return index;}String.prototype.myIndexOf = myIndexOf;// 正则方法function myIndexOf(T) { let reg = new RegExp(T); let res = reg.exec(this); return res === null ? -1 : res.index;} call12345678910111213141516171819202122232425Function.prototype.myCall = function(context, ...args) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;}// 使用let obj = { desc: function(from, to) { console.log(`${this.name}来自${from}去往${to}`); }}let person = { name: 'lbs',}obj.desc.myCall(person, &quot;北京&quot;,&quot;上海&quot;) apply1234567891011Function.prototype.myApply = function(context, args=[]) { const ctx = context || window; const fn = Symbol(); ctx[fn] = this; const res = ctx[fn](...args); delete ctx[fn]; return res;} bind12345678910111213Function.prototype.myBind = function(content, ...args) { const fn = this; return function newFn(...newFnArgs) { // 检测 New // 如果当前函数的this指向的是构造函数中的this 则判定为new 操作 if (this instanceof newFn) { return new fn(...args, ...newFnArgs); }; return fn.myApply(context, [...args, ...newFnArgs]); }} instanceof123456789101. 通过left.__proto__.__proto__这种方式从下往上的获取原型对象2. 通过Object.create(null)的实例是没有原型链3. 有原型链的实例的尽头都是Objectfunction instanceof(left, right) { if(!left.__proto__) return false; if(right === Object || left.__proto__ === right.prototype) return true; return instanceof(left.__proto__, right);} 手写 Object.is123456789function is(x, y) { if (x===y) { // x,y都为0，但是1 / +0 = +Infinity,1 / -0 = -Infinity 是不一样的 return x !== 0 || y !== 0 || 1 / x === 1 / y; } else { //NaN === NaN = false是不对的，做一个拦截操作 return x !== x &amp;&amp; y !== y; }} ajax12345678910111213141516171819202122232425262728function ajax(method, url, headers, body) { return new Promise((resolve, reject) =&gt; { let req = null; try{ req = new XMLHttpRequest(); } catch{ req = new ActiveXObject('Microsoft.XMLHTTP') } req.open(method, url); for(let key in headers) { req.setRequestHeader(key, headers[key]); } req.onreadystatechange(() =&gt; { if(req.readystate ===4) { if(req.status &gt;= 200 &amp;&amp; req.status &lt;= 300) { resolve(req.responseText); } else { reject(req); } } }) req.send(body) })} async 和 await12345678910111213141516171819202122232425262728293031323334// 执行async函数，返回的都是Promise对象async function test1 () { return 1;}async function test2() { return Promise.resolve(2);}console.log(test1(),test2());// Promise.then 成功的情况对应的就是awaitasync function test3() { const p = Promise.resolve(3); p.then((data) =&gt; console.log(data)); const data = await p; console.log(data);}test3();// Promise.catch 异常对应 try...catchasync function test4() { const p = Promise.reject(&quot;异常了&quot;); try{ const data = await p; console.log(data) } catch(e){ console.log(e) }}test4(); map123456789101112Array.prototype.map = function(fn, toThis) { const arr = this; const result = []; const _this = toThis || Object.create(null); for(let i = 0; i &lt; arr.length; i++) { const item = fn.call(_this, arr[i], i, arr); result.push(item); } return result;} 手写 promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158class Promise1{ static PENDING = 'pending'; static FULFILLED = 'fulfilled'; static REJECTED = 'rejected'; constructor(executor) { this.status = Promise.PENDING; //默认状态，进行中 this.value = null; //成功值 this.reason = null; // 失败原因 // 解决异步问题 this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; try { executor(this.resolve.bind(this), this.reject.bind(this)) } catch(e) { this.reject(e) } } resolve(value) { if (this.status === Promise.PENDING) { this.status = Promise.FULFILLED; this.value = value; setTimeout(() =&gt; { this.onFulfilledCallbacks.forEach((cb) =&gt; cb((this.value))) }) } } reject(reason) { if (this.status === Promise.PENDING) { this.status = Promise.REJECTED; this.reason = reason; setTimeout(() =&gt; { this.onRejectedCallbacks.forEach((cb) =&gt; cb(this.reason)) }) } } then(onFulfilled, onRejected) { if (typeof onFulfilled !== 'function') { onFulfilled = () =&gt; this.value; } if (typeof onRejected !== 'function') { onRejected = () =&gt; this.reason; } return new Promise1((resolve, reject) =&gt; { if (this.status === Promise.PENDING) { return new Promise1((resolve, reject) =&gt; { this.onFulfilledCallbacks.push(() =&gt; { this.parse(onFulfilled(this.value), resolve, reject) }); }) return new Promise1((resolve, reject) =&gt; { this.onRejectedCallbacks.push(() =&gt; { this.parse(onRejected(this.value),resolve,reject) }); }) } if (this.status === Promise.FULFILLED) { setTimeout(() =&gt; { return new Promise1((resolve, reject) =&gt; { this.parse(onFulfilled(this.value), resolve, reject) }) }) } if (this.status === Promise.REJECTED) { setTimeout(() =&gt; { return new Promise1((resolve, reject) =&gt; { this.parse(onRejected(this.reason), resolve, reject) }) }) } }) } parse(result, resolve, reject) { try { if (result instanceof Promise1) { result.then(resolve, reject) } else { resolve(result) } } catch (error) { reject(error) } } static resolve(value) { return new Promise1((resolve, reject) =&gt; { if (value instanceof Promise1) { value.then(resolve, reject) } else { resolve(value) } }) } static reject(reason) { return new Promise1((resolve, reject) =&gt; { reject(reason) }) } static all(promises) { const result = []; return new Promise1((resolve, reject) =&gt; { promises.forEach((promise) =&gt; { promise.then((value) =&gt; { result.push(value); if (result.length === promises.length) { resolve(result) } },reason =&gt; { reject(reason) }) }) }) } static race(promises) { return new Promise1((resolve, reject) =&gt; { promises.forEach((promise) =&gt; { promise.then((value) =&gt; { resolve(value) },(reason) =&gt; { reject(reason) }) }) }) }}let aaa = new Promise1((resolve, reject) =&gt; { resolve(&quot;lbs&quot;)// reject('error')}).then((value) =&gt; { console.log(value) return '666'})aaa.then(() =&gt; { console.log(123)})console.log(aaa) 手写 event bus1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class EventEmitter { constructor() { this.events = {} this.maxListeners = maxListeners || Infinity; } emit(event, ...args) { const cbs = this.events[event]; if(!cbs) { console.log(&quot;没有这个事件函数&quot;); return this; } cbs.forEach(cb =&gt; cb.apply(this, args)) return this; } on(event, cb) { if (!this.events[event]) { this.events[event] = [] } if (this.maxListeners !== Infinity &amp;&amp; this.events[event].length &gt;= this.maxListeners) { console.log(&quot;当事件超过了最大监听数&quot;) return this; } this.events[event].push(cb) return this; } once(event, cb) { const func = (...args) =&gt; { this.off(event, fn); cb.apply(this, args); } this.on(event, func) return this; } off(event, cb) { if (!cb) { this.events[event] = null } else { this.events[event] = this.events[event].filter(item=&gt;item !==cb) } return this; }} 继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 构造函数继承function Person() { this.name = 'lbs'}function Student() { Person.call(this) this.age = 18}const s = new Student()// 原型链继承function Person() { this.name = 'lbs'}function Student() { this.age = 18}Student.prototype = new Person()const s = new Student()//寄生式组合继承function Person(obj){ this.name = obj.name;}function Student(obj){ Person.call(this, obj); this.age = obj.age;}// object.create()// 方法创建一个新对象，使用现有的对象来提供新创建对象的__proto__Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;// 或者：Student.prototype = Object.create(Person.prototype, { constructor: { value: Student, enumerable: false, writable: true, configurable: true, }})const student = new Student({name: &quot;lbs&quot;, age: 18});console.log(student); createElement 手写1234567891011121314151617181920212223242526272829303132333435363738394041424344const symbolFor = Symbol.for;const REACT_ELEMENT_TYPE = symbolFor('react.element');const RESERVED_PROPS = { key: true, ref: true, __self: true, __source: true,}function createElement(type, config, children) { const props = {}; let key = null; if (config !== null) { key = config.key; } for (let propName in config) { if (!RESERVED_PROPS.hasOwnProperty(propName)) { props[propName] = config[propName]; } } const childrenLength = arguments.length -2; if(childrenLength === 1) { props.children = children; } else if(childrenLength &gt; 1) { const childArray = Array(childrenLength); for(let i = 0; i &lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } props.children = childArray; } const element = { $$typeof: REACT_ELEMENT_TYPE, type, key, props }} 编写正则，验证一个 6 ～ 16 位的字符串，必须同时包含大小写字母和数字1234567正向预查 ？= 必须反向预查 ？！必须不let reg = /(?!^[a-zA-Z]+$)(?!^[0-9]+$)(?!^[a-z0-9]+$)(?!^[A-Z0-9]+$)^[a-zA-Z0-9]{6,16}$/;补充：数字、字母、下划线组成字符串，必须有_let reg = /(?=_)\\w/;let reg = /(?!^[a-zA-Z0-9]+$)^\\w{1,10}$/; 限制1-10位 获取所有属性为 name，值为 value 的元素集合12345678910111213141516171819202122232425// 正则\\b单词边界function getElements(property, value) { let elements = document.getElementsByTagName('*'); let arr = []; elements = Array.from(elements); elements.forEach(item =&gt; { // 当前元素property对应的值 let itemValue = item.getAttribute(propertype); if (property === &quot;class&quot;) { const reg = new RegExp(`\\b${value}\\b`); if (reg.test(itemValue)) { arr.push(item); } } if(itemValue === value) { arr.push(item); } }) return arr;} 英文字母汉字组成的字符串，用正则给英文单词前后加空格123456let str = &quot;中国hello你好&quot;let reg = /\\b[a-z]+\\b/ig;str = str.replace(reg, value =&gt; { return ` ${value} `;}).trim(); // 去除首尾空格 js 实现斐波那契数列的几种方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1.递归function fibonacci(n) { if (n === 1 || n === 2) { return 1; } return fibonacci(n - 1) + fibonacci(n - 2);}// 2.尾递归(每次调用都在收集结果，避免了线性递归不收集结果只依次展开消耗内存的坏处)function fibonacci(n, res1 = 1, res2 = 1) { if (n &lt;= 2) return res2; return fibonacci(n - 1, res2, res1 + res2);}// 循环function fibonacci(n) { let num1 = 1; let num2 = 2; let sum = 1; for(let i = 3; i &lt; n; i++) { sum = num1 + num2; num1 = num2; num2 = sum; } return sum;}// 数组function fibonacci(n) { const arr = [0,1,1]; if (n &lt; 0) { throw new Error('输入的数字不能小于0') } if (n &gt;= 3) { for(let i = 3; i &lt;= n; i++) { arr[i] = arr[i - 1] + arr[i - 2]; } } return arr[n];} 并发加载123456789101112131415161718192021222324252627282930313233343536373839404142function limitLoad(urls, handler, limit) { const sequence = [].concat(urls); let promises = []; promises = sequence.splice(0, limit).map((url, index) =&gt; { return handler(url).then(() =&gt; { return index }) }) let p = Promise.race(promises); for(let i = 0; i &lt; sequence.length; i++) { p = p.then((res) =&gt; { promises[res] = handler(sequence[i]).then(() =&gt; { return res; }) console.log(promises) return Promise.race(promises) }) }}function loadImg(url) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; {// console.log(url.info + '---OK!!!') resolve() },url.time) })}let urls = [{info: 1,time: 2000},{info: 2,time: 1000},{info: 3,time: 3000},{info: 4,time: 4000},{info: 5,time: 5000},]limitLoad(urls, loadImg, 3) 前端内存处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781. 内存的生命周期 内存分配：声明变量、函数对象的时候，js会自动分配内存 内存使用 内存回收2. js中的垃圾回收机制 引用计数：缺点循环引用无法清除 标记清除3. 常见内存泄漏 全局变量（记得手动回收） 未被清除的定时器 闭包 dom的引用4. 怎么避免内存泄漏 减少不必要的全局变量 使用完数据，及时解除引用实现sizeOf，传入object，计算其所占字节大小number: 8 字节string: 2 字节boolean; 4 字节const seen = new WeakSet();function sizeOfObject(obj) { if (obj === null) { return 0; } let bytes = 0; const keys = Object.keys(obj); for(let i = 0; i &lt; keys.length; i++) { const key = keys[i]; bytes += calculator(key); if (typeof obj[key] === 'object' &amp;&amp; obj[key] !== null) { if (seen.has(obj[key])) { continue; } seen.add(obj[key]) } bytes += calculator(obj[key]) }}function calculator(obj) { const objType = typeof obj; switch(objType) { case 'string': { return obj.length * 2 } case 'boolean': { return 4 } case 'number': { return 8 } case 'object': { if (Array.isArray(obj)) { return obj.map(calculator).reduce((accu, curr) =&gt; { return accu + curr }, 0) } else { return sizeOfObject(obj) } } default: { return 0 } }} 数据结构就是在计算机中存储和组织数据的方式。 算法（Algorithm）解决问题的逻辑或步骤 栈(封装)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function Stack() { this.items = []; // 1. 将元素压入栈 Stack.prototype.push = function (element) { this.items.push(element); } // 2.从栈中取出元素 Stack.prototype.pop = function() { return this.items.pop(); } // 3.查看一下栈顶元素 Stack.prototype.peek = function() { return this.items[this.items.length - 1] } // 4.判断栈是否为空 Stack.prototype.isEmpty = function() { return !this.items.length } // 5.获取栈中元素个数 Stack.prototype.size = function () { return this.item.length; } // 6. toString方法 Stack.prototype.toString = function() { let res = &quot;&quot;; for(let i = 0;i &lt; this.items.length;i++) { res += `${this.items[i]} `; } return res; }}const stack = new Stack();// 实例：将十进制转换成二进制function dec2bin(decimalNumber) { let stack = new Stack(); let binary = ''; while(decimalNumber &gt; 0) { stack.push(decimalNumber % 2); decimalNumber = Math.floor(decimalNumber / 2); } while(!stack.isEmpty()) { binary += stack.pop(); } return binary;} 平衡括号问题12345678910111213141516171819202122232425262728293031function check(str) { const stack = new Stack() const open = &quot;{[(&quot; const close = &quot;}])&quot; let index = 0 let balanced = true while(index &lt; str.length &amp;&amp; balanced) { if (open.includes(str[index])) { stack.push(str[index]) }else { const top = stack.pop() if (open.indexOf(top) === close.indexOf(str[index])) { balanced = true } else { balanced = false } } index++ } if (balanced &amp;&amp; stack.isEmpty()) { return true } return false}check(&quot;{([][])}&quot;)check(&quot;{[(])}&quot;) 翻转链表12345678910function reverseList(head) { if (head === null || head.next === null) return head; let result = reverseList(head.next) head.next.nexd = head head.next = null return result;} 二分查找1234567891011121314151617function binarySearch(elements,value,_start,_end) { let end = _end || elements.length - 1; let start = _start || 0; let povitIndex = Math.floor((start + end) / 2); if (elements[povitIndex] === value) { return povitIndex; } if (value &lt; elements[povitIndex]) { return binarySearch(elements, value, 0, povitIndex - 1); } else { return binarySearch(elements, value, povitIndex + 1, end); } return false;} 快速排序123456789101112131415161718192021222324function quickSort(elements) { if(elements.length &lt;= 1) { return elements } let pivotIndex = Math.floor(elements.length / 2) let [pivot] = elements.splice(pivotIndex,1) let left = []; let right = []; for(let i = 0; i &lt; elements.length; i++) { if (elements[i] &lt; pivot) { left.push(elements[i]) } else { right.push(elements[i]) } } return quickSort(left).concat([pivot], quickSort(right))}let elements = [2,4,3,7,5]console.log(quickSort(elements)) 冒泡排序123456789101112131415161718192021function bubbleSort(elements) { let elementLength = elements.length; for(let i = 0; i &lt; elementLength - 1; i++ ) { for(let j = 0; j &lt; elementLength - i - 1; j++) { if(elements[j] &gt; elements[j + 1]) { let temp = elements[j]; elements[j] = elements[j + 1] elements[j + 1] = temp } } } console.log(elements)}let elements = [2,4,3,7,5]bubbleSort(elements)// console.log(elements) 二叉搜索树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154//满二叉树：每层节点数都达到最大值，第n层节点数为2^(n - 1),总节点数为2^n -1(2的n次方减一)//完全二叉树：除最后一层外，其他各层节点数都达到最大个数，最后一层所有节点集中在最左边class Node { constructor(value) { this.value = value this.left = null this.right = null }}class BinarySearchTree { constructor() { this.root = null } // 插入前比较 insertNode(node, newNode) { // 右侧插入 if (newNode.value &gt; node.value) { if (node.right === null) { node.right = newNode } else { this.insertNode(node.right, newNode) } } else if (newNode.value &lt; node.value) { // 左侧插入 if (node.left === null) { node.left = newNode } else { this.insertNode(node.left, newNode) } } } // 插入 insert(value) { let newNode = new Node(value); if (this.root === null) { this.root = newNode } else { this.insertNode(this.root, newNode) } } preOrderTraversalNode(node,callback) { if (node === null) return callback(node.value) this.preOrderTraversalNode(node.left, callback) this.preOrderTraversalNode(node.right, callback) } // 先序遍历 preOrderTraversal(callback) { this.preOrderTraversalNode(this.root, callback) } inOrderTraversalNode(node, callback) { if (node === null) return; this.inOrderTraversalNode(node.left, callback) callback(node.value) this.inOrderTraversalNode(node.right, callback) } // 中序遍历 inOrderTraversal(callback) { this.inOrderTraversalNode(this.root, callback) } postOrderTraversalNode(node, callback) { if (node === null) return; this.postOrderTraversalNode(node.left, callback) this.postOrderTraversalNode(node.right, callback) callback(node.value) } // 中序遍历 postOrderTraversal(callback) { this.postOrderTraversalNode(this.root, callback) } //最大值 max() { let node = this.root; while(node.right !== null) { node = node.right } return node.value } // 最小值 min() { let node = this.root while(node.left !== null) { node = node.left } return node.value } // 寻找指定值是否存在 search(val){ let node = this.root while(node !== null) { if(val &lt; node.value) { node = node.left } else if(val &gt; node.value) { node = node.right } else { return true } } }}var bst = new BinarySearchTree()bst.insert(3)bst.insert(2)bst.insert(5)// bst.preOrderTraversal((nodeValue) =&gt; {// console.log(nodeValue)// })// bst.inOrderTraversal((nodeValue) =&gt;{// console.log(nodeValue)// })// bst.postOrderTraversal((nodeValue) =&gt;{// console.log(nodeValue)// })// console.log(bst.max())console.log(bst.search(5))console.log(bst) 翻转链表12345678910111213141516171819202122232425262728293031323334// 递归var reverseList = function (head) { if (head === null || head.next === null) return head; let res = reverseList(head.next) head.next.next = head head.next = null return res}// 循环var reverseList = function(head) { let pre = null let cur = head; if(cur === null || cur.next === null) { return cur } while(cur) { const t = cur.next cur.next = pre pre = cur cur = t // cur.next = null // cur.next.next = cur // cur = cur.nexxt } return pre} 算法 1: Two Sum1234567891011121314151617181920example:given nums = [2, 7, 11, 15], target = 9because num[0] + num[1] = 2 + 7 = 9,return [0, 1]答：function twoSum(nums, target) { const map = new Map(); for(let i = 0; i &lt; nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) { return [map.get(complement), i] } else { map.set(nums[i], i) } }} 装箱：基本类型到引用类型的一个转换拆箱：将引用类型到基本类型的转换（toPrimitive） 编码和解码：escape(str) unescape(str)encodeURI() decodeURI()encodeURIComponent() decodeURIComponent()btoa() atob() 回流：相当与刷新页面重绘： 不刷新，动态更新内容重绘不一定引起回流，回流一定引起重绘","link":"/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%89%8B%E5%86%99%E9%83%A8%E5%88%86/"},{"title":"面试题——封装函数驼峰命名","text":"封装函数使字符串以驼峰式命名 已知字符串 foo = ‘get-element-by-id’,写一个函数将其转换为驼峰式命名“getElementById” 1234567891011121314151617181920212223//详细过程分析：var foo = 'get-element-by-id';//根据某个字符进行分割var arr = foo.split('-');//分割成四个片段保存在数组内console.log(arr) // (4) [&quot;get&quot;, &quot;element&quot;, &quot;by&quot;, &quot;id&quot;]//将下标为1的数组元素第一个字符元素转为大写console.log(arr[1].charAt(0).toUpperCase()) //E//截取后面字符元素console.log(arr[1].substr(1, arr[1].length - 1)) //lement//遍历for(var i = 1; i &lt; arr.length; i++) { arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1)}console.log(arr) //(4) [&quot;get&quot;, &quot;Element&quot;, &quot;By&quot;, &quot;Id&quot;]//根据某一个字符将数组转换为字符串console.log(arr.join('')); 1234567891011//封装function toString(foo) { var arr = foo.split('-'); for(var i = 1; i &lt; arr.length; i++) { arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1) } return arr.join('');}console.log(toString('get-element-by-id')) 把 the-first-name 变成 theFirstName 123456var reg = /-(\\w)/gvar str = &quot;the-first-name&quot;console.log(str.replace(reg, function($, $1){ return $1.toUpperCase()})) 把 aabb 换成 bbaa 123456var reg = /(\\w)\\1(\\w)\\2/g;var str = &quot;aabb&quot;;// console.log(str.replace(reg,&quot;$2$2$1$1&quot;));//&quot;bbaa&quot;console.log(str.replace(reg,function($,$1,$2){ return $2+$2+$1+$1;})) 正则简单的去重 123456789101112131415var str = &quot;aaaabbbbbccccc&quot;;var reg = /(\\w)\\1*/g;console.log.replace(reg,&quot;$1&quot;));//abc ~~~ 把&quot;1000000000&quot;变成&quot;100.000.000&quot;这种写法，把后面往前面查，三位加个点 ~~~ var str = &quot;100000000&quot;; var reg = /(?=(\\B)(\\d{3})+$)/g; console.log(str.replace(reg,&quot;.&quot;))//&quot;100.000.000&quot; || string.replace(/\\B(?=(\\d{3})+(?!\\d))/g, &quot;.&quot;) //先行断言?=,后行断言(?!\\d) || (25435345.22).toLocaleString(str('en-US')","link":"/2019/06/22/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D/"},{"title":"面试题分享——作用域","text":"作用域 123456789101112131415161718192021222324252627var num1 = 55;var num2 = 66;function f1 (num, num1) { //形参num, num1相当于在函数内进行了一下声明： //var num //var num1 num = 100; num1 = 100; num2 = 100; //相当于在全局内进行了声明 console.log(num); //100 console.log(num1); //100 console.log(num2); //100}f1(num1, num2);//num1 = 55; num2 = 66;console.log(num1); //55console.log(num2); //100console.log(num); //报错输出：10010010055100Uncaught ReferenceError: num is not defined 创建 10 个标签，点击的时候弹出来对面的下标序号1234567891011for (var i = 0; i &lt; 10; i++) { (function(i){ var a = document.createElement('a') a.innerHTML = i + '&lt;br&gt;' a.addEventListener('click', function(e) { e.preventDefault() alert(i) }) document.body.appendChild(a) })(i)} 闭包实际应用中主要用于封装变量，收敛权限123456789101112131415161718function isFirstLoad() { var _list = [] return function (val) { if (_list.indexOf &gt;= 0) { return false } else { _list.push(val) return true } }}//执行var firstLoad = isFirstLoad()firstLoad(10) //truefirstLoad(10) //falsefirstLoad(20) //truefirstLoad(20) //false","link":"/2019/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"面试题目总结","text":"[toc] 从浏览器地址栏输入 url 到显示页面的步骤 1. 浏览器查看缓存(浏览器对应的都会有cache文件)。 若请求有缓存且未过期，则取缓存资源提供给客户端，否则发起请求与服务器进行验证。 检验是否过期通常有两个HTTP头：Expires、Cache-control 2.浏览器需要获取域名对应的ip地址，过程如下： 1.本地host文件查找 - 浏览器解析URL获取协议、域名、端口、path路径，然后查看本地硬盘中hosts文件，看是否存在与这个域名对应的规则，如果有就直接使用hosts文件里面的ip地址。 2.路由器缓存 3.ISP DNS(Domain Name System域名系统)(情报局)缓存（互联网提供服务商）-本地DNS服务器以递归方式进行查询缓存记录， 若没有就向跟DNS服务器查询。根DNS服务器查询到结果后会把域名和IP地址告诉本地DNS服务器， 本地DNS服务器把对应关系草存在缓存中（一边下次用户查询，加快网络访问），然后再发给浏览器客户端的解析服务器。 3.客户端发送HTTP请求。 4.TCP传输报文（三次握手四次挥手） 5.向客户端返回资源 6.解析HTML文档，构建DOM树，CSSOM树，下载资源，执行js脚本等。 DNS 负载均衡1当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个域名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 强缓存和协商缓存123强缓存：（expires、Cache-Control）在过期时间内，浏览器再次加载资源时，不会向服务器发起请求，直接从缓存中读取资源协商缓存：向服务器发送请求，服务器会根据请求头（request header）的一些参数（Etag、last-modified）来判断是否命中协商缓存，首先根据Etag的值判断请求的文件有没有被修改，如果Etag一致则没有被修改，命中协商缓存返回304，如果不一致则返回新的资源并带上新的Etag返回200状态码。如果没有Etag值，则对比If-Modified-Since和请求文件的最后修改时间，一致则命中协商缓存返回304，不一致则返回新的last-modified和200状态码 http 协议的特点123456789101112131415161718192021222324251.支持客户/服务器模式2.简单快速：客户向服务器发送请求时，只需传送请求方法和路径。3.灵活：http允许传输任意类型的数据对象（Content-Type内容编码类型）application/x-www-form-urlencoded 常见post提交数据格式（key-value格式）application/json4.无连接：限制每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。（原因是早期服务器需要同时面对全世界数十万、上百万的客户端的网页访问，但是每次客户端与服务端传输的数据关联性很低，就会导致大部分通过会很空闲，无端占用资源）（解决无连接）Keep-Alive：使客户端到服务端之间的Http连接保持，不会断开，当再次对服务器发送请求时，keep-Alive功能避免了重新建立连接5.无状态：Http是一个无状态协议，就是每个请求都是独立的，数据传输完毕不会记录任何信息。缺点就是如果后续处理需要前面的信息，就必须重传，就会导致每次连接传送的数据量增加，如果服务器不需要前面信息的时候应答就会很快。（解决无状态）怎样保持http连接状态呢Cookie（每次http请求的时候，客户端都需要发送响应的cookie信息到服务端，服务端根据cookie判断来自哪个客户端）服务端生成cookie，客户端保存Session服务端生成一个sessionid，在客户端下次请求的时候在cookie里面记录这个sessionid，然后发送给服务端，服务端再根据cookie中的sessionid来识别客户端返回资源数据。禁用cookie怎么办？url重写，每次http请求的时候，在url后面拼接sid=**参数withCredentials:指定在涉及到跨域请求时，是否携带cookie信息，默认为falseAccess-Control-Allow-Credentials: true cookie 和 session 的区别12341.存取方式不同： cookie只能保存ASCII字符串，session能够存储任意类型的数据2.隐私策略不同3.cookie是存在客户端，session是存在服务器的4.浏览器的支持不同，浏览器可以禁用cookie 权限身份验证12345678910111213一般都是通过sessionid来进行用户身份验证，sessionid一般会存放在redis中。1.用户向服务端发送用户名和密码进行登陆2.服务器验证通过后，服务器为用户创建一个session，并将session信息存储起来3.服务器向用户返回一个sessionid，写入用户的cookie4.当用户保持登陆状态时，每次后续请求都会一起发送给后端5.服务器将存储在cookie中的sessionid和存储在内存或者数据库中的sessin信息进行一个比较，验证用户身份，然后返回响应信息注意：1.依赖session的关键业务一定要确保客户端开启了cookie2.注意session的过期时间一般在http header的Authorization字段中添加token 禁用 cookie 之后 session 还能用吗？12url重写，例如 https://javascript.cn/?session_id=xxx缺点是安全性降低，可以对sessionid进行一次加密后传输 get 和 post 的区别1234561.url可见性：get参数url可见，post参数url不可见2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数3.缓存性：get请求可以缓存，post请求不可以缓存4.get请求网页回退时，不产生影响，post请求网页回退会重新发请求5.传输数据：get一般传输数据大小不超过4k，post可以传输大量数据6.post较get安全性较高，get是不安全的因为url可见，可能会泄漏私密信息 http 常见的请求头字段12345678910111213141516Accept: 浏览器可接受的数据类型Accept-Charset: 浏览器可接受的字符集Accept-Encoding：浏览器能够进行解码的数据编码方式Accept-Language： 浏览器所希望的语言种类Connection：是否需要持久连接，值“Keep-Alive”，HTTP1.1默认进行持久连接Cookie：cookie信息content-typeIf-Modified-Since：内容被修改才会返回User-Agent：浏览器类型响应头：content-Length: 表示内容长度content-type：文档类型Date：当前时间Expires：指定缓存过期时间Last-Modified：文档过期时间 http 和 https 的区别12345678910http是超文本传输协议，信息是明文传输，https是更加安全的ssl加密传输协议http默认是80端口，https默认是443端口https需要申请CA证书https是http + ssl/tls（数字证书）进行组合的更加安全的传输协议https工作原理（非对称加密）1.服务端向客户端传递证书作为公钥2.客户端对证书进行解析，判断证书的办法机构和过期时间等，如果都没有问题，生成一个随机值作为私钥，然后使用证书进行加密发送给服务端3.服务端解密得到客户端私钥4.之后双方利用私钥进行加密解密，完成信息的通信 xss（跨域脚本攻击）csrf（跨站请求伪造）123csrf: 需要用户先登陆网站A，获取cookie，利用的是网站A本身的漏洞，去请求网站A的api，---进行token验证，referer验证，只接收本站的请求xss：向网站A注入js代码，然后执行js代码，篡改网站A的内容，破坏页面正常结构，插入恶意广告。---编码转换 http1.0、http1.1 和 http2.0 的区别123http/1.0 每个请求都要建立一个连接http/1.1 多了长连接keep-alive，若干个请求需要排队串行化单线程处理，会发生网络请求阻塞问题。http/2.0 同一个连接可以有多个请求，各个请求直接互不影响（进行了头部压缩和多路复用的优化） 设计模式123456单例模式 （class组件中new store创建store实例）工厂模式 （mobx store中creatLayoutStore）观察者模式发布订阅模式装饰器模式 （移动、pc配置同步@sync） TCP 与 UDP 区别123456* TCP是面向连接的协议，发送数据前先要建立连接，TCP提供可靠的服务，通过TCP建立连接传输的数据不会丢失，没有重复，并且按照顺序到达。* UDP是无连接的协议，发送数据前不需要建立连接，是不可靠的* TCP只支持点对点通信，而UDP支持一对一，多对多* TCP是面向字节流的，UDP是面向报文的* TCP通信类似打电话，接通后需要确认身份，才可以开始通信* UDP类似广播直接进行通信 TCP/IP 模型1234应用层（应用层就是向用户提供通信服务的活动，提供用户程序接口HTTP、DNS）传输层（传输层为两台主机上的应用程序提供端到端的通信TCP，UDP）网络层（网络层实现数据包的选路和转发）数据链路层（ARP地址解析协议、RARP逆地址解析协议，使用物理地址寻找一台机器） 正向代理和反向代理12正向代理是客户端代理，服务端不知道是哪个客户端发起的请求反向代理是服务端代理，客户端不知道是哪个服务端提供的资源 OSI 模型12345678910应用层表示层会话层传输层网络层数据链路层物理层 三次握手为什么需要三次握手？两次握手第二次结束后，服务端并不能保证客户端已经接收到了第二次的应答信息，如此一来服务器会一直保持通信过程，因为 TCP 通信会占用端口，造成资源浪费。 防止已失效的连接请求报文段突然又传送到服务端，产生错误。如上述情况，如果 client 没有再次向 server 发出确认，server 收不到确认就不会建立连接，可以避免 server 端一直等待浪费资源。 四次挥手 https://blog.csdn.net/rememberyf/article/details/80309148 301 和 302 的区别1234567891011121314151617181920212223301 表示资源被永久移除，浏览器在拿到状态码后跳转到一个新的URL地址，可从相应头的location首部中获取，搜索引擎在抓取新内容的同时也将就地址交换为重定向之后的网址。302 表示地址资源还在，仍可以访问，搜索引擎会抓取新的内容而保存旧的地址，seo 302 优于301.重定向的原因：网站调整（改变网页目录结构）页面被移到一个新地址页面扩展名改变 .php -&gt;.html如果不做重定向会返回404页面，会白白流失用户访问量。1XX 信息性状态码，表示接受的请求正在处理2XX 成功状态码，表示请求被正常处理完毕3XX 重定向状态码，表示需要进行附加操作以完成请求4XX 客户端错误状态码，表示服务器无法处理请求 400 Bad Request请求出现语法错误 401 被请求的页面需要用户名和密码 403 forbidden 请求页面的访问被禁止 404 资源未找到5XX 服务器错误状态码，表示服务器处理请求出错 502 网关错误 503 服务器超负载或者停机维护，无法处理请求 504 网关超时 cookie cookie 可用于传递少量数据，是一个再服务器和客户端之间来回传送文本值的内置机制，服务器可以根据 cookie 追踪用户在不同页面的访问信息。 cookie 特点 1.大小限制，cookie 大小限制在 4KB 以内 2.宽带限制，cookie 数据会在服务器和浏览器之间来回传送，所以访问页面会消耗宽带。 3.安全风险，cookie 会频繁的在网络中传送，不加密的情况下是有安全风险的。 4.操作复杂123456function setCookie(name: string, value: string) { const exp = new Date(); //过期时间设置为一天 exp.setTime(exp.getTime() + 24 * 60 * 60 * 1000); document.cookie = `${name}=${escape(value);expires=${exp.toString()}}`;} localStorage 会话存储 和 sessionStorage 本地存储 1.存储容量大 2.零宽带，仅存储在本地，不会和服务器发生任何交互行为，不存在网络宽带占用问题。 3.编程接口，提供一套丰富的接口，操作数据更加方便。 4.独立的存储空间，不会造成数据的混乱。 主要区别在于数据存储的 时间范围和页面范围 sessionStorage: 数据只存储到窗口或标签关闭时，只在当前窗口的当前标签内可见,5M 左右，不同浏览器不同大小。 localStorage: 数据会一直存在除非手动清除，数据可被同源(协议、域名、端口号一致)的每个窗口或标签共享,5M 左右，不同浏览器不同大小。 监测是否支持 web Storage 1.通过 window.sessionStorage,window.localStorage 判断浏览器是否支持 2.通过 try{}catch{} 执行一下 storage.setItem(‘key’, value);storage.removeItem(‘key’),判断接口方法是否可用。 html5 的几种存储形式 1.本地存储 localStorage,sessionStorage 2.离线缓存 application cache indexedDb,webSQL 性能优化1234567891011121.负载均衡、CDN加速、设置缓存、2.业务逻辑优化3.代码程序优化（组件按需加载、图片懒加载，代码压缩）4.避免重绘回流重绘：页面元素的样式改变不会影响它在文档流中的位置时发生重绘回流：DOM尺寸大小结构发生变化时回流一定会导致重绘如何避免：1.避免频繁操作dom，通过创建document.createDocumentFragment()一次性插入需要操作的dom2.具有复杂动画的Dom元素使用绝对定位，使其脱离文档流3.合并对于Dom中style样式的操作4.避免使用css表达式 calc() fetch 和 axios12345678910fetch取消发送1.创建一个AbortController实例2.该实例具有signal属性3.将signal传递给fetch option4.调用AbortController的abort属性来取消所有使用该信号的fetchaxios取消发送1.const cancelToken = axios.CancelToken2.const source = CancelToken.source()3.axios.get('/xxx',{cancelToken: source.token}) flex 常用属性，grid 布局123456789101112131415flex属性：1.flex-direction属性，决定主轴方向2.flex-wrap属性，控制换行3.flex-flow属性，flex-direction和flex-wrap的简写形式，默认值flex-flow: row nowrap;4.justify-content属性，项目主轴上的对齐方式5.align-item属性，项目在交叉轴上的对齐方式6.align-content属性，多个轴线的时候在元素在交叉轴的对齐方式，只有一根轴线时不起作用flex（子元素的属性）：1.order属性,定义项目的排列顺序，数值越小，排列越靠前，默认为0.2.align-self属性，允许单个项目与其他项目不一样的对齐方式，会覆盖align-items属性.3.flex属性，flex-grow、flex-shrink、flex-basis简写，默认为0 1 auto auto(1 1 auto) none(0 0 auto)4.flex-grow属性，定义项目的放大比例，默认为0，即如果存在剩余空间也不放大，1等分，一个项目为2，其他为1，则前者占据空间是其他的两倍。5.flex-shrink属性，定义项目的缩小比例，默认为1，空间不足则缩小，如果所有项目都为1，则等比例缩小，如果有的项目为0，则空间不足时为0的不缩小，负值无效6.flex-basis属性，项目占据的固定空间 padding-bottom 实现子元素高度等于父元素宽度问题1当margin或者padding取值是百分比的时候，无论是left，right或者top，bottom，都是以父元素的width为参考物，进行提前占位 预编译123456在作用域的创建阶段（预编译阶段），会生成js的变量对象（VO对象）供js引擎去访问。1.创建ao对象2.找形参和变量声明，作为ao对象的属性名，值为undefined3.实参和形参相统一4.找函数声明，如果名字和变量相同则覆盖变量声明5.解释执行 箭头函数中的 this121.箭头函数中的this是在定义函数的时候绑定的（继承自父执行上下文中的this），而不是执行函数时绑定。2.箭头函数没有this，所以不能用作构造函数。 Map 和 Set 两种新的数据结构的区别？1231. Map类似Object是一种键值对集合，区别在于Map的键不仅限于字符串，其他各种类型的值都可以作为Map的键2.Set是类似数组的一种数据结构，不点在于Set中没有重复的值 你对闭包了解多少？解释一下作用域链是如何产生的 解释一下js执行山下文的创建、执行过程 解释一下闭包所产生的变量放在哪里 闭包的定义：闭包就是能够读取其他函数内部变量的函数。 闭包的底层实现原理 js 执行上下文： 1234567891011121314151617181920212223242526272829js运行三部曲1.语法分析2.预编译3.解释执行js代码需要经过浏览器V8引擎进行预编译，里面涉及到变量提升、函数提升。预编译的环境需要个环境，这个环境就是执行上下文。js执行上下文分为三种：1.全局执行上下文：代码开始执行时首先进入的环境2.函数执行上下文：函数调用时，会开始执行函数中的代码3.eval执行上下文：不建议使用执行上下文的周期，分为两个阶段1.创建阶段 创建词法环境 生成变量对象VO，建立作用域链 确认this指向，并绑定this2.执行阶段 进行变量赋值，函数引用以及执行代码预编译发生在函数执行前，预编译四部曲：1.创建AO对象2.找形参和变量声明，将变量和形参作为AO的属性名，值为undefined3.将形参和实参相统一4.在函数体中找到函数声明，值赋予函数体（函数名相同，后者覆盖前者）5.最后程序输出变量值的时候，就是从AO对象中拿（此时就产生了外部作用域的引用，js查找变量的规则就是如果在函数执行上下文中找不到变量，就在调用上下文中寻找他，如果还没有就一直往上一级，直到全局执行上下文，如果还没有，就是undefined，js形成闭包） 原型12345student.__proto__ === Student.prototype1.每个函数function都由一个prototype，即显式原型。是在定义函数的时候自动添加的，默认是一个空的Object对象2.每个引用类型都有一个__proto__,即隐式原型。是创建对象时自动添加的，默认值为构造函数的prototype属性值实例对象的隐式原型 等于 对应构造函数或类的显式原型能直接操作显式原型，不能直接操作隐式原型 js 的 new 操作符都做了些什么？1234567891011121314151617181920211. 创建一个空的js对象{}2. 将空对象的隐式原型__proto__指向构造函数的原型3. 将空对象作为构造函数的上下文（改变this指向）4. 对构造函数返回值做判断实现：function create(fn, ...args) { let obj = Object.create({}); // obj.__proto__ = fn.prototype; Object.setPrototypeOf(obj, fn.prototype); let result = fn.apply(obj, args); return result instanceof Object ? result : obj;}补充：在new的时候，会对构造函数的返回值做一些判断1. 如果返回值是基础类型数据，则忽略返回值2. 如果返回值是引用数据类型，则使用return的返回，也就是new操作符无效 calc, support, media 各自的含义及用法？1234567891011121314151617@support 主要用于检测浏览器是否支持css的某个属性，相当于条件语句，支持的话写一套样式，不支持写另外一套样式，例如 @supports (display: grid) { div { display: grid; } } @supports not (display: grid) { div { float: right; } }calc(): 用于动态计算值，支持 + - * / 运算。@media查询：可以针对不同的媒体类型定义不同的样式。 什么是会话 cookie,什么是持久 cookie?1cookie是服务器返回的，指定了expire（有效期）的是持久cookie,没有指定的是会话cookie img 标签 title 和 alt 属性1234alt: 图片加载失败时，显示在网页上的替代文字title: 鼠标放在图片上的提示文字alt是必须属性，可以为空；title为非必须 es6 新特性12345671.let和const2.模版字符串3.箭头函数4.函数可以设置默认参数值5.扩展运算符6.对象和数组的解构7.class 图片懒加载原理12345671. 浏览器是否发起请求是根据&lt;img /&gt;标签的src属性2. 所以懒加载的关键是：在图片没有进入可视区域时，先不给&lt;img /&gt;的src属性赋值，等到图片进入可是区域再给src赋值。当图片底边距离页面的偏移（图片高度+图片距离顶部偏移高度）小于等于浏览器底边距离页面顶部高度（浏览器一屏高度 + 滚动区域） H5 新增了哪些标签？1article、aside、audio、video、footer、header、nav、section SVG 和 Canvas 的区别？12341.svg:表示以XML格式定义图像的可伸缩矢量图形。2.canvas：通过js来绘制2D图形svg通过标签fill属性可以调整颜色 AMD 和 CMD 的区别1234567共同点：1.两者都是框架在推广过程中对模块定义的规范产出2.都是异步加载模块不同点：1.AMD是RequireJs在推广过程中对模块定义的规范产出，CMD是SeaJs在推广过程中对模块定义的规范化产出2.AMD推崇依赖前置，CMD推崇依赖就近3.AMD的应用体验好，因为模块提前执行了，CMD性能好，因为只有用户需要的时候才执行 如何实现 js 倒计时的纠偏？123451. 第一种通过前端定时向服务端发送请求获取最新的时间差，以此来校准倒计时时间。2. 通过前端根据偏差时间来自动调整下次间隔的时间来实现，首先以setTimeout递归的方式来实现倒计时，通过一个变量记录倒计时的秒数，根据秒数和间隔时间计算出此时无偏差时应该显示的时间，然后拿当前真实时间与这个时间相减，就可以得到时间的偏差大小，因此在设置下一个定时器的时候，间隔时间减去这个偏差大小就可以纠正时间误差。 js 的执行机制12345678910111213141516js是单线程的，处理js任务只能一个一个顺序执行，js中把任务分为了同步任务和异步任务，同步任务进入主线程先执行，异步任务进入Event Table并注册函数，指定事情完成后，Event Table就会将函数移入到事件队列Event Queque中，等待主线程任务执行完毕，就会从事件队列中取出对应事件进入主线程执行。macro-task（宏任务）：包括整体代码script、setTimeout、setIntervalmicro-task（微任务）：Promise.then、process.nextTick微任务先于宏任务先执行（除了script）执行过程不同任务进入不同的event quuejs先执行整体的同步任务代码，遇到微任务就会将其放入到微任务事件队列，遇到宏任务放到宏任务事件队列中。然后整体的同步任务代码执行完之后，就会先执行微任务队列中的任务，等待微任务队列中的所有任务执行完毕之后，再去从宏任务队列中找到第一个任务进行执行，执行过程中，如果遇到微任务就会放到微任务队列中，等到该宏任务执行完毕之后，就会查看微任务队列中有没有微任务，如果有就先执行微任务队列中的任务，否则执行第二个宏任务，以此类推。 React请说一下你对 React 的理解？1234567891011121314151. react是一个网页的UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。2. react的核心设计思路有三个：声明式 命令式：命令程序一步一步的执行操作 声明式：只需告诉程序我们想要的结果，其他的交给程序去做。组件化 将视图拆分和模块复用，做到高内聚低耦合通用性 一次学习，随处编写。RN，react360等，跨平台底层靠虚拟DOM实现3. 缺点1.没有官方系统解决方案，在开发大型应用时需要向社区寻找并整合解决方案。2.过于灵活，需要注意代码规范 React.lazy 懒加载12345678910// React.lazy方法可以异步加载组件const Foo = React.lazy(() =&gt; import('../components/Foo')// React.lazy不能单独使用，需要配合React.suspense,用来包裹异步组件，添加loading效果等。&lt;React.Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt; &lt;Foo /&gt;&lt;/React.Suspense&gt;React.lazy原理React.lazy使用import来懒加载组件，import在webpack中最终会调用requireEnsure方法，动态插入script来请求js文件，类似jsonp的形式。 类组件和函数组件之间的区别？1234567891011121314相同点：接受属性返回React元素不同点： 1.编程思想不同：类组件需要创建实例，基于面向对象的方式编程。函数式组件接受输入返回输出，属于函数式编程的思想。 2.内存占用：类组件需要创建实例，会占用内存，函数组件不需要创建实例，可以节约内存 3.捕获特性：函数组件具有捕获特性 4.可测试性：函数组件更方便编写单元测试 5.状态：类组件有实例可以维护自己的状态，函数组件可以使用useState维护自己的状态 6.声明周期：类组件有生命周期，可以在生命周期内写逻辑，函数组件可以在useEffect中 7.逻辑复用：函数组件通过继承实现逻辑复用，函数组件可以通过自定义hooks实现逻辑复用 8.性能优化：类组件通过shouldComponentUpdate和PureComponent来跳过更新，函数组件通过React.memo 当调用 setState 的时候，发生了什么事？12将传递给setState的参数对象合并到组件的当前的状态，react遍历dom节点，计算差异，更新UI。https://segmentfault.com/a/1190000018250127 为什么 setState 的参数是一个 callback 而不是一个对象123456因为this.props和this.state的更新可能是异步的，不能依赖它们的值去计算下一个state(更新状态不要直接修改this.state，虽然状态可以改变，但不会触发组件的更新)setState何时同步何时异步？异步：由React控制的事件处理程序以及生命周期函数中调用setState为异步同步：React控制之外的原生js绑定的事件、setTimeout/setInterval等。 setState 什么时候同步什么时候异步？12345678910111213react三个模式：1.legacy模式： 通过ReactDOM.render(&lt;App /&gt;, rootNode)创建的，当前react的使用方式2.blocking模式：通过ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;),实验阶段，作为迁移到concurrent模式的第一个步骤3.concurrent模式，通过ReactDOM.createRoot(rootNode).render(&lt;App /&gt;),实验阶段，未来react的默认开发模式setState 只在合成事件（react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件）和钩子函数（生命周期中）是异步的，在原生事件和setTimeout中都是同步的。不同模式执行结果不同，legacy模式命中batchedUpadates（批处理）时异步，为命中时同步concurrent模式都是异步的setState异步并不是说内部由异步代码实现，其本身执行过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了“异步”可以通过第二个参数的callback回调函数中拿到最新的值，在异步中如果对同一个值进行多次setState，那么setState的批量更新策略会将其覆盖，去最后一次的执行，如果同时setState多个值，会在更新时对其进行合并批量更新。 react 渲染机制12345678首先打开页面会渲染出一颗DOM树，更新数据会生成一颗虚拟DOM树，通过diff算法，比较两颗DOM树的差异，找到更新的地方进行批量改动。diff：计算一棵树形结构到另一颗树形结构的最少操作。1.把树形结构按照层级分解，只比较同级元素2.给列表结构的每个单元添加唯一的 key 属性，方便比较3.diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。（官方也不推荐） React.StrictMode 目前有助于：12345识别不安全的生命周期关于使用过时字符串 ref API 的警告关于使用废弃的 findDOMNode 方法的警告检测意外的副作用检测过时的 context API 虚拟 DOM 优点12345678910111213141516171819202122231. 减少不必要的DOM操作 1.1虚拟dom可以将多次操作合并为一次操作，比如添加100个节点，确是一个一个操作的 1.2虚拟dom借助dom diff可以将多余的操作省略掉，比如添加100个节点，其中10个是新增的2. 跨平台渲染 1.因为虚拟dom本质上是一个js对象react虚拟dom结构:const vNode = { key: null, props:{ children: [ {type: 'span', ....}, ], className: 'red', onClick: () =&gt; {} }, ref: null, type: 'div',}创建虚拟dom：React.createElement diff 策略`策略一： tree diff1.React 对树进行分层比较，两颗虚拟 DOM 树只会对同一层级的 DOM 节点进行比较。如果存在跨层级的操作，只会进行创建和删除 2.如果节点是组件就进行 Component diff 3.如果节点是标签就进行 Element diff 策略二：component diff如果为非同类型组件的话标记组件为 dirty component，替换组件下所有子节点，类型相同更新属性，然后深入组件进行 Tree diff（递归遍历对比） 策略三：element diff如果节点是原生标签，则看标签名标签名不同直接替换，相同更新属性，然后进入标签进行 Tree diff（递归遍历对比）` shouldComponentUpdate(nextProps, nextState)是做什么的，（react 性能优化是哪个周期函数？）12shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新绘制dom,由于渲染dom非常消耗性能，合理的调用shouldComponentUpdate方法可以极大的提高性能。 createElement 和 cloneElement 有什么区别？1234567891011121314React.createElement()构建React元素。接受三个参数，第一个参数为标签名，如div、span等，或者react组件，第二个参数为传入的属性，第三个为组件的子组件。React.createElement( type, [props], [...children])React.cloneElement(),第一个参数传入react元素不是标签名，第二个参数传入属性，新添加的属性会并入原有的属性，第三个参数为子组件React.cloneElement( element, [props], [...children]) 虚拟 DOM 的优缺点？123456789优点：1. 处理了浏览器兼容性问题，避免了用户操作真实DOM2.内容经过xss处理，可以防范xss攻击3.跨平台开发4.更新的时候可以实现差异化更新，减少更新DOM的操作缺点：1.虚拟DOM需要消耗额外的内存2.首次渲染不一定会更快 React 中创建组件的方式1React.createClass()、ES6 class组件 无无状态函数式组件 react 中 key 的作用12345key在react中用于追踪哪些列表中元素被修改、添加或者移除的辅助标识。在开发中，需要保证某个元素的key在同级元素中具有唯一性。diff算法会借助元素的key值来判断元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染 react 优势12341. 速度快：不直接操作dom，采用虚拟dom的概念2.跨浏览器兼容，兼容性好3.一切都是component，代码更加模块化，可维护性高4.单向数据流，采用Flux单向数据层架构 react 事件机制1234567react的事件机制利用了事件委托机制，事件并没有真正的绑定在真实的dom节点上，而是把事件绑定在结构的最外层document，使用统一的事件监听器，所有事件都由这个监听器统一分发。组件挂载和更新时，会将绑定的事件分门别类的放进一个叫EvnentPluginHub的事件池中。事件触发时，根据事件产生的Event对象找到触发事件的组件，再通过组件标识和事件类型从事件池中找到对应的事件监听回调，然后执行相关的监听函数。 异步回调中怎么使用 syntheticEvent？123在合成事件机制里，一旦事件监听回调执行，合成事件对象就会被销毁，异步回调执行的时候合成事件对象早就被销毁了。解决方法：执行event.persist(),通知react不需要回收。 React 生命周期123456789101112131415161718192021React 16推出Fiber之后，如果要开启async rendering，那么在render函数之前的所有函数都有可能被执行多次废弃：componentWillMountcomponentWillReceiveProps(nextProps)componentWillUpdate(nextProps, nextState)代替：静态函数：static getDerivedStateFromProps(nextProps, prevState)静态函数：static getDerivedStateFromError(error) // 渲染备用UI此生命周期return的值会自动调用setState，将值和state合并运行事件节点：子组件被渲染发生错误后且在页面更新前getSnapshotBeforeUpdate(prevProps, prevState) 此生命周期的返回值将作为参数传递给componentDidUpdate()componentDidCatch(error, info) // 打印错误信息错误边界无法捕获的错误：1.组件自身的错误2.异步错误，setTimeout3.事件中的错误，比如click事件中发生错误 Redux12345678910111. 构建action，通过创建一个函数，返回一个对象，需要携带type属性2. 构建reducer，用来响应action，然后通过return把数据传回store3. 利用createStore来构建store，把reducer作为参数传入4. 利用store.subscribe()注册监听5. 利用store.dispatch()发送action6. 利用store.getState()拿到值 Typescriptts 中 type 和 interface 的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445相同点：1.都可以描述一个对象和函数interface User { name: string;}interface SetUser { (name: string): void;}type User = { name: string;}type SetUser = (name: string): void;2.扩展与交叉类型interface可以extends进行类型扩展，type可以通过交叉类型实现interface的extend行为。interface可以exteds type，type也可以与interface类型交叉（&amp;符号）不同点：1.type可以声明基本类型别名，联合类型，元祖等类型基本类型别名type Name = string;联合类型interface Dog { wang();}interface Cat { miao();}type Pet = Dog | Cat;元祖类型type PetList = [Dog, Cat];2. interface能够声明合并interface User { name: string;}interface User { age: number;}=/**interface User { name: string; age: number;}*/ ts 中如何实现一个函数的重载12js是动态类型语言，所以是没有overload的，但js可以在运行的时候判断类型ts的重载只是重载函数声明，函数的实现还是只有一个 mobx1234567Observable //被观察者Observer // 观察者Reaction //响应mobx底层对数据的观察是使用Object.defineProperty(mobx4)或Proxy(mobx5)observer这个装饰器，对react组件的render方法进行跟踪，将render方法加入到各个observable的依赖中，当observale发生变化的时候，就会调用forceUpdate更新组件（mobx4将Array用类数组对象来模拟的，通过包装类封装为一个对象） webpack 常用 loader12345678910111213样式：style-loader、css-loader、less-loader、sass-loader文件：file-loader、url-loader编译：babel-loader、ts-loader校验：eslint-loader常用的pluginhtml-webpack-pluginwebpack-bundle-analyzer 打包分析HotModuleReplacementPlugin 热更新自己写webpack插件：主要就是通过访问compliler和compilation拦截webpack的执行 垃圾回收机制12345678910111213垃圾收集器会定期（周期性）的找出那些不再继续使用的变量，释放其内存，因为开销比较大，所以会按照固定的时间间隔周期性的执行最常用的两种方法：标记清除（常用）和引用计数标记清除：变量进入作用域，进行标记，离开作用域进行清除回收引用计数：就是跟踪记录每个值被引用的次数，引用一次加1，删除减1，引用计数为0时，进行回收，（循环引用可能会导致内存泄漏）常见的内存泄漏原因：全局变量过多引起内存泄漏闭包dom事件未清除循环引用 谈谈你对 webpack 的理解？1234567webpack是一个打包模块化js的工具，在webpack里一切文件皆模块，通过loader转换，通过plugin注入钩子，最后输出由多个模块组合成的文件，webpack专注构建模块化。WebPack可以看做是模块的打包机器：它做的事情是，分析你的项目结构，找到js模块及其它的一些浏览器不能直接运行的拓展语言，例如：Scss，TS等，并将其打包为合适的格式以供浏览器使用。 说说 webpack 与 grunt、gulp 的不同？12345678910111213141516171819三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据，整条链式操作构成了一个任务，多个任务就构成了web的构建流程。webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。所以，从构建来说，gulp和grunt需要开发者将整个前端构建过程拆分成多个`Task`，并合理控制所有`Task`的调用关系；webpack需要开发者找到入口，并需要清楚对于不同的资源应该使什么Loader做何种解析和加工对于知识背景来说，gulp更像后端开发者的思路，需要对于整个流程了如指掌webpack更倾向于前端开发者的思路 什么是 bundle,什么是 chunk，什么是 module?123bundle：是由webpack打包出来的文件chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块 什么是 Loader?什么是 Plugin?123451.Loaders是用来告诉webpack如何转化处理某一类型的文件，并且引入到打包出的文中2）Plugin是用来自定义webpack打包过程的方式，一个插件是含有apply方法的一个，通过这个方法可以参与到整个webpack打包的各个流程(生命周期)。 有哪些常见的 Loader？他们是解决什么问题的？12345678910file-loader：把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件url-loader：和file-loader类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中去source-map-loader：加载额外的Source Map文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把ES6转换成ES5css-loader：加载CSS，支持模块化、压缩、文件导入等特性style-loader：把CSS代码注入到JavaScript中，通过DOM操作去加载CSS。eslint-loader：通过ESLint检查JavaScript代码 有哪些常见的 Plugin？他们是解决什么问题的？123define-plugin：定义环境变量commons-chunk-plugin：提取公共代码uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 Loader 和 Plugin 的不同？123456789101112不同的作用Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。不同的用法Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。 webpack 的构建流程是什么?1234567891011121314151617181920212223Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；开始编译：用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；确定入口：根据配置中的 entry 找出所有的入口文件；编译模块：从入口文件出发，调用所有配置的 Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；完成模块编译：在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。在以上过程中，Webpack会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 描述一下编写 loader 或 plugin 的思路？1234Loader像一个&quot;翻译官&quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。编写Loader时要遵循单一原则，每个Loader只做一种&quot;转义&quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 如何利用 webpack 来优化前端性能？123456789101112131415用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件，利用cssnano（css-loader?minimize）来压缩css利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现提取公共代码。 如何提高 webpack 的构建速度？1234567多入口情况下，使用CommonsChunkPlugin来提取公共代码通过externals配置来提取常用库利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。使用Happypack 实现多线程加速编译使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用Tree-shaking和Scope Hoisting来剔除多余代码 怎么配置单页应用？怎么配置多页应用？12单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述多页应用的话，可以使用webpack的AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。多页应用中要注意的是：每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表,随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置 vue 项目中实现按需加载？123456为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。通过import(*)语句来控制加载时机，webpack内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个chunk。当代码执行到import(*)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill 自主搭建、灵活定制、高效复用 1.单向链表的创建、插入和反转 2.二叉搜索树的查找、插入、删除思想，写伪代码3.tcp 链接和释放过程，http，https，tcp 和 udp 比较 4.链表顺序翻转","link":"/2021/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"title":"docker常用命令","text":"镜像操作 获取镜像 docker pull12# docker pull 从镜像仓库中拉取或者更新指定镜像docker pull ubuntu:18.04 列出已经下载的镜像 docker images123docker images# 列出某一个镜像docker images ubuntu 删除镜像 docker rmi1234567891011121314151617docker rmi 501# ordocker rmi centos# docker prune命令# 删除所有未被tag标记或者未被容器使用的镜像docker image prune# 删除所有未被容器使用的镜像docker image prune -a# 删除所有停止运行的容器docker container prune# 删除所有未被挂载的卷docker volume prune# 删除所有网络docker network prune# 删除docker所有资源docker system prune 上传镜像 docker push12# docker push:将本地的镜像上传到镜像仓库，先登录镜像仓库docker push mynode:v1 容器操作列出容器 docker ps12# -a :显示所有的容器，包括未运行的docker ps 停止容器 docker stop12# 停止运行中的容器myrunoobdocker stop myrunoob 启动容器 docker start12# 启动已被停止的容器myrunoobdocker start myrunoob 重启容器 docker restart12# 重启容器myrunoobdocker restart myrunoob 删除容器 docker rm12# 强制删除容器 db01、db02docker rm -f db01 db02 查看容器信息 docker inspect123# 获取容器/镜像的元数据# 获取镜像mysql:5.6的元信息docker inspect mysql:5.6 查看容器日志 docker logs12# 跟踪查看容器mynginx的日志输出docker logs -f mynginx 进入容器控制台 docker exec1234567// 在运行的容器中执行命令// -d:分离模式，在后台运行// -i: 即使没有附加也保持STDIN打开// -t: 分配一个伪终端// docker exec -it &lt;container-id&gt; /bin/sh// 执行 exit 退出","link":"/2022/08/01/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"aliyun服务器实践","text":"创建新的账号默认使用 root 登录，由于 root 权限太高，出于安全考虑，创建 foolishmax（自定义）账号 123456789101112131415161718192021222324252627282930# 新增账号foolishmaxadduser foolishmax# 修改foolishmax的密码passwd foolishmax# 为foolishmax账号添加sudo权限# 找到文件位置 /etc/sudoerswhereis sudoers# 修改权限# u 标识所有者、w 表示写权限 + 表示添加chmod u+w /etc/sudoers# 编辑 /etc/sudoers# 找到 `root ALL=(ALL) ALL`# 再加一行 `work ALL=(ALL) ALL`vim /etc/sudoers# 还原权限chmod u-w /etc/sudoers# 切换foolishmax用户su foolishmax# 切换回rootsu# 输入密码# 切换成功 下载常用工具12345678910111213141516171819// gityum -y install gitgit --version// 安装dockeryum -y install dockerdocker --version// 安装docker-compose// 1. 下载二进制文件wget https://github.com/docker/compose/releases/download/1.24.0/docker-compose-Linux-x86_64// 2.移动文件mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose// 3.赋予可执行权限chmod +x /usr/local/bin/docker-compose// 4.创建软链ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose// 5.测试是否安装成功docker-compose --version 开放端口aliyun 控制台服务 发布测试机思路： 使用 github actions 监听 dev 分支 push 登录测试机，获取最新 dev 分支代码 重建构建镜像 docker-compose build project-name 重启所有容器 docker-compose up -d github actions代码在项目 .github/workflows 目录下面的 .yml 格式文件deplop-dev.yml示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions# github actions 中文文档 https://docs.github.com/cn/actions/getting-started-with-github-actionsname: deploy for devon: push: branches: - 'dev' # 只针对 dev 分支 paths: - '.github/workflows/*' # - '__test__/**' # dev 不需要立即测试 - 'src/**' - 'Dockerfile' - 'docker-compose.yml' - 'bin/*'jobs: deploy-dev: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: set ssh key # 临时设置 ssh key run: | mkdir -p ~/.ssh/ echo &quot;${{secrets.WFP_ID_RSA}}&quot; &gt; ~/.ssh/id_rsa # secret 在这里配置 https://github.com/imooc-lego/biz-editor-server/settings/secrets chmod 600 ~/.ssh/id_rsa ssh-keyscan &quot;182.92.xxx.xxx&quot; &gt;&gt; ~/.ssh/known_hosts - name: deploy # 部署 run: | ssh work@182.92.xxx.xxx &quot; # 【注意】用 work 账号登录，手动创建 /home/work/imooc-lego 目录 # 然后 git clone https://username:password@github.com/imooc-lego/biz-editor-server.git -b dev （私有仓库，使用 github 用户名和密码） # 记得删除 origin ，否则会暴露 github 密码 cd /home/work/imooc-lego/biz-editor-server; git remote add origin https://wangfupeng1988:${{secrets.WFP_PASSWORD}}@github.com/imooc-lego/biz-editor-server.git; git checkout dev; git pull origin dev; # 重新下载最新代码 git remote remove origin; # 删除 origin ，否则会暴露 github 密码 # 启动 docker docker-compose build editor-server; # 和 docker-compose.yml service 名字一致 docker-compose up -d; &quot; - name: delete ssh key # 删除 ssh key run: rm -rf ~/.ssh/id_rsa","link":"/2022/08/02/aliyun%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E8%B7%B5/"},{"title":"实现精简版useSize","text":"ahooks是阿里开源的一套 React Hooks 库，里面封装了大量好用的 Hooks，最近也在项目中频繁使用到了库中useSize这个钩子函数，于是就学习了一下它的源码实现，并且实现了一个精简版useSize。 要点一：ResizeObserver监听 Element 内容区域的边界框改变 要点二：requestAnimationFrame优化高频刷新情况下的数据更新 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import { MutableRefObject, useCallback, useEffect, useLayoutEffect, useRef, useState,} from &quot;react&quot;;type TargetValue&lt;T&gt; = T | undefined | null;type TargetType = HTMLElement | Element | Window | Document;export type BasicTarget&lt;T extends TargetType = Element&gt; = | (() =&gt; TargetValue&lt;T&gt;) | TargetValue&lt;T&gt; | MutableRefObject&lt;TargetValue&lt;T&gt;&gt;;type Size = { width: number; height: number };export default function useSize(target: BasicTarget): Size | undefined { const [state, setState] = useState&lt;Size | undefined&gt;(); const ref = useRef(0); const [resizeObserver, setResizeObserver] = useState&lt;ResizeObserver&gt;(); const setRafState = useCallback( (value: Size | ((prevState?: Size) =&gt; Size)) =&gt; { cancelAnimationFrame(ref.current); ref.current = requestAnimationFrame(() =&gt; { setState(value); }); }, [] ); useEffect( () =&gt; () =&gt; { resizeObserver?.disconnect(); cancelAnimationFrame(ref.current); }, [] ); useLayoutEffect(() =&gt; { if (!target) return; let targetEl: TargetValue&lt;TargetType&gt;; if (&quot;current&quot; in target) { targetEl = target.current; } else if (typeof target === &quot;function&quot;) { targetEl = target(); } else { targetEl = target; } if (!targetEl) return; const resizeObserver = new ResizeObserver((entries) =&gt; { entries.forEach((entry) =&gt; { const { clientWidth, clientHeight } = entry.target; setRafState({ width: clientWidth, height: clientHeight, }); }); }); setResizeObserver(resizeObserver); resizeObserver?.observe(targetEl); }, []); return state;} 具体使用12345678910111213export default function App() { const ref = useRef(null); const size = useSize(ref); return ( &lt;div ref={ref} style={{ border: &quot;1px solid red&quot; }}&gt; &lt;p&gt;Try to resize the preview window &lt;/p&gt; &lt;p&gt; width: {size?.width}px, height: {size?.height}px &lt;/p&gt; &lt;/div&gt; );} 仅作为自己的学习积累，有什么需要改进的地方请大家多多批评指点 😅！","link":"/2022/08/04/%E5%AE%9E%E7%8E%B0%E7%B2%BE%E7%AE%80%E7%89%88useSize/"},{"title":"vue基础知识","text":"vue 的特点（优点） vue 关注视图层，用数据操作的方式代替了 dom 操作 vue 通过响应式的数据绑定实现了数据和视图之间的更新交互 vue 通过组件化开发让工程结构更加明确，更易于维护 vue 通过虚拟 DOM，优化了 DOM 操作，实现了性能提高 vue 拥有自己的 vue-cli 脚手架工具，对良好的工程化性能 Vue 的双向数据绑定原理是什么？vue.js 是采用 数据劫持 结合 发布-订阅者 模式的方式，通过Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 1.当把一个普通JavaScript对象传给Vue实例当作它的data选项的时候，Vue会遍历它的属性， 用Object.defineProperty劫持各个属性的setter、getter，给这个对象的某一个值赋值， 就会触发setter，就能监听到数据的变化 2. compile解析模板指令，将模板中的变量替换成数据，然后渲染页面视图，并将每个指令对应的 节点添加监听数据的订阅者Watcher，一旦数据由变动，收到通知更新视图 3. 通过Observer来监听model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭 起Observer和Compile之间的桥梁，达到数据变化-&gt;视图更新，视图变化-&gt;数据更新。 Proxy 与 Object.defineProperty 优劣对比？ Proxy 的优势如下： Proxy 可以监听对象，而 Object.defineProperty 只能监听属性。 Proxy 还可以直接监听数组的变化。 Proxy 有多大 13 种的拦截方法，不限于 apply、ownKeys、deletePreperty 等，这些都是 Object.defineProperty 不具备的。 Object.defineProperty 的优势： 兼容性好，支持 IE9，而 Proxy 存在浏览器兼容问题。 解释单向数据流和双向数据绑定单向数据流： 数据流是单向的，数据流动方向可以追踪，流动单一，追查问题可以更加方便快捷， 缺点就是写起来不太方便，要是UI发生变更就必须创建各种action来维护对应的state 双向数据绑定： 数据之间是相同的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的 场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，添加了出错debug的难度 请详细说下你对 Vue 生命周期的理解？总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后 beforeCreate 创建前执行（vue实例的挂载元素$el和数据对象data都为undefined，还未初始化） created 完成创建 （完成了data数据初始化，el还未初始化） beforeMount 载入前（vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。） mounted 载入后html已经渲染(vue实例挂载完成，data.message成功渲染。) beforeUpdate 更新前状态（view层的数据变化前，不是data中的数据改变前） updated 更新状态后 beforeDestroy 销毁前 destroyed 销毁后 （在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在） 说一下每一个阶段可以做的事情 beforeCreate:可以在这里加一个loading事件，在加载实例时触发。 created: 初始化完成时的事件写这里，如果这里结束了loading事件，异步请求也在这里调用。 mounted: 挂载元素，获取到DOM节点 updated: 对数据进行处理的函数写这里。 beforeDestroy: 可以写一个确认停止事件的确认框。 vue-router 有哪几种导航钩子？三种 1. 全局导航钩子（跳转前进行判断拦截） + to: Route:即将要进入的目标 路由对象 + from: Route:当前导航正要离开的路由 + next: Function: 一定要调用该方法来resolve这个钩子，执行结果依赖于next方法的调用参数 - next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 - next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 - next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 - next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 router.beforeEach(to, from, next), //全局前置守卫 router.beforeResolve(to, from, next), //全局解析守卫，在 2.5.0+ 你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后， 解析守卫就被调用。 router.afterEach(to, from ) //全局后置守卫，钩子不会接受 next 函数也不会改变导航本身 2. 组件内钩子 beforeRouteEnter(to, from, next) //跳转到这个组件时 beforeRouteUpdate(to, from, next) //当前路由改变，但是该组件被复用时调用 beforeRouteLeave(to, from, next) //离开这个组件时 3. 单独路由独享组件 用法同全局守卫，只是将其写进其中一个路由对象中，只在这个路由下起作用。 beforeEnter(to, from, next) 完整的导航解析流程： 1. 导航被触发。 2. 在失活的组件里调用离开守卫。 3. 调用全局的 beforeEach 守卫。 4. 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 5. 在路由配置里调用 beforeEnter。 6. 解析异步路由组件。 7. 在被激活的组件里调用 beforeRouteEnter。 8. 调用全局的 beforeResolve 守卫 (2.5+)。 9. 导航被确认。 10. 调用全局的 afterEach 钩子。 11. 触发 DOM 更新。 12. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 动态路由定义和获取？在 router 目录下的 index.js 文件中，对 path 属性加上 /:id。 使用 router 对象的 params.id 获取 key 值的作用？key是为了高效的实现DOM渲染。 v-model 原理1.v-bind绑定一个value属性，监听message 2.v-on指令给当前元素绑定input事件 123456789&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;!--等价于下面--&gt;&lt;input type=&quot;text&quot; v-bind:value=&quot;message&quot; v-on:input=&quot;message=$event.target.value&quot;&gt;&lt;h2&gt;{{message}}&lt;/h2&gt; v-model 修饰符 1.lazy 修饰符 1.1 默认情况下，v-model 默认是在 input 事件中同步输入框的数据的 1.2 一旦有数据发生改变对应的 data 中的数据就会自动发生改变 1.3 lazy 是修饰符可以让数据在失去焦点或者回车时才会更新 2.number 修饰符 2.1 默认情况下，在输入框中我们输入数字还是字母，都会被当作字符串类型进行处理 2.2 但是如果我们希望处理的是是数字类型，那么最好直接将内容当作数字处理 2.3 number 修饰符可以让输入框中输入的内容自动转成数字类型 3.trim 修饰符（移除的字符包括空格、行终止符、制表符、换行符、回车符、换页符等） 如果输入的内容首尾有很多空格，通常我们希望将其去除 trim 修饰符可以过滤内容左右两边的空格 补充：str.replace(/\\s/g, “”); //去除字符串所有空格 v-on 修饰符 .stop 调用 event.stopPropagation() .prevent 调用 event.preventDefault() .{keyCode|keyAlias} 只当事件是从特定键触发时才触发回调 .native 监听组件根元素的原生事件 .once 只能触发一次回调 Vue.set//Vue中不允许动态添加根级别的响应式属性，Vue.set方法可以向嵌套对象添加 响应式属性。 //参数一：要修改的对象 //参数二：索引值 //参数三：修改后的值 Vue.set(vm.obj, 2, 'b') vm.$set(vm.obj, 2, 'b') vue-router 使用 params 与 query 传参有什么区别？vue-router可以通过params与query进行传参 1234567//传递this.$router.push({path: './xxx', params: {xx:xxx}})this.$router.push({path: './xxx', query: {xx:xxx}})//接受this.$route.paramsthis.$route.query params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系 params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题 Vue 如何取出 URL 中的 #vue-router 默认使用hash模式，所以路由加载时候，项目中的url会自带#，如果不想使用#，可以使用 vue-router 的另一种模式history new Router ({ mode: 'history', routes: [] }) 对 MVC、MVVM 的理解？1. MVC：所有的通信都是单向的 View传送指令到Controller Controller 完成业务逻辑后，要求Model改变状态 Model将新的数据发送到View，用户得到反馈 2.MVVM（类似MVP——Model View Presenter） View层：视图层 Model层：数据层 ViewModel层：视图模型层 视图模型层时view和model沟通的桥梁 一方面实现了Data Binding，数据绑定，将model的改变实时反应到view中 另一方面实现了DOM Listener，也就是DOM监听，发生事件改变，改变对应的data 一种前端架构模式，model为数据模型，view为视图UI层,view和model之间 并没有直接的联系，通过viewmodel实现双向数据的绑定。各部分通信都是双向的 因此开发者只需关注业务层，无需手动操作DOM，无需关心数据状态的同步问题，复杂 的数据状态维护完全由MVVM来统一管理。 采用双向数据绑定，View的变动自动反应在ViewModel，反之亦然 虚拟 DOM为什么需要虚拟DOM？ 浏览器加载一个HTML文件需要做那些事？ 创建DOM tree ——&gt; 创建CSS tree ——&gt; 构建Render tree ——&gt; 布局Layout ——&gt; 绘制Painting 如果用传统的原生api或jQuery操作DOM时，浏览器会从构建DOM树开始从头到尾 执行一边流程，就会浪费掉很多性能。 1. state数据 2.（JSX）模板 3. 数据 + 模板生成虚拟DOM（虚拟DOM就是一个JS对象，用来描述真实的DOM） 4. 用虚拟DOM的结构生成真实的DOM来显示 5. state数据发生改变 6. 数据 + 模板生成新的虚拟DOM 7. 比较原始虚拟DOM和新的虚拟DOM的区别，找到不同点 通过diff算法，将不同的比较内容结果保存到本地的一个js对象中，最终一次性 的将这个js对象attach应用到DOM树上，通知浏览器执行绘制工作，避免了大量的 无畏计算。 8. 直接操作DOM，改变内容。 nextTick 的应用场景Vue.nextTick 用于延迟执行一段代码，它的回调函数会在DOM更新完成后调用。 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调 函数中 在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于 徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。 原理： nextTick实际上就是创建一个新的宏任务，vue中双向绑定的数据赋值时需要调用 watcher的update方法(比如某个div绑定了一个数据，那么该div就会生成一个 watcher，而update的方法就是更新自身的innerHTML，当然中间还有一层虚拟DOM)， 而watcher的update就是通过nextTick来执行的。 Vue 组件中 data 为什么必须是函数？如果data是一个对象，那么 由于对象本身属于引用类型，当我们修改其中一个属性值的之后， 会影响到所有Vue实例的数据。如果将data作为一个函数返回一个对象，那么每一个实例的data 属性都是独立的，相互不会影响。例如：在同一个组件复用的时候，就类似给每个组件实例 创建了一个私有的数据空间，让各自的组件实例维护各自的数据。 计算属性 computed、watch 和事件 methods 有什么区别？computed： 计算属性是会基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时 才会重新求值。 computed属性有两个方法：set、get `fullName: { //赋值 set: function(newValue){const names = newValue.split(' '); this.firstName = names[0];this.lastName = names[1];},//一般用不着,使用的时候有参数 //取值 get: function(){return this.firstName + ' ' + this.lastName} } ` watch：更多的的是观察作用，类似于某些数据的监听回调，每当监听的数据变化时都 会执行相应的回调进行后续的操作。 method：不管数据是否改变，只要发生重新渲染，methods都会调用执行。 运用场景： 当需要进行数值计算，并且依赖于其他数据时，应该使用 computed，利用 computed 的缓存特性，避免每次获取值时，都需要重新计算。 当需要在数据变化时执行异步或者开销较大的操作时，使用 watch。 Vue 父子组件之间如何传值？父组件从后端获取数据，vue官方推荐使用axios来进行前后端交互，使用 axios.get(),返回一个Promise，然后用.then()在里面写个接收函数来接受返回值ret， ret的返回值就可以对应的赋值给data里面定义的key-value值。 父传子： 在父组件中使用的子组件标签上通过 v-bind:xxx=&quot;&quot;,然后再回到子组件中， 通过props{list: Array}来接收从父组件传过来的值，接收的值就可以在子组件中使用， 这样就完成了将数据传输到子组件的全过程。 子传父： 子组件向父组件传值一般都是通过事件决定，例如click，当子组件上绑定 被点击事件触发时，可以在这个触发事件的函数中，使用vue自带的 this.$emit('父组件接收的事件名'， 要传输的参数)，然后再父组件中使用的子组件 标签上通过 @事件名 = 'func'，然后再父组件的method中补全这个func，然后func 中将从子组件中传递过来的值赋给父组件的data中，这样就完成了子组件向父组件传值了。 props 数据验证： `不支持驼峰标识，驼峰需要改成 **-** 连接 的形式` 1.都支持哪数据类型? String、Number、Boolean、Array、Object、Date、Function、Symbol 2.props也支持自定义类型： Vue.component('my-component', { props: { //基础类型检查（'null'匹配任何类型） propA: Number, //多个可能的值类型 propB: [String, Number], //是否是必填的字符串 propC: { type: String, required: true }, //带有默认值的数字 propD: { type: Number, default: 100 }, //对象或数组默认值必须从一个工厂函数获取 propE: { type: Object, default: function(){ return {} } ======== type: Array, default: function(){ return [] } }, //自定义验证函数 propF: { validate: function(value){ return ['success','warning','danger'].indexOf(value)!== -1 } } } }) 为什么需要浅拷贝？js变量的引用类型在进行复制操作的时候会复制地址，导致两个变量指向同一份数据。 在对一个对象进行操作并且不希望影响原对象的时候，应该先进行拷贝操作。 父子组件的访问方式 父组件访问子组件： $children ——用的比较少 $refs ——用的较多 子组件访问父组件： $parent ——用的较少 子组件访问根组件： $root ——用的较多 插槽 插槽 具名插槽 作用域插槽：父组件替换插槽的标签，但是内容有子组件来提供。 keep-alive 遇见 vue-router keep-alive 是 vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染 两个重要的属性： include - 字符串或正则表达，只有匹配的组件会被缓存 exclude - 字符串或正则表达，任何匹配的组件不会被缓存 router-view 也是一个组件，如果直接被包在 keep-aive 里面，所有路径匹配的视图组件都会被缓存。 对应两个钩子函数 activated 和 deactivated，当组件被激活时，触发 activated，组件被移除时，触发 deactivated。 为什么选择 axios？ axios：ajax i/o system(个人理解) 尤大 在 2016-11-3，公告以后 vue-resource 不再维护，官方推荐新的 ajax 库用 axios。 功能特点 在浏览器中发送 XMLHttpRequest 请求 在 node.js 中发送 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 … 谈谈对 Vue SSR 的理解 SSR 大致的意思就是 vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成 html 片段直接返回给客户端这个过程就交租服务端渲染。 服务端渲染 SSR 的优缺点： 优点： 更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 首屏加载更快：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； 缺点： 更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源(CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic )下使用，请准备相应的服务器负载，并明智地采用缓存策略。 你有对 Vue 项目进行哪些优化？ 代码层面的优化： v-if 和 v-show 区分使用场景 合理使用 computed 和 watch v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化(通过 Object.freeze 冻结一个对象，之后就不能修改了，避免了 Object.defineProperty 对数据的劫持) 事件的销毁(在 js 中使用 addEventListener 等方式创建的事件不会自动销毁，需要手动移除对这些事件的监听，避免造成内存泄漏) 图片资源懒加载(vue-lazyload 插件) 路由懒加载 第三方插件的按需引入 服务端渲染 SSR or 预渲染 Webpack 层面的优化 webpack 对图片进行压缩 多个页面的公共代码抽离成单独的文件 基础的 Web 技术优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈","link":"/2019/07/29/Vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"vue响应式系统实现","text":"源码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273const bucket = new WeakMap();// 用一个全局变量存储当前激活的effect函数let activeEffect;// effect栈const effectStack = [];function effect(fn, options = []) { const effectFn = () =&gt; { // 调用cleanup函数完成清除工作 cleanup(effectFn); // 当调用effect注册副作用函数时，将副作用函数赋值给activeEffect activeEffect = effectFn; // 调用副作用函数之前将当前副作用函数压入栈顶 effectStack.push(effectFn); // 把fn的执行结果存储在res中 const res = fn(); // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并将activeEffect还原为之前的值 effectStack.pop(); activeEffect = effectStack[effectStack.length - 1]; return res; }; // 将options挂载到effectFn上 effectFn.options = options; // 用来存储所有与该副作用函数相关的依赖集合 effectFn.deps = []; // 只有非lazy的时候，才执行 if (!options.lazy) { effectFn(); } return effectFn;}// computedfunction computed(getter) { // 用来缓存上一次计算的值 let value; // dirty标志，用来识别是否需要重新计算值，为true时则意味着“脏”，需要计算 let dirty = true; const effectFn = effect(getter, { lazy: true, scheduler() { if (!dirty) { dirty = true; // 当计算属性依赖的响应式数据变化时，手动调用trigger函数触发响应 trigger(obj, &quot;value&quot;); } }, }); const obj = { get value() { if (dirty) { value = effectFn(); dirty = false; } // 当读取value时，手动调用track函数进行追踪 track(obj, &quot;value&quot;); return value; }, }; return obj;}// watchfunction watch(source, cb, options = {}) { let getter; // 如果是函数，说明用户传递的不再是一个响应式数据，而是一个getter函数，直接把source赋值给getter if (typeof source === &quot;function&quot;) { getter = source; } else { // 否则调用traverse递归读取响应式数据属性 getter = () =&gt; traverse(source); } //定义旧值和新值 let oldValue, newValue; // cleanup用来存储用户注册的国旗回调 let cleanup; // 定义onInvalidate函数 function onInvalidate(fn) { // 将过期回调存储到cleanup中 cleanup = fn; } // 提取调度器scheduler为一个独立的job函数 const job = () =&gt; { // 在scheduler中重新执行副作用函数，得到的是新值 newValue = effectFn(); // 在调用糊掉函数cb之前，先调用过期回调 if (cleanup) { cleanup(); } // 将旧值和新值作为回调函数的参数 cb(newValue, oldValue); // 更新旧值，不然下次会得到错误的旧值 oldValue = newValue; }; // 使用effect注册副作用函数时，开启lazy选项，并把返回值存储到effectFn中一边后续手动调用 const effectFn = effect(() =&gt; getter(), { lazy: true, scheduler: job, }); if (options.immediate) { // 当immediate为true时立即执行job，从而触发回调执行 job(); } else { // 手动调用副作用函数，拿到的值就是旧值 oldValue = effectFn(); }}function traverse(value, seen = new Set()) { // 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做 if (typeof value !== &quot;object&quot; || value === null || seen.has(value)) return; // 将数据添加到seen中，代表便利地读取过了，避免循环引用引起的死循环 seen.add(value); // 暂时不考虑数组等其他结构 // 假设value是一个对象，使用for...in读取对新啊个的每一个值，并递归调用traverse进行处理 for (const k in value) { traverse(value[k], seen); } return value;}function cleanup(effectFn) { // 遍历effectFn.deps数组 for (let i = 0; i &lt; effectFn.deps.length; i++) { // deps是依赖集合 const deps = effectFn.deps[i]; // 将effectFn从依赖集合中移除 deps.delete(effectFn); } // 最后需要重置effectFn.deps数组 effectFn.deps.length = 0;}// 在get拦截函数内调用track函数追踪变化function track(target, key) { // 没有activeEffect，直接return if (!activeEffect) return target[key]; // 根据target从“桶”中取得depsMap，也是一个Map类型：key --&gt; effects let depsMap = bucket.get(target); // 如果不存在depsMap，新建一个Map并与target关联 if (!depsMap) { bucket.set(target, (depsMap = new Map())); } // 根据key从depsMap中取得deps，它是一个Set类型， // 里面存储着所有与当前key相关联的副作用函数：effects let deps = depsMap.get(key); if (!deps) { depsMap.set(key, (deps = new Set())); } // 最后将当前激活的副作用函数添加到“桶”中 deps.add(activeEffect); // deps就是一个与当前副作用函数存在联系的依赖集合 // 将其添加到activeEffect.deps数组中 activeEffect.deps.push(deps);}// 在set函数拦截内调用trigger函数出发变化function trigger(target, key) { // 根据target从桶中取出depsMap，它是 key --&gt; effects const depsMap = bucket.get(target); if (!depsMap) return; // 根据key取得所有副作用函数effects const effects = depsMap.get(key); // 在调用forEach遍历Set集合时，如果一个值已经被访问过了， // 但该值被删除并重新添加集合，如果此时forEach遍历还没结束 // 该值会重新被访问，就会导致无限循环执行。 // 解决方法：构造另一个Set集合遍历它 const effectsToRun = new Set(); // 执行副作用函数 effects &amp;&amp; effects.forEach((effectFn) =&gt; { // 如果trigger触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行 if (effectFn !== activeEffect) { effectsToRun.add(effectFn); } }); effectsToRun.forEach((effectFn) =&gt; { // 如果一个副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递 if (effectFn.options.scheduler) { effectFn.options.scheduler(effectFn); } else { // 否则直接执行副作用函数 effectFn(); } });}const data = { text: &quot;hello world&quot;, ok: false, foo: 1, bar: 2 };const obj = new Proxy(data, { // 拦截读取操作 get(target, key) { // 将副作用函数activeEffect添加到存储副作用函数的桶中 track(target, key); // 返回属性值 return target[key]; }, // 拦截设置操作 set(target, key, newVal) { // 设置属性值 target[key] = newVal; // 把副作用函数从桶中取出并执行 trigger(target, key); },});let temp1, temp2;// watchwatch( () =&gt; obj.foo, (newValue, oldValue) =&gt; { console.log(&quot;数据变化了&quot;, newValue, oldValue); }, { immediate: true, });obj.foo++;// computed// const sum = computed(() =&gt; obj.foo + obj.bar);// effect(() =&gt; {// console.log(sum.value);// });// obj.foo++;// lazy// const effectFn = effect(// () =&gt; {// console.log(obj.text);// },// {// lazy: true,// }// );// effectFn();// 嵌套的effect与effect栈// effect(function effectFn1() {// console.log(&quot;effectFn1 执行&quot;);// effect(function effectFn2() {// console.log(&quot;effectFn2 执行&quot;);// temp2 = obj.ok;// });// temp1 = obj.text;// obj.text += &quot;1&quot;;// });// 分支切换与cleanup// effect(() =&gt; {// console.log('effect run');// document.body.innerText = obj.ok ? obj.text : &quot;not&quot;;// obj.text = 'foolishmax'// });// 不存在的属性不添加响应式// setTimeout(() =&gt; {// obj.text = &quot;hello vue3&quot;;// // obj.notExist = 'hello vue3'// }, 3000);","link":"/2022/08/07/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"javaScript","slug":"javaScript","link":"/tags/javaScript/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"other","slug":"other","link":"/tags/other/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"Css","slug":"Css","link":"/tags/Css/"},{"name":"网络请求","slug":"网络请求","link":"/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"异步","slug":"异步","link":"/tags/%E5%BC%82%E6%AD%A5/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"lerna","slug":"lerna","link":"/tags/lerna/"},{"name":"渲染机制类","slug":"渲染机制类","link":"/tags/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E7%B1%BB/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"前端安全","slug":"前端安全","link":"/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"本地存储","slug":"本地存储","link":"/tags/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"},{"name":"token","slug":"token","link":"/tags/token/"},{"name":"牛客","slug":"牛客","link":"/tags/%E7%89%9B%E5%AE%A2/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"aliyun","slug":"aliyun","link":"/tags/aliyun/"},{"name":"react-hooks","slug":"react-hooks","link":"/tags/react-hooks/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"DOM","slug":"DOM","link":"/categories/DOM/"},{"name":"浏览器","slug":"浏览器","link":"/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"other","slug":"other","link":"/categories/other/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"Css","slug":"Css","link":"/categories/Css/"},{"name":"网络请求","slug":"网络请求","link":"/categories/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"异步","slug":"异步","link":"/categories/%E5%BC%82%E6%AD%A5/"},{"name":"node","slug":"node","link":"/categories/node/"},{"name":"lerna","slug":"lerna","link":"/categories/lerna/"},{"name":"渲染机制类","slug":"渲染机制类","link":"/categories/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E7%B1%BB/"},{"name":"Webpack","slug":"Webpack","link":"/categories/Webpack/"},{"name":"vue3","slug":"vue3","link":"/categories/vue3/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"javaScript","slug":"javaScript","link":"/categories/javaScript/"},{"name":"前端安全","slug":"前端安全","link":"/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"面经","slug":"面经","link":"/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"本地存储","slug":"本地存储","link":"/categories/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"},{"name":"Vue、React","slug":"Vue、React","link":"/categories/Vue%E3%80%81React/"},{"name":"token","slug":"token","link":"/categories/token/"},{"name":"牛客","slug":"牛客","link":"/categories/%E7%89%9B%E5%AE%A2/"},{"name":"Ajax","slug":"Ajax","link":"/categories/Ajax/"},{"name":"面试题","slug":"面试题","link":"/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"pages":[{"title":"标签","text":"","link":"/tags/index.html"},{"title":"关于","text":"我本将心向明月，奈何明月照沟渠","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}]}